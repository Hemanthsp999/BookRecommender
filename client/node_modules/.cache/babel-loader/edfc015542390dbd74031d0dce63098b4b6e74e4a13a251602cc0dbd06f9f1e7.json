{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n * @param {string} relativePath relative path\n * @returns {string} request\n */\nconst relativePathToRequest = relativePath => {\n  if (relativePath === \"\") return \"./.\";\n  if (relativePath === \"..\") return \"../.\";\n  if (relativePath.startsWith(\"../\")) return relativePath;\n  return `./${relativePath}`;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n  if (maybeAbsolutePath[0] === \"/\") {\n    if (maybeAbsolutePath.length > 1 && maybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\") {\n      // this 'path' is actually a regexp generated by dynamic requires.\n      // Don't treat it as an absolute path.\n      return maybeAbsolutePath;\n    }\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = relativePathToRequest(path.posix.relative(context, resource));\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  }\n  if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = path.win32.relative(context, resource);\n    if (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n      resource = relativePathToRequest(resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\"));\n    }\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  }\n\n  // not an absolute path\n  return maybeAbsolutePath;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\nconst makeCacheable = realFn => {\n  /** @type {WeakMap<object, Map<string, ParsedResource>>} */\n  const cache = new WeakMap();\n  const getCache = associatedObjectForCache => {\n    const entry = cache.get(associatedObjectForCache);\n    if (entry !== undefined) return entry;\n    /** @type {Map<string, ParsedResource>} */\n    const map = new Map();\n    cache.set(associatedObjectForCache, map);\n    return map;\n  };\n\n  /**\n   * @param {string} str the path with query and fragment\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {ParsedResource} parsed parts\n   */\n  const fn = (str, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return realFn(str);\n    const cache = getCache(associatedObjectForCache);\n    const entry = cache.get(str);\n    if (entry !== undefined) return entry;\n    const result = realFn(str);\n    cache.set(str, result);\n    return result;\n  };\n  fn.bindCache = associatedObjectForCache => {\n    const cache = getCache(associatedObjectForCache);\n    return str => {\n      const entry = cache.get(str);\n      if (entry !== undefined) return entry;\n      const result = realFn(str);\n      cache.set(str, result);\n      return result;\n    };\n  };\n  return fn;\n};\nconst makeCacheableWithContext = fn => {\n  /** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n  const cache = new WeakMap();\n\n  /**\n   * @param {string} context context used to create relative path\n   * @param {string} identifier identifier used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {string} the returned relative path\n   */\n  const cachedFn = (context, identifier, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return fn(context, identifier);\n    let innerCache = cache.get(associatedObjectForCache);\n    if (innerCache === undefined) {\n      innerCache = new Map();\n      cache.set(associatedObjectForCache, innerCache);\n    }\n    let cachedResult;\n    let innerSubCache = innerCache.get(context);\n    if (innerSubCache === undefined) {\n      innerCache.set(context, innerSubCache = new Map());\n    } else {\n      cachedResult = innerSubCache.get(identifier);\n    }\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    } else {\n      const result = fn(context, identifier);\n      innerSubCache.set(identifier, result);\n      return result;\n    }\n  };\n\n  /**\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string, string): string} cached function\n   */\n  cachedFn.bindCache = associatedObjectForCache => {\n    let innerCache;\n    if (associatedObjectForCache) {\n      innerCache = cache.get(associatedObjectForCache);\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n    } else {\n      innerCache = new Map();\n    }\n\n    /**\n     * @param {string} context context used to create relative path\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n    const boundFn = (context, identifier) => {\n      let cachedResult;\n      let innerSubCache = innerCache.get(context);\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      } else {\n        cachedResult = innerSubCache.get(identifier);\n      }\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n    return boundFn;\n  };\n\n  /**\n   * @param {string} context context used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string): string} cached function\n   */\n  cachedFn.bindContextCache = (context, associatedObjectForCache) => {\n    let innerSubCache;\n    if (associatedObjectForCache) {\n      let innerCache = cache.get(associatedObjectForCache);\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n      innerSubCache = innerCache.get(context);\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      }\n    } else {\n      innerSubCache = new Map();\n    }\n\n    /**\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n    const boundFn = identifier => {\n      const cachedResult = innerSubCache.get(identifier);\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n    return boundFn;\n  };\n  return cachedFn;\n};\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => absoluteToRequest(context, str)).join(\"\");\n};\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsAbsolute = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => requestToAbsolute(context, str)).join(\"\");\n};\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nconst _contextify = (context, request) => {\n  return request.split(\"!\").map(r => absoluteToRequest(context, r)).join(\"!\");\n};\nconst contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n  return request.split(\"!\").map(r => requestToAbsolute(context, r)).join(\"!\");\n};\nconst absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\nconst PATH_QUERY_FRAGMENT_REGEXP = /^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\nconst _parseResource = str => {\n  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n    fragment: match[3] || \"\"\n  };\n};\nexports.parseResource = makeCacheable(_parseResource);\n\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\nconst _parseResourceWithoutFragment = str => {\n  const match = PATH_QUERY_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n  };\n};\nexports.parseResourceWithoutFragment = makeCacheable(_parseResourceWithoutFragment);\n\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n  let depth = -1;\n  let append = \"\";\n  outputPath = outputPath.replace(/[\\\\/]$/, \"\");\n  for (const part of filename.split(/[/\\\\]+/)) {\n    if (part === \"..\") {\n      if (depth > -1) {\n        depth--;\n      } else {\n        const i = outputPath.lastIndexOf(\"/\");\n        const j = outputPath.lastIndexOf(\"\\\\\");\n        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n        if (pos < 0) return outputPath + \"/\";\n        append = outputPath.slice(pos + 1) + \"/\" + append;\n        outputPath = outputPath.slice(0, pos);\n      }\n    } else if (part !== \".\") {\n      depth++;\n    }\n  }\n  return depth > 0 ? `${\"../\".repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;\n};","map":{"version":3,"names":["path","require","WINDOWS_ABS_PATH_REGEXP","SEGMENTS_SPLIT_REGEXP","WINDOWS_PATH_SEPARATOR_REGEXP","relativePathToRequest","relativePath","startsWith","absoluteToRequest","context","maybeAbsolutePath","length","querySplitPos","indexOf","resource","slice","posix","relative","test","win32","replace","requestToAbsolute","join","makeCacheable","realFn","cache","WeakMap","getCache","associatedObjectForCache","entry","get","undefined","map","Map","set","fn","str","result","bindCache","makeCacheableWithContext","cachedFn","identifier","innerCache","cachedResult","innerSubCache","boundFn","bindContextCache","_makePathsRelative","split","exports","makePathsRelative","_makePathsAbsolute","makePathsAbsolute","_contextify","request","r","contextify","_absolutify","absolutify","PATH_QUERY_FRAGMENT_REGEXP","PATH_QUERY_REGEXP","_parseResource","match","exec","query","fragment","parseResource","_parseResourceWithoutFragment","parseResourceWithoutFragment","getUndoPath","filename","outputPath","enforceRelative","depth","append","part","i","lastIndexOf","j","pos","Math","max","repeat"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/identifier.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n * @param {string} relativePath relative path\n * @returns {string} request\n */\nconst relativePathToRequest = relativePath => {\n\tif (relativePath === \"\") return \"./.\";\n\tif (relativePath === \"..\") return \"../.\";\n\tif (relativePath.startsWith(\"../\")) return relativePath;\n\treturn `./${relativePath}`;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n\tif (maybeAbsolutePath[0] === \"/\") {\n\t\tif (\n\t\t\tmaybeAbsolutePath.length > 1 &&\n\t\t\tmaybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\"\n\t\t) {\n\t\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t\t// Don't treat it as an absolute path.\n\t\t\treturn maybeAbsolutePath;\n\t\t}\n\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = relativePathToRequest(path.posix.relative(context, resource));\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\tif (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = path.win32.relative(context, resource);\n\t\tif (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n\t\t\tresource = relativePathToRequest(\n\t\t\t\tresource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\")\n\t\t\t);\n\t\t}\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\t// not an absolute path\n\treturn maybeAbsolutePath;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n\tif (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\"))\n\t\treturn path.join(context, relativePath);\n\treturn relativePath;\n};\n\nconst makeCacheable = realFn => {\n\t/** @type {WeakMap<object, Map<string, ParsedResource>>} */\n\tconst cache = new WeakMap();\n\n\tconst getCache = associatedObjectForCache => {\n\t\tconst entry = cache.get(associatedObjectForCache);\n\t\tif (entry !== undefined) return entry;\n\t\t/** @type {Map<string, ParsedResource>} */\n\t\tconst map = new Map();\n\t\tcache.set(associatedObjectForCache, map);\n\t\treturn map;\n\t};\n\n\t/**\n\t * @param {string} str the path with query and fragment\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {ParsedResource} parsed parts\n\t */\n\tconst fn = (str, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return realFn(str);\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\tconst entry = cache.get(str);\n\t\tif (entry !== undefined) return entry;\n\t\tconst result = realFn(str);\n\t\tcache.set(str, result);\n\t\treturn result;\n\t};\n\n\tfn.bindCache = associatedObjectForCache => {\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\treturn str => {\n\t\t\tconst entry = cache.get(str);\n\t\t\tif (entry !== undefined) return entry;\n\t\t\tconst result = realFn(str);\n\t\t\tcache.set(str, result);\n\t\t\treturn result;\n\t\t};\n\t};\n\n\treturn fn;\n};\n\nconst makeCacheableWithContext = fn => {\n\t/** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n\tconst cache = new WeakMap();\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {string} identifier identifier used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {string} the returned relative path\n\t */\n\tconst cachedFn = (context, identifier, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return fn(context, identifier);\n\n\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\tif (innerCache === undefined) {\n\t\t\tinnerCache = new Map();\n\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t}\n\n\t\tlet cachedResult;\n\t\tlet innerSubCache = innerCache.get(context);\n\t\tif (innerSubCache === undefined) {\n\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t} else {\n\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t}\n\n\t\tif (cachedResult !== undefined) {\n\t\t\treturn cachedResult;\n\t\t} else {\n\t\t\tconst result = fn(context, identifier);\n\t\t\tinnerSubCache.set(identifier, result);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\t/**\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string, string): string} cached function\n\t */\n\tcachedFn.bindCache = associatedObjectForCache => {\n\t\tlet innerCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tinnerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\t\t} else {\n\t\t\tinnerCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} context context used to create relative path\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = (context, identifier) => {\n\t\t\tlet cachedResult;\n\t\t\tlet innerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t} else {\n\t\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t\t}\n\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string): string} cached function\n\t */\n\tcachedFn.bindContextCache = (context, associatedObjectForCache) => {\n\t\tlet innerSubCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\n\t\t\tinnerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t}\n\t\t} else {\n\t\t\tinnerSubCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = identifier => {\n\t\t\tconst cachedResult = innerSubCache.get(identifier);\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\treturn cachedFn;\n};\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => absoluteToRequest(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsAbsolute = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => requestToAbsolute(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nconst _contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => absoluteToRequest(context, r))\n\t\t.join(\"!\");\n};\n\nconst contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => requestToAbsolute(context, r))\n\t\t.join(\"!\");\n};\n\nconst absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\n\nconst PATH_QUERY_FRAGMENT_REGEXP =\n\t/^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\nconst _parseResource = str => {\n\tconst match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n\t\tfragment: match[3] || \"\"\n\t};\n};\nexports.parseResource = makeCacheable(_parseResource);\n\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\nconst _parseResourceWithoutFragment = str => {\n\tconst match = PATH_QUERY_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n\t};\n};\nexports.parseResourceWithoutFragment = makeCacheable(\n\t_parseResourceWithoutFragment\n);\n\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n\tlet depth = -1;\n\tlet append = \"\";\n\toutputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\tfor (const part of filename.split(/[/\\\\]+/)) {\n\t\tif (part === \"..\") {\n\t\t\tif (depth > -1) {\n\t\t\t\tdepth--;\n\t\t\t} else {\n\t\t\t\tconst i = outputPath.lastIndexOf(\"/\");\n\t\t\t\tconst j = outputPath.lastIndexOf(\"\\\\\");\n\t\t\t\tconst pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n\t\t\t\tif (pos < 0) return outputPath + \"/\";\n\t\t\t\tappend = outputPath.slice(pos + 1) + \"/\" + append;\n\t\t\t\toutputPath = outputPath.slice(0, pos);\n\t\t\t}\n\t\t} else if (part !== \".\") {\n\t\t\tdepth++;\n\t\t}\n\t}\n\treturn depth > 0\n\t\t? `${\"../\".repeat(depth)}${append}`\n\t\t: enforceRelative\n\t\t? `./${append}`\n\t\t: append;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}