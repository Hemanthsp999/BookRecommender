{"ast":null,"code":"'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst types = require('./types');\nconst rcodes = require('./rcodes');\nconst opcodes = require('./opcodes');\nconst classes = require('./classes');\nconst optioncodes = require('./optioncodes');\nconst ip = require('@leichtgewicht/ip-codec');\nconst QUERY_FLAG = 0;\nconst RESPONSE_FLAG = 1 << 15;\nconst FLUSH_MASK = 1 << 15;\nconst NOT_FLUSH_MASK = ~FLUSH_MASK;\nconst QU_MASK = 1 << 15;\nconst NOT_QU_MASK = ~QU_MASK;\nconst name = exports.name = {};\nname.encode = function (str, buf, offset) {\n  if (!buf) buf = Buffer.alloc(name.encodingLength(str));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n\n  // strip leading and trailing .\n  const n = str.replace(/^\\.|\\.$/gm, '');\n  if (n.length) {\n    const list = n.split('.');\n    for (let i = 0; i < list.length; i++) {\n      const len = buf.write(list[i], offset + 1);\n      buf[offset] = len;\n      offset += len + 1;\n    }\n  }\n  buf[offset++] = 0;\n  name.encode.bytes = offset - oldOffset;\n  return buf;\n};\nname.encode.bytes = 0;\nname.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const list = [];\n  let oldOffset = offset;\n  let totalLength = 0;\n  let consumedBytes = 0;\n  let jumped = false;\n  while (true) {\n    if (offset >= buf.length) {\n      throw new Error('Cannot decode name (buffer overflow)');\n    }\n    const len = buf[offset++];\n    consumedBytes += jumped ? 0 : 1;\n    if (len === 0) {\n      break;\n    } else if ((len & 0xc0) === 0) {\n      if (offset + len > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)');\n      }\n      totalLength += len + 1;\n      if (totalLength > 254) {\n        throw new Error('Cannot decode name (name too long)');\n      }\n      list.push(buf.toString('utf-8', offset, offset + len));\n      offset += len;\n      consumedBytes += jumped ? 0 : len;\n    } else if ((len & 0xc0) === 0xc0) {\n      if (offset + 1 > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)');\n      }\n      const jumpOffset = buf.readUInt16BE(offset - 1) - 0xc000;\n      if (jumpOffset >= oldOffset) {\n        // Allow only pointers to prior data. RFC 1035, section 4.1.4 states:\n        // \"[...] an entire domain name or a list of labels at the end of a domain name\n        // is replaced with a pointer to a prior occurance (sic) of the same name.\"\n        throw new Error('Cannot decode name (bad pointer)');\n      }\n      offset = jumpOffset;\n      oldOffset = jumpOffset;\n      consumedBytes += jumped ? 0 : 1;\n      jumped = true;\n    } else {\n      throw new Error('Cannot decode name (bad label)');\n    }\n  }\n  name.decode.bytes = consumedBytes;\n  return list.length === 0 ? '.' : list.join('.');\n};\nname.decode.bytes = 0;\nname.encodingLength = function (n) {\n  if (n === '.' || n === '..') return 1;\n  return Buffer.byteLength(n.replace(/^\\.|\\.$/gm, '')) + 2;\n};\nconst string = {};\nstring.encode = function (s, buf, offset) {\n  if (!buf) buf = Buffer.alloc(string.encodingLength(s));\n  if (!offset) offset = 0;\n  const len = buf.write(s, offset + 1);\n  buf[offset] = len;\n  string.encode.bytes = len + 1;\n  return buf;\n};\nstring.encode.bytes = 0;\nstring.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf[offset];\n  const s = buf.toString('utf-8', offset + 1, offset + 1 + len);\n  string.decode.bytes = len + 1;\n  return s;\n};\nstring.decode.bytes = 0;\nstring.encodingLength = function (s) {\n  return Buffer.byteLength(s) + 1;\n};\nconst header = {};\nheader.encode = function (h, buf, offset) {\n  if (!buf) buf = header.encodingLength(h);\n  if (!offset) offset = 0;\n  const flags = (h.flags || 0) & 32767;\n  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG;\n  buf.writeUInt16BE(h.id || 0, offset);\n  buf.writeUInt16BE(flags | type, offset + 2);\n  buf.writeUInt16BE(h.questions.length, offset + 4);\n  buf.writeUInt16BE(h.answers.length, offset + 6);\n  buf.writeUInt16BE(h.authorities.length, offset + 8);\n  buf.writeUInt16BE(h.additionals.length, offset + 10);\n  return buf;\n};\nheader.encode.bytes = 12;\nheader.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  if (buf.length < 12) throw new Error('Header must be 12 bytes');\n  const flags = buf.readUInt16BE(offset + 2);\n  return {\n    id: buf.readUInt16BE(offset),\n    type: flags & RESPONSE_FLAG ? 'response' : 'query',\n    flags: flags & 32767,\n    flag_qr: (flags >> 15 & 0x1) === 1,\n    opcode: opcodes.toString(flags >> 11 & 0xf),\n    flag_aa: (flags >> 10 & 0x1) === 1,\n    flag_tc: (flags >> 9 & 0x1) === 1,\n    flag_rd: (flags >> 8 & 0x1) === 1,\n    flag_ra: (flags >> 7 & 0x1) === 1,\n    flag_z: (flags >> 6 & 0x1) === 1,\n    flag_ad: (flags >> 5 & 0x1) === 1,\n    flag_cd: (flags >> 4 & 0x1) === 1,\n    rcode: rcodes.toString(flags & 0xf),\n    questions: new Array(buf.readUInt16BE(offset + 4)),\n    answers: new Array(buf.readUInt16BE(offset + 6)),\n    authorities: new Array(buf.readUInt16BE(offset + 8)),\n    additionals: new Array(buf.readUInt16BE(offset + 10))\n  };\n};\nheader.decode.bytes = 12;\nheader.encodingLength = function () {\n  return 12;\n};\nconst runknown = exports.unknown = {};\nrunknown.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(runknown.encodingLength(data));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(data.length, offset);\n  data.copy(buf, offset + 2);\n  runknown.encode.bytes = data.length + 2;\n  return buf;\n};\nrunknown.encode.bytes = 0;\nrunknown.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const data = buf.slice(offset + 2, offset + 2 + len);\n  runknown.decode.bytes = len + 2;\n  return data;\n};\nrunknown.decode.bytes = 0;\nrunknown.encodingLength = function (data) {\n  return data.length + 2;\n};\nconst rns = exports.ns = {};\nrns.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rns.encodingLength(data));\n  if (!offset) offset = 0;\n  name.encode(data, buf, offset + 2);\n  buf.writeUInt16BE(name.encode.bytes, offset);\n  rns.encode.bytes = name.encode.bytes + 2;\n  return buf;\n};\nrns.encode.bytes = 0;\nrns.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const dd = name.decode(buf, offset + 2);\n  rns.decode.bytes = len + 2;\n  return dd;\n};\nrns.decode.bytes = 0;\nrns.encodingLength = function (data) {\n  return name.encodingLength(data) + 2;\n};\nconst rsoa = exports.soa = {};\nrsoa.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsoa.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  name.encode(data.mname, buf, offset);\n  offset += name.encode.bytes;\n  name.encode(data.rname, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt32BE(data.serial || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.refresh || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.retry || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.expire || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.minimum || 0, offset);\n  offset += 4;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rsoa.encode.bytes = offset - oldOffset;\n  return buf;\n};\nrsoa.encode.bytes = 0;\nrsoa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.mname = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  data.rname = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  data.serial = buf.readUInt32BE(offset);\n  offset += 4;\n  data.refresh = buf.readUInt32BE(offset);\n  offset += 4;\n  data.retry = buf.readUInt32BE(offset);\n  offset += 4;\n  data.expire = buf.readUInt32BE(offset);\n  offset += 4;\n  data.minimum = buf.readUInt32BE(offset);\n  offset += 4;\n  rsoa.decode.bytes = offset - oldOffset;\n  return data;\n};\nrsoa.decode.bytes = 0;\nrsoa.encodingLength = function (data) {\n  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname);\n};\nconst rtxt = exports.txt = {};\nrtxt.encode = function (data, buf, offset) {\n  if (!Array.isArray(data)) data = [data];\n  for (let i = 0; i < data.length; i++) {\n    if (typeof data[i] === 'string') {\n      data[i] = Buffer.from(data[i]);\n    }\n    if (!Buffer.isBuffer(data[i])) {\n      throw new Error('Must be a Buffer');\n    }\n  }\n  if (!buf) buf = Buffer.alloc(rtxt.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  data.forEach(function (d) {\n    buf[offset++] = d.length;\n    d.copy(buf, offset, 0, d.length);\n    offset += d.length;\n  });\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rtxt.encode.bytes = offset - oldOffset;\n  return buf;\n};\nrtxt.encode.bytes = 0;\nrtxt.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  let remaining = buf.readUInt16BE(offset);\n  offset += 2;\n  let data = [];\n  while (remaining > 0) {\n    const len = buf[offset++];\n    --remaining;\n    if (remaining < len) {\n      throw new Error('Buffer overflow');\n    }\n    data.push(buf.slice(offset, offset + len));\n    offset += len;\n    remaining -= len;\n  }\n  rtxt.decode.bytes = offset - oldOffset;\n  return data;\n};\nrtxt.decode.bytes = 0;\nrtxt.encodingLength = function (data) {\n  if (!Array.isArray(data)) data = [data];\n  let length = 2;\n  data.forEach(function (buf) {\n    if (typeof buf === 'string') {\n      length += Buffer.byteLength(buf) + 1;\n    } else {\n      length += buf.length + 1;\n    }\n  });\n  return length;\n};\nconst rnull = exports.null = {};\nrnull.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnull.encodingLength(data));\n  if (!offset) offset = 0;\n  if (typeof data === 'string') data = Buffer.from(data);\n  if (!data) data = Buffer.alloc(0);\n  const oldOffset = offset;\n  offset += 2;\n  const len = data.length;\n  data.copy(buf, offset, 0, len);\n  offset += len;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rnull.encode.bytes = offset - oldOffset;\n  return buf;\n};\nrnull.encode.bytes = 0;\nrnull.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  const data = buf.slice(offset, offset + len);\n  offset += len;\n  rnull.decode.bytes = offset - oldOffset;\n  return data;\n};\nrnull.decode.bytes = 0;\nrnull.encodingLength = function (data) {\n  if (!data) return 2;\n  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2;\n};\nconst rhinfo = exports.hinfo = {};\nrhinfo.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rhinfo.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  string.encode(data.cpu, buf, offset);\n  offset += string.encode.bytes;\n  string.encode(data.os, buf, offset);\n  offset += string.encode.bytes;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rhinfo.encode.bytes = offset - oldOffset;\n  return buf;\n};\nrhinfo.encode.bytes = 0;\nrhinfo.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.cpu = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.os = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  rhinfo.decode.bytes = offset - oldOffset;\n  return data;\n};\nrhinfo.decode.bytes = 0;\nrhinfo.encodingLength = function (data) {\n  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2;\n};\nconst rptr = exports.ptr = {};\nconst rcname = exports.cname = rptr;\nconst rdname = exports.dname = rptr;\nrptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rptr.encodingLength(data));\n  if (!offset) offset = 0;\n  name.encode(data, buf, offset + 2);\n  buf.writeUInt16BE(name.encode.bytes, offset);\n  rptr.encode.bytes = name.encode.bytes + 2;\n  return buf;\n};\nrptr.encode.bytes = 0;\nrptr.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const data = name.decode(buf, offset + 2);\n  rptr.decode.bytes = name.decode.bytes + 2;\n  return data;\n};\nrptr.decode.bytes = 0;\nrptr.encodingLength = function (data) {\n  return name.encodingLength(data) + 2;\n};\nconst rsrv = exports.srv = {};\nrsrv.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsrv.encodingLength(data));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(data.priority || 0, offset + 2);\n  buf.writeUInt16BE(data.weight || 0, offset + 4);\n  buf.writeUInt16BE(data.port || 0, offset + 6);\n  name.encode(data.target, buf, offset + 8);\n  const len = name.encode.bytes + 6;\n  buf.writeUInt16BE(len, offset);\n  rsrv.encode.bytes = len + 2;\n  return buf;\n};\nrsrv.encode.bytes = 0;\nrsrv.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const data = {};\n  data.priority = buf.readUInt16BE(offset + 2);\n  data.weight = buf.readUInt16BE(offset + 4);\n  data.port = buf.readUInt16BE(offset + 6);\n  data.target = name.decode(buf, offset + 8);\n  rsrv.decode.bytes = len + 2;\n  return data;\n};\nrsrv.decode.bytes = 0;\nrsrv.encodingLength = function (data) {\n  return 8 + name.encodingLength(data.target);\n};\nconst rcaa = exports.caa = {};\nrcaa.ISSUER_CRITICAL = 1 << 7;\nrcaa.encode = function (data, buf, offset) {\n  const len = rcaa.encodingLength(data);\n  if (!buf) buf = Buffer.alloc(rcaa.encodingLength(data));\n  if (!offset) offset = 0;\n  if (data.issuerCritical) {\n    data.flags = rcaa.ISSUER_CRITICAL;\n  }\n  buf.writeUInt16BE(len - 2, offset);\n  offset += 2;\n  buf.writeUInt8(data.flags || 0, offset);\n  offset += 1;\n  string.encode(data.tag, buf, offset);\n  offset += string.encode.bytes;\n  buf.write(data.value, offset);\n  offset += Buffer.byteLength(data.value);\n  rcaa.encode.bytes = len;\n  return buf;\n};\nrcaa.encode.bytes = 0;\nrcaa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  const oldOffset = offset;\n  const data = {};\n  data.flags = buf.readUInt8(offset);\n  offset += 1;\n  data.tag = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.value = buf.toString('utf-8', offset, oldOffset + len);\n  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL);\n  rcaa.decode.bytes = len + 2;\n  return data;\n};\nrcaa.decode.bytes = 0;\nrcaa.encodingLength = function (data) {\n  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2;\n};\nconst rmx = exports.mx = {};\nrmx.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rmx.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  buf.writeUInt16BE(data.preference || 0, offset);\n  offset += 2;\n  name.encode(data.exchange, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rmx.encode.bytes = offset - oldOffset;\n  return buf;\n};\nrmx.encode.bytes = 0;\nrmx.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.preference = buf.readUInt16BE(offset);\n  offset += 2;\n  data.exchange = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  rmx.decode.bytes = offset - oldOffset;\n  return data;\n};\nrmx.encodingLength = function (data) {\n  return 4 + name.encodingLength(data.exchange);\n};\nconst ra = exports.a = {};\nra.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ra.encodingLength(host));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(4, offset);\n  offset += 2;\n  ip.v4.encode(host, buf, offset);\n  ra.encode.bytes = 6;\n  return buf;\n};\nra.encode.bytes = 0;\nra.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  offset += 2;\n  const host = ip.v4.decode(buf, offset);\n  ra.decode.bytes = 6;\n  return host;\n};\nra.decode.bytes = 0;\nra.encodingLength = function () {\n  return 6;\n};\nconst raaaa = exports.aaaa = {};\nraaaa.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(raaaa.encodingLength(host));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(16, offset);\n  offset += 2;\n  ip.v6.encode(host, buf, offset);\n  raaaa.encode.bytes = 18;\n  return buf;\n};\nraaaa.encode.bytes = 0;\nraaaa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  offset += 2;\n  const host = ip.v6.decode(buf, offset);\n  raaaa.decode.bytes = 18;\n  return host;\n};\nraaaa.decode.bytes = 0;\nraaaa.encodingLength = function () {\n  return 18;\n};\nconst roption = exports.option = {};\nroption.encode = function (option, buf, offset) {\n  if (!buf) buf = Buffer.alloc(roption.encodingLength(option));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const code = optioncodes.toCode(option.code);\n  buf.writeUInt16BE(code, offset);\n  offset += 2;\n  if (option.data) {\n    buf.writeUInt16BE(option.data.length, offset);\n    offset += 2;\n    option.data.copy(buf, offset);\n    offset += option.data.length;\n  } else {\n    switch (code) {\n      // case 3: NSID.  No encode makes sense.\n      // case 5,6,7: Not implementable\n      case 8:\n        // ECS\n        // note: do IP math before calling\n        const spl = option.sourcePrefixLength || 0;\n        const fam = option.family || ip.familyOf(option.ip);\n        const ipBuf = ip.encode(option.ip, Buffer.alloc);\n        const ipLen = Math.ceil(spl / 8);\n        buf.writeUInt16BE(ipLen + 4, offset);\n        offset += 2;\n        buf.writeUInt16BE(fam, offset);\n        offset += 2;\n        buf.writeUInt8(spl, offset++);\n        buf.writeUInt8(option.scopePrefixLength || 0, offset++);\n        ipBuf.copy(buf, offset, 0, ipLen);\n        offset += ipLen;\n        break;\n      // case 9: EXPIRE (experimental)\n      // case 10: COOKIE.  No encode makes sense.\n      case 11:\n        // KEEP-ALIVE\n        if (option.timeout) {\n          buf.writeUInt16BE(2, offset);\n          offset += 2;\n          buf.writeUInt16BE(option.timeout, offset);\n          offset += 2;\n        } else {\n          buf.writeUInt16BE(0, offset);\n          offset += 2;\n        }\n        break;\n      case 12:\n        // PADDING\n        const len = option.length || 0;\n        buf.writeUInt16BE(len, offset);\n        offset += 2;\n        buf.fill(0, offset, offset + len);\n        offset += len;\n        break;\n      // case 13:  CHAIN.  Experimental.\n      case 14:\n        // KEY-TAG\n        const tagsLen = option.tags.length * 2;\n        buf.writeUInt16BE(tagsLen, offset);\n        offset += 2;\n        for (const tag of option.tags) {\n          buf.writeUInt16BE(tag, offset);\n          offset += 2;\n        }\n        break;\n      default:\n        throw new Error(`Unknown roption code: ${option.code}`);\n    }\n  }\n  roption.encode.bytes = offset - oldOffset;\n  return buf;\n};\nroption.encode.bytes = 0;\nroption.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const option = {};\n  option.code = buf.readUInt16BE(offset);\n  option.type = optioncodes.toString(option.code);\n  offset += 2;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  option.data = buf.slice(offset, offset + len);\n  switch (option.code) {\n    // case 3: NSID.  No decode makes sense.\n    case 8:\n      // ECS\n      option.family = buf.readUInt16BE(offset);\n      offset += 2;\n      option.sourcePrefixLength = buf.readUInt8(offset++);\n      option.scopePrefixLength = buf.readUInt8(offset++);\n      const padded = Buffer.alloc(option.family === 1 ? 4 : 16);\n      buf.copy(padded, 0, offset, offset + len - 4);\n      option.ip = ip.decode(padded);\n      break;\n    // case 12: Padding.  No decode makes sense.\n    case 11:\n      // KEEP-ALIVE\n      if (len > 0) {\n        option.timeout = buf.readUInt16BE(offset);\n        offset += 2;\n      }\n      break;\n    case 14:\n      option.tags = [];\n      for (let i = 0; i < len; i += 2) {\n        option.tags.push(buf.readUInt16BE(offset));\n        offset += 2;\n      }\n    // don't worry about default.  caller will use data if desired\n  }\n\n  roption.decode.bytes = len + 4;\n  return option;\n};\nroption.decode.bytes = 0;\nroption.encodingLength = function (option) {\n  if (option.data) {\n    return option.data.length + 4;\n  }\n  const code = optioncodes.toCode(option.code);\n  switch (code) {\n    case 8:\n      // ECS\n      const spl = option.sourcePrefixLength || 0;\n      return Math.ceil(spl / 8) + 8;\n    case 11:\n      // KEEP-ALIVE\n      return typeof option.timeout === 'number' ? 6 : 4;\n    case 12:\n      // PADDING\n      return option.length + 4;\n    case 14:\n      // KEY-TAG\n      return 4 + option.tags.length * 2;\n  }\n  throw new Error(`Unknown roption code: ${option.code}`);\n};\nconst ropt = exports.opt = {};\nropt.encode = function (options, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ropt.encodingLength(options));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const rdlen = encodingLengthList(options, roption);\n  buf.writeUInt16BE(rdlen, offset);\n  offset = encodeList(options, roption, buf, offset + 2);\n  ropt.encode.bytes = offset - oldOffset;\n  return buf;\n};\nropt.encode.bytes = 0;\nropt.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const options = [];\n  let rdlen = buf.readUInt16BE(offset);\n  offset += 2;\n  let o = 0;\n  while (rdlen > 0) {\n    options[o++] = roption.decode(buf, offset);\n    offset += roption.decode.bytes;\n    rdlen -= roption.decode.bytes;\n  }\n  ropt.decode.bytes = offset - oldOffset;\n  return options;\n};\nropt.decode.bytes = 0;\nropt.encodingLength = function (options) {\n  return 2 + encodingLengthList(options || [], roption);\n};\nconst rdnskey = exports.dnskey = {};\nrdnskey.PROTOCOL_DNSSEC = 3;\nrdnskey.ZONE_KEY = 0x80;\nrdnskey.SECURE_ENTRYPOINT = 0x8000;\nrdnskey.encode = function (key, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rdnskey.encodingLength(key));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const keydata = key.key;\n  if (!Buffer.isBuffer(keydata)) {\n    throw new Error('Key must be a Buffer');\n  }\n  offset += 2; // Leave space for length\n  buf.writeUInt16BE(key.flags, offset);\n  offset += 2;\n  buf.writeUInt8(rdnskey.PROTOCOL_DNSSEC, offset);\n  offset += 1;\n  buf.writeUInt8(key.algorithm, offset);\n  offset += 1;\n  keydata.copy(buf, offset, 0, keydata.length);\n  offset += keydata.length;\n  rdnskey.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rdnskey.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrdnskey.encode.bytes = 0;\nrdnskey.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var key = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  key.flags = buf.readUInt16BE(offset);\n  offset += 2;\n  if (buf.readUInt8(offset) !== rdnskey.PROTOCOL_DNSSEC) {\n    throw new Error('Protocol must be 3');\n  }\n  offset += 1;\n  key.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  key.key = buf.slice(offset, oldOffset + length + 2);\n  offset += key.key.length;\n  rdnskey.decode.bytes = offset - oldOffset;\n  return key;\n};\nrdnskey.decode.bytes = 0;\nrdnskey.encodingLength = function (key) {\n  return 6 + Buffer.byteLength(key.key);\n};\nconst rrrsig = exports.rrsig = {};\nrrrsig.encode = function (sig, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrrsig.encodingLength(sig));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const signature = sig.signature;\n  if (!Buffer.isBuffer(signature)) {\n    throw new Error('Signature must be a Buffer');\n  }\n  offset += 2; // Leave space for length\n  buf.writeUInt16BE(types.toType(sig.typeCovered), offset);\n  offset += 2;\n  buf.writeUInt8(sig.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(sig.labels, offset);\n  offset += 1;\n  buf.writeUInt32BE(sig.originalTTL, offset);\n  offset += 4;\n  buf.writeUInt32BE(sig.expiration, offset);\n  offset += 4;\n  buf.writeUInt32BE(sig.inception, offset);\n  offset += 4;\n  buf.writeUInt16BE(sig.keyTag, offset);\n  offset += 2;\n  name.encode(sig.signersName, buf, offset);\n  offset += name.encode.bytes;\n  signature.copy(buf, offset, 0, signature.length);\n  offset += signature.length;\n  rrrsig.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rrrsig.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrrrsig.encode.bytes = 0;\nrrrsig.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var sig = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  sig.typeCovered = types.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  sig.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  sig.labels = buf.readUInt8(offset);\n  offset += 1;\n  sig.originalTTL = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.expiration = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.inception = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.keyTag = buf.readUInt16BE(offset);\n  offset += 2;\n  sig.signersName = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  sig.signature = buf.slice(offset, oldOffset + length + 2);\n  offset += sig.signature.length;\n  rrrsig.decode.bytes = offset - oldOffset;\n  return sig;\n};\nrrrsig.decode.bytes = 0;\nrrrsig.encodingLength = function (sig) {\n  return 20 + name.encodingLength(sig.signersName) + Buffer.byteLength(sig.signature);\n};\nconst rrp = exports.rp = {};\nrrp.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrp.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // Leave space for length\n  name.encode(data.mbox || '.', buf, offset);\n  offset += name.encode.bytes;\n  name.encode(data.txt || '.', buf, offset);\n  offset += name.encode.bytes;\n  rrp.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rrp.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrrp.encode.bytes = 0;\nrrp.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.mbox = name.decode(buf, offset) || '.';\n  offset += name.decode.bytes;\n  data.txt = name.decode(buf, offset) || '.';\n  offset += name.decode.bytes;\n  rrp.decode.bytes = offset - oldOffset;\n  return data;\n};\nrrp.decode.bytes = 0;\nrrp.encodingLength = function (data) {\n  return 2 + name.encodingLength(data.mbox || '.') + name.encodingLength(data.txt || '.');\n};\nconst typebitmap = {};\ntypebitmap.encode = function (typelist, buf, offset) {\n  if (!buf) buf = Buffer.alloc(typebitmap.encodingLength(typelist));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var typesByWindow = [];\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i]);\n    if (typesByWindow[typeid >> 8] === undefined) {\n      typesByWindow[typeid >> 8] = [];\n    }\n    typesByWindow[typeid >> 8][typeid >> 3 & 0x1F] |= 1 << 7 - (typeid & 0x7);\n  }\n  for (i = 0; i < typesByWindow.length; i++) {\n    if (typesByWindow[i] !== undefined) {\n      var windowBuf = Buffer.from(typesByWindow[i]);\n      buf.writeUInt8(i, offset);\n      offset += 1;\n      buf.writeUInt8(windowBuf.length, offset);\n      offset += 1;\n      windowBuf.copy(buf, offset);\n      offset += windowBuf.length;\n    }\n  }\n  typebitmap.encode.bytes = offset - oldOffset;\n  return buf;\n};\ntypebitmap.encode.bytes = 0;\ntypebitmap.decode = function (buf, offset, length) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var typelist = [];\n  while (offset - oldOffset < length) {\n    var window = buf.readUInt8(offset);\n    offset += 1;\n    var windowLength = buf.readUInt8(offset);\n    offset += 1;\n    for (var i = 0; i < windowLength; i++) {\n      var b = buf.readUInt8(offset + i);\n      for (var j = 0; j < 8; j++) {\n        if (b & 1 << 7 - j) {\n          var typeid = types.toString(window << 8 | i << 3 | j);\n          typelist.push(typeid);\n        }\n      }\n    }\n    offset += windowLength;\n  }\n  typebitmap.decode.bytes = offset - oldOffset;\n  return typelist;\n};\ntypebitmap.decode.bytes = 0;\ntypebitmap.encodingLength = function (typelist) {\n  var extents = [];\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i]);\n    extents[typeid >> 8] = Math.max(extents[typeid >> 8] || 0, typeid & 0xFF);\n  }\n  var len = 0;\n  for (i = 0; i < extents.length; i++) {\n    if (extents[i] !== undefined) {\n      len += 2 + Math.ceil((extents[i] + 1) / 8);\n    }\n  }\n  return len;\n};\nconst rnsec = exports.nsec = {};\nrnsec.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // Leave space for length\n  name.encode(record.nextDomain, buf, offset);\n  offset += name.encode.bytes;\n  typebitmap.encode(record.rrtypes, buf, offset);\n  offset += typebitmap.encode.bytes;\n  rnsec.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rnsec.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrnsec.encode.bytes = 0;\nrnsec.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var record = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  record.nextDomain = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset));\n  offset += typebitmap.decode.bytes;\n  rnsec.decode.bytes = offset - oldOffset;\n  return record;\n};\nrnsec.decode.bytes = 0;\nrnsec.encodingLength = function (record) {\n  return 2 + name.encodingLength(record.nextDomain) + typebitmap.encodingLength(record.rrtypes);\n};\nconst rnsec3 = exports.nsec3 = {};\nrnsec3.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec3.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const salt = record.salt;\n  if (!Buffer.isBuffer(salt)) {\n    throw new Error('salt must be a Buffer');\n  }\n  const nextDomain = record.nextDomain;\n  if (!Buffer.isBuffer(nextDomain)) {\n    throw new Error('nextDomain must be a Buffer');\n  }\n  offset += 2; // Leave space for length\n  buf.writeUInt8(record.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(record.flags, offset);\n  offset += 1;\n  buf.writeUInt16BE(record.iterations, offset);\n  offset += 2;\n  buf.writeUInt8(salt.length, offset);\n  offset += 1;\n  salt.copy(buf, offset, 0, salt.length);\n  offset += salt.length;\n  buf.writeUInt8(nextDomain.length, offset);\n  offset += 1;\n  nextDomain.copy(buf, offset, 0, nextDomain.length);\n  offset += nextDomain.length;\n  typebitmap.encode(record.rrtypes, buf, offset);\n  offset += typebitmap.encode.bytes;\n  rnsec3.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rnsec3.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrnsec3.encode.bytes = 0;\nrnsec3.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var record = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  record.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  record.flags = buf.readUInt8(offset);\n  offset += 1;\n  record.iterations = buf.readUInt16BE(offset);\n  offset += 2;\n  const saltLength = buf.readUInt8(offset);\n  offset += 1;\n  record.salt = buf.slice(offset, offset + saltLength);\n  offset += saltLength;\n  const hashLength = buf.readUInt8(offset);\n  offset += 1;\n  record.nextDomain = buf.slice(offset, offset + hashLength);\n  offset += hashLength;\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset));\n  offset += typebitmap.decode.bytes;\n  rnsec3.decode.bytes = offset - oldOffset;\n  return record;\n};\nrnsec3.decode.bytes = 0;\nrnsec3.encodingLength = function (record) {\n  return 8 + record.salt.length + record.nextDomain.length + typebitmap.encodingLength(record.rrtypes);\n};\nconst rds = exports.ds = {};\nrds.encode = function (digest, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rds.encodingLength(digest));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const digestdata = digest.digest;\n  if (!Buffer.isBuffer(digestdata)) {\n    throw new Error('Digest must be a Buffer');\n  }\n  offset += 2; // Leave space for length\n  buf.writeUInt16BE(digest.keyTag, offset);\n  offset += 2;\n  buf.writeUInt8(digest.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(digest.digestType, offset);\n  offset += 1;\n  digestdata.copy(buf, offset, 0, digestdata.length);\n  offset += digestdata.length;\n  rds.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rds.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrds.encode.bytes = 0;\nrds.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var digest = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  digest.keyTag = buf.readUInt16BE(offset);\n  offset += 2;\n  digest.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  digest.digestType = buf.readUInt8(offset);\n  offset += 1;\n  digest.digest = buf.slice(offset, oldOffset + length + 2);\n  offset += digest.digest.length;\n  rds.decode.bytes = offset - oldOffset;\n  return digest;\n};\nrds.decode.bytes = 0;\nrds.encodingLength = function (digest) {\n  return 6 + Buffer.byteLength(digest.digest);\n};\nconst rsshfp = exports.sshfp = {};\nrsshfp.getFingerprintLengthForHashType = function getFingerprintLengthForHashType(hashType) {\n  switch (hashType) {\n    case 1:\n      return 20;\n    case 2:\n      return 32;\n  }\n};\nrsshfp.encode = function encode(record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsshfp.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // The function call starts with the offset pointer at the RDLENGTH field, not the RDATA one\n  buf[offset] = record.algorithm;\n  offset += 1;\n  buf[offset] = record.hash;\n  offset += 1;\n  const fingerprintBuf = Buffer.from(record.fingerprint.toUpperCase(), 'hex');\n  if (fingerprintBuf.length !== rsshfp.getFingerprintLengthForHashType(record.hash)) {\n    throw new Error('Invalid fingerprint length');\n  }\n  fingerprintBuf.copy(buf, offset);\n  offset += fingerprintBuf.byteLength;\n  rsshfp.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rsshfp.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrsshfp.encode.bytes = 0;\nrsshfp.decode = function decode(buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const record = {};\n  offset += 2; // Account for the RDLENGTH field\n  record.algorithm = buf[offset];\n  offset += 1;\n  record.hash = buf[offset];\n  offset += 1;\n  const fingerprintLength = rsshfp.getFingerprintLengthForHashType(record.hash);\n  record.fingerprint = buf.slice(offset, offset + fingerprintLength).toString('hex').toUpperCase();\n  offset += fingerprintLength;\n  rsshfp.decode.bytes = offset - oldOffset;\n  return record;\n};\nrsshfp.decode.bytes = 0;\nrsshfp.encodingLength = function (record) {\n  return 4 + Buffer.from(record.fingerprint, 'hex').byteLength;\n};\nconst rnaptr = exports.naptr = {};\nrnaptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnaptr.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  buf.writeUInt16BE(data.order || 0, offset);\n  offset += 2;\n  buf.writeUInt16BE(data.preference || 0, offset);\n  offset += 2;\n  string.encode(data.flags, buf, offset);\n  offset += string.encode.bytes;\n  string.encode(data.services, buf, offset);\n  offset += string.encode.bytes;\n  string.encode(data.regexp, buf, offset);\n  offset += string.encode.bytes;\n  name.encode(data.replacement, buf, offset);\n  offset += name.encode.bytes;\n  rnaptr.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rnaptr.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrnaptr.encode.bytes = 0;\nrnaptr.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.order = buf.readUInt16BE(offset);\n  offset += 2;\n  data.preference = buf.readUInt16BE(offset);\n  offset += 2;\n  data.flags = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.services = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.regexp = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.replacement = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  rnaptr.decode.bytes = offset - oldOffset;\n  return data;\n};\nrnaptr.decode.bytes = 0;\nrnaptr.encodingLength = function (data) {\n  return string.encodingLength(data.flags) + string.encodingLength(data.services) + string.encodingLength(data.regexp) + name.encodingLength(data.replacement) + 6;\n};\nconst rtlsa = exports.tlsa = {};\nrtlsa.encode = function (cert, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rtlsa.encodingLength(cert));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const certdata = cert.certificate;\n  if (!Buffer.isBuffer(certdata)) {\n    throw new Error('Certificate must be a Buffer');\n  }\n  offset += 2; // Leave space for length\n  buf.writeUInt8(cert.usage, offset);\n  offset += 1;\n  buf.writeUInt8(cert.selector, offset);\n  offset += 1;\n  buf.writeUInt8(cert.matchingType, offset);\n  offset += 1;\n  certdata.copy(buf, offset, 0, certdata.length);\n  offset += certdata.length;\n  rtlsa.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rtlsa.encode.bytes - 2, oldOffset);\n  return buf;\n};\nrtlsa.encode.bytes = 0;\nrtlsa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const cert = {};\n  const length = buf.readUInt16BE(offset);\n  offset += 2;\n  cert.usage = buf.readUInt8(offset);\n  offset += 1;\n  cert.selector = buf.readUInt8(offset);\n  offset += 1;\n  cert.matchingType = buf.readUInt8(offset);\n  offset += 1;\n  cert.certificate = buf.slice(offset, oldOffset + length + 2);\n  offset += cert.certificate.length;\n  rtlsa.decode.bytes = offset - oldOffset;\n  return cert;\n};\nrtlsa.decode.bytes = 0;\nrtlsa.encodingLength = function (cert) {\n  return 5 + Buffer.byteLength(cert.certificate);\n};\nconst renc = exports.record = function (type) {\n  switch (type.toUpperCase()) {\n    case 'A':\n      return ra;\n    case 'PTR':\n      return rptr;\n    case 'CNAME':\n      return rcname;\n    case 'DNAME':\n      return rdname;\n    case 'TXT':\n      return rtxt;\n    case 'NULL':\n      return rnull;\n    case 'AAAA':\n      return raaaa;\n    case 'SRV':\n      return rsrv;\n    case 'HINFO':\n      return rhinfo;\n    case 'CAA':\n      return rcaa;\n    case 'NS':\n      return rns;\n    case 'SOA':\n      return rsoa;\n    case 'MX':\n      return rmx;\n    case 'OPT':\n      return ropt;\n    case 'DNSKEY':\n      return rdnskey;\n    case 'RRSIG':\n      return rrrsig;\n    case 'RP':\n      return rrp;\n    case 'NSEC':\n      return rnsec;\n    case 'NSEC3':\n      return rnsec3;\n    case 'SSHFP':\n      return rsshfp;\n    case 'DS':\n      return rds;\n    case 'NAPTR':\n      return rnaptr;\n    case 'TLSA':\n      return rtlsa;\n  }\n  return runknown;\n};\nconst answer = exports.answer = {};\nanswer.encode = function (a, buf, offset) {\n  if (!buf) buf = Buffer.alloc(answer.encodingLength(a));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  name.encode(a.name, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(types.toType(a.type), offset);\n  if (a.type.toUpperCase() === 'OPT') {\n    if (a.name !== '.') {\n      throw new Error('OPT name must be root.');\n    }\n    buf.writeUInt16BE(a.udpPayloadSize || 4096, offset + 2);\n    buf.writeUInt8(a.extendedRcode || 0, offset + 4);\n    buf.writeUInt8(a.ednsVersion || 0, offset + 5);\n    buf.writeUInt16BE(a.flags || 0, offset + 6);\n    offset += 8;\n    ropt.encode(a.options || [], buf, offset);\n    offset += ropt.encode.bytes;\n  } else {\n    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class);\n    if (a.flush) klass |= FLUSH_MASK; // the 1st bit of the class is the flush bit\n    buf.writeUInt16BE(klass, offset + 2);\n    buf.writeUInt32BE(a.ttl || 0, offset + 4);\n    offset += 8;\n    const enc = renc(a.type);\n    enc.encode(a.data, buf, offset);\n    offset += enc.encode.bytes;\n  }\n  answer.encode.bytes = offset - oldOffset;\n  return buf;\n};\nanswer.encode.bytes = 0;\nanswer.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const a = {};\n  const oldOffset = offset;\n  a.name = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  a.type = types.toString(buf.readUInt16BE(offset));\n  if (a.type === 'OPT') {\n    a.udpPayloadSize = buf.readUInt16BE(offset + 2);\n    a.extendedRcode = buf.readUInt8(offset + 4);\n    a.ednsVersion = buf.readUInt8(offset + 5);\n    a.flags = buf.readUInt16BE(offset + 6);\n    a.flag_do = (a.flags >> 15 & 0x1) === 1;\n    a.options = ropt.decode(buf, offset + 8);\n    offset += 8 + ropt.decode.bytes;\n  } else {\n    const klass = buf.readUInt16BE(offset + 2);\n    a.ttl = buf.readUInt32BE(offset + 4);\n    a.class = classes.toString(klass & NOT_FLUSH_MASK);\n    a.flush = !!(klass & FLUSH_MASK);\n    const enc = renc(a.type);\n    a.data = enc.decode(buf, offset + 8);\n    offset += 8 + enc.decode.bytes;\n  }\n  answer.decode.bytes = offset - oldOffset;\n  return a;\n};\nanswer.decode.bytes = 0;\nanswer.encodingLength = function (a) {\n  const data = a.data !== null && a.data !== undefined ? a.data : a.options;\n  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data);\n};\nconst question = exports.question = {};\nquestion.encode = function (q, buf, offset) {\n  if (!buf) buf = Buffer.alloc(question.encodingLength(q));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  name.encode(q.name, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(types.toType(q.type), offset);\n  offset += 2;\n  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset);\n  offset += 2;\n  question.encode.bytes = offset - oldOffset;\n  return q;\n};\nquestion.encode.bytes = 0;\nquestion.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const q = {};\n  q.name = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  q.type = types.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  q.class = classes.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  const qu = !!(q.class & QU_MASK);\n  if (qu) q.class &= NOT_QU_MASK;\n  question.decode.bytes = offset - oldOffset;\n  return q;\n};\nquestion.decode.bytes = 0;\nquestion.encodingLength = function (q) {\n  return name.encodingLength(q.name) + 4;\n};\nexports.AUTHORITATIVE_ANSWER = 1 << 10;\nexports.TRUNCATED_RESPONSE = 1 << 9;\nexports.RECURSION_DESIRED = 1 << 8;\nexports.RECURSION_AVAILABLE = 1 << 7;\nexports.AUTHENTIC_DATA = 1 << 5;\nexports.CHECKING_DISABLED = 1 << 4;\nexports.DNSSEC_OK = 1 << 15;\nexports.encode = function (result, buf, offset) {\n  const allocing = !buf;\n  if (allocing) buf = Buffer.alloc(exports.encodingLength(result));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  if (!result.questions) result.questions = [];\n  if (!result.answers) result.answers = [];\n  if (!result.authorities) result.authorities = [];\n  if (!result.additionals) result.additionals = [];\n  header.encode(result, buf, offset);\n  offset += header.encode.bytes;\n  offset = encodeList(result.questions, question, buf, offset);\n  offset = encodeList(result.answers, answer, buf, offset);\n  offset = encodeList(result.authorities, answer, buf, offset);\n  offset = encodeList(result.additionals, answer, buf, offset);\n  exports.encode.bytes = offset - oldOffset;\n\n  // just a quick sanity check\n  if (allocing && exports.encode.bytes !== buf.length) {\n    return buf.slice(0, exports.encode.bytes);\n  }\n  return buf;\n};\nexports.encode.bytes = 0;\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const result = header.decode(buf, offset);\n  offset += header.decode.bytes;\n  offset = decodeList(result.questions, question, buf, offset);\n  offset = decodeList(result.answers, answer, buf, offset);\n  offset = decodeList(result.authorities, answer, buf, offset);\n  offset = decodeList(result.additionals, answer, buf, offset);\n  exports.decode.bytes = offset - oldOffset;\n  return result;\n};\nexports.decode.bytes = 0;\nexports.encodingLength = function (result) {\n  return header.encodingLength(result) + encodingLengthList(result.questions || [], question) + encodingLengthList(result.answers || [], answer) + encodingLengthList(result.authorities || [], answer) + encodingLengthList(result.additionals || [], answer);\n};\nexports.streamEncode = function (result) {\n  const buf = exports.encode(result);\n  const sbuf = Buffer.alloc(2);\n  sbuf.writeUInt16BE(buf.byteLength);\n  const combine = Buffer.concat([sbuf, buf]);\n  exports.streamEncode.bytes = combine.byteLength;\n  return combine;\n};\nexports.streamEncode.bytes = 0;\nexports.streamDecode = function (sbuf) {\n  const len = sbuf.readUInt16BE(0);\n  if (sbuf.byteLength < len + 2) {\n    // not enough data\n    return null;\n  }\n  const result = exports.decode(sbuf.slice(2));\n  exports.streamDecode.bytes = exports.decode.bytes;\n  return result;\n};\nexports.streamDecode.bytes = 0;\nfunction encodingLengthList(list, enc) {\n  let len = 0;\n  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i]);\n  return len;\n}\nfunction encodeList(list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    enc.encode(list[i], buf, offset);\n    offset += enc.encode.bytes;\n  }\n  return offset;\n}\nfunction decodeList(list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    list[i] = enc.decode(buf, offset);\n    offset += enc.decode.bytes;\n  }\n  return offset;\n}","map":{"version":3,"names":["Buffer","require","types","rcodes","opcodes","classes","optioncodes","ip","QUERY_FLAG","RESPONSE_FLAG","FLUSH_MASK","NOT_FLUSH_MASK","QU_MASK","NOT_QU_MASK","name","exports","encode","str","buf","offset","alloc","encodingLength","oldOffset","n","replace","length","list","split","i","len","write","bytes","decode","totalLength","consumedBytes","jumped","Error","push","toString","jumpOffset","readUInt16BE","join","byteLength","string","s","header","h","flags","type","writeUInt16BE","id","questions","answers","authorities","additionals","flag_qr","opcode","flag_aa","flag_tc","flag_rd","flag_ra","flag_z","flag_ad","flag_cd","rcode","Array","runknown","unknown","data","copy","slice","rns","ns","dd","rsoa","soa","mname","rname","writeUInt32BE","serial","refresh","retry","expire","minimum","readUInt32BE","rtxt","txt","isArray","from","isBuffer","forEach","d","remaining","rnull","null","rhinfo","hinfo","cpu","os","rptr","ptr","rcname","cname","rdname","dname","rsrv","srv","priority","weight","port","target","rcaa","caa","ISSUER_CRITICAL","issuerCritical","writeUInt8","tag","value","readUInt8","rmx","mx","preference","exchange","ra","a","host","v4","raaaa","aaaa","v6","roption","option","code","toCode","spl","sourcePrefixLength","fam","family","familyOf","ipBuf","ipLen","Math","ceil","scopePrefixLength","timeout","fill","tagsLen","tags","padded","ropt","opt","options","rdlen","encodingLengthList","encodeList","o","rdnskey","dnskey","PROTOCOL_DNSSEC","ZONE_KEY","SECURE_ENTRYPOINT","key","keydata","algorithm","rrrsig","rrsig","sig","signature","toType","typeCovered","labels","originalTTL","expiration","inception","keyTag","signersName","rrp","rp","mbox","typebitmap","typelist","typesByWindow","typeid","undefined","windowBuf","window","windowLength","b","j","extents","max","rnsec","nsec","record","nextDomain","rrtypes","rnsec3","nsec3","salt","iterations","saltLength","hashLength","rds","ds","digest","digestdata","digestType","rsshfp","sshfp","getFingerprintLengthForHashType","hashType","hash","fingerprintBuf","fingerprint","toUpperCase","fingerprintLength","rnaptr","naptr","order","services","regexp","replacement","rtlsa","tlsa","cert","certdata","certificate","usage","selector","matchingType","renc","answer","udpPayloadSize","extendedRcode","ednsVersion","klass","toClass","class","flush","ttl","enc","flag_do","question","q","qu","AUTHORITATIVE_ANSWER","TRUNCATED_RESPONSE","RECURSION_DESIRED","RECURSION_AVAILABLE","AUTHENTIC_DATA","CHECKING_DISABLED","DNSSEC_OK","result","allocing","decodeList","streamEncode","sbuf","combine","concat","streamDecode"],"sources":["/home/hemanth/react-project/client/node_modules/dns-packet/index.js"],"sourcesContent":["'use strict'\n\nconst Buffer = require('buffer').Buffer\nconst types = require('./types')\nconst rcodes = require('./rcodes')\nconst opcodes = require('./opcodes')\nconst classes = require('./classes')\nconst optioncodes = require('./optioncodes')\nconst ip = require('@leichtgewicht/ip-codec')\n\nconst QUERY_FLAG = 0\nconst RESPONSE_FLAG = 1 << 15\nconst FLUSH_MASK = 1 << 15\nconst NOT_FLUSH_MASK = ~FLUSH_MASK\nconst QU_MASK = 1 << 15\nconst NOT_QU_MASK = ~QU_MASK\n\nconst name = exports.name = {}\n\nname.encode = function (str, buf, offset) {\n  if (!buf) buf = Buffer.alloc(name.encodingLength(str))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  // strip leading and trailing .\n  const n = str.replace(/^\\.|\\.$/gm, '')\n  if (n.length) {\n    const list = n.split('.')\n\n    for (let i = 0; i < list.length; i++) {\n      const len = buf.write(list[i], offset + 1)\n      buf[offset] = len\n      offset += len + 1\n    }\n  }\n\n  buf[offset++] = 0\n\n  name.encode.bytes = offset - oldOffset\n  return buf\n}\n\nname.encode.bytes = 0\n\nname.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const list = []\n  let oldOffset = offset\n  let totalLength = 0\n  let consumedBytes = 0\n  let jumped = false\n\n  while (true) {\n    if (offset >= buf.length) {\n      throw new Error('Cannot decode name (buffer overflow)')\n    }\n    const len = buf[offset++]\n    consumedBytes += jumped ? 0 : 1\n\n    if (len === 0) {\n      break\n    } else if ((len & 0xc0) === 0) {\n      if (offset + len > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)')\n      }\n      totalLength += len + 1\n      if (totalLength > 254) {\n        throw new Error('Cannot decode name (name too long)')\n      }\n      list.push(buf.toString('utf-8', offset, offset + len))\n      offset += len\n      consumedBytes += jumped ? 0 : len\n    } else if ((len & 0xc0) === 0xc0) {\n      if (offset + 1 > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)')\n      }\n      const jumpOffset = buf.readUInt16BE(offset - 1) - 0xc000\n      if (jumpOffset >= oldOffset) {\n        // Allow only pointers to prior data. RFC 1035, section 4.1.4 states:\n        // \"[...] an entire domain name or a list of labels at the end of a domain name\n        // is replaced with a pointer to a prior occurance (sic) of the same name.\"\n        throw new Error('Cannot decode name (bad pointer)')\n      }\n      offset = jumpOffset\n      oldOffset = jumpOffset\n      consumedBytes += jumped ? 0 : 1\n      jumped = true\n    } else {\n      throw new Error('Cannot decode name (bad label)')\n    }\n  }\n\n  name.decode.bytes = consumedBytes\n  return list.length === 0 ? '.' : list.join('.')\n}\n\nname.decode.bytes = 0\n\nname.encodingLength = function (n) {\n  if (n === '.' || n === '..') return 1\n  return Buffer.byteLength(n.replace(/^\\.|\\.$/gm, '')) + 2\n}\n\nconst string = {}\n\nstring.encode = function (s, buf, offset) {\n  if (!buf) buf = Buffer.alloc(string.encodingLength(s))\n  if (!offset) offset = 0\n\n  const len = buf.write(s, offset + 1)\n  buf[offset] = len\n  string.encode.bytes = len + 1\n  return buf\n}\n\nstring.encode.bytes = 0\n\nstring.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf[offset]\n  const s = buf.toString('utf-8', offset + 1, offset + 1 + len)\n  string.decode.bytes = len + 1\n  return s\n}\n\nstring.decode.bytes = 0\n\nstring.encodingLength = function (s) {\n  return Buffer.byteLength(s) + 1\n}\n\nconst header = {}\n\nheader.encode = function (h, buf, offset) {\n  if (!buf) buf = header.encodingLength(h)\n  if (!offset) offset = 0\n\n  const flags = (h.flags || 0) & 32767\n  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG\n\n  buf.writeUInt16BE(h.id || 0, offset)\n  buf.writeUInt16BE(flags | type, offset + 2)\n  buf.writeUInt16BE(h.questions.length, offset + 4)\n  buf.writeUInt16BE(h.answers.length, offset + 6)\n  buf.writeUInt16BE(h.authorities.length, offset + 8)\n  buf.writeUInt16BE(h.additionals.length, offset + 10)\n\n  return buf\n}\n\nheader.encode.bytes = 12\n\nheader.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  if (buf.length < 12) throw new Error('Header must be 12 bytes')\n  const flags = buf.readUInt16BE(offset + 2)\n\n  return {\n    id: buf.readUInt16BE(offset),\n    type: flags & RESPONSE_FLAG ? 'response' : 'query',\n    flags: flags & 32767,\n    flag_qr: ((flags >> 15) & 0x1) === 1,\n    opcode: opcodes.toString((flags >> 11) & 0xf),\n    flag_aa: ((flags >> 10) & 0x1) === 1,\n    flag_tc: ((flags >> 9) & 0x1) === 1,\n    flag_rd: ((flags >> 8) & 0x1) === 1,\n    flag_ra: ((flags >> 7) & 0x1) === 1,\n    flag_z: ((flags >> 6) & 0x1) === 1,\n    flag_ad: ((flags >> 5) & 0x1) === 1,\n    flag_cd: ((flags >> 4) & 0x1) === 1,\n    rcode: rcodes.toString(flags & 0xf),\n    questions: new Array(buf.readUInt16BE(offset + 4)),\n    answers: new Array(buf.readUInt16BE(offset + 6)),\n    authorities: new Array(buf.readUInt16BE(offset + 8)),\n    additionals: new Array(buf.readUInt16BE(offset + 10))\n  }\n}\n\nheader.decode.bytes = 12\n\nheader.encodingLength = function () {\n  return 12\n}\n\nconst runknown = exports.unknown = {}\n\nrunknown.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(runknown.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.length, offset)\n  data.copy(buf, offset + 2)\n\n  runknown.encode.bytes = data.length + 2\n  return buf\n}\n\nrunknown.encode.bytes = 0\n\nrunknown.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const data = buf.slice(offset + 2, offset + 2 + len)\n  runknown.decode.bytes = len + 2\n  return data\n}\n\nrunknown.decode.bytes = 0\n\nrunknown.encodingLength = function (data) {\n  return data.length + 2\n}\n\nconst rns = exports.ns = {}\n\nrns.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rns.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rns.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrns.encode.bytes = 0\n\nrns.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const dd = name.decode(buf, offset + 2)\n\n  rns.decode.bytes = len + 2\n  return dd\n}\n\nrns.decode.bytes = 0\n\nrns.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsoa = exports.soa = {}\n\nrsoa.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsoa.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  name.encode(data.mname, buf, offset)\n  offset += name.encode.bytes\n  name.encode(data.rname, buf, offset)\n  offset += name.encode.bytes\n  buf.writeUInt32BE(data.serial || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.refresh || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.retry || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.expire || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.minimum || 0, offset)\n  offset += 4\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rsoa.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrsoa.encode.bytes = 0\n\nrsoa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.mname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.rname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.serial = buf.readUInt32BE(offset)\n  offset += 4\n  data.refresh = buf.readUInt32BE(offset)\n  offset += 4\n  data.retry = buf.readUInt32BE(offset)\n  offset += 4\n  data.expire = buf.readUInt32BE(offset)\n  offset += 4\n  data.minimum = buf.readUInt32BE(offset)\n  offset += 4\n\n  rsoa.decode.bytes = offset - oldOffset\n  return data\n}\n\nrsoa.decode.bytes = 0\n\nrsoa.encodingLength = function (data) {\n  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname)\n}\n\nconst rtxt = exports.txt = {}\n\nrtxt.encode = function (data, buf, offset) {\n  if (!Array.isArray(data)) data = [data]\n  for (let i = 0; i < data.length; i++) {\n    if (typeof data[i] === 'string') {\n      data[i] = Buffer.from(data[i])\n    }\n    if (!Buffer.isBuffer(data[i])) {\n      throw new Error('Must be a Buffer')\n    }\n  }\n\n  if (!buf) buf = Buffer.alloc(rtxt.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n\n  data.forEach(function (d) {\n    buf[offset++] = d.length\n    d.copy(buf, offset, 0, d.length)\n    offset += d.length\n  })\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rtxt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrtxt.encode.bytes = 0\n\nrtxt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  let remaining = buf.readUInt16BE(offset)\n  offset += 2\n\n  let data = []\n  while (remaining > 0) {\n    const len = buf[offset++]\n    --remaining\n    if (remaining < len) {\n      throw new Error('Buffer overflow')\n    }\n    data.push(buf.slice(offset, offset + len))\n    offset += len\n    remaining -= len\n  }\n\n  rtxt.decode.bytes = offset - oldOffset\n  return data\n}\n\nrtxt.decode.bytes = 0\n\nrtxt.encodingLength = function (data) {\n  if (!Array.isArray(data)) data = [data]\n  let length = 2\n  data.forEach(function (buf) {\n    if (typeof buf === 'string') {\n      length += Buffer.byteLength(buf) + 1\n    } else {\n      length += buf.length + 1\n    }\n  })\n  return length\n}\n\nconst rnull = exports.null = {}\n\nrnull.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnull.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (typeof data === 'string') data = Buffer.from(data)\n  if (!data) data = Buffer.alloc(0)\n\n  const oldOffset = offset\n  offset += 2\n\n  const len = data.length\n  data.copy(buf, offset, 0, len)\n  offset += len\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rnull.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrnull.encode.bytes = 0\n\nrnull.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  const len = buf.readUInt16BE(offset)\n\n  offset += 2\n\n  const data = buf.slice(offset, offset + len)\n  offset += len\n\n  rnull.decode.bytes = offset - oldOffset\n  return data\n}\n\nrnull.decode.bytes = 0\n\nrnull.encodingLength = function (data) {\n  if (!data) return 2\n  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2\n}\n\nconst rhinfo = exports.hinfo = {}\n\nrhinfo.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rhinfo.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  string.encode(data.cpu, buf, offset)\n  offset += string.encode.bytes\n  string.encode(data.os, buf, offset)\n  offset += string.encode.bytes\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rhinfo.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrhinfo.encode.bytes = 0\n\nrhinfo.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.cpu = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.os = string.decode(buf, offset)\n  offset += string.decode.bytes\n  rhinfo.decode.bytes = offset - oldOffset\n  return data\n}\n\nrhinfo.decode.bytes = 0\n\nrhinfo.encodingLength = function (data) {\n  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2\n}\n\nconst rptr = exports.ptr = {}\nconst rcname = exports.cname = rptr\nconst rdname = exports.dname = rptr\n\nrptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rptr.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rptr.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrptr.encode.bytes = 0\n\nrptr.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const data = name.decode(buf, offset + 2)\n  rptr.decode.bytes = name.decode.bytes + 2\n  return data\n}\n\nrptr.decode.bytes = 0\n\nrptr.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsrv = exports.srv = {}\n\nrsrv.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsrv.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.priority || 0, offset + 2)\n  buf.writeUInt16BE(data.weight || 0, offset + 4)\n  buf.writeUInt16BE(data.port || 0, offset + 6)\n  name.encode(data.target, buf, offset + 8)\n\n  const len = name.encode.bytes + 6\n  buf.writeUInt16BE(len, offset)\n\n  rsrv.encode.bytes = len + 2\n  return buf\n}\n\nrsrv.encode.bytes = 0\n\nrsrv.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n\n  const data = {}\n  data.priority = buf.readUInt16BE(offset + 2)\n  data.weight = buf.readUInt16BE(offset + 4)\n  data.port = buf.readUInt16BE(offset + 6)\n  data.target = name.decode(buf, offset + 8)\n\n  rsrv.decode.bytes = len + 2\n  return data\n}\n\nrsrv.decode.bytes = 0\n\nrsrv.encodingLength = function (data) {\n  return 8 + name.encodingLength(data.target)\n}\n\nconst rcaa = exports.caa = {}\n\nrcaa.ISSUER_CRITICAL = 1 << 7\n\nrcaa.encode = function (data, buf, offset) {\n  const len = rcaa.encodingLength(data)\n\n  if (!buf) buf = Buffer.alloc(rcaa.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (data.issuerCritical) {\n    data.flags = rcaa.ISSUER_CRITICAL\n  }\n\n  buf.writeUInt16BE(len - 2, offset)\n  offset += 2\n  buf.writeUInt8(data.flags || 0, offset)\n  offset += 1\n  string.encode(data.tag, buf, offset)\n  offset += string.encode.bytes\n  buf.write(data.value, offset)\n  offset += Buffer.byteLength(data.value)\n\n  rcaa.encode.bytes = len\n  return buf\n}\n\nrcaa.encode.bytes = 0\n\nrcaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  offset += 2\n\n  const oldOffset = offset\n  const data = {}\n  data.flags = buf.readUInt8(offset)\n  offset += 1\n  data.tag = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.value = buf.toString('utf-8', offset, oldOffset + len)\n\n  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL)\n\n  rcaa.decode.bytes = len + 2\n\n  return data\n}\n\nrcaa.decode.bytes = 0\n\nrcaa.encodingLength = function (data) {\n  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2\n}\n\nconst rmx = exports.mx = {}\n\nrmx.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rmx.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  buf.writeUInt16BE(data.preference || 0, offset)\n  offset += 2\n  name.encode(data.exchange, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rmx.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrmx.encode.bytes = 0\n\nrmx.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.preference = buf.readUInt16BE(offset)\n  offset += 2\n  data.exchange = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  rmx.decode.bytes = offset - oldOffset\n  return data\n}\n\nrmx.encodingLength = function (data) {\n  return 4 + name.encodingLength(data.exchange)\n}\n\nconst ra = exports.a = {}\n\nra.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ra.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(4, offset)\n  offset += 2\n  ip.v4.encode(host, buf, offset)\n  ra.encode.bytes = 6\n  return buf\n}\n\nra.encode.bytes = 0\n\nra.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.v4.decode(buf, offset)\n  ra.decode.bytes = 6\n  return host\n}\n\nra.decode.bytes = 0\n\nra.encodingLength = function () {\n  return 6\n}\n\nconst raaaa = exports.aaaa = {}\n\nraaaa.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(raaaa.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(16, offset)\n  offset += 2\n  ip.v6.encode(host, buf, offset)\n  raaaa.encode.bytes = 18\n  return buf\n}\n\nraaaa.encode.bytes = 0\n\nraaaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.v6.decode(buf, offset)\n  raaaa.decode.bytes = 18\n  return host\n}\n\nraaaa.decode.bytes = 0\n\nraaaa.encodingLength = function () {\n  return 18\n}\n\nconst roption = exports.option = {}\n\nroption.encode = function (option, buf, offset) {\n  if (!buf) buf = Buffer.alloc(roption.encodingLength(option))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const code = optioncodes.toCode(option.code)\n  buf.writeUInt16BE(code, offset)\n  offset += 2\n  if (option.data) {\n    buf.writeUInt16BE(option.data.length, offset)\n    offset += 2\n    option.data.copy(buf, offset)\n    offset += option.data.length\n  } else {\n    switch (code) {\n      // case 3: NSID.  No encode makes sense.\n      // case 5,6,7: Not implementable\n      case 8: // ECS\n        // note: do IP math before calling\n        const spl = option.sourcePrefixLength || 0\n        const fam = option.family || ip.familyOf(option.ip)\n        const ipBuf = ip.encode(option.ip, Buffer.alloc)\n        const ipLen = Math.ceil(spl / 8)\n        buf.writeUInt16BE(ipLen + 4, offset)\n        offset += 2\n        buf.writeUInt16BE(fam, offset)\n        offset += 2\n        buf.writeUInt8(spl, offset++)\n        buf.writeUInt8(option.scopePrefixLength || 0, offset++)\n\n        ipBuf.copy(buf, offset, 0, ipLen)\n        offset += ipLen\n        break\n      // case 9: EXPIRE (experimental)\n      // case 10: COOKIE.  No encode makes sense.\n      case 11: // KEEP-ALIVE\n        if (option.timeout) {\n          buf.writeUInt16BE(2, offset)\n          offset += 2\n          buf.writeUInt16BE(option.timeout, offset)\n          offset += 2\n        } else {\n          buf.writeUInt16BE(0, offset)\n          offset += 2\n        }\n        break\n      case 12: // PADDING\n        const len = option.length || 0\n        buf.writeUInt16BE(len, offset)\n        offset += 2\n        buf.fill(0, offset, offset + len)\n        offset += len\n        break\n      // case 13:  CHAIN.  Experimental.\n      case 14: // KEY-TAG\n        const tagsLen = option.tags.length * 2\n        buf.writeUInt16BE(tagsLen, offset)\n        offset += 2\n        for (const tag of option.tags) {\n          buf.writeUInt16BE(tag, offset)\n          offset += 2\n        }\n        break\n      default:\n        throw new Error(`Unknown roption code: ${option.code}`)\n    }\n  }\n\n  roption.encode.bytes = offset - oldOffset\n  return buf\n}\n\nroption.encode.bytes = 0\n\nroption.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const option = {}\n  option.code = buf.readUInt16BE(offset)\n  option.type = optioncodes.toString(option.code)\n  offset += 2\n  const len = buf.readUInt16BE(offset)\n  offset += 2\n  option.data = buf.slice(offset, offset + len)\n  switch (option.code) {\n    // case 3: NSID.  No decode makes sense.\n    case 8: // ECS\n      option.family = buf.readUInt16BE(offset)\n      offset += 2\n      option.sourcePrefixLength = buf.readUInt8(offset++)\n      option.scopePrefixLength = buf.readUInt8(offset++)\n      const padded = Buffer.alloc((option.family === 1) ? 4 : 16)\n      buf.copy(padded, 0, offset, offset + len - 4)\n      option.ip = ip.decode(padded)\n      break\n    // case 12: Padding.  No decode makes sense.\n    case 11: // KEEP-ALIVE\n      if (len > 0) {\n        option.timeout = buf.readUInt16BE(offset)\n        offset += 2\n      }\n      break\n    case 14:\n      option.tags = []\n      for (let i = 0; i < len; i += 2) {\n        option.tags.push(buf.readUInt16BE(offset))\n        offset += 2\n      }\n    // don't worry about default.  caller will use data if desired\n  }\n\n  roption.decode.bytes = len + 4\n  return option\n}\n\nroption.decode.bytes = 0\n\nroption.encodingLength = function (option) {\n  if (option.data) {\n    return option.data.length + 4\n  }\n  const code = optioncodes.toCode(option.code)\n  switch (code) {\n    case 8: // ECS\n      const spl = option.sourcePrefixLength || 0\n      return Math.ceil(spl / 8) + 8\n    case 11: // KEEP-ALIVE\n      return (typeof option.timeout === 'number') ? 6 : 4\n    case 12: // PADDING\n      return option.length + 4\n    case 14: // KEY-TAG\n      return 4 + (option.tags.length * 2)\n  }\n  throw new Error(`Unknown roption code: ${option.code}`)\n}\n\nconst ropt = exports.opt = {}\n\nropt.encode = function (options, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ropt.encodingLength(options))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const rdlen = encodingLengthList(options, roption)\n  buf.writeUInt16BE(rdlen, offset)\n  offset = encodeList(options, roption, buf, offset + 2)\n\n  ropt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nropt.encode.bytes = 0\n\nropt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const options = []\n  let rdlen = buf.readUInt16BE(offset)\n  offset += 2\n  let o = 0\n  while (rdlen > 0) {\n    options[o++] = roption.decode(buf, offset)\n    offset += roption.decode.bytes\n    rdlen -= roption.decode.bytes\n  }\n  ropt.decode.bytes = offset - oldOffset\n  return options\n}\n\nropt.decode.bytes = 0\n\nropt.encodingLength = function (options) {\n  return 2 + encodingLengthList(options || [], roption)\n}\n\nconst rdnskey = exports.dnskey = {}\n\nrdnskey.PROTOCOL_DNSSEC = 3\nrdnskey.ZONE_KEY = 0x80\nrdnskey.SECURE_ENTRYPOINT = 0x8000\n\nrdnskey.encode = function (key, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rdnskey.encodingLength(key))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const keydata = key.key\n  if (!Buffer.isBuffer(keydata)) {\n    throw new Error('Key must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(key.flags, offset)\n  offset += 2\n  buf.writeUInt8(rdnskey.PROTOCOL_DNSSEC, offset)\n  offset += 1\n  buf.writeUInt8(key.algorithm, offset)\n  offset += 1\n  keydata.copy(buf, offset, 0, keydata.length)\n  offset += keydata.length\n\n  rdnskey.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rdnskey.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrdnskey.encode.bytes = 0\n\nrdnskey.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var key = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  key.flags = buf.readUInt16BE(offset)\n  offset += 2\n  if (buf.readUInt8(offset) !== rdnskey.PROTOCOL_DNSSEC) {\n    throw new Error('Protocol must be 3')\n  }\n  offset += 1\n  key.algorithm = buf.readUInt8(offset)\n  offset += 1\n  key.key = buf.slice(offset, oldOffset + length + 2)\n  offset += key.key.length\n  rdnskey.decode.bytes = offset - oldOffset\n  return key\n}\n\nrdnskey.decode.bytes = 0\n\nrdnskey.encodingLength = function (key) {\n  return 6 + Buffer.byteLength(key.key)\n}\n\nconst rrrsig = exports.rrsig = {}\n\nrrrsig.encode = function (sig, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrrsig.encodingLength(sig))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const signature = sig.signature\n  if (!Buffer.isBuffer(signature)) {\n    throw new Error('Signature must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(types.toType(sig.typeCovered), offset)\n  offset += 2\n  buf.writeUInt8(sig.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(sig.labels, offset)\n  offset += 1\n  buf.writeUInt32BE(sig.originalTTL, offset)\n  offset += 4\n  buf.writeUInt32BE(sig.expiration, offset)\n  offset += 4\n  buf.writeUInt32BE(sig.inception, offset)\n  offset += 4\n  buf.writeUInt16BE(sig.keyTag, offset)\n  offset += 2\n  name.encode(sig.signersName, buf, offset)\n  offset += name.encode.bytes\n  signature.copy(buf, offset, 0, signature.length)\n  offset += signature.length\n\n  rrrsig.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rrrsig.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrrrsig.encode.bytes = 0\n\nrrrsig.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var sig = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  sig.typeCovered = types.toString(buf.readUInt16BE(offset))\n  offset += 2\n  sig.algorithm = buf.readUInt8(offset)\n  offset += 1\n  sig.labels = buf.readUInt8(offset)\n  offset += 1\n  sig.originalTTL = buf.readUInt32BE(offset)\n  offset += 4\n  sig.expiration = buf.readUInt32BE(offset)\n  offset += 4\n  sig.inception = buf.readUInt32BE(offset)\n  offset += 4\n  sig.keyTag = buf.readUInt16BE(offset)\n  offset += 2\n  sig.signersName = name.decode(buf, offset)\n  offset += name.decode.bytes\n  sig.signature = buf.slice(offset, oldOffset + length + 2)\n  offset += sig.signature.length\n  rrrsig.decode.bytes = offset - oldOffset\n  return sig\n}\n\nrrrsig.decode.bytes = 0\n\nrrrsig.encodingLength = function (sig) {\n  return 20 +\n    name.encodingLength(sig.signersName) +\n    Buffer.byteLength(sig.signature)\n}\n\nconst rrp = exports.rp = {}\n\nrrp.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrp.encodingLength(data))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // Leave space for length\n  name.encode(data.mbox || '.', buf, offset)\n  offset += name.encode.bytes\n  name.encode(data.txt || '.', buf, offset)\n  offset += name.encode.bytes\n  rrp.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rrp.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrrp.encode.bytes = 0\n\nrrp.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.mbox = name.decode(buf, offset) || '.'\n  offset += name.decode.bytes\n  data.txt = name.decode(buf, offset) || '.'\n  offset += name.decode.bytes\n  rrp.decode.bytes = offset - oldOffset\n  return data\n}\n\nrrp.decode.bytes = 0\n\nrrp.encodingLength = function (data) {\n  return 2 + name.encodingLength(data.mbox || '.') + name.encodingLength(data.txt || '.')\n}\n\nconst typebitmap = {}\n\ntypebitmap.encode = function (typelist, buf, offset) {\n  if (!buf) buf = Buffer.alloc(typebitmap.encodingLength(typelist))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var typesByWindow = []\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i])\n    if (typesByWindow[typeid >> 8] === undefined) {\n      typesByWindow[typeid >> 8] = []\n    }\n    typesByWindow[typeid >> 8][(typeid >> 3) & 0x1F] |= 1 << (7 - (typeid & 0x7))\n  }\n\n  for (i = 0; i < typesByWindow.length; i++) {\n    if (typesByWindow[i] !== undefined) {\n      var windowBuf = Buffer.from(typesByWindow[i])\n      buf.writeUInt8(i, offset)\n      offset += 1\n      buf.writeUInt8(windowBuf.length, offset)\n      offset += 1\n      windowBuf.copy(buf, offset)\n      offset += windowBuf.length\n    }\n  }\n\n  typebitmap.encode.bytes = offset - oldOffset\n  return buf\n}\n\ntypebitmap.encode.bytes = 0\n\ntypebitmap.decode = function (buf, offset, length) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var typelist = []\n  while (offset - oldOffset < length) {\n    var window = buf.readUInt8(offset)\n    offset += 1\n    var windowLength = buf.readUInt8(offset)\n    offset += 1\n    for (var i = 0; i < windowLength; i++) {\n      var b = buf.readUInt8(offset + i)\n      for (var j = 0; j < 8; j++) {\n        if (b & (1 << (7 - j))) {\n          var typeid = types.toString((window << 8) | (i << 3) | j)\n          typelist.push(typeid)\n        }\n      }\n    }\n    offset += windowLength\n  }\n\n  typebitmap.decode.bytes = offset - oldOffset\n  return typelist\n}\n\ntypebitmap.decode.bytes = 0\n\ntypebitmap.encodingLength = function (typelist) {\n  var extents = []\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i])\n    extents[typeid >> 8] = Math.max(extents[typeid >> 8] || 0, typeid & 0xFF)\n  }\n\n  var len = 0\n  for (i = 0; i < extents.length; i++) {\n    if (extents[i] !== undefined) {\n      len += 2 + Math.ceil((extents[i] + 1) / 8)\n    }\n  }\n\n  return len\n}\n\nconst rnsec = exports.nsec = {}\n\nrnsec.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // Leave space for length\n  name.encode(record.nextDomain, buf, offset)\n  offset += name.encode.bytes\n  typebitmap.encode(record.rrtypes, buf, offset)\n  offset += typebitmap.encode.bytes\n\n  rnsec.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rnsec.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrnsec.encode.bytes = 0\n\nrnsec.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var record = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  record.nextDomain = name.decode(buf, offset)\n  offset += name.decode.bytes\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset))\n  offset += typebitmap.decode.bytes\n\n  rnsec.decode.bytes = offset - oldOffset\n  return record\n}\n\nrnsec.decode.bytes = 0\n\nrnsec.encodingLength = function (record) {\n  return 2 +\n    name.encodingLength(record.nextDomain) +\n    typebitmap.encodingLength(record.rrtypes)\n}\n\nconst rnsec3 = exports.nsec3 = {}\n\nrnsec3.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec3.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const salt = record.salt\n  if (!Buffer.isBuffer(salt)) {\n    throw new Error('salt must be a Buffer')\n  }\n\n  const nextDomain = record.nextDomain\n  if (!Buffer.isBuffer(nextDomain)) {\n    throw new Error('nextDomain must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt8(record.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(record.flags, offset)\n  offset += 1\n  buf.writeUInt16BE(record.iterations, offset)\n  offset += 2\n  buf.writeUInt8(salt.length, offset)\n  offset += 1\n  salt.copy(buf, offset, 0, salt.length)\n  offset += salt.length\n  buf.writeUInt8(nextDomain.length, offset)\n  offset += 1\n  nextDomain.copy(buf, offset, 0, nextDomain.length)\n  offset += nextDomain.length\n  typebitmap.encode(record.rrtypes, buf, offset)\n  offset += typebitmap.encode.bytes\n\n  rnsec3.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rnsec3.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrnsec3.encode.bytes = 0\n\nrnsec3.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var record = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  record.algorithm = buf.readUInt8(offset)\n  offset += 1\n  record.flags = buf.readUInt8(offset)\n  offset += 1\n  record.iterations = buf.readUInt16BE(offset)\n  offset += 2\n  const saltLength = buf.readUInt8(offset)\n  offset += 1\n  record.salt = buf.slice(offset, offset + saltLength)\n  offset += saltLength\n  const hashLength = buf.readUInt8(offset)\n  offset += 1\n  record.nextDomain = buf.slice(offset, offset + hashLength)\n  offset += hashLength\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset))\n  offset += typebitmap.decode.bytes\n\n  rnsec3.decode.bytes = offset - oldOffset\n  return record\n}\n\nrnsec3.decode.bytes = 0\n\nrnsec3.encodingLength = function (record) {\n  return 8 +\n    record.salt.length +\n    record.nextDomain.length +\n    typebitmap.encodingLength(record.rrtypes)\n}\n\nconst rds = exports.ds = {}\n\nrds.encode = function (digest, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rds.encodingLength(digest))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const digestdata = digest.digest\n  if (!Buffer.isBuffer(digestdata)) {\n    throw new Error('Digest must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(digest.keyTag, offset)\n  offset += 2\n  buf.writeUInt8(digest.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(digest.digestType, offset)\n  offset += 1\n  digestdata.copy(buf, offset, 0, digestdata.length)\n  offset += digestdata.length\n\n  rds.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rds.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrds.encode.bytes = 0\n\nrds.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var digest = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  digest.keyTag = buf.readUInt16BE(offset)\n  offset += 2\n  digest.algorithm = buf.readUInt8(offset)\n  offset += 1\n  digest.digestType = buf.readUInt8(offset)\n  offset += 1\n  digest.digest = buf.slice(offset, oldOffset + length + 2)\n  offset += digest.digest.length\n  rds.decode.bytes = offset - oldOffset\n  return digest\n}\n\nrds.decode.bytes = 0\n\nrds.encodingLength = function (digest) {\n  return 6 + Buffer.byteLength(digest.digest)\n}\n\nconst rsshfp = exports.sshfp = {}\n\nrsshfp.getFingerprintLengthForHashType = function getFingerprintLengthForHashType (hashType) {\n  switch (hashType) {\n    case 1: return 20\n    case 2: return 32\n  }\n}\n\nrsshfp.encode = function encode (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsshfp.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // The function call starts with the offset pointer at the RDLENGTH field, not the RDATA one\n  buf[offset] = record.algorithm\n  offset += 1\n  buf[offset] = record.hash\n  offset += 1\n\n  const fingerprintBuf = Buffer.from(record.fingerprint.toUpperCase(), 'hex')\n  if (fingerprintBuf.length !== rsshfp.getFingerprintLengthForHashType(record.hash)) {\n    throw new Error('Invalid fingerprint length')\n  }\n  fingerprintBuf.copy(buf, offset)\n  offset += fingerprintBuf.byteLength\n\n  rsshfp.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rsshfp.encode.bytes - 2, oldOffset)\n\n  return buf\n}\n\nrsshfp.encode.bytes = 0\n\nrsshfp.decode = function decode (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const record = {}\n  offset += 2 // Account for the RDLENGTH field\n  record.algorithm = buf[offset]\n  offset += 1\n  record.hash = buf[offset]\n  offset += 1\n\n  const fingerprintLength = rsshfp.getFingerprintLengthForHashType(record.hash)\n  record.fingerprint = buf.slice(offset, offset + fingerprintLength).toString('hex').toUpperCase()\n  offset += fingerprintLength\n  rsshfp.decode.bytes = offset - oldOffset\n  return record\n}\n\nrsshfp.decode.bytes = 0\n\nrsshfp.encodingLength = function (record) {\n  return 4 + Buffer.from(record.fingerprint, 'hex').byteLength\n}\n\nconst rnaptr = exports.naptr = {}\n\nrnaptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnaptr.encodingLength(data))\n  if (!offset) offset = 0\n  const oldOffset = offset\n  offset += 2\n  buf.writeUInt16BE(data.order || 0, offset)\n  offset += 2\n  buf.writeUInt16BE(data.preference || 0, offset)\n  offset += 2\n  string.encode(data.flags, buf, offset)\n  offset += string.encode.bytes\n  string.encode(data.services, buf, offset)\n  offset += string.encode.bytes\n  string.encode(data.regexp, buf, offset)\n  offset += string.encode.bytes\n  name.encode(data.replacement, buf, offset)\n  offset += name.encode.bytes\n  rnaptr.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rnaptr.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrnaptr.encode.bytes = 0\n\nrnaptr.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  const data = {}\n  offset += 2\n  data.order = buf.readUInt16BE(offset)\n  offset += 2\n  data.preference = buf.readUInt16BE(offset)\n  offset += 2\n  data.flags = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.services = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.regexp = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.replacement = name.decode(buf, offset)\n  offset += name.decode.bytes\n  rnaptr.decode.bytes = offset - oldOffset\n  return data\n}\n\nrnaptr.decode.bytes = 0\n\nrnaptr.encodingLength = function (data) {\n  return string.encodingLength(data.flags) +\n    string.encodingLength(data.services) +\n    string.encodingLength(data.regexp) +\n    name.encodingLength(data.replacement) + 6\n}\n\nconst rtlsa = exports.tlsa = {}\n\nrtlsa.encode = function (cert, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rtlsa.encodingLength(cert))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const certdata = cert.certificate\n  if (!Buffer.isBuffer(certdata)) {\n    throw new Error('Certificate must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt8(cert.usage, offset)\n  offset += 1\n  buf.writeUInt8(cert.selector, offset)\n  offset += 1\n  buf.writeUInt8(cert.matchingType, offset)\n  offset += 1\n  certdata.copy(buf, offset, 0, certdata.length)\n  offset += certdata.length\n\n  rtlsa.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rtlsa.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrtlsa.encode.bytes = 0\n\nrtlsa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const cert = {}\n  const length = buf.readUInt16BE(offset)\n  offset += 2\n  cert.usage = buf.readUInt8(offset)\n  offset += 1\n  cert.selector = buf.readUInt8(offset)\n  offset += 1\n  cert.matchingType = buf.readUInt8(offset)\n  offset += 1\n  cert.certificate = buf.slice(offset, oldOffset + length + 2)\n  offset += cert.certificate.length\n  rtlsa.decode.bytes = offset - oldOffset\n  return cert\n}\n\nrtlsa.decode.bytes = 0\n\nrtlsa.encodingLength = function (cert) {\n  return 5 + Buffer.byteLength(cert.certificate)\n}\n\nconst renc = exports.record = function (type) {\n  switch (type.toUpperCase()) {\n    case 'A': return ra\n    case 'PTR': return rptr\n    case 'CNAME': return rcname\n    case 'DNAME': return rdname\n    case 'TXT': return rtxt\n    case 'NULL': return rnull\n    case 'AAAA': return raaaa\n    case 'SRV': return rsrv\n    case 'HINFO': return rhinfo\n    case 'CAA': return rcaa\n    case 'NS': return rns\n    case 'SOA': return rsoa\n    case 'MX': return rmx\n    case 'OPT': return ropt\n    case 'DNSKEY': return rdnskey\n    case 'RRSIG': return rrrsig\n    case 'RP': return rrp\n    case 'NSEC': return rnsec\n    case 'NSEC3': return rnsec3\n    case 'SSHFP': return rsshfp\n    case 'DS': return rds\n    case 'NAPTR': return rnaptr\n    case 'TLSA': return rtlsa\n  }\n  return runknown\n}\n\nconst answer = exports.answer = {}\n\nanswer.encode = function (a, buf, offset) {\n  if (!buf) buf = Buffer.alloc(answer.encodingLength(a))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(a.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(a.type), offset)\n\n  if (a.type.toUpperCase() === 'OPT') {\n    if (a.name !== '.') {\n      throw new Error('OPT name must be root.')\n    }\n    buf.writeUInt16BE(a.udpPayloadSize || 4096, offset + 2)\n    buf.writeUInt8(a.extendedRcode || 0, offset + 4)\n    buf.writeUInt8(a.ednsVersion || 0, offset + 5)\n    buf.writeUInt16BE(a.flags || 0, offset + 6)\n\n    offset += 8\n    ropt.encode(a.options || [], buf, offset)\n    offset += ropt.encode.bytes\n  } else {\n    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class)\n    if (a.flush) klass |= FLUSH_MASK // the 1st bit of the class is the flush bit\n    buf.writeUInt16BE(klass, offset + 2)\n    buf.writeUInt32BE(a.ttl || 0, offset + 4)\n\n    offset += 8\n    const enc = renc(a.type)\n    enc.encode(a.data, buf, offset)\n    offset += enc.encode.bytes\n  }\n\n  answer.encode.bytes = offset - oldOffset\n  return buf\n}\n\nanswer.encode.bytes = 0\n\nanswer.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const a = {}\n  const oldOffset = offset\n\n  a.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n  a.type = types.toString(buf.readUInt16BE(offset))\n  if (a.type === 'OPT') {\n    a.udpPayloadSize = buf.readUInt16BE(offset + 2)\n    a.extendedRcode = buf.readUInt8(offset + 4)\n    a.ednsVersion = buf.readUInt8(offset + 5)\n    a.flags = buf.readUInt16BE(offset + 6)\n    a.flag_do = ((a.flags >> 15) & 0x1) === 1\n    a.options = ropt.decode(buf, offset + 8)\n    offset += 8 + ropt.decode.bytes\n  } else {\n    const klass = buf.readUInt16BE(offset + 2)\n    a.ttl = buf.readUInt32BE(offset + 4)\n\n    a.class = classes.toString(klass & NOT_FLUSH_MASK)\n    a.flush = !!(klass & FLUSH_MASK)\n\n    const enc = renc(a.type)\n    a.data = enc.decode(buf, offset + 8)\n    offset += 8 + enc.decode.bytes\n  }\n\n  answer.decode.bytes = offset - oldOffset\n  return a\n}\n\nanswer.decode.bytes = 0\n\nanswer.encodingLength = function (a) {\n  const data = (a.data !== null && a.data !== undefined) ? a.data : a.options\n  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data)\n}\n\nconst question = exports.question = {}\n\nquestion.encode = function (q, buf, offset) {\n  if (!buf) buf = Buffer.alloc(question.encodingLength(q))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(q.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(q.type), offset)\n  offset += 2\n\n  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset)\n  offset += 2\n\n  question.encode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.encode.bytes = 0\n\nquestion.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const q = {}\n\n  q.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  q.type = types.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  q.class = classes.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  const qu = !!(q.class & QU_MASK)\n  if (qu) q.class &= NOT_QU_MASK\n\n  question.decode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.decode.bytes = 0\n\nquestion.encodingLength = function (q) {\n  return name.encodingLength(q.name) + 4\n}\n\nexports.AUTHORITATIVE_ANSWER = 1 << 10\nexports.TRUNCATED_RESPONSE = 1 << 9\nexports.RECURSION_DESIRED = 1 << 8\nexports.RECURSION_AVAILABLE = 1 << 7\nexports.AUTHENTIC_DATA = 1 << 5\nexports.CHECKING_DISABLED = 1 << 4\nexports.DNSSEC_OK = 1 << 15\n\nexports.encode = function (result, buf, offset) {\n  const allocing = !buf\n\n  if (allocing) buf = Buffer.alloc(exports.encodingLength(result))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  if (!result.questions) result.questions = []\n  if (!result.answers) result.answers = []\n  if (!result.authorities) result.authorities = []\n  if (!result.additionals) result.additionals = []\n\n  header.encode(result, buf, offset)\n  offset += header.encode.bytes\n\n  offset = encodeList(result.questions, question, buf, offset)\n  offset = encodeList(result.answers, answer, buf, offset)\n  offset = encodeList(result.authorities, answer, buf, offset)\n  offset = encodeList(result.additionals, answer, buf, offset)\n\n  exports.encode.bytes = offset - oldOffset\n\n  // just a quick sanity check\n  if (allocing && exports.encode.bytes !== buf.length) {\n    return buf.slice(0, exports.encode.bytes)\n  }\n\n  return buf\n}\n\nexports.encode.bytes = 0\n\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const result = header.decode(buf, offset)\n  offset += header.decode.bytes\n\n  offset = decodeList(result.questions, question, buf, offset)\n  offset = decodeList(result.answers, answer, buf, offset)\n  offset = decodeList(result.authorities, answer, buf, offset)\n  offset = decodeList(result.additionals, answer, buf, offset)\n\n  exports.decode.bytes = offset - oldOffset\n\n  return result\n}\n\nexports.decode.bytes = 0\n\nexports.encodingLength = function (result) {\n  return header.encodingLength(result) +\n    encodingLengthList(result.questions || [], question) +\n    encodingLengthList(result.answers || [], answer) +\n    encodingLengthList(result.authorities || [], answer) +\n    encodingLengthList(result.additionals || [], answer)\n}\n\nexports.streamEncode = function (result) {\n  const buf = exports.encode(result)\n  const sbuf = Buffer.alloc(2)\n  sbuf.writeUInt16BE(buf.byteLength)\n  const combine = Buffer.concat([sbuf, buf])\n  exports.streamEncode.bytes = combine.byteLength\n  return combine\n}\n\nexports.streamEncode.bytes = 0\n\nexports.streamDecode = function (sbuf) {\n  const len = sbuf.readUInt16BE(0)\n  if (sbuf.byteLength < len + 2) {\n    // not enough data\n    return null\n  }\n  const result = exports.decode(sbuf.slice(2))\n  exports.streamDecode.bytes = exports.decode.bytes\n  return result\n}\n\nexports.streamDecode.bytes = 0\n\nfunction encodingLengthList (list, enc) {\n  let len = 0\n  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i])\n  return len\n}\n\nfunction encodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    enc.encode(list[i], buf, offset)\n    offset += enc.encode.bytes\n  }\n  return offset\n}\n\nfunction decodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    list[i] = enc.decode(buf, offset)\n    offset += enc.decode.bytes\n  }\n  return offset\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}