{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  getOrInsert\n} = require(\"./util/MapHelpers\");\nconst {\n  first\n} = require(\"./util/SetHelpers\");\nconst createHash = require(\"./util/createHash\");\nconst {\n  runtimeToString,\n  RuntimeSpecMap\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nclass CodeGenerationResults {\n  /**\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor() {\n    let hashFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"md4\";\n    /** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n    this.map = new Map();\n    this._hashFunction = hashFunction;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {CodeGenerationResult} the CodeGenerationResult\n   */\n  get(module, runtime) {\n    const entry = this.map.get(module);\n    if (entry === undefined) {\n      throw new Error(`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(this.map.keys(), m => m.identifier()).join(\", \")})`);\n    }\n    if (runtime === undefined) {\n      if (entry.size > 1) {\n        const results = new Set(entry.values());\n        if (results.size !== 1) {\n          throw new Error(`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n        }\n        return first(results);\n      }\n      return entry.values().next().value;\n    }\n    const result = entry.get(runtime);\n    if (result === undefined) {\n      throw new Error(`No code generation entry for runtime ${runtimeToString(runtime)} for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")})`);\n    }\n    return result;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {boolean} true, when we have data for this\n   */\n  has(module, runtime) {\n    const entry = this.map.get(module);\n    if (entry === undefined) {\n      return false;\n    }\n    if (runtime !== undefined) {\n      return entry.has(runtime);\n    } else if (entry.size > 1) {\n      const results = new Set(entry.values());\n      return results.size === 1;\n    } else {\n      return entry.size === 1;\n    }\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} sourceType the source type\n   * @returns {Source} a source\n   */\n  getSource(module, runtime, sourceType) {\n    return this.get(module, runtime).sources.get(sourceType);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n  getRuntimeRequirements(module, runtime) {\n    return this.get(module, runtime).runtimeRequirements;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} key data key\n   * @returns {any} data generated by code generation\n   */\n  getData(module, runtime, key) {\n    const data = this.get(module, runtime).data;\n    return data === undefined ? undefined : data.get(key);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {any} hash of the code generation\n   */\n  getHash(module, runtime) {\n    const info = this.get(module, runtime);\n    if (info.hash !== undefined) return info.hash;\n    const hash = createHash(this._hashFunction);\n    for (const [type, source] of info.sources) {\n      hash.update(type);\n      source.updateHash(hash);\n    }\n    if (info.runtimeRequirements) {\n      for (const rr of info.runtimeRequirements) hash.update(rr);\n    }\n    return info.hash = /** @type {string} */hash.digest(\"hex\");\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {CodeGenerationResult} result result from module\n   * @returns {void}\n   */\n  add(module, runtime, result) {\n    const map = getOrInsert(this.map, module, () => new RuntimeSpecMap());\n    map.set(runtime, result);\n  }\n}\nmodule.exports = CodeGenerationResults;","map":{"version":3,"names":["getOrInsert","require","first","createHash","runtimeToString","RuntimeSpecMap","CodeGenerationResults","constructor","hashFunction","arguments","length","undefined","map","Map","_hashFunction","get","module","runtime","entry","Error","identifier","Array","from","keys","m","join","size","results","Set","values","r","next","value","result","has","getSource","sourceType","sources","getRuntimeRequirements","runtimeRequirements","getData","key","data","getHash","info","hash","type","source","update","updateHash","rr","digest","add","set","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/CodeGenerationResults.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { getOrInsert } = require(\"./util/MapHelpers\");\nconst { first } = require(\"./util/SetHelpers\");\nconst createHash = require(\"./util/createHash\");\nconst { runtimeToString, RuntimeSpecMap } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nclass CodeGenerationResults {\n\t/**\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(hashFunction = \"md4\") {\n\t\t/** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n\t\tthis.map = new Map();\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {CodeGenerationResult} the CodeGenerationResult\n\t */\n\tget(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(\n\t\t\t\t\tthis.map.keys(),\n\t\t\t\t\tm => m.identifier()\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\tif (runtime === undefined) {\n\t\t\tif (entry.size > 1) {\n\t\t\t\tconst results = new Set(entry.values());\n\t\t\t\tif (results.size !== 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\t\tentry.keys(),\n\t\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn first(results);\n\t\t\t}\n\t\t\treturn entry.values().next().value;\n\t\t}\n\t\tconst result = entry.get(runtime);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\tentry.keys(),\n\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {boolean} true, when we have data for this\n\t */\n\thas(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tif (runtime !== undefined) {\n\t\t\treturn entry.has(runtime);\n\t\t} else if (entry.size > 1) {\n\t\t\tconst results = new Set(entry.values());\n\t\t\treturn results.size === 1;\n\t\t} else {\n\t\t\treturn entry.size === 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} sourceType the source type\n\t * @returns {Source} a source\n\t */\n\tgetSource(module, runtime, sourceType) {\n\t\treturn this.get(module, runtime).sources.get(sourceType);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetRuntimeRequirements(module, runtime) {\n\t\treturn this.get(module, runtime).runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} key data key\n\t * @returns {any} data generated by code generation\n\t */\n\tgetData(module, runtime, key) {\n\t\tconst data = this.get(module, runtime).data;\n\t\treturn data === undefined ? undefined : data.get(key);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {any} hash of the code generation\n\t */\n\tgetHash(module, runtime) {\n\t\tconst info = this.get(module, runtime);\n\t\tif (info.hash !== undefined) return info.hash;\n\t\tconst hash = createHash(this._hashFunction);\n\t\tfor (const [type, source] of info.sources) {\n\t\t\thash.update(type);\n\t\t\tsource.updateHash(hash);\n\t\t}\n\t\tif (info.runtimeRequirements) {\n\t\t\tfor (const rr of info.runtimeRequirements) hash.update(rr);\n\t\t}\n\t\treturn (info.hash = /** @type {string} */ (hash.digest(\"hex\")));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {CodeGenerationResult} result result from module\n\t * @returns {void}\n\t */\n\tadd(module, runtime, result) {\n\t\tconst map = getOrInsert(this.map, module, () => new RuntimeSpecMap());\n\t\tmap.set(runtime, result);\n\t}\n}\n\nmodule.exports = CodeGenerationResults;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}