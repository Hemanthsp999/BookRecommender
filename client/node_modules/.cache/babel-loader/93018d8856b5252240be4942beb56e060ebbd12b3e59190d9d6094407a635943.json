{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  find\n} = require(\"../util/SetHelpers\");\nconst {\n  compareModulesByPreOrderIndexOrIdentifier,\n  compareModulesByPostOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass ChunkModuleIdRangePlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"ChunkModuleIdRangePlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.moduleIds.tap(\"ChunkModuleIdRangePlugin\", modules => {\n        const chunkGraph = compilation.chunkGraph;\n        const chunk = find(compilation.chunks, chunk => chunk.name === options.name);\n        if (!chunk) {\n          throw new Error(`ChunkModuleIdRangePlugin: Chunk with name '${options.name}\"' was not found`);\n        }\n        let chunkModules;\n        if (options.order) {\n          let cmpFn;\n          switch (options.order) {\n            case \"index\":\n            case \"preOrderIndex\":\n              cmpFn = compareModulesByPreOrderIndexOrIdentifier(moduleGraph);\n              break;\n            case \"index2\":\n            case \"postOrderIndex\":\n              cmpFn = compareModulesByPostOrderIndexOrIdentifier(moduleGraph);\n              break;\n            default:\n              throw new Error(\"ChunkModuleIdRangePlugin: unexpected value of order\");\n          }\n          chunkModules = chunkGraph.getOrderedChunkModules(chunk, cmpFn);\n        } else {\n          chunkModules = Array.from(modules).filter(m => {\n            return chunkGraph.isModuleInChunk(m, chunk);\n          }).sort(compareModulesByPreOrderIndexOrIdentifier(moduleGraph));\n        }\n        let currentId = options.start || 0;\n        for (let i = 0; i < chunkModules.length; i++) {\n          const m = chunkModules[i];\n          if (m.needId && chunkGraph.getModuleId(m) === null) {\n            chunkGraph.setModuleId(m, currentId++);\n          }\n          if (options.end && currentId > options.end) break;\n        }\n      });\n    });\n  }\n}\nmodule.exports = ChunkModuleIdRangePlugin;","map":{"version":3,"names":["find","require","compareModulesByPreOrderIndexOrIdentifier","compareModulesByPostOrderIndexOrIdentifier","ChunkModuleIdRangePlugin","constructor","options","apply","compiler","hooks","compilation","tap","moduleGraph","moduleIds","modules","chunkGraph","chunk","chunks","name","Error","chunkModules","order","cmpFn","getOrderedChunkModules","Array","from","filter","m","isModuleInChunk","sort","currentId","start","i","length","needId","getModuleId","setModuleId","end","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/ids/ChunkModuleIdRangePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { find } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier,\n\tcompareModulesByPostOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass ChunkModuleIdRangePlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"ChunkModuleIdRangePlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.moduleIds.tap(\"ChunkModuleIdRangePlugin\", modules => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst chunk = find(\n\t\t\t\t\tcompilation.chunks,\n\t\t\t\t\tchunk => chunk.name === options.name\n\t\t\t\t);\n\t\t\t\tif (!chunk) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkModuleIdRangePlugin: Chunk with name '${options.name}\"' was not found`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet chunkModules;\n\t\t\t\tif (options.order) {\n\t\t\t\t\tlet cmpFn;\n\t\t\t\t\tswitch (options.order) {\n\t\t\t\t\t\tcase \"index\":\n\t\t\t\t\t\tcase \"preOrderIndex\":\n\t\t\t\t\t\t\tcmpFn = compareModulesByPreOrderIndexOrIdentifier(moduleGraph);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"index2\":\n\t\t\t\t\t\tcase \"postOrderIndex\":\n\t\t\t\t\t\t\tcmpFn = compareModulesByPostOrderIndexOrIdentifier(moduleGraph);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\"ChunkModuleIdRangePlugin: unexpected value of order\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tchunkModules = chunkGraph.getOrderedChunkModules(chunk, cmpFn);\n\t\t\t\t} else {\n\t\t\t\t\tchunkModules = Array.from(modules)\n\t\t\t\t\t\t.filter(m => {\n\t\t\t\t\t\t\treturn chunkGraph.isModuleInChunk(m, chunk);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.sort(compareModulesByPreOrderIndexOrIdentifier(moduleGraph));\n\t\t\t\t}\n\n\t\t\t\tlet currentId = options.start || 0;\n\t\t\t\tfor (let i = 0; i < chunkModules.length; i++) {\n\t\t\t\t\tconst m = chunkModules[i];\n\t\t\t\t\tif (m.needId && chunkGraph.getModuleId(m) === null) {\n\t\t\t\t\t\tchunkGraph.setModuleId(m, currentId++);\n\t\t\t\t\t}\n\t\t\t\t\tif (options.end && currentId > options.end) break;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\nmodule.exports = ChunkModuleIdRangePlugin;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAM;EAAEA;AAAK,CAAC,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAM;EACLC,yCAAyC;EACzCC;AACD,CAAC,GAAGF,OAAO,CAAC,qBAAqB,CAAC;;AAElC;;AAEA,MAAMG,wBAAwB,CAAC;EAC9BC,WAAWA,CAACC,OAAO,EAAE;IACpB,IAAI,CAACA,OAAO,GAAGA,OAAO;EACvB;;EAEA;AACD;AACA;AACA;AACA;EACCC,KAAKA,CAACC,QAAQ,EAAE;IACf,MAAMF,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5BE,QAAQ,CAACC,KAAK,CAACC,WAAW,CAACC,GAAG,CAAC,0BAA0B,EAAED,WAAW,IAAI;MACzE,MAAME,WAAW,GAAGF,WAAW,CAACE,WAAW;MAC3CF,WAAW,CAACD,KAAK,CAACI,SAAS,CAACF,GAAG,CAAC,0BAA0B,EAAEG,OAAO,IAAI;QACtE,MAAMC,UAAU,GAAGL,WAAW,CAACK,UAAU;QACzC,MAAMC,KAAK,GAAGhB,IAAI,CACjBU,WAAW,CAACO,MAAM,EAClBD,KAAK,IAAIA,KAAK,CAACE,IAAI,KAAKZ,OAAO,CAACY,IACjC,CAAC;QACD,IAAI,CAACF,KAAK,EAAE;UACX,MAAM,IAAIG,KAAK,CACb,8CAA6Cb,OAAO,CAACY,IAAK,kBAC5D,CAAC;QACF;QAEA,IAAIE,YAAY;QAChB,IAAId,OAAO,CAACe,KAAK,EAAE;UAClB,IAAIC,KAAK;UACT,QAAQhB,OAAO,CAACe,KAAK;YACpB,KAAK,OAAO;YACZ,KAAK,eAAe;cACnBC,KAAK,GAAGpB,yCAAyC,CAACU,WAAW,CAAC;cAC9D;YACD,KAAK,QAAQ;YACb,KAAK,gBAAgB;cACpBU,KAAK,GAAGnB,0CAA0C,CAACS,WAAW,CAAC;cAC/D;YACD;cACC,MAAM,IAAIO,KAAK,CACd,qDACD,CAAC;UACH;UACAC,YAAY,GAAGL,UAAU,CAACQ,sBAAsB,CAACP,KAAK,EAAEM,KAAK,CAAC;QAC/D,CAAC,MAAM;UACNF,YAAY,GAAGI,KAAK,CAACC,IAAI,CAACX,OAAO,CAAC,CAChCY,MAAM,CAACC,CAAC,IAAI;YACZ,OAAOZ,UAAU,CAACa,eAAe,CAACD,CAAC,EAAEX,KAAK,CAAC;UAC5C,CAAC,CAAC,CACDa,IAAI,CAAC3B,yCAAyC,CAACU,WAAW,CAAC,CAAC;QAC/D;QAEA,IAAIkB,SAAS,GAAGxB,OAAO,CAACyB,KAAK,IAAI,CAAC;QAClC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,YAAY,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;UAC7C,MAAML,CAAC,GAAGP,YAAY,CAACY,CAAC,CAAC;UACzB,IAAIL,CAAC,CAACO,MAAM,IAAInB,UAAU,CAACoB,WAAW,CAACR,CAAC,CAAC,KAAK,IAAI,EAAE;YACnDZ,UAAU,CAACqB,WAAW,CAACT,CAAC,EAAEG,SAAS,EAAE,CAAC;UACvC;UACA,IAAIxB,OAAO,CAAC+B,GAAG,IAAIP,SAAS,GAAGxB,OAAO,CAAC+B,GAAG,EAAE;QAC7C;MACD,CAAC,CAAC;IACH,CAAC,CAAC;EACH;AACD;AACAC,MAAM,CAACC,OAAO,GAAGnC,wBAAwB"},"metadata":{},"sourceType":"script","externalDependencies":[]}