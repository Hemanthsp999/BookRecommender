{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst {\n  formatSize\n} = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n  createFileSerializer,\n  NOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nclass PackContainer {\n  /**\n   * @param {Object} data stored data\n   * @param {string} version version identifier\n   * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n   * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n   * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n   * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n   */\n  constructor(data, version, buildSnapshot, buildDependencies, resolveResults, resolveBuildDependenciesSnapshot) {\n    this.data = data;\n    this.version = version;\n    this.buildSnapshot = buildSnapshot;\n    this.buildDependencies = buildDependencies;\n    this.resolveResults = resolveResults;\n    this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n  }\n  serialize(_ref) {\n    let {\n      write,\n      writeLazy\n    } = _ref;\n    write(this.version);\n    write(this.buildSnapshot);\n    write(this.buildDependencies);\n    write(this.resolveResults);\n    write(this.resolveBuildDependenciesSnapshot);\n    writeLazy(this.data);\n  }\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.version = read();\n    this.buildSnapshot = read();\n    this.buildDependencies = read();\n    this.resolveResults = read();\n    this.resolveBuildDependenciesSnapshot = read();\n    this.data = read();\n  }\n}\nmakeSerializable(PackContainer, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContainer\");\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n  /**\n   * @param {string} identifier identifier of item\n   * @param {string | null} etag etag of item\n   * @param {any} value fresh value of item\n   */\n  constructor(identifier, etag, value) {\n    this.identifier = identifier;\n    this.etag = etag;\n    this.location = -1;\n    this.lastAccess = Date.now();\n    this.freshValue = value;\n  }\n}\nclass Pack {\n  constructor(logger, maxAge) {\n    /** @type {Map<string, PackItemInfo>} */\n    this.itemInfo = new Map();\n    /** @type {string[]} */\n    this.requests = [];\n    this.requestsTimeout = undefined;\n    /** @type {Map<string, PackItemInfo>} */\n    this.freshContent = new Map();\n    /** @type {(undefined | PackContent)[]} */\n    this.content = [];\n    this.invalid = false;\n    this.logger = logger;\n    this.maxAge = maxAge;\n  }\n  _addRequest(identifier) {\n    this.requests.push(identifier);\n    if (this.requestsTimeout === undefined) {\n      this.requestsTimeout = setTimeout(() => {\n        this.requests.push(undefined);\n        this.requestsTimeout = undefined;\n      }, MAX_TIME_IN_FRESH_PACK);\n      if (this.requestsTimeout.unref) this.requestsTimeout.unref();\n    }\n  }\n  stopCapturingRequests() {\n    if (this.requestsTimeout !== undefined) {\n      clearTimeout(this.requestsTimeout);\n      this.requestsTimeout = undefined;\n    }\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @returns {any} cached content\n   */\n  get(identifier, etag) {\n    const info = this.itemInfo.get(identifier);\n    this._addRequest(identifier);\n    if (info === undefined) {\n      return undefined;\n    }\n    if (info.etag !== etag) return null;\n    info.lastAccess = Date.now();\n    const loc = info.location;\n    if (loc === -1) {\n      return info.freshValue;\n    } else {\n      if (!this.content[loc]) {\n        return undefined;\n      }\n      return this.content[loc].get(identifier);\n    }\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {void}\n   */\n  set(identifier, etag, data) {\n    if (!this.invalid) {\n      this.invalid = true;\n      this.logger.log(`Pack got invalid because of write to: ${identifier}`);\n    }\n    const info = this.itemInfo.get(identifier);\n    if (info === undefined) {\n      const newInfo = new PackItemInfo(identifier, etag, data);\n      this.itemInfo.set(identifier, newInfo);\n      this._addRequest(identifier);\n      this.freshContent.set(identifier, newInfo);\n    } else {\n      const loc = info.location;\n      if (loc >= 0) {\n        this._addRequest(identifier);\n        this.freshContent.set(identifier, info);\n        const content = this.content[loc];\n        content.delete(identifier);\n        if (content.items.size === 0) {\n          this.content[loc] = undefined;\n          this.logger.debug(\"Pack %d got empty and is removed\", loc);\n        }\n      }\n      info.freshValue = data;\n      info.lastAccess = Date.now();\n      info.etag = etag;\n      info.location = -1;\n    }\n  }\n  getContentStats() {\n    let count = 0;\n    let size = 0;\n    for (const content of this.content) {\n      if (content !== undefined) {\n        count++;\n        const s = content.getSize();\n        if (s > 0) {\n          size += s;\n        }\n      }\n    }\n    return {\n      count,\n      size\n    };\n  }\n\n  /**\n   * @returns {number} new location of data entries\n   */\n  _findLocation() {\n    let i;\n    for (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n    return i;\n  }\n  _gcAndUpdateLocation(items, usedItems, newLoc) {\n    let count = 0;\n    let lastGC;\n    const now = Date.now();\n    for (const identifier of items) {\n      const info = this.itemInfo.get(identifier);\n      if (now - info.lastAccess > this.maxAge) {\n        this.itemInfo.delete(identifier);\n        items.delete(identifier);\n        usedItems.delete(identifier);\n        count++;\n        lastGC = identifier;\n      } else {\n        info.location = newLoc;\n      }\n    }\n    if (count > 0) {\n      this.logger.log(\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\", count, newLoc, items.size, lastGC);\n    }\n  }\n  _persistFreshContent() {\n    const itemsCount = this.freshContent.size;\n    if (itemsCount > 0) {\n      const packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n      const itemsPerPack = Math.ceil(itemsCount / packCount);\n      const packs = [];\n      let i = 0;\n      let ignoreNextTimeTick = false;\n      const createNextPack = () => {\n        const loc = this._findLocation();\n        this.content[loc] = null; // reserve\n        const pack = {\n          /** @type {Set<string>} */\n          items: new Set(),\n          /** @type {Map<string, any>} */\n          map: new Map(),\n          loc\n        };\n        packs.push(pack);\n        return pack;\n      };\n      let pack = createNextPack();\n      if (this.requestsTimeout !== undefined) clearTimeout(this.requestsTimeout);\n      for (const identifier of this.requests) {\n        if (identifier === undefined) {\n          if (ignoreNextTimeTick) {\n            ignoreNextTimeTick = false;\n          } else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n            i = 0;\n            pack = createNextPack();\n          }\n          continue;\n        }\n        const info = this.freshContent.get(identifier);\n        if (info === undefined) continue;\n        pack.items.add(identifier);\n        pack.map.set(identifier, info.freshValue);\n        info.location = pack.loc;\n        info.freshValue = undefined;\n        this.freshContent.delete(identifier);\n        if (++i > itemsPerPack) {\n          i = 0;\n          pack = createNextPack();\n          ignoreNextTimeTick = true;\n        }\n      }\n      this.requests.length = 0;\n      for (const pack of packs) {\n        this.content[pack.loc] = new PackContent(pack.items, new Set(pack.items), new PackContentItems(pack.map));\n      }\n      this.logger.log(`${itemsCount} fresh items in cache put into pack ${packs.length > 1 ? packs.map(pack => `${pack.loc} (${pack.items.size} items)`).join(\", \") : packs[0].loc}`);\n    }\n  }\n\n  /**\n   * Merges small content files to a single content file\n   */\n  _optimizeSmallContent() {\n    // 1. Find all small content files\n    // Treat unused content files separately to avoid\n    // a merge-split cycle\n    /** @type {number[]} */\n    const smallUsedContents = [];\n    /** @type {number} */\n    let smallUsedContentSize = 0;\n    /** @type {number[]} */\n    const smallUnusedContents = [];\n    /** @type {number} */\n    let smallUnusedContentSize = 0;\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      if (content.outdated) continue;\n      const size = content.getSize();\n      if (size < 0 || size > MIN_CONTENT_SIZE) continue;\n      if (content.used.size > 0) {\n        smallUsedContents.push(i);\n        smallUsedContentSize += size;\n      } else {\n        smallUnusedContents.push(i);\n        smallUnusedContentSize += size;\n      }\n    }\n\n    // 2. Check if minimum number is reached\n    let mergedIndices;\n    if (smallUsedContents.length >= CONTENT_COUNT_TO_MERGE || smallUsedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUsedContents;\n    } else if (smallUnusedContents.length >= CONTENT_COUNT_TO_MERGE || smallUnusedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUnusedContents;\n    } else return;\n    const mergedContent = [];\n\n    // 3. Remove old content entries\n    for (const i of mergedIndices) {\n      mergedContent.push(this.content[i]);\n      this.content[i] = undefined;\n    }\n\n    // 4. Determine merged items\n    /** @type {Set<string>} */\n    const mergedItems = new Set();\n    /** @type {Set<string>} */\n    const mergedUsedItems = new Set();\n    /** @type {(function(Map<string, any>): Promise)[]} */\n    const addToMergedMap = [];\n    for (const content of mergedContent) {\n      for (const identifier of content.items) {\n        mergedItems.add(identifier);\n      }\n      for (const identifier of content.used) {\n        mergedUsedItems.add(identifier);\n      }\n      addToMergedMap.push(async map => {\n        // unpack existing content\n        // after that values are accessible in .content\n        await content.unpack(\"it should be merged with other small pack contents\");\n        for (const [identifier, value] of content.content) {\n          map.set(identifier, value);\n        }\n      });\n    }\n\n    // 5. GC and update location of merged items\n    const newLoc = this._findLocation();\n    this._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n    // 6. If not empty, store content somewhere\n    if (mergedItems.size > 0) {\n      this.content[newLoc] = new PackContent(mergedItems, mergedUsedItems, memoize(async () => {\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        await Promise.all(addToMergedMap.map(fn => fn(map)));\n        return new PackContentItems(map);\n      }));\n      this.logger.log(\"Merged %d small files with %d cache items into pack %d\", mergedContent.length, mergedItems.size, newLoc);\n    }\n  }\n\n  /**\n   * Split large content files with used and unused items\n   * into two parts to separate used from unused items\n   */\n  _optimizeUnusedContent() {\n    // 1. Find a large content file with used and unused items\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      const size = content.getSize();\n      if (size < MIN_CONTENT_SIZE) continue;\n      const used = content.used.size;\n      const total = content.items.size;\n      if (used > 0 && used < total) {\n        // 2. Remove this content\n        this.content[i] = undefined;\n\n        // 3. Determine items for the used content file\n        const usedItems = new Set(content.used);\n        const newLoc = this._findLocation();\n        this._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n        // 4. Create content file for used items\n        if (usedItems.size > 0) {\n          this.content[newLoc] = new PackContent(usedItems, new Set(usedItems), async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n            for (const identifier of usedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n            return new PackContentItems(map);\n          });\n        }\n\n        // 5. Determine items for the unused content file\n        const unusedItems = new Set(content.items);\n        const usedOfUnusedItems = new Set();\n        for (const identifier of usedItems) {\n          unusedItems.delete(identifier);\n        }\n        const newUnusedLoc = this._findLocation();\n        this._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n        // 6. Create content file for unused items\n        if (unusedItems.size > 0) {\n          this.content[newUnusedLoc] = new PackContent(unusedItems, usedOfUnusedItems, async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n            for (const identifier of unusedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n            return new PackContentItems(map);\n          });\n        }\n        this.logger.log(\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\", i, newLoc, usedItems.size, newUnusedLoc, unusedItems.size);\n\n        // optimizing only one of them is good enough and\n        // reduces the amount of serialization needed\n        return;\n      }\n    }\n  }\n\n  /**\n   * Find the content with the oldest item and run GC on that.\n   * Only runs for one content to avoid large invalidation.\n   */\n  _gcOldestContent() {\n    /** @type {PackItemInfo} */\n    let oldest = undefined;\n    for (const info of this.itemInfo.values()) {\n      if (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n        oldest = info;\n      }\n    }\n    if (Date.now() - oldest.lastAccess > this.maxAge) {\n      const loc = oldest.location;\n      if (loc < 0) return;\n      const content = this.content[loc];\n      const items = new Set(content.items);\n      const usedItems = new Set(content.used);\n      this._gcAndUpdateLocation(items, usedItems, loc);\n      this.content[loc] = items.size > 0 ? new PackContent(items, usedItems, async () => {\n        await content.unpack(\"it contains old items that should be garbage collected\");\n        const map = new Map();\n        for (const identifier of items) {\n          map.set(identifier, content.content.get(identifier));\n        }\n        return new PackContentItems(map);\n      }) : undefined;\n    }\n  }\n  serialize(_ref3) {\n    let {\n      write,\n      writeSeparate\n    } = _ref3;\n    this._persistFreshContent();\n    this._optimizeSmallContent();\n    this._optimizeUnusedContent();\n    this._gcOldestContent();\n    for (const identifier of this.itemInfo.keys()) {\n      write(identifier);\n    }\n    write(null); // null as marker of the end of keys\n    for (const info of this.itemInfo.values()) {\n      write(info.etag);\n    }\n    for (const info of this.itemInfo.values()) {\n      write(info.lastAccess);\n    }\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content !== undefined) {\n        write(content.items);\n        content.writeLazy(lazy => writeSeparate(lazy, {\n          name: `${i}`\n        }));\n      } else {\n        write(undefined); // undefined marks an empty content slot\n      }\n    }\n\n    write(null); // null as marker of the end of items\n  }\n\n  deserialize(_ref4) {\n    let {\n      read,\n      logger\n    } = _ref4;\n    this.logger = logger;\n    {\n      const items = [];\n      let item = read();\n      while (item !== null) {\n        items.push(item);\n        item = read();\n      }\n      this.itemInfo.clear();\n      const infoItems = items.map(identifier => {\n        const info = new PackItemInfo(identifier, undefined, undefined);\n        this.itemInfo.set(identifier, info);\n        return info;\n      });\n      for (const info of infoItems) {\n        info.etag = read();\n      }\n      for (const info of infoItems) {\n        info.lastAccess = read();\n      }\n    }\n    this.content.length = 0;\n    let items = read();\n    while (items !== null) {\n      if (items === undefined) {\n        this.content.push(items);\n      } else {\n        const idx = this.content.length;\n        const lazy = read();\n        this.content.push(new PackContent(items, new Set(), lazy, logger, `${this.content.length}`));\n        for (const identifier of items) {\n          this.itemInfo.get(identifier).location = idx;\n        }\n      }\n      items = read();\n    }\n  }\n}\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\nclass PackContentItems {\n  /**\n   * @param {Map<string, any>} map items\n   */\n  constructor(map) {\n    this.map = map;\n  }\n  serialize(_ref5) {\n    let {\n      write,\n      snapshot,\n      rollback,\n      logger,\n      profile\n    } = _ref5;\n    if (profile) {\n      write(false);\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n        try {\n          write(key);\n          const start = process.hrtime();\n          write(value);\n          const durationHr = process.hrtime(start);\n          const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n          if (duration > 1) {\n            if (duration > 500) logger.error(`Serialization of '${key}': ${duration} ms`);else if (duration > 50) logger.warn(`Serialization of '${key}': ${duration} ms`);else if (duration > 10) logger.info(`Serialization of '${key}': ${duration} ms`);else if (duration > 5) logger.log(`Serialization of '${key}': ${duration} ms`);else logger.debug(`Serialization of '${key}': ${duration} ms`);\n          }\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          const msg = \"Skipped not serializable cache item\";\n          if (e.message.includes(\"ModuleBuildError\")) {\n            logger.log(`${msg} (in build error): ${e.message}`);\n            logger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n          } else {\n            logger.warn(`${msg}: ${e.message}`);\n            logger.debug(`${msg} '${key}': ${e.stack}`);\n          }\n        }\n      }\n      write(null);\n      return;\n    }\n    // Try to serialize all at once\n    const s = snapshot();\n    try {\n      write(true);\n      write(this.map);\n    } catch (e) {\n      rollback(s);\n\n      // Try to serialize each item on it's own\n      write(false);\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n        try {\n          write(key);\n          write(value);\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          logger.warn(`Skipped not serializable cache item '${key}': ${e.message}`);\n          logger.debug(e.stack);\n        }\n      }\n      write(null);\n    }\n  }\n  deserialize(_ref6) {\n    let {\n      read,\n      logger,\n      profile\n    } = _ref6;\n    if (read()) {\n      this.map = read();\n    } else if (profile) {\n      const map = new Map();\n      let key = read();\n      while (key !== null) {\n        const start = process.hrtime();\n        const value = read();\n        const durationHr = process.hrtime(start);\n        const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n        if (duration > 1) {\n          if (duration > 100) logger.error(`Deserialization of '${key}': ${duration} ms`);else if (duration > 20) logger.warn(`Deserialization of '${key}': ${duration} ms`);else if (duration > 5) logger.info(`Deserialization of '${key}': ${duration} ms`);else if (duration > 2) logger.log(`Deserialization of '${key}': ${duration} ms`);else logger.debug(`Deserialization of '${key}': ${duration} ms`);\n        }\n        map.set(key, value);\n        key = read();\n      }\n      this.map = map;\n    } else {\n      const map = new Map();\n      let key = read();\n      while (key !== null) {\n        map.set(key, read());\n        key = read();\n      }\n      this.map = map;\n    }\n  }\n}\nmakeSerializable(PackContentItems, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContentItems\");\nclass PackContent {\n  /*\n  \tThis class can be in these states:\n  \t   |   this.lazy    | this.content | this.outdated | state\n  \tA1 |   undefined    |     Map      |     false     | fresh content\n  \tA2 |   undefined    |     Map      |     true      | (will not happen)\n  \tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n  \tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n  \tC1 | lazy* () => {} |     Map      |     false     | deserialized\n  \tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n  \t\tthis.used is a subset of this.items.\n  \tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n  \tWhen this.lazy and this.content is set, they contain the same data.\n  \tthis.get must only be called with a valid item from this.items.\n  \tIn state C this.lazy is unMemoized\n  */\n\n  /**\n   * @param {Set<string>} items keys\n   * @param {Set<string>} usedItems used keys\n   * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n   * @param {Logger=} logger logger for logging\n   * @param {string=} lazyName name of dataOrFn for logging\n   */\n  constructor(items, usedItems, dataOrFn, logger, lazyName) {\n    this.items = items;\n    /** @type {function(): Promise<PackContentItems> | PackContentItems} */\n    this.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n    /** @type {Map<string, any>} */\n    this.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n    this.outdated = false;\n    this.used = usedItems;\n    this.logger = logger;\n    this.lazyName = lazyName;\n  }\n  get(identifier) {\n    this.used.add(identifier);\n    if (this.content) {\n      return this.content.get(identifier);\n    }\n\n    // We are in state B\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `restore cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to restore cache content ${lazyName} (${formatSize(this.getSize())}) because of request to: ${identifier}`);\n      this.logger.time(timeMessage);\n    }\n    const value = this.lazy();\n    if (\"then\" in value) {\n      return value.then(data => {\n        const map = data.map;\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        // Move to state C\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return map.get(identifier);\n      });\n    } else {\n      const map = value.map;\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n      // Move to state C\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n      return map.get(identifier);\n    }\n  }\n\n  /**\n   * @param {string} reason explanation why unpack is necessary\n   * @returns {void | Promise} maybe a promise if lazy\n   */\n  unpack(reason) {\n    if (this.content) return;\n\n    // Move from state B to C\n    if (this.lazy) {\n      const {\n        lazyName\n      } = this;\n      let timeMessage;\n      if (lazyName) {\n        // only log once\n        this.lazyName = undefined;\n        timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n        this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because ${reason}`);\n        this.logger.time(timeMessage);\n      }\n      const value = this.lazy();\n      if (\"then\" in value) {\n        return value.then(data => {\n          if (timeMessage) {\n            this.logger.timeEnd(timeMessage);\n          }\n          this.content = data.map;\n        });\n      } else {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        this.content = value.map;\n      }\n    }\n  }\n\n  /**\n   * @returns {number} size of the content or -1 if not known\n   */\n  getSize() {\n    if (!this.lazy) return -1;\n    const options = /** @type {any} */this.lazy.options;\n    if (!options) return -1;\n    const size = options.size;\n    if (typeof size !== \"number\") return -1;\n    return size;\n  }\n  delete(identifier) {\n    this.items.delete(identifier);\n    this.used.delete(identifier);\n    this.outdated = true;\n  }\n\n  /**\n   * @template T\n   * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n   * @returns {void}\n   */\n  writeLazy(write) {\n    if (!this.outdated && this.lazy) {\n      // State B1 or C1\n      // this.lazy is still the valid deserialized version\n      write(this.lazy);\n      return;\n    }\n    if (!this.outdated && this.content) {\n      // State A1\n      const map = new Map(this.content);\n      // Move to state C1\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n    if (this.content) {\n      // State A2 or C2\n      /** @type {Map<string, any>} */\n      const map = new Map();\n      for (const item of this.items) {\n        map.set(item, this.content.get(item));\n      }\n      // Move to state C1\n      this.outdated = false;\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n    // State B2\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because it's outdated and need to be serialized`);\n      this.logger.time(timeMessage);\n    }\n    const value = this.lazy();\n    this.outdated = false;\n    if (\"then\" in value) {\n      // Move to state B1\n      this.lazy = write(() => value.then(data => {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        const oldMap = data.map;\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        for (const item of this.items) {\n          map.set(item, oldMap.get(item));\n        }\n        // Move to state C1 (or maybe C2)\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return new PackContentItems(map);\n      }));\n    } else {\n      // Move to state C1\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n      const oldMap = value.map;\n      /** @type {Map<string, any>} */\n      const map = new Map();\n      for (const item of this.items) {\n        map.set(item, oldMap.get(item));\n      }\n      this.content = map;\n      this.lazy = write(() => new PackContentItems(map));\n    }\n  }\n}\nconst allowCollectingMemory = buf => {\n  const wasted = buf.buffer.byteLength - buf.byteLength;\n  if (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n    return Buffer.from(buf);\n  }\n  return buf;\n};\nclass PackFileCacheStrategy {\n  /**\n   * @param {Object} options options\n   * @param {Compiler} options.compiler the compiler\n   * @param {IntermediateFileSystem} options.fs the filesystem\n   * @param {string} options.context the context directory\n   * @param {string} options.cacheLocation the location of the cache data\n   * @param {string} options.version version identifier\n   * @param {Logger} options.logger a logger\n   * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n   * @param {number} options.maxAge max age of cache items\n   * @param {boolean} options.profile track and log detailed timing information for individual cache items\n   * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n   * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n   */\n  constructor(_ref7) {\n    let {\n      compiler,\n      fs,\n      context,\n      cacheLocation,\n      version,\n      logger,\n      snapshot,\n      maxAge,\n      profile,\n      allowCollectingMemory,\n      compression\n    } = _ref7;\n    this.fileSerializer = createFileSerializer(fs, compiler.options.output.hashFunction);\n    this.fileSystemInfo = new FileSystemInfo(fs, {\n      managedPaths: snapshot.managedPaths,\n      immutablePaths: snapshot.immutablePaths,\n      logger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n      hashFunction: compiler.options.output.hashFunction\n    });\n    this.compiler = compiler;\n    this.context = context;\n    this.cacheLocation = cacheLocation;\n    this.version = version;\n    this.logger = logger;\n    this.maxAge = maxAge;\n    this.profile = profile;\n    this.allowCollectingMemory = allowCollectingMemory;\n    this.compression = compression;\n    this._extension = compression === \"brotli\" ? \".pack.br\" : compression === \"gzip\" ? \".pack.gz\" : \".pack\";\n    this.snapshot = snapshot;\n    /** @type {Set<string>} */\n    this.buildDependencies = new Set();\n    /** @type {LazySet<string>} */\n    this.newBuildDependencies = new LazySet();\n    /** @type {Snapshot} */\n    this.resolveBuildDependenciesSnapshot = undefined;\n    /** @type {Map<string, string | false>} */\n    this.resolveResults = undefined;\n    /** @type {Snapshot} */\n    this.buildSnapshot = undefined;\n    /** @type {Promise<Pack>} */\n    this.packPromise = this._openPack();\n    this.storePromise = Promise.resolve();\n  }\n  _getPack() {\n    if (this.packPromise === undefined) {\n      this.packPromise = this.storePromise.then(() => this._openPack());\n    }\n    return this.packPromise;\n  }\n\n  /**\n   * @returns {Promise<Pack>} the pack\n   */\n  _openPack() {\n    const {\n      logger,\n      profile,\n      cacheLocation,\n      version\n    } = this;\n    /** @type {Snapshot} */\n    let buildSnapshot;\n    /** @type {Set<string>} */\n    let buildDependencies;\n    /** @type {Set<string>} */\n    let newBuildDependencies;\n    /** @type {Snapshot} */\n    let resolveBuildDependenciesSnapshot;\n    /** @type {Map<string, string | false>} */\n    let resolveResults;\n    logger.time(\"restore cache container\");\n    return this.fileSerializer.deserialize(null, {\n      filename: `${cacheLocation}/index${this._extension}`,\n      extension: `${this._extension}`,\n      logger,\n      profile,\n      retainedBuffer: this.allowCollectingMemory ? allowCollectingMemory : undefined\n    }).catch(err => {\n      if (err.code !== \"ENOENT\") {\n        logger.warn(`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`);\n        logger.debug(err.stack);\n      } else {\n        logger.debug(`No pack exists at ${cacheLocation}${this._extension}: ${err}`);\n      }\n      return undefined;\n    }).then(packContainer => {\n      logger.timeEnd(\"restore cache container\");\n      if (!packContainer) return undefined;\n      if (!(packContainer instanceof PackContainer)) {\n        logger.warn(`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`, packContainer);\n        return undefined;\n      }\n      if (packContainer.version !== version) {\n        logger.log(`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`);\n        return undefined;\n      }\n      logger.time(\"check build dependencies\");\n      return Promise.all([new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.buildSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n          if (!valid) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`);\n            return resolve(false);\n          }\n          buildSnapshot = packContainer.buildSnapshot;\n          return resolve(true);\n        });\n      }), new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.resolveBuildDependenciesSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n          if (valid) {\n            resolveBuildDependenciesSnapshot = packContainer.resolveBuildDependenciesSnapshot;\n            buildDependencies = packContainer.buildDependencies;\n            resolveResults = packContainer.resolveResults;\n            return resolve(true);\n          }\n          logger.log(\"resolving of build dependencies is invalid, will re-resolve build dependencies\");\n          this.fileSystemInfo.checkResolveResultsValid(packContainer.resolveResults, (err, valid) => {\n            if (err) {\n              logger.log(`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`);\n              logger.debug(err.stack);\n              return resolve(false);\n            }\n            if (valid) {\n              newBuildDependencies = packContainer.buildDependencies;\n              resolveResults = packContainer.resolveResults;\n              return resolve(true);\n            }\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`);\n            return resolve(false);\n          });\n        });\n      })]).catch(err => {\n        logger.timeEnd(\"check build dependencies\");\n        throw err;\n      }).then(_ref8 => {\n        let [buildSnapshotValid, resolveValid] = _ref8;\n        logger.timeEnd(\"check build dependencies\");\n        if (buildSnapshotValid && resolveValid) {\n          logger.time(\"restore cache content metadata\");\n          const d = packContainer.data();\n          logger.timeEnd(\"restore cache content metadata\");\n          return d;\n        }\n        return undefined;\n      });\n    }).then(pack => {\n      if (pack) {\n        pack.maxAge = this.maxAge;\n        this.buildSnapshot = buildSnapshot;\n        if (buildDependencies) this.buildDependencies = buildDependencies;\n        if (newBuildDependencies) this.newBuildDependencies.addAll(newBuildDependencies);\n        this.resolveResults = resolveResults;\n        this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n        return pack;\n      }\n      return new Pack(logger, this.maxAge);\n    }).catch(err => {\n      this.logger.warn(`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`);\n      this.logger.debug(err.stack);\n      return new Pack(logger, this.maxAge);\n    });\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {Promise<void>} promise\n   */\n  store(identifier, etag, data) {\n    return this._getPack().then(pack => {\n      pack.set(identifier, etag === null ? null : etag.toString(), data);\n    });\n  }\n\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @returns {Promise<any>} promise to the cached content\n   */\n  restore(identifier, etag) {\n    return this._getPack().then(pack => pack.get(identifier, etag === null ? null : etag.toString())).catch(err => {\n      if (err && err.code !== \"ENOENT\") {\n        this.logger.warn(`Restoring failed for ${identifier} from pack: ${err}`);\n        this.logger.debug(err.stack);\n      }\n    });\n  }\n  storeBuildDependencies(dependencies) {\n    this.newBuildDependencies.addAll(dependencies);\n  }\n  afterAllStored() {\n    const packPromise = this.packPromise;\n    if (packPromise === undefined) return Promise.resolve();\n    const reportProgress = ProgressPlugin.getReporter(this.compiler);\n    return this.storePromise = packPromise.then(pack => {\n      pack.stopCapturingRequests();\n      if (!pack.invalid) return;\n      this.packPromise = undefined;\n      this.logger.log(`Storing pack...`);\n      let promise;\n      const newBuildDependencies = new Set();\n      for (const dep of this.newBuildDependencies) {\n        if (!this.buildDependencies.has(dep)) {\n          newBuildDependencies.add(dep);\n        }\n      }\n      if (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n        if (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n        this.logger.debug(`Capturing build dependencies... (${Array.from(newBuildDependencies).join(\", \")})`);\n        promise = new Promise((resolve, reject) => {\n          this.logger.time(\"resolve build dependencies\");\n          this.fileSystemInfo.resolveBuildDependencies(this.context, newBuildDependencies, (err, result) => {\n            this.logger.timeEnd(\"resolve build dependencies\");\n            if (err) return reject(err);\n            this.logger.time(\"snapshot build dependencies\");\n            const {\n              files,\n              directories,\n              missing,\n              resolveResults,\n              resolveDependencies\n            } = result;\n            if (this.resolveResults) {\n              for (const [key, value] of resolveResults) {\n                this.resolveResults.set(key, value);\n              }\n            } else {\n              this.resolveResults = resolveResults;\n            }\n            if (reportProgress) {\n              reportProgress(0.6, \"snapshot build dependencies\", \"resolving\");\n            }\n            this.fileSystemInfo.createSnapshot(undefined, resolveDependencies.files, resolveDependencies.directories, resolveDependencies.missing, this.snapshot.resolveBuildDependencies, (err, snapshot) => {\n              if (err) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(err);\n              }\n              if (!snapshot) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(new Error(\"Unable to snapshot resolve dependencies\"));\n              }\n              if (this.resolveBuildDependenciesSnapshot) {\n                this.resolveBuildDependenciesSnapshot = this.fileSystemInfo.mergeSnapshots(this.resolveBuildDependenciesSnapshot, snapshot);\n              } else {\n                this.resolveBuildDependenciesSnapshot = snapshot;\n              }\n              if (reportProgress) {\n                reportProgress(0.7, \"snapshot build dependencies\", \"modules\");\n              }\n              this.fileSystemInfo.createSnapshot(undefined, files, directories, missing, this.snapshot.buildDependencies, (err, snapshot) => {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                if (err) return reject(err);\n                if (!snapshot) {\n                  return reject(new Error(\"Unable to snapshot build dependencies\"));\n                }\n                this.logger.debug(\"Captured build dependencies\");\n                if (this.buildSnapshot) {\n                  this.buildSnapshot = this.fileSystemInfo.mergeSnapshots(this.buildSnapshot, snapshot);\n                } else {\n                  this.buildSnapshot = snapshot;\n                }\n                resolve();\n              });\n            });\n          });\n        });\n      } else {\n        promise = Promise.resolve();\n      }\n      return promise.then(() => {\n        if (reportProgress) reportProgress(0.8, \"serialize pack\");\n        this.logger.time(`store pack`);\n        const updatedBuildDependencies = new Set(this.buildDependencies);\n        for (const dep of newBuildDependencies) {\n          updatedBuildDependencies.add(dep);\n        }\n        const content = new PackContainer(pack, this.version, this.buildSnapshot, updatedBuildDependencies, this.resolveResults, this.resolveBuildDependenciesSnapshot);\n        return this.fileSerializer.serialize(content, {\n          filename: `${this.cacheLocation}/index${this._extension}`,\n          extension: `${this._extension}`,\n          logger: this.logger,\n          profile: this.profile\n        }).then(() => {\n          for (const dep of newBuildDependencies) {\n            this.buildDependencies.add(dep);\n          }\n          this.newBuildDependencies.clear();\n          this.logger.timeEnd(`store pack`);\n          const stats = pack.getContentStats();\n          this.logger.log(\"Stored pack (%d items, %d files, %d MiB)\", pack.itemInfo.size, stats.count, Math.round(stats.size / 1024 / 1024));\n        }).catch(err => {\n          this.logger.timeEnd(`store pack`);\n          this.logger.warn(`Caching failed for pack: ${err}`);\n          this.logger.debug(err.stack);\n        });\n      });\n    }).catch(err => {\n      this.logger.warn(`Caching failed for pack: ${err}`);\n      this.logger.debug(err.stack);\n    });\n  }\n  clear() {\n    this.fileSystemInfo.clear();\n    this.buildDependencies.clear();\n    this.newBuildDependencies.clear();\n    this.resolveBuildDependenciesSnapshot = undefined;\n    this.resolveResults = undefined;\n    this.buildSnapshot = undefined;\n    this.packPromise = undefined;\n  }\n}\nmodule.exports = PackFileCacheStrategy;","map":{"version":3,"names":["FileSystemInfo","require","ProgressPlugin","formatSize","SerializerMiddleware","LazySet","makeSerializable","memoize","createFileSerializer","NOT_SERIALIZABLE","PackContainer","constructor","data","version","buildSnapshot","buildDependencies","resolveResults","resolveBuildDependenciesSnapshot","serialize","_ref","write","writeLazy","deserialize","_ref2","read","MIN_CONTENT_SIZE","CONTENT_COUNT_TO_MERGE","MIN_ITEMS_IN_FRESH_PACK","MAX_ITEMS_IN_FRESH_PACK","MAX_TIME_IN_FRESH_PACK","PackItemInfo","identifier","etag","value","location","lastAccess","Date","now","freshValue","Pack","logger","maxAge","itemInfo","Map","requests","requestsTimeout","undefined","freshContent","content","invalid","_addRequest","push","setTimeout","unref","stopCapturingRequests","clearTimeout","get","info","loc","set","log","newInfo","delete","items","size","debug","getContentStats","count","s","getSize","_findLocation","i","length","_gcAndUpdateLocation","usedItems","newLoc","lastGC","_persistFreshContent","itemsCount","packCount","Math","ceil","itemsPerPack","packs","ignoreNextTimeTick","createNextPack","pack","Set","map","add","PackContent","PackContentItems","join","_optimizeSmallContent","smallUsedContents","smallUsedContentSize","smallUnusedContents","smallUnusedContentSize","outdated","used","mergedIndices","mergedContent","mergedItems","mergedUsedItems","addToMergedMap","unpack","Promise","all","fn","_optimizeUnusedContent","total","unusedItems","usedOfUnusedItems","newUnusedLoc","_gcOldestContent","oldest","values","_ref3","writeSeparate","keys","lazy","name","_ref4","item","clear","infoItems","idx","_ref5","snapshot","rollback","profile","key","start","process","hrtime","durationHr","duration","error","warn","e","msg","message","includes","stack","_ref6","dataOrFn","lazyName","timeMessage","time","then","timeEnd","unMemoizeLazy","reason","options","oldMap","allowCollectingMemory","buf","wasted","buffer","byteLength","Buffer","from","PackFileCacheStrategy","_ref7","compiler","fs","context","cacheLocation","compression","fileSerializer","output","hashFunction","fileSystemInfo","managedPaths","immutablePaths","getChildLogger","_extension","newBuildDependencies","packPromise","_openPack","storePromise","resolve","_getPack","filename","extension","retainedBuffer","catch","err","code","packContainer","reject","checkSnapshotValid","valid","checkResolveResultsValid","_ref8","buildSnapshotValid","resolveValid","d","addAll","store","toString","restore","storeBuildDependencies","dependencies","afterAllStored","reportProgress","getReporter","promise","dep","has","Array","resolveBuildDependencies","result","files","directories","missing","resolveDependencies","createSnapshot","Error","mergeSnapshots","updatedBuildDependencies","stats","round","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/cache/PackFileCacheStrategy.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst { formatSize } = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n\tcreateFileSerializer,\n\tNOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nclass PackContainer {\n\t/**\n\t * @param {Object} data stored data\n\t * @param {string} version version identifier\n\t * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n\t * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n\t * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n\t * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n\t */\n\tconstructor(\n\t\tdata,\n\t\tversion,\n\t\tbuildSnapshot,\n\t\tbuildDependencies,\n\t\tresolveResults,\n\t\tresolveBuildDependenciesSnapshot\n\t) {\n\t\tthis.data = data;\n\t\tthis.version = version;\n\t\tthis.buildSnapshot = buildSnapshot;\n\t\tthis.buildDependencies = buildDependencies;\n\t\tthis.resolveResults = resolveResults;\n\t\tthis.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n\t}\n\n\tserialize({ write, writeLazy }) {\n\t\twrite(this.version);\n\t\twrite(this.buildSnapshot);\n\t\twrite(this.buildDependencies);\n\t\twrite(this.resolveResults);\n\t\twrite(this.resolveBuildDependenciesSnapshot);\n\t\twriteLazy(this.data);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.version = read();\n\t\tthis.buildSnapshot = read();\n\t\tthis.buildDependencies = read();\n\t\tthis.resolveResults = read();\n\t\tthis.resolveBuildDependenciesSnapshot = read();\n\t\tthis.data = read();\n\t}\n}\n\nmakeSerializable(\n\tPackContainer,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContainer\"\n);\n\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n\t/**\n\t * @param {string} identifier identifier of item\n\t * @param {string | null} etag etag of item\n\t * @param {any} value fresh value of item\n\t */\n\tconstructor(identifier, etag, value) {\n\t\tthis.identifier = identifier;\n\t\tthis.etag = etag;\n\t\tthis.location = -1;\n\t\tthis.lastAccess = Date.now();\n\t\tthis.freshValue = value;\n\t}\n}\n\nclass Pack {\n\tconstructor(logger, maxAge) {\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.itemInfo = new Map();\n\t\t/** @type {string[]} */\n\t\tthis.requests = [];\n\t\tthis.requestsTimeout = undefined;\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.freshContent = new Map();\n\t\t/** @type {(undefined | PackContent)[]} */\n\t\tthis.content = [];\n\t\tthis.invalid = false;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t}\n\n\t_addRequest(identifier) {\n\t\tthis.requests.push(identifier);\n\t\tif (this.requestsTimeout === undefined) {\n\t\t\tthis.requestsTimeout = setTimeout(() => {\n\t\t\t\tthis.requests.push(undefined);\n\t\t\t\tthis.requestsTimeout = undefined;\n\t\t\t}, MAX_TIME_IN_FRESH_PACK);\n\t\t\tif (this.requestsTimeout.unref) this.requestsTimeout.unref();\n\t\t}\n\t}\n\n\tstopCapturingRequests() {\n\t\tif (this.requestsTimeout !== undefined) {\n\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tthis.requestsTimeout = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @returns {any} cached content\n\t */\n\tget(identifier, etag) {\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tthis._addRequest(identifier);\n\t\tif (info === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (info.etag !== etag) return null;\n\t\tinfo.lastAccess = Date.now();\n\t\tconst loc = info.location;\n\t\tif (loc === -1) {\n\t\t\treturn info.freshValue;\n\t\t} else {\n\t\t\tif (!this.content[loc]) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn this.content[loc].get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {void}\n\t */\n\tset(identifier, etag, data) {\n\t\tif (!this.invalid) {\n\t\t\tthis.invalid = true;\n\t\t\tthis.logger.log(`Pack got invalid because of write to: ${identifier}`);\n\t\t}\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tif (info === undefined) {\n\t\t\tconst newInfo = new PackItemInfo(identifier, etag, data);\n\t\t\tthis.itemInfo.set(identifier, newInfo);\n\t\t\tthis._addRequest(identifier);\n\t\t\tthis.freshContent.set(identifier, newInfo);\n\t\t} else {\n\t\t\tconst loc = info.location;\n\t\t\tif (loc >= 0) {\n\t\t\t\tthis._addRequest(identifier);\n\t\t\t\tthis.freshContent.set(identifier, info);\n\t\t\t\tconst content = this.content[loc];\n\t\t\t\tcontent.delete(identifier);\n\t\t\t\tif (content.items.size === 0) {\n\t\t\t\t\tthis.content[loc] = undefined;\n\t\t\t\t\tthis.logger.debug(\"Pack %d got empty and is removed\", loc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.freshValue = data;\n\t\t\tinfo.lastAccess = Date.now();\n\t\t\tinfo.etag = etag;\n\t\t\tinfo.location = -1;\n\t\t}\n\t}\n\n\tgetContentStats() {\n\t\tlet count = 0;\n\t\tlet size = 0;\n\t\tfor (const content of this.content) {\n\t\t\tif (content !== undefined) {\n\t\t\t\tcount++;\n\t\t\t\tconst s = content.getSize();\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tsize += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { count, size };\n\t}\n\n\t/**\n\t * @returns {number} new location of data entries\n\t */\n\t_findLocation() {\n\t\tlet i;\n\t\tfor (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n\t\treturn i;\n\t}\n\n\t_gcAndUpdateLocation(items, usedItems, newLoc) {\n\t\tlet count = 0;\n\t\tlet lastGC;\n\t\tconst now = Date.now();\n\t\tfor (const identifier of items) {\n\t\t\tconst info = this.itemInfo.get(identifier);\n\t\t\tif (now - info.lastAccess > this.maxAge) {\n\t\t\t\tthis.itemInfo.delete(identifier);\n\t\t\t\titems.delete(identifier);\n\t\t\t\tusedItems.delete(identifier);\n\t\t\t\tcount++;\n\t\t\t\tlastGC = identifier;\n\t\t\t} else {\n\t\t\t\tinfo.location = newLoc;\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\tthis.logger.log(\n\t\t\t\t\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\",\n\t\t\t\tcount,\n\t\t\t\tnewLoc,\n\t\t\t\titems.size,\n\t\t\t\tlastGC\n\t\t\t);\n\t\t}\n\t}\n\n\t_persistFreshContent() {\n\t\tconst itemsCount = this.freshContent.size;\n\t\tif (itemsCount > 0) {\n\t\t\tconst packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n\t\t\tconst itemsPerPack = Math.ceil(itemsCount / packCount);\n\t\t\tconst packs = [];\n\t\t\tlet i = 0;\n\t\t\tlet ignoreNextTimeTick = false;\n\t\t\tconst createNextPack = () => {\n\t\t\t\tconst loc = this._findLocation();\n\t\t\t\tthis.content[loc] = null; // reserve\n\t\t\t\tconst pack = {\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\titems: new Set(),\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tmap: new Map(),\n\t\t\t\t\tloc\n\t\t\t\t};\n\t\t\t\tpacks.push(pack);\n\t\t\t\treturn pack;\n\t\t\t};\n\t\t\tlet pack = createNextPack();\n\t\t\tif (this.requestsTimeout !== undefined)\n\t\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tfor (const identifier of this.requests) {\n\t\t\t\tif (identifier === undefined) {\n\t\t\t\t\tif (ignoreNextTimeTick) {\n\t\t\t\t\t\tignoreNextTimeTick = false;\n\t\t\t\t\t} else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst info = this.freshContent.get(identifier);\n\t\t\t\tif (info === undefined) continue;\n\t\t\t\tpack.items.add(identifier);\n\t\t\t\tpack.map.set(identifier, info.freshValue);\n\t\t\t\tinfo.location = pack.loc;\n\t\t\t\tinfo.freshValue = undefined;\n\t\t\t\tthis.freshContent.delete(identifier);\n\t\t\t\tif (++i > itemsPerPack) {\n\t\t\t\t\ti = 0;\n\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\tignoreNextTimeTick = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.requests.length = 0;\n\t\t\tfor (const pack of packs) {\n\t\t\t\tthis.content[pack.loc] = new PackContent(\n\t\t\t\t\tpack.items,\n\t\t\t\t\tnew Set(pack.items),\n\t\t\t\t\tnew PackContentItems(pack.map)\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.logger.log(\n\t\t\t\t`${itemsCount} fresh items in cache put into pack ${\n\t\t\t\t\tpacks.length > 1\n\t\t\t\t\t\t? packs\n\t\t\t\t\t\t\t\t.map(pack => `${pack.loc} (${pack.items.size} items)`)\n\t\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t\t: packs[0].loc\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Merges small content files to a single content file\n\t */\n\t_optimizeSmallContent() {\n\t\t// 1. Find all small content files\n\t\t// Treat unused content files separately to avoid\n\t\t// a merge-split cycle\n\t\t/** @type {number[]} */\n\t\tconst smallUsedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUsedContentSize = 0;\n\t\t/** @type {number[]} */\n\t\tconst smallUnusedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUnusedContentSize = 0;\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tif (content.outdated) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < 0 || size > MIN_CONTENT_SIZE) continue;\n\t\t\tif (content.used.size > 0) {\n\t\t\t\tsmallUsedContents.push(i);\n\t\t\t\tsmallUsedContentSize += size;\n\t\t\t} else {\n\t\t\t\tsmallUnusedContents.push(i);\n\t\t\t\tsmallUnusedContentSize += size;\n\t\t\t}\n\t\t}\n\n\t\t// 2. Check if minimum number is reached\n\t\tlet mergedIndices;\n\t\tif (\n\t\t\tsmallUsedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUsedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUsedContents;\n\t\t} else if (\n\t\t\tsmallUnusedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUnusedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUnusedContents;\n\t\t} else return;\n\n\t\tconst mergedContent = [];\n\n\t\t// 3. Remove old content entries\n\t\tfor (const i of mergedIndices) {\n\t\t\tmergedContent.push(this.content[i]);\n\t\t\tthis.content[i] = undefined;\n\t\t}\n\n\t\t// 4. Determine merged items\n\t\t/** @type {Set<string>} */\n\t\tconst mergedItems = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst mergedUsedItems = new Set();\n\t\t/** @type {(function(Map<string, any>): Promise)[]} */\n\t\tconst addToMergedMap = [];\n\t\tfor (const content of mergedContent) {\n\t\t\tfor (const identifier of content.items) {\n\t\t\t\tmergedItems.add(identifier);\n\t\t\t}\n\t\t\tfor (const identifier of content.used) {\n\t\t\t\tmergedUsedItems.add(identifier);\n\t\t\t}\n\t\t\taddToMergedMap.push(async map => {\n\t\t\t\t// unpack existing content\n\t\t\t\t// after that values are accessible in .content\n\t\t\t\tawait content.unpack(\n\t\t\t\t\t\"it should be merged with other small pack contents\"\n\t\t\t\t);\n\t\t\t\tfor (const [identifier, value] of content.content) {\n\t\t\t\t\tmap.set(identifier, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// 5. GC and update location of merged items\n\t\tconst newLoc = this._findLocation();\n\t\tthis._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n\t\t// 6. If not empty, store content somewhere\n\t\tif (mergedItems.size > 0) {\n\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\tmergedItems,\n\t\t\t\tmergedUsedItems,\n\t\t\t\tmemoize(async () => {\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tawait Promise.all(addToMergedMap.map(fn => fn(map)));\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.logger.log(\n\t\t\t\t\"Merged %d small files with %d cache items into pack %d\",\n\t\t\t\tmergedContent.length,\n\t\t\t\tmergedItems.size,\n\t\t\t\tnewLoc\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Split large content files with used and unused items\n\t * into two parts to separate used from unused items\n\t */\n\t_optimizeUnusedContent() {\n\t\t// 1. Find a large content file with used and unused items\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < MIN_CONTENT_SIZE) continue;\n\t\t\tconst used = content.used.size;\n\t\t\tconst total = content.items.size;\n\t\t\tif (used > 0 && used < total) {\n\t\t\t\t// 2. Remove this content\n\t\t\t\tthis.content[i] = undefined;\n\n\t\t\t\t// 3. Determine items for the used content file\n\t\t\t\tconst usedItems = new Set(content.used);\n\t\t\t\tconst newLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n\t\t\t\t// 4. Create content file for used items\n\t\t\t\tif (usedItems.size > 0) {\n\t\t\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\t\t\tusedItems,\n\t\t\t\t\t\tnew Set(usedItems),\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// 5. Determine items for the unused content file\n\t\t\t\tconst unusedItems = new Set(content.items);\n\t\t\t\tconst usedOfUnusedItems = new Set();\n\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\tunusedItems.delete(identifier);\n\t\t\t\t}\n\t\t\t\tconst newUnusedLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n\t\t\t\t// 6. Create content file for unused items\n\t\t\t\tif (unusedItems.size > 0) {\n\t\t\t\t\tthis.content[newUnusedLoc] = new PackContent(\n\t\t\t\t\t\tunusedItems,\n\t\t\t\t\t\tusedOfUnusedItems,\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of unusedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\",\n\t\t\t\t\ti,\n\t\t\t\t\tnewLoc,\n\t\t\t\t\tusedItems.size,\n\t\t\t\t\tnewUnusedLoc,\n\t\t\t\t\tunusedItems.size\n\t\t\t\t);\n\n\t\t\t\t// optimizing only one of them is good enough and\n\t\t\t\t// reduces the amount of serialization needed\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find the content with the oldest item and run GC on that.\n\t * Only runs for one content to avoid large invalidation.\n\t */\n\t_gcOldestContent() {\n\t\t/** @type {PackItemInfo} */\n\t\tlet oldest = undefined;\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\tif (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n\t\t\t\toldest = info;\n\t\t\t}\n\t\t}\n\t\tif (Date.now() - oldest.lastAccess > this.maxAge) {\n\t\t\tconst loc = oldest.location;\n\t\t\tif (loc < 0) return;\n\t\t\tconst content = this.content[loc];\n\t\t\tconst items = new Set(content.items);\n\t\t\tconst usedItems = new Set(content.used);\n\t\t\tthis._gcAndUpdateLocation(items, usedItems, loc);\n\n\t\t\tthis.content[loc] =\n\t\t\t\titems.size > 0\n\t\t\t\t\t? new PackContent(items, usedItems, async () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it contains old items that should be garbage collected\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t  })\n\t\t\t\t\t: undefined;\n\t\t}\n\t}\n\n\tserialize({ write, writeSeparate }) {\n\t\tthis._persistFreshContent();\n\t\tthis._optimizeSmallContent();\n\t\tthis._optimizeUnusedContent();\n\t\tthis._gcOldestContent();\n\t\tfor (const identifier of this.itemInfo.keys()) {\n\t\t\twrite(identifier);\n\t\t}\n\t\twrite(null); // null as marker of the end of keys\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.etag);\n\t\t}\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.lastAccess);\n\t\t}\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content !== undefined) {\n\t\t\t\twrite(content.items);\n\t\t\t\tcontent.writeLazy(lazy => writeSeparate(lazy, { name: `${i}` }));\n\t\t\t} else {\n\t\t\t\twrite(undefined); // undefined marks an empty content slot\n\t\t\t}\n\t\t}\n\t\twrite(null); // null as marker of the end of items\n\t}\n\n\tdeserialize({ read, logger }) {\n\t\tthis.logger = logger;\n\t\t{\n\t\t\tconst items = [];\n\t\t\tlet item = read();\n\t\t\twhile (item !== null) {\n\t\t\t\titems.push(item);\n\t\t\t\titem = read();\n\t\t\t}\n\t\t\tthis.itemInfo.clear();\n\t\t\tconst infoItems = items.map(identifier => {\n\t\t\t\tconst info = new PackItemInfo(identifier, undefined, undefined);\n\t\t\t\tthis.itemInfo.set(identifier, info);\n\t\t\t\treturn info;\n\t\t\t});\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.etag = read();\n\t\t\t}\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.lastAccess = read();\n\t\t\t}\n\t\t}\n\t\tthis.content.length = 0;\n\t\tlet items = read();\n\t\twhile (items !== null) {\n\t\t\tif (items === undefined) {\n\t\t\t\tthis.content.push(items);\n\t\t\t} else {\n\t\t\t\tconst idx = this.content.length;\n\t\t\t\tconst lazy = read();\n\t\t\t\tthis.content.push(\n\t\t\t\t\tnew PackContent(\n\t\t\t\t\t\titems,\n\t\t\t\t\t\tnew Set(),\n\t\t\t\t\t\tlazy,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t`${this.content.length}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\tthis.itemInfo.get(identifier).location = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\titems = read();\n\t\t}\n\t}\n}\n\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\n\nclass PackContentItems {\n\t/**\n\t * @param {Map<string, any>} map items\n\t */\n\tconstructor(map) {\n\t\tthis.map = map;\n\t}\n\n\tserialize({ write, snapshot, rollback, logger, profile }) {\n\t\tif (profile) {\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\tconst start = process.hrtime();\n\t\t\t\t\twrite(value);\n\t\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\t\tif (duration > 1) {\n\t\t\t\t\t\tif (duration > 500)\n\t\t\t\t\t\t\tlogger.error(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 50)\n\t\t\t\t\t\t\tlogger.warn(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 10)\n\t\t\t\t\t\t\tlogger.info(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\t\tlogger.log(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse logger.debug(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tconst msg = \"Skipped not serializable cache item\";\n\t\t\t\t\tif (e.message.includes(\"ModuleBuildError\")) {\n\t\t\t\t\t\tlogger.log(`${msg} (in build error): ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(`${msg}: ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}': ${e.stack}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t\treturn;\n\t\t}\n\t\t// Try to serialize all at once\n\t\tconst s = snapshot();\n\t\ttry {\n\t\t\twrite(true);\n\t\t\twrite(this.map);\n\t\t} catch (e) {\n\t\t\trollback(s);\n\n\t\t\t// Try to serialize each item on it's own\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\twrite(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Skipped not serializable cache item '${key}': ${e.message}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t}\n\t}\n\n\tdeserialize({ read, logger, profile }) {\n\t\tif (read()) {\n\t\t\tthis.map = read();\n\t\t} else if (profile) {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tconst start = process.hrtime();\n\t\t\t\tconst value = read();\n\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\tif (duration > 1) {\n\t\t\t\t\tif (duration > 100)\n\t\t\t\t\t\tlogger.error(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 20)\n\t\t\t\t\t\tlogger.warn(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\tlogger.info(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 2)\n\t\t\t\t\t\tlogger.log(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse logger.debug(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t}\n\t\t\t\tmap.set(key, value);\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t} else {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tmap.set(key, read());\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t}\n\t}\n}\n\nmakeSerializable(\n\tPackContentItems,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContentItems\"\n);\n\nclass PackContent {\n\t/*\n\t\tThis class can be in these states:\n\t\t   |   this.lazy    | this.content | this.outdated | state\n\t\tA1 |   undefined    |     Map      |     false     | fresh content\n\t\tA2 |   undefined    |     Map      |     true      | (will not happen)\n\t\tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n\t\tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n\t\tC1 | lazy* () => {} |     Map      |     false     | deserialized\n\t\tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n\n\t\tthis.used is a subset of this.items.\n\t\tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n\t\tWhen this.lazy and this.content is set, they contain the same data.\n\t\tthis.get must only be called with a valid item from this.items.\n\t\tIn state C this.lazy is unMemoized\n\t*/\n\n\t/**\n\t * @param {Set<string>} items keys\n\t * @param {Set<string>} usedItems used keys\n\t * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n\t * @param {Logger=} logger logger for logging\n\t * @param {string=} lazyName name of dataOrFn for logging\n\t */\n\tconstructor(items, usedItems, dataOrFn, logger, lazyName) {\n\t\tthis.items = items;\n\t\t/** @type {function(): Promise<PackContentItems> | PackContentItems} */\n\t\tthis.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n\t\t/** @type {Map<string, any>} */\n\t\tthis.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n\t\tthis.outdated = false;\n\t\tthis.used = usedItems;\n\t\tthis.logger = logger;\n\t\tthis.lazyName = lazyName;\n\t}\n\n\tget(identifier) {\n\t\tthis.used.add(identifier);\n\t\tif (this.content) {\n\t\t\treturn this.content.get(identifier);\n\t\t}\n\n\t\t// We are in state B\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `restore cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to restore cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because of request to: ${identifier}`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tif (\"then\" in value) {\n\t\t\treturn value.then(data => {\n\t\t\t\tconst map = data.map;\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\t// Move to state C\n\t\t\t\tthis.content = map;\n\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\t\treturn map.get(identifier);\n\t\t\t});\n\t\t} else {\n\t\t\tconst map = value.map;\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\t// Move to state C\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\treturn map.get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} reason explanation why unpack is necessary\n\t * @returns {void | Promise} maybe a promise if lazy\n\t */\n\tunpack(reason) {\n\t\tif (this.content) return;\n\n\t\t// Move from state B to C\n\t\tif (this.lazy) {\n\t\t\tconst { lazyName } = this;\n\t\t\tlet timeMessage;\n\t\t\tif (lazyName) {\n\t\t\t\t// only log once\n\t\t\t\tthis.lazyName = undefined;\n\t\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)})`;\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\t\tthis.getSize()\n\t\t\t\t\t)}) because ${reason}`\n\t\t\t\t);\n\t\t\t\tthis.logger.time(timeMessage);\n\t\t\t}\n\t\t\tconst value = this.lazy();\n\t\t\tif (\"then\" in value) {\n\t\t\t\treturn value.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tthis.content = data.map;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\tthis.content = value.map;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number} size of the content or -1 if not known\n\t */\n\tgetSize() {\n\t\tif (!this.lazy) return -1;\n\t\tconst options = /** @type {any} */ (this.lazy).options;\n\t\tif (!options) return -1;\n\t\tconst size = options.size;\n\t\tif (typeof size !== \"number\") return -1;\n\t\treturn size;\n\t}\n\n\tdelete(identifier) {\n\t\tthis.items.delete(identifier);\n\t\tthis.used.delete(identifier);\n\t\tthis.outdated = true;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n\t * @returns {void}\n\t */\n\twriteLazy(write) {\n\t\tif (!this.outdated && this.lazy) {\n\t\t\t// State B1 or C1\n\t\t\t// this.lazy is still the valid deserialized version\n\t\t\twrite(this.lazy);\n\t\t\treturn;\n\t\t}\n\t\tif (!this.outdated && this.content) {\n\t\t\t// State A1\n\t\t\tconst map = new Map(this.content);\n\t\t\t// Move to state C1\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tif (this.content) {\n\t\t\t// State A2 or C2\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, this.content.get(item));\n\t\t\t}\n\t\t\t// Move to state C1\n\t\t\tthis.outdated = false;\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\t// State B2\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because it's outdated and need to be serialized`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tthis.outdated = false;\n\t\tif (\"then\" in value) {\n\t\t\t// Move to state B1\n\t\t\tthis.lazy = write(() =>\n\t\t\t\tvalue.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tconst oldMap = data.map;\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tfor (const item of this.items) {\n\t\t\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t\t\t}\n\t\t\t\t\t// Move to state C1 (or maybe C2)\n\t\t\t\t\tthis.content = map;\n\t\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\t// Move to state C1\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\tconst oldMap = value.map;\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t}\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = write(() => new PackContentItems(map));\n\t\t}\n\t}\n}\n\nconst allowCollectingMemory = buf => {\n\tconst wasted = buf.buffer.byteLength - buf.byteLength;\n\tif (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n\t\treturn Buffer.from(buf);\n\t}\n\treturn buf;\n};\n\nclass PackFileCacheStrategy {\n\t/**\n\t * @param {Object} options options\n\t * @param {Compiler} options.compiler the compiler\n\t * @param {IntermediateFileSystem} options.fs the filesystem\n\t * @param {string} options.context the context directory\n\t * @param {string} options.cacheLocation the location of the cache data\n\t * @param {string} options.version version identifier\n\t * @param {Logger} options.logger a logger\n\t * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n\t * @param {number} options.maxAge max age of cache items\n\t * @param {boolean} options.profile track and log detailed timing information for individual cache items\n\t * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n\t * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n\t */\n\tconstructor({\n\t\tcompiler,\n\t\tfs,\n\t\tcontext,\n\t\tcacheLocation,\n\t\tversion,\n\t\tlogger,\n\t\tsnapshot,\n\t\tmaxAge,\n\t\tprofile,\n\t\tallowCollectingMemory,\n\t\tcompression\n\t}) {\n\t\tthis.fileSerializer = createFileSerializer(\n\t\t\tfs,\n\t\t\tcompiler.options.output.hashFunction\n\t\t);\n\t\tthis.fileSystemInfo = new FileSystemInfo(fs, {\n\t\t\tmanagedPaths: snapshot.managedPaths,\n\t\t\timmutablePaths: snapshot.immutablePaths,\n\t\t\tlogger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n\t\t\thashFunction: compiler.options.output.hashFunction\n\t\t});\n\t\tthis.compiler = compiler;\n\t\tthis.context = context;\n\t\tthis.cacheLocation = cacheLocation;\n\t\tthis.version = version;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t\tthis.profile = profile;\n\t\tthis.allowCollectingMemory = allowCollectingMemory;\n\t\tthis.compression = compression;\n\t\tthis._extension =\n\t\t\tcompression === \"brotli\"\n\t\t\t\t? \".pack.br\"\n\t\t\t\t: compression === \"gzip\"\n\t\t\t\t? \".pack.gz\"\n\t\t\t\t: \".pack\";\n\t\tthis.snapshot = snapshot;\n\t\t/** @type {Set<string>} */\n\t\tthis.buildDependencies = new Set();\n\t\t/** @type {LazySet<string>} */\n\t\tthis.newBuildDependencies = new LazySet();\n\t\t/** @type {Snapshot} */\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\t/** @type {Map<string, string | false>} */\n\t\tthis.resolveResults = undefined;\n\t\t/** @type {Snapshot} */\n\t\tthis.buildSnapshot = undefined;\n\t\t/** @type {Promise<Pack>} */\n\t\tthis.packPromise = this._openPack();\n\t\tthis.storePromise = Promise.resolve();\n\t}\n\n\t_getPack() {\n\t\tif (this.packPromise === undefined) {\n\t\t\tthis.packPromise = this.storePromise.then(() => this._openPack());\n\t\t}\n\t\treturn this.packPromise;\n\t}\n\n\t/**\n\t * @returns {Promise<Pack>} the pack\n\t */\n\t_openPack() {\n\t\tconst { logger, profile, cacheLocation, version } = this;\n\t\t/** @type {Snapshot} */\n\t\tlet buildSnapshot;\n\t\t/** @type {Set<string>} */\n\t\tlet buildDependencies;\n\t\t/** @type {Set<string>} */\n\t\tlet newBuildDependencies;\n\t\t/** @type {Snapshot} */\n\t\tlet resolveBuildDependenciesSnapshot;\n\t\t/** @type {Map<string, string | false>} */\n\t\tlet resolveResults;\n\t\tlogger.time(\"restore cache container\");\n\t\treturn this.fileSerializer\n\t\t\t.deserialize(null, {\n\t\t\t\tfilename: `${cacheLocation}/index${this._extension}`,\n\t\t\t\textension: `${this._extension}`,\n\t\t\t\tlogger,\n\t\t\t\tprofile,\n\t\t\t\tretainedBuffer: this.allowCollectingMemory\n\t\t\t\t\t? allowCollectingMemory\n\t\t\t\t\t: undefined\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tif (err.code !== \"ENOENT\") {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`No pack exists at ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t})\n\t\t\t.then(packContainer => {\n\t\t\t\tlogger.timeEnd(\"restore cache container\");\n\t\t\t\tif (!packContainer) return undefined;\n\t\t\t\tif (!(packContainer instanceof PackContainer)) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`,\n\t\t\t\t\t\tpackContainer\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (packContainer.version !== version) {\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tlogger.time(\"check build dependencies\");\n\t\t\t\treturn Promise.all([\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.buildSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbuildSnapshot = packContainer.buildSnapshot;\n\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\tresolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot;\n\t\t\t\t\t\t\t\t\tbuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\"resolving of build dependencies is invalid, will re-resolve build dependencies\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.checkResolveResultsValid(\n\t\t\t\t\t\t\t\t\tpackContainer.resolveResults,\n\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\t\t\tnewBuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t})\n\t\t\t\t\t.then(([buildSnapshotValid, resolveValid]) => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tif (buildSnapshotValid && resolveValid) {\n\t\t\t\t\t\t\tlogger.time(\"restore cache content metadata\");\n\t\t\t\t\t\t\tconst d = packContainer.data();\n\t\t\t\t\t\t\tlogger.timeEnd(\"restore cache content metadata\");\n\t\t\t\t\t\t\treturn d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.then(pack => {\n\t\t\t\tif (pack) {\n\t\t\t\t\tpack.maxAge = this.maxAge;\n\t\t\t\t\tthis.buildSnapshot = buildSnapshot;\n\t\t\t\t\tif (buildDependencies) this.buildDependencies = buildDependencies;\n\t\t\t\t\tif (newBuildDependencies)\n\t\t\t\t\t\tthis.newBuildDependencies.addAll(newBuildDependencies);\n\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\tresolveBuildDependenciesSnapshot;\n\t\t\t\t\treturn pack;\n\t\t\t\t}\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(\n\t\t\t\t\t`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`\n\t\t\t\t);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {Promise<void>} promise\n\t */\n\tstore(identifier, etag, data) {\n\t\treturn this._getPack().then(pack => {\n\t\t\tpack.set(identifier, etag === null ? null : etag.toString(), data);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @returns {Promise<any>} promise to the cached content\n\t */\n\trestore(identifier, etag) {\n\t\treturn this._getPack()\n\t\t\t.then(pack =>\n\t\t\t\tpack.get(identifier, etag === null ? null : etag.toString())\n\t\t\t)\n\t\t\t.catch(err => {\n\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t`Restoring failed for ${identifier} from pack: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tstoreBuildDependencies(dependencies) {\n\t\tthis.newBuildDependencies.addAll(dependencies);\n\t}\n\n\tafterAllStored() {\n\t\tconst packPromise = this.packPromise;\n\t\tif (packPromise === undefined) return Promise.resolve();\n\t\tconst reportProgress = ProgressPlugin.getReporter(this.compiler);\n\t\treturn (this.storePromise = packPromise\n\t\t\t.then(pack => {\n\t\t\t\tpack.stopCapturingRequests();\n\t\t\t\tif (!pack.invalid) return;\n\t\t\t\tthis.packPromise = undefined;\n\t\t\t\tthis.logger.log(`Storing pack...`);\n\t\t\t\tlet promise;\n\t\t\t\tconst newBuildDependencies = new Set();\n\t\t\t\tfor (const dep of this.newBuildDependencies) {\n\t\t\t\t\tif (!this.buildDependencies.has(dep)) {\n\t\t\t\t\t\tnewBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n\t\t\t\t\tif (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t`Capturing build dependencies... (${Array.from(\n\t\t\t\t\t\t\tnewBuildDependencies\n\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t);\n\t\t\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.logger.time(\"resolve build dependencies\");\n\t\t\t\t\t\tthis.fileSystemInfo.resolveBuildDependencies(\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\tnewBuildDependencies,\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"resolve build dependencies\");\n\t\t\t\t\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t\t\t\t\tthis.logger.time(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\tresolveResults,\n\t\t\t\t\t\t\t\t\tresolveDependencies\n\t\t\t\t\t\t\t\t} = result;\n\t\t\t\t\t\t\t\tif (this.resolveResults) {\n\t\t\t\t\t\t\t\t\tfor (const [key, value] of resolveResults) {\n\t\t\t\t\t\t\t\t\t\tthis.resolveResults.set(key, value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.6,\n\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\"resolving\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tresolveDependencies.files,\n\t\t\t\t\t\t\t\t\tresolveDependencies.directories,\n\t\t\t\t\t\t\t\t\tresolveDependencies.missing,\n\t\t\t\t\t\t\t\t\tthis.snapshot.resolveBuildDependencies,\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot resolve dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (this.resolveBuildDependenciesSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t\t0.7,\n\t\t\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"modules\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\t\t\tthis.snapshot.buildDependencies,\n\t\t\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot build dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\"Captured build dependencies\");\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.buildSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn promise.then(() => {\n\t\t\t\t\tif (reportProgress) reportProgress(0.8, \"serialize pack\");\n\t\t\t\t\tthis.logger.time(`store pack`);\n\t\t\t\t\tconst updatedBuildDependencies = new Set(this.buildDependencies);\n\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\tupdatedBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t\tconst content = new PackContainer(\n\t\t\t\t\t\tpack,\n\t\t\t\t\t\tthis.version,\n\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\tupdatedBuildDependencies,\n\t\t\t\t\t\tthis.resolveResults,\n\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot\n\t\t\t\t\t);\n\t\t\t\t\treturn this.fileSerializer\n\t\t\t\t\t\t.serialize(content, {\n\t\t\t\t\t\t\tfilename: `${this.cacheLocation}/index${this._extension}`,\n\t\t\t\t\t\t\textension: `${this._extension}`,\n\t\t\t\t\t\t\tlogger: this.logger,\n\t\t\t\t\t\t\tprofile: this.profile\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\t\t\tthis.buildDependencies.add(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.newBuildDependencies.clear();\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tconst stats = pack.getContentStats();\n\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t\"Stored pack (%d items, %d files, %d MiB)\",\n\t\t\t\t\t\t\t\tpack.itemInfo.size,\n\t\t\t\t\t\t\t\tstats.count,\n\t\t\t\t\t\t\t\tMath.round(stats.size / 1024 / 1024)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t}));\n\t}\n\n\tclear() {\n\t\tthis.fileSystemInfo.clear();\n\t\tthis.buildDependencies.clear();\n\t\tthis.newBuildDependencies.clear();\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\tthis.resolveResults = undefined;\n\t\tthis.buildSnapshot = undefined;\n\t\tthis.packPromise = undefined;\n\t}\n}\n\nmodule.exports = PackFileCacheStrategy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}