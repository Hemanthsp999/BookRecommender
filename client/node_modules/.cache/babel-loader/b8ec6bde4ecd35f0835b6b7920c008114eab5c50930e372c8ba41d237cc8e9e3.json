{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\n\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\nclass CacheEntry {\n  constructor(result, snapshot) {\n    this.result = result;\n    this.snapshot = snapshot;\n  }\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    write(this.result);\n    write(this.snapshot);\n  }\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.result = read();\n    this.snapshot = read();\n  }\n}\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n  if (set instanceof LazySet) {\n    set.addAll(otherSet);\n  } else {\n    for (const item of otherSet) {\n      set.add(item);\n    }\n  }\n};\n\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\nconst objectToString = (object, excludeContext) => {\n  let str = \"\";\n  for (const key in object) {\n    if (excludeContext && key === \"context\") continue;\n    const value = object[key];\n    if (typeof value === \"object\" && value !== null) {\n      str += `|${key}=[${objectToString(value, false)}|]`;\n    } else {\n      str += `|${key}=|${value}`;\n    }\n  }\n  return str;\n};\nclass ResolverCachePlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const cache = compiler.getCache(\"ResolverCachePlugin\");\n    /** @type {FileSystemInfo} */\n    let fileSystemInfo;\n    let snapshotOptions;\n    let realResolves = 0;\n    let cachedResolves = 0;\n    let cacheInvalidResolves = 0;\n    let concurrentResolves = 0;\n    compiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n      snapshotOptions = compilation.options.snapshot.resolve;\n      fileSystemInfo = compilation.fileSystemInfo;\n      compilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n        if (realResolves + cachedResolves > 0) {\n          const logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n          logger.log(`${Math.round(100 * realResolves / (realResolves + cachedResolves))}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`);\n          realResolves = 0;\n          cachedResolves = 0;\n          cacheInvalidResolves = 0;\n          concurrentResolves = 0;\n        }\n      });\n    });\n    /**\n     * @param {ItemCacheFacade} itemCache cache\n     * @param {Resolver} resolver the resolver\n     * @param {Object} resolveContext context for resolving meta info\n     * @param {Object} request the request info object\n     * @param {function((Error | null)=, Object=): void} callback callback function\n     * @returns {void}\n     */\n    const doRealResolve = (itemCache, resolver, resolveContext, request, callback) => {\n      realResolves++;\n      const newRequest = {\n        _ResolverCachePluginCacheMiss: true,\n        ...request\n      };\n      const newResolveContext = {\n        ...resolveContext,\n        stack: new Set(),\n        /** @type {LazySet<string>} */\n        missingDependencies: new LazySet(),\n        /** @type {LazySet<string>} */\n        fileDependencies: new LazySet(),\n        /** @type {LazySet<string>} */\n        contextDependencies: new LazySet()\n      };\n      let yieldResult;\n      let withYield = false;\n      if (typeof newResolveContext.yield === \"function\") {\n        yieldResult = [];\n        withYield = true;\n        newResolveContext.yield = obj => yieldResult.push(obj);\n      }\n      const propagate = key => {\n        if (resolveContext[key]) {\n          addAllToSet(resolveContext[key], newResolveContext[key]);\n        }\n      };\n      const resolveTime = Date.now();\n      resolver.doResolve(resolver.hooks.resolve, newRequest, \"Cache miss\", newResolveContext, (err, result) => {\n        propagate(\"fileDependencies\");\n        propagate(\"contextDependencies\");\n        propagate(\"missingDependencies\");\n        if (err) return callback(err);\n        const fileDependencies = newResolveContext.fileDependencies;\n        const contextDependencies = newResolveContext.contextDependencies;\n        const missingDependencies = newResolveContext.missingDependencies;\n        fileSystemInfo.createSnapshot(resolveTime, fileDependencies, contextDependencies, missingDependencies, snapshotOptions, (err, snapshot) => {\n          if (err) return callback(err);\n          const resolveResult = withYield ? yieldResult : result;\n          // since we intercept resolve hook\n          // we still can get result in callback\n          if (withYield && result) yieldResult.push(result);\n          if (!snapshot) {\n            if (resolveResult) return callback(null, resolveResult);\n            return callback();\n          }\n          itemCache.store(new CacheEntry(resolveResult, snapshot), storeErr => {\n            if (storeErr) return callback(storeErr);\n            if (resolveResult) return callback(null, resolveResult);\n            callback();\n          });\n        });\n      });\n    };\n    compiler.resolverFactory.hooks.resolver.intercept({\n      factory(type, hook) {\n        /** @type {Map<string, (function(Error=, Object=): void)[]>} */\n        const activeRequests = new Map();\n        /** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n        const activeRequestsWithYield = new Map();\n        hook.tap(\"ResolverCachePlugin\",\n        /**\n         * @param {Resolver} resolver the resolver\n         * @param {Object} options resolve options\n         * @param {Object} userOptions resolve options passed by the user\n         * @returns {void}\n         */\n        (resolver, options, userOptions) => {\n          if (options.cache !== true) return;\n          const optionsIdent = objectToString(userOptions, false);\n          const cacheWithContext = options.cacheWithContext !== undefined ? options.cacheWithContext : false;\n          resolver.hooks.resolve.tapAsync({\n            name: \"ResolverCachePlugin\",\n            stage: -100\n          }, (request, resolveContext, callback) => {\n            if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n              return callback();\n            }\n            const withYield = typeof resolveContext.yield === \"function\";\n            const identifier = `${type}${withYield ? \"|yield\" : \"|default\"}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n            if (withYield) {\n              const activeRequest = activeRequestsWithYield.get(identifier);\n              if (activeRequest) {\n                activeRequest[0].push(callback);\n                activeRequest[1].push(resolveContext.yield);\n                return;\n              }\n            } else {\n              const activeRequest = activeRequests.get(identifier);\n              if (activeRequest) {\n                activeRequest.push(callback);\n                return;\n              }\n            }\n            const itemCache = cache.getItemCache(identifier, null);\n            let callbacks, yields;\n            const done = withYield ? (err, result) => {\n              if (callbacks === undefined) {\n                if (err) {\n                  callback(err);\n                } else {\n                  if (result) for (const r of result) resolveContext.yield(r);\n                  callback(null, null);\n                }\n                yields = undefined;\n                callbacks = false;\n              } else {\n                if (err) {\n                  for (const cb of callbacks) cb(err);\n                } else {\n                  for (let i = 0; i < callbacks.length; i++) {\n                    const cb = callbacks[i];\n                    const yield_ = yields[i];\n                    if (result) for (const r of result) yield_(r);\n                    cb(null, null);\n                  }\n                }\n                activeRequestsWithYield.delete(identifier);\n                yields = undefined;\n                callbacks = false;\n              }\n            } : (err, result) => {\n              if (callbacks === undefined) {\n                callback(err, result);\n                callbacks = false;\n              } else {\n                for (const callback of callbacks) {\n                  callback(err, result);\n                }\n                activeRequests.delete(identifier);\n                callbacks = false;\n              }\n            };\n            /**\n             * @param {Error=} err error if any\n             * @param {CacheEntry=} cacheEntry cache entry\n             * @returns {void}\n             */\n            const processCacheResult = (err, cacheEntry) => {\n              if (err) return done(err);\n              if (cacheEntry) {\n                const {\n                  snapshot,\n                  result\n                } = cacheEntry;\n                fileSystemInfo.checkSnapshotValid(snapshot, (err, valid) => {\n                  if (err || !valid) {\n                    cacheInvalidResolves++;\n                    return doRealResolve(itemCache, resolver, resolveContext, request, done);\n                  }\n                  cachedResolves++;\n                  if (resolveContext.missingDependencies) {\n                    addAllToSet(resolveContext.missingDependencies, snapshot.getMissingIterable());\n                  }\n                  if (resolveContext.fileDependencies) {\n                    addAllToSet(resolveContext.fileDependencies, snapshot.getFileIterable());\n                  }\n                  if (resolveContext.contextDependencies) {\n                    addAllToSet(resolveContext.contextDependencies, snapshot.getContextIterable());\n                  }\n                  done(null, result);\n                });\n              } else {\n                doRealResolve(itemCache, resolver, resolveContext, request, done);\n              }\n            };\n            itemCache.get(processCacheResult);\n            if (withYield && callbacks === undefined) {\n              callbacks = [callback];\n              yields = [resolveContext.yield];\n              activeRequestsWithYield.set(identifier, /** @type {[any, any]} */[callbacks, yields]);\n            } else if (callbacks === undefined) {\n              callbacks = [callback];\n              activeRequests.set(identifier, callbacks);\n            }\n          });\n        });\n        return hook;\n      }\n    });\n  }\n}\nmodule.exports = ResolverCachePlugin;","map":{"version":3,"names":["LazySet","require","makeSerializable","CacheEntry","constructor","result","snapshot","serialize","_ref","write","deserialize","_ref2","read","addAllToSet","set","otherSet","addAll","item","add","objectToString","object","excludeContext","str","key","value","ResolverCachePlugin","apply","compiler","cache","getCache","fileSystemInfo","snapshotOptions","realResolves","cachedResolves","cacheInvalidResolves","concurrentResolves","hooks","thisCompilation","tap","compilation","options","resolve","finishModules","logger","getLogger","log","Math","round","doRealResolve","itemCache","resolver","resolveContext","request","callback","newRequest","_ResolverCachePluginCacheMiss","newResolveContext","stack","Set","missingDependencies","fileDependencies","contextDependencies","yieldResult","withYield","yield","obj","push","propagate","resolveTime","Date","now","doResolve","err","createSnapshot","resolveResult","store","storeErr","resolverFactory","intercept","factory","type","hook","activeRequests","Map","activeRequestsWithYield","userOptions","optionsIdent","cacheWithContext","undefined","tapAsync","name","stage","identifier","activeRequest","get","getItemCache","callbacks","yields","done","r","cb","i","length","yield_","delete","processCacheResult","cacheEntry","checkSnapshotValid","valid","getMissingIterable","getFileIterable","getContextIterable","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/cache/ResolverCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\n\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\nclass CacheEntry {\n\tconstructor(result, snapshot) {\n\t\tthis.result = result;\n\t\tthis.snapshot = snapshot;\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this.result);\n\t\twrite(this.snapshot);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.result = read();\n\t\tthis.snapshot = read();\n\t}\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n\tif (set instanceof LazySet) {\n\t\tset.addAll(otherSet);\n\t} else {\n\t\tfor (const item of otherSet) {\n\t\t\tset.add(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\nconst objectToString = (object, excludeContext) => {\n\tlet str = \"\";\n\tfor (const key in object) {\n\t\tif (excludeContext && key === \"context\") continue;\n\t\tconst value = object[key];\n\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\tstr += `|${key}=[${objectToString(value, false)}|]`;\n\t\t} else {\n\t\t\tstr += `|${key}=|${value}`;\n\t\t}\n\t}\n\treturn str;\n};\n\nclass ResolverCachePlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cache = compiler.getCache(\"ResolverCachePlugin\");\n\t\t/** @type {FileSystemInfo} */\n\t\tlet fileSystemInfo;\n\t\tlet snapshotOptions;\n\t\tlet realResolves = 0;\n\t\tlet cachedResolves = 0;\n\t\tlet cacheInvalidResolves = 0;\n\t\tlet concurrentResolves = 0;\n\t\tcompiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n\t\t\tsnapshotOptions = compilation.options.snapshot.resolve;\n\t\t\tfileSystemInfo = compilation.fileSystemInfo;\n\t\t\tcompilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n\t\t\t\tif (realResolves + cachedResolves > 0) {\n\t\t\t\t\tconst logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t(100 * realResolves) / (realResolves + cachedResolves)\n\t\t\t\t\t\t)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`\n\t\t\t\t\t);\n\t\t\t\t\trealResolves = 0;\n\t\t\t\t\tcachedResolves = 0;\n\t\t\t\t\tcacheInvalidResolves = 0;\n\t\t\t\t\tconcurrentResolves = 0;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t/**\n\t\t * @param {ItemCacheFacade} itemCache cache\n\t\t * @param {Resolver} resolver the resolver\n\t\t * @param {Object} resolveContext context for resolving meta info\n\t\t * @param {Object} request the request info object\n\t\t * @param {function((Error | null)=, Object=): void} callback callback function\n\t\t * @returns {void}\n\t\t */\n\t\tconst doRealResolve = (\n\t\t\titemCache,\n\t\t\tresolver,\n\t\t\tresolveContext,\n\t\t\trequest,\n\t\t\tcallback\n\t\t) => {\n\t\t\trealResolves++;\n\t\t\tconst newRequest = {\n\t\t\t\t_ResolverCachePluginCacheMiss: true,\n\t\t\t\t...request\n\t\t\t};\n\t\t\tconst newResolveContext = {\n\t\t\t\t...resolveContext,\n\t\t\t\tstack: new Set(),\n\t\t\t\t/** @type {LazySet<string>} */\n\t\t\t\tmissingDependencies: new LazySet(),\n\t\t\t\t/** @type {LazySet<string>} */\n\t\t\t\tfileDependencies: new LazySet(),\n\t\t\t\t/** @type {LazySet<string>} */\n\t\t\t\tcontextDependencies: new LazySet()\n\t\t\t};\n\t\t\tlet yieldResult;\n\t\t\tlet withYield = false;\n\t\t\tif (typeof newResolveContext.yield === \"function\") {\n\t\t\t\tyieldResult = [];\n\t\t\t\twithYield = true;\n\t\t\t\tnewResolveContext.yield = obj => yieldResult.push(obj);\n\t\t\t}\n\t\t\tconst propagate = key => {\n\t\t\t\tif (resolveContext[key]) {\n\t\t\t\t\taddAllToSet(resolveContext[key], newResolveContext[key]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst resolveTime = Date.now();\n\t\t\tresolver.doResolve(\n\t\t\t\tresolver.hooks.resolve,\n\t\t\t\tnewRequest,\n\t\t\t\t\"Cache miss\",\n\t\t\t\tnewResolveContext,\n\t\t\t\t(err, result) => {\n\t\t\t\t\tpropagate(\"fileDependencies\");\n\t\t\t\t\tpropagate(\"contextDependencies\");\n\t\t\t\t\tpropagate(\"missingDependencies\");\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst fileDependencies = newResolveContext.fileDependencies;\n\t\t\t\t\tconst contextDependencies = newResolveContext.contextDependencies;\n\t\t\t\t\tconst missingDependencies = newResolveContext.missingDependencies;\n\t\t\t\t\tfileSystemInfo.createSnapshot(\n\t\t\t\t\t\tresolveTime,\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tsnapshotOptions,\n\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resolveResult = withYield ? yieldResult : result;\n\t\t\t\t\t\t\t// since we intercept resolve hook\n\t\t\t\t\t\t\t// we still can get result in callback\n\t\t\t\t\t\t\tif (withYield && result) yieldResult.push(result);\n\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemCache.store(\n\t\t\t\t\t\t\t\tnew CacheEntry(resolveResult, snapshot),\n\t\t\t\t\t\t\t\tstoreErr => {\n\t\t\t\t\t\t\t\t\tif (storeErr) return callback(storeErr);\n\t\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\t\tcompiler.resolverFactory.hooks.resolver.intercept({\n\t\t\tfactory(type, hook) {\n\t\t\t\t/** @type {Map<string, (function(Error=, Object=): void)[]>} */\n\t\t\t\tconst activeRequests = new Map();\n\t\t\t\t/** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n\t\t\t\tconst activeRequestsWithYield = new Map();\n\t\t\t\thook.tap(\n\t\t\t\t\t\"ResolverCachePlugin\",\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Resolver} resolver the resolver\n\t\t\t\t\t * @param {Object} options resolve options\n\t\t\t\t\t * @param {Object} userOptions resolve options passed by the user\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(resolver, options, userOptions) => {\n\t\t\t\t\t\tif (options.cache !== true) return;\n\t\t\t\t\t\tconst optionsIdent = objectToString(userOptions, false);\n\t\t\t\t\t\tconst cacheWithContext =\n\t\t\t\t\t\t\toptions.cacheWithContext !== undefined\n\t\t\t\t\t\t\t\t? options.cacheWithContext\n\t\t\t\t\t\t\t\t: false;\n\t\t\t\t\t\tresolver.hooks.resolve.tapAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"ResolverCachePlugin\",\n\t\t\t\t\t\t\t\tstage: -100\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\t\t\t\tif (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst withYield = typeof resolveContext.yield === \"function\";\n\t\t\t\t\t\t\t\tconst identifier = `${type}${\n\t\t\t\t\t\t\t\t\twithYield ? \"|yield\" : \"|default\"\n\t\t\t\t\t\t\t\t}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n\n\t\t\t\t\t\t\t\tif (withYield) {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequestsWithYield.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest[0].push(callback);\n\t\t\t\t\t\t\t\t\t\tactiveRequest[1].push(resolveContext.yield);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequests.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest.push(callback);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst itemCache = cache.getItemCache(identifier, null);\n\t\t\t\t\t\t\t\tlet callbacks, yields;\n\t\t\t\t\t\t\t\tconst done = withYield\n\t\t\t\t\t\t\t\t\t? (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (result)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const r of result) resolveContext.yield(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const cb of callbacks) cb(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst cb = callbacks[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst yield_ = yields[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (result) for (const r of result) yield_(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t: (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequests.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Error=} err error if any\n\t\t\t\t\t\t\t\t * @param {CacheEntry=} cacheEntry cache entry\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processCacheResult = (err, cacheEntry) => {\n\t\t\t\t\t\t\t\t\tif (err) return done(err);\n\n\t\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\t\tconst { snapshot, result } = cacheEntry;\n\t\t\t\t\t\t\t\t\t\tfileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err || !valid) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcacheInvalidResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn doRealResolve(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcachedResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.missingDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getMissingIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.fileDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getFileIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.contextDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getContextIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdone(null, result);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdoRealResolve(\n\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\titemCache.get(processCacheResult);\n\t\t\t\t\t\t\t\tif (withYield && callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tyields = [resolveContext.yield];\n\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.set(\n\t\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\t\t/** @type {[any, any]} */ ([callbacks, yields])\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tactiveRequests.set(identifier, callbacks);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\treturn hook;\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = ResolverCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}