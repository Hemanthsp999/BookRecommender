{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst makeSerializable = require(\"./makeSerializable.js\");\n\n/**\n * @template T\n * @param {Set<T>} targetSet set where items should be added\n * @param {Set<Iterable<T>>} toMerge iterables to be merged\n * @returns {void}\n */\nconst merge = (targetSet, toMerge) => {\n  for (const set of toMerge) {\n    for (const item of set) {\n      targetSet.add(item);\n    }\n  }\n};\n\n/**\n * @template T\n * @param {Set<Iterable<T>>} targetSet set where iterables should be added\n * @param {Array<LazySet<T>>} toDeepMerge lazy sets to be flattened\n * @returns {void}\n */\nconst flatten = (targetSet, toDeepMerge) => {\n  for (const set of toDeepMerge) {\n    if (set._set.size > 0) targetSet.add(set._set);\n    if (set._needMerge) {\n      for (const mergedSet of set._toMerge) {\n        targetSet.add(mergedSet);\n      }\n      flatten(targetSet, set._toDeepMerge);\n    }\n  }\n};\n\n/**\n * Like Set but with an addAll method to eventually add items from another iterable.\n * Access methods make sure that all delayed operations are executed.\n * Iteration methods deopts to normal Set performance until clear is called again (because of the chance of modifications during iteration).\n * @template T\n */\nclass LazySet {\n  /**\n   * @param {Iterable<T>=} iterable init iterable\n   */\n  constructor(iterable) {\n    /** @type {Set<T>} */\n    this._set = new Set(iterable);\n    /** @type {Set<Iterable<T>>} */\n    this._toMerge = new Set();\n    /** @type {Array<LazySet<T>>} */\n    this._toDeepMerge = [];\n    this._needMerge = false;\n    this._deopt = false;\n  }\n  _flatten() {\n    flatten(this._toMerge, this._toDeepMerge);\n    this._toDeepMerge.length = 0;\n  }\n  _merge() {\n    this._flatten();\n    merge(this._set, this._toMerge);\n    this._toMerge.clear();\n    this._needMerge = false;\n  }\n  _isEmpty() {\n    return this._set.size === 0 && this._toMerge.size === 0 && this._toDeepMerge.length === 0;\n  }\n  get size() {\n    if (this._needMerge) this._merge();\n    return this._set.size;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {LazySet<T>} itself\n   */\n  add(item) {\n    this._set.add(item);\n    return this;\n  }\n\n  /**\n   * @param {Iterable<T> | LazySet<T>} iterable a immutable iterable or another immutable LazySet which will eventually be merged into the Set\n   * @returns {LazySet<T>} itself\n   */\n  addAll(iterable) {\n    if (this._deopt) {\n      const _set = this._set;\n      for (const item of iterable) {\n        _set.add(item);\n      }\n    } else {\n      if (iterable instanceof LazySet) {\n        if (iterable._isEmpty()) return this;\n        this._toDeepMerge.push(iterable);\n        this._needMerge = true;\n        if (this._toDeepMerge.length > 100000) {\n          this._flatten();\n        }\n      } else {\n        this._toMerge.add(iterable);\n        this._needMerge = true;\n      }\n      if (this._toMerge.size > 100000) this._merge();\n    }\n    return this;\n  }\n  clear() {\n    this._set.clear();\n    this._toMerge.clear();\n    this._toDeepMerge.length = 0;\n    this._needMerge = false;\n    this._deopt = false;\n  }\n\n  /**\n   * @param {T} value an item\n   * @returns {boolean} true, if the value was in the Set before\n   */\n  delete(value) {\n    if (this._needMerge) this._merge();\n    return this._set.delete(value);\n  }\n  entries() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.entries();\n  }\n\n  /**\n   * @param {function(T, T, Set<T>): void} callbackFn function called for each entry\n   * @param {any} thisArg this argument for the callbackFn\n   * @returns {void}\n   */\n  forEach(callbackFn, thisArg) {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    this._set.forEach(callbackFn, thisArg);\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, when the item is in the Set\n   */\n  has(item) {\n    if (this._needMerge) this._merge();\n    return this._set.has(item);\n  }\n  keys() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.keys();\n  }\n  values() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set.values();\n  }\n  [Symbol.iterator]() {\n    this._deopt = true;\n    if (this._needMerge) this._merge();\n    return this._set[Symbol.iterator]();\n  }\n\n  /* istanbul ignore next */\n  get [Symbol.toStringTag]() {\n    return \"LazySet\";\n  }\n\n  /**\n   * @param {import(\"../serialization/ObjectMiddleware\").ObjectSerializerContext} context context\n   */\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    if (this._needMerge) this._merge();\n    write(this._set.size);\n    for (const item of this._set) write(item);\n  }\n\n  /**\n   * @template T\n   * @param {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} context context\n   * @returns {LazySet<T>} lazy set\n   */\n  static deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    const count = read();\n    const items = [];\n    for (let i = 0; i < count; i++) {\n      items.push(read());\n    }\n    return new LazySet(items);\n  }\n}\nmakeSerializable(LazySet, \"webpack/lib/util/LazySet\");\nmodule.exports = LazySet;","map":{"version":3,"names":["makeSerializable","require","merge","targetSet","toMerge","set","item","add","flatten","toDeepMerge","_set","size","_needMerge","mergedSet","_toMerge","_toDeepMerge","LazySet","constructor","iterable","Set","_deopt","_flatten","length","_merge","clear","_isEmpty","addAll","push","delete","value","entries","forEach","callbackFn","thisArg","has","keys","values","Symbol","iterator","toStringTag","serialize","_ref","write","deserialize","_ref2","read","count","items","i","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/LazySet.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst makeSerializable = require(\"./makeSerializable.js\");\n\n/**\n * @template T\n * @param {Set<T>} targetSet set where items should be added\n * @param {Set<Iterable<T>>} toMerge iterables to be merged\n * @returns {void}\n */\nconst merge = (targetSet, toMerge) => {\n\tfor (const set of toMerge) {\n\t\tfor (const item of set) {\n\t\t\ttargetSet.add(item);\n\t\t}\n\t}\n};\n\n/**\n * @template T\n * @param {Set<Iterable<T>>} targetSet set where iterables should be added\n * @param {Array<LazySet<T>>} toDeepMerge lazy sets to be flattened\n * @returns {void}\n */\nconst flatten = (targetSet, toDeepMerge) => {\n\tfor (const set of toDeepMerge) {\n\t\tif (set._set.size > 0) targetSet.add(set._set);\n\t\tif (set._needMerge) {\n\t\t\tfor (const mergedSet of set._toMerge) {\n\t\t\t\ttargetSet.add(mergedSet);\n\t\t\t}\n\t\t\tflatten(targetSet, set._toDeepMerge);\n\t\t}\n\t}\n};\n\n/**\n * Like Set but with an addAll method to eventually add items from another iterable.\n * Access methods make sure that all delayed operations are executed.\n * Iteration methods deopts to normal Set performance until clear is called again (because of the chance of modifications during iteration).\n * @template T\n */\nclass LazySet {\n\t/**\n\t * @param {Iterable<T>=} iterable init iterable\n\t */\n\tconstructor(iterable) {\n\t\t/** @type {Set<T>} */\n\t\tthis._set = new Set(iterable);\n\t\t/** @type {Set<Iterable<T>>} */\n\t\tthis._toMerge = new Set();\n\t\t/** @type {Array<LazySet<T>>} */\n\t\tthis._toDeepMerge = [];\n\t\tthis._needMerge = false;\n\t\tthis._deopt = false;\n\t}\n\n\t_flatten() {\n\t\tflatten(this._toMerge, this._toDeepMerge);\n\t\tthis._toDeepMerge.length = 0;\n\t}\n\n\t_merge() {\n\t\tthis._flatten();\n\t\tmerge(this._set, this._toMerge);\n\t\tthis._toMerge.clear();\n\t\tthis._needMerge = false;\n\t}\n\n\t_isEmpty() {\n\t\treturn (\n\t\t\tthis._set.size === 0 &&\n\t\t\tthis._toMerge.size === 0 &&\n\t\t\tthis._toDeepMerge.length === 0\n\t\t);\n\t}\n\n\tget size() {\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.size;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {LazySet<T>} itself\n\t */\n\tadd(item) {\n\t\tthis._set.add(item);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {Iterable<T> | LazySet<T>} iterable a immutable iterable or another immutable LazySet which will eventually be merged into the Set\n\t * @returns {LazySet<T>} itself\n\t */\n\taddAll(iterable) {\n\t\tif (this._deopt) {\n\t\t\tconst _set = this._set;\n\t\t\tfor (const item of iterable) {\n\t\t\t\t_set.add(item);\n\t\t\t}\n\t\t} else {\n\t\t\tif (iterable instanceof LazySet) {\n\t\t\t\tif (iterable._isEmpty()) return this;\n\t\t\t\tthis._toDeepMerge.push(iterable);\n\t\t\t\tthis._needMerge = true;\n\t\t\t\tif (this._toDeepMerge.length > 100000) {\n\t\t\t\t\tthis._flatten();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._toMerge.add(iterable);\n\t\t\t\tthis._needMerge = true;\n\t\t\t}\n\t\t\tif (this._toMerge.size > 100000) this._merge();\n\t\t}\n\t\treturn this;\n\t}\n\n\tclear() {\n\t\tthis._set.clear();\n\t\tthis._toMerge.clear();\n\t\tthis._toDeepMerge.length = 0;\n\t\tthis._needMerge = false;\n\t\tthis._deopt = false;\n\t}\n\n\t/**\n\t * @param {T} value an item\n\t * @returns {boolean} true, if the value was in the Set before\n\t */\n\tdelete(value) {\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.delete(value);\n\t}\n\n\tentries() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.entries();\n\t}\n\n\t/**\n\t * @param {function(T, T, Set<T>): void} callbackFn function called for each entry\n\t * @param {any} thisArg this argument for the callbackFn\n\t * @returns {void}\n\t */\n\tforEach(callbackFn, thisArg) {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\tthis._set.forEach(callbackFn, thisArg);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, when the item is in the Set\n\t */\n\thas(item) {\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.has(item);\n\t}\n\n\tkeys() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.keys();\n\t}\n\n\tvalues() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set.values();\n\t}\n\n\t[Symbol.iterator]() {\n\t\tthis._deopt = true;\n\t\tif (this._needMerge) this._merge();\n\t\treturn this._set[Symbol.iterator]();\n\t}\n\n\t/* istanbul ignore next */\n\tget [Symbol.toStringTag]() {\n\t\treturn \"LazySet\";\n\t}\n\n\t/**\n\t * @param {import(\"../serialization/ObjectMiddleware\").ObjectSerializerContext} context context\n\t */\n\tserialize({ write }) {\n\t\tif (this._needMerge) this._merge();\n\t\twrite(this._set.size);\n\t\tfor (const item of this._set) write(item);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} context context\n\t * @returns {LazySet<T>} lazy set\n\t */\n\tstatic deserialize({ read }) {\n\t\tconst count = read();\n\t\tconst items = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\titems.push(read());\n\t\t}\n\t\treturn new LazySet(items);\n\t}\n}\n\nmakeSerializable(LazySet, \"webpack/lib/util/LazySet\");\n\nmodule.exports = LazySet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}