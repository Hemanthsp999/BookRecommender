{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\nconst deprecateContext = util.deprecate(() => {}, \"Hook.context is deprecated and will be removed\");\nconst CALL_DELEGATE = function () {\n  this.call = this._createCall(\"sync\");\n  return this.call(...arguments);\n};\nconst CALL_ASYNC_DELEGATE = function () {\n  this.callAsync = this._createCall(\"async\");\n  return this.callAsync(...arguments);\n};\nconst PROMISE_DELEGATE = function () {\n  this.promise = this._createCall(\"promise\");\n  return this.promise(...arguments);\n};\nclass Hook {\n  constructor() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    this._args = args;\n    this.name = name;\n    this.taps = [];\n    this.interceptors = [];\n    this._call = CALL_DELEGATE;\n    this.call = CALL_DELEGATE;\n    this._callAsync = CALL_ASYNC_DELEGATE;\n    this.callAsync = CALL_ASYNC_DELEGATE;\n    this._promise = PROMISE_DELEGATE;\n    this.promise = PROMISE_DELEGATE;\n    this._x = undefined;\n    this.compile = this.compile;\n    this.tap = this.tap;\n    this.tapAsync = this.tapAsync;\n    this.tapPromise = this.tapPromise;\n  }\n  compile(options) {\n    throw new Error(\"Abstract: should be overridden\");\n  }\n  _createCall(type) {\n    return this.compile({\n      taps: this.taps,\n      interceptors: this.interceptors,\n      args: this._args,\n      type: type\n    });\n  }\n  _tap(type, options, fn) {\n    if (typeof options === \"string\") {\n      options = {\n        name: options.trim()\n      };\n    } else if (typeof options !== \"object\" || options === null) {\n      throw new Error(\"Invalid tap options\");\n    }\n    if (typeof options.name !== \"string\" || options.name === \"\") {\n      throw new Error(\"Missing name for tap\");\n    }\n    if (typeof options.context !== \"undefined\") {\n      deprecateContext();\n    }\n    options = Object.assign({\n      type,\n      fn\n    }, options);\n    options = this._runRegisterInterceptors(options);\n    this._insert(options);\n  }\n  tap(options, fn) {\n    this._tap(\"sync\", options, fn);\n  }\n  tapAsync(options, fn) {\n    this._tap(\"async\", options, fn);\n  }\n  tapPromise(options, fn) {\n    this._tap(\"promise\", options, fn);\n  }\n  _runRegisterInterceptors(options) {\n    for (const interceptor of this.interceptors) {\n      if (interceptor.register) {\n        const newOptions = interceptor.register(options);\n        if (newOptions !== undefined) {\n          options = newOptions;\n        }\n      }\n    }\n    return options;\n  }\n  withOptions(options) {\n    const mergeOptions = opt => Object.assign({}, options, typeof opt === \"string\" ? {\n      name: opt\n    } : opt);\n    return {\n      name: this.name,\n      tap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n      tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n      tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n      intercept: interceptor => this.intercept(interceptor),\n      isUsed: () => this.isUsed(),\n      withOptions: opt => this.withOptions(mergeOptions(opt))\n    };\n  }\n  isUsed() {\n    return this.taps.length > 0 || this.interceptors.length > 0;\n  }\n  intercept(interceptor) {\n    this._resetCompilation();\n    this.interceptors.push(Object.assign({}, interceptor));\n    if (interceptor.register) {\n      for (let i = 0; i < this.taps.length; i++) {\n        this.taps[i] = interceptor.register(this.taps[i]);\n      }\n    }\n  }\n  _resetCompilation() {\n    this.call = this._call;\n    this.callAsync = this._callAsync;\n    this.promise = this._promise;\n  }\n  _insert(item) {\n    this._resetCompilation();\n    let before;\n    if (typeof item.before === \"string\") {\n      before = new Set([item.before]);\n    } else if (Array.isArray(item.before)) {\n      before = new Set(item.before);\n    }\n    let stage = 0;\n    if (typeof item.stage === \"number\") {\n      stage = item.stage;\n    }\n    let i = this.taps.length;\n    while (i > 0) {\n      i--;\n      const x = this.taps[i];\n      this.taps[i + 1] = x;\n      const xStage = x.stage || 0;\n      if (before) {\n        if (before.has(x.name)) {\n          before.delete(x.name);\n          continue;\n        }\n        if (before.size > 0) {\n          continue;\n        }\n      }\n      if (xStage > stage) {\n        continue;\n      }\n      i++;\n      break;\n    }\n    this.taps[i] = item;\n  }\n}\nObject.setPrototypeOf(Hook.prototype, null);\nmodule.exports = Hook;","map":{"version":3,"names":["util","require","deprecateContext","deprecate","CALL_DELEGATE","call","_createCall","arguments","CALL_ASYNC_DELEGATE","callAsync","PROMISE_DELEGATE","promise","Hook","constructor","args","length","undefined","name","_args","taps","interceptors","_call","_callAsync","_promise","_x","compile","tap","tapAsync","tapPromise","options","Error","type","_tap","fn","trim","context","Object","assign","_runRegisterInterceptors","_insert","interceptor","register","newOptions","withOptions","mergeOptions","opt","intercept","isUsed","_resetCompilation","push","i","item","before","Set","Array","isArray","stage","x","xStage","has","delete","size","setPrototypeOf","prototype","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/tapable/lib/Hook.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst deprecateContext = util.deprecate(() => {},\n\"Hook.context is deprecated and will be removed\");\n\nconst CALL_DELEGATE = function(...args) {\n\tthis.call = this._createCall(\"sync\");\n\treturn this.call(...args);\n};\nconst CALL_ASYNC_DELEGATE = function(...args) {\n\tthis.callAsync = this._createCall(\"async\");\n\treturn this.callAsync(...args);\n};\nconst PROMISE_DELEGATE = function(...args) {\n\tthis.promise = this._createCall(\"promise\");\n\treturn this.promise(...args);\n};\n\nclass Hook {\n\tconstructor(args = [], name = undefined) {\n\t\tthis._args = args;\n\t\tthis.name = name;\n\t\tthis.taps = [];\n\t\tthis.interceptors = [];\n\t\tthis._call = CALL_DELEGATE;\n\t\tthis.call = CALL_DELEGATE;\n\t\tthis._callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis.callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis._promise = PROMISE_DELEGATE;\n\t\tthis.promise = PROMISE_DELEGATE;\n\t\tthis._x = undefined;\n\n\t\tthis.compile = this.compile;\n\t\tthis.tap = this.tap;\n\t\tthis.tapAsync = this.tapAsync;\n\t\tthis.tapPromise = this.tapPromise;\n\t}\n\n\tcompile(options) {\n\t\tthrow new Error(\"Abstract: should be overridden\");\n\t}\n\n\t_createCall(type) {\n\t\treturn this.compile({\n\t\t\ttaps: this.taps,\n\t\t\tinterceptors: this.interceptors,\n\t\t\targs: this._args,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\t_tap(type, options, fn) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = {\n\t\t\t\tname: options.trim()\n\t\t\t};\n\t\t} else if (typeof options !== \"object\" || options === null) {\n\t\t\tthrow new Error(\"Invalid tap options\");\n\t\t}\n\t\tif (typeof options.name !== \"string\" || options.name === \"\") {\n\t\t\tthrow new Error(\"Missing name for tap\");\n\t\t}\n\t\tif (typeof options.context !== \"undefined\") {\n\t\t\tdeprecateContext();\n\t\t}\n\t\toptions = Object.assign({ type, fn }, options);\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttap(options, fn) {\n\t\tthis._tap(\"sync\", options, fn);\n\t}\n\n\ttapAsync(options, fn) {\n\t\tthis._tap(\"async\", options, fn);\n\t}\n\n\ttapPromise(options, fn) {\n\t\tthis._tap(\"promise\", options, fn);\n\t}\n\n\t_runRegisterInterceptors(options) {\n\t\tfor (const interceptor of this.interceptors) {\n\t\t\tif (interceptor.register) {\n\t\t\t\tconst newOptions = interceptor.register(options);\n\t\t\t\tif (newOptions !== undefined) {\n\t\t\t\t\toptions = newOptions;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\twithOptions(options) {\n\t\tconst mergeOptions = opt =>\n\t\t\tObject.assign({}, options, typeof opt === \"string\" ? { name: opt } : opt);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\ttap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n\t\t\ttapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n\t\t\ttapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n\t\t\tintercept: interceptor => this.intercept(interceptor),\n\t\t\tisUsed: () => this.isUsed(),\n\t\t\twithOptions: opt => this.withOptions(mergeOptions(opt))\n\t\t};\n\t}\n\n\tisUsed() {\n\t\treturn this.taps.length > 0 || this.interceptors.length > 0;\n\t}\n\n\tintercept(interceptor) {\n\t\tthis._resetCompilation();\n\t\tthis.interceptors.push(Object.assign({}, interceptor));\n\t\tif (interceptor.register) {\n\t\t\tfor (let i = 0; i < this.taps.length; i++) {\n\t\t\t\tthis.taps[i] = interceptor.register(this.taps[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t_resetCompilation() {\n\t\tthis.call = this._call;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis.promise = this._promise;\n\t}\n\n\t_insert(item) {\n\t\tthis._resetCompilation();\n\t\tlet before;\n\t\tif (typeof item.before === \"string\") {\n\t\t\tbefore = new Set([item.before]);\n\t\t} else if (Array.isArray(item.before)) {\n\t\t\tbefore = new Set(item.before);\n\t\t}\n\t\tlet stage = 0;\n\t\tif (typeof item.stage === \"number\") {\n\t\t\tstage = item.stage;\n\t\t}\n\t\tlet i = this.taps.length;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tconst x = this.taps[i];\n\t\t\tthis.taps[i + 1] = x;\n\t\t\tconst xStage = x.stage || 0;\n\t\t\tif (before) {\n\t\t\t\tif (before.has(x.name)) {\n\t\t\t\t\tbefore.delete(x.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (before.size > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xStage > stage) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tthis.taps[i] = item;\n\t}\n}\n\nObject.setPrototypeOf(Hook.prototype, null);\n\nmodule.exports = Hook;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAE5B,MAAMC,gBAAgB,GAAGF,IAAI,CAACG,SAAS,CAAC,MAAM,CAAC,CAAC,EAChD,gDAAgD,CAAC;AAEjD,MAAMC,aAAa,GAAG,SAAAA,CAAA,EAAkB;EACvC,IAAI,CAACC,IAAI,GAAG,IAAI,CAACC,WAAW,CAAC,MAAM,CAAC;EACpC,OAAO,IAAI,CAACD,IAAI,CAAC,GAAAE,SAAO,CAAC;AAC1B,CAAC;AACD,MAAMC,mBAAmB,GAAG,SAAAA,CAAA,EAAkB;EAC7C,IAAI,CAACC,SAAS,GAAG,IAAI,CAACH,WAAW,CAAC,OAAO,CAAC;EAC1C,OAAO,IAAI,CAACG,SAAS,CAAC,GAAAF,SAAO,CAAC;AAC/B,CAAC;AACD,MAAMG,gBAAgB,GAAG,SAAAA,CAAA,EAAkB;EAC1C,IAAI,CAACC,OAAO,GAAG,IAAI,CAACL,WAAW,CAAC,SAAS,CAAC;EAC1C,OAAO,IAAI,CAACK,OAAO,CAAC,GAAAJ,SAAO,CAAC;AAC7B,CAAC;AAED,MAAMK,IAAI,CAAC;EACVC,WAAWA,CAAA,EAA8B;IAAA,IAA7BC,IAAI,GAAAP,SAAA,CAAAQ,MAAA,QAAAR,SAAA,QAAAS,SAAA,GAAAT,SAAA,MAAG,EAAE;IAAA,IAAEU,IAAI,GAAAV,SAAA,CAAAQ,MAAA,QAAAR,SAAA,QAAAS,SAAA,GAAAT,SAAA,MAAGS,SAAS;IACtC,IAAI,CAACE,KAAK,GAAGJ,IAAI;IACjB,IAAI,CAACG,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACE,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,KAAK,GAAGjB,aAAa;IAC1B,IAAI,CAACC,IAAI,GAAGD,aAAa;IACzB,IAAI,CAACkB,UAAU,GAAGd,mBAAmB;IACrC,IAAI,CAACC,SAAS,GAAGD,mBAAmB;IACpC,IAAI,CAACe,QAAQ,GAAGb,gBAAgB;IAChC,IAAI,CAACC,OAAO,GAAGD,gBAAgB;IAC/B,IAAI,CAACc,EAAE,GAAGR,SAAS;IAEnB,IAAI,CAACS,OAAO,GAAG,IAAI,CAACA,OAAO;IAC3B,IAAI,CAACC,GAAG,GAAG,IAAI,CAACA,GAAG;IACnB,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC7B,IAAI,CAACC,UAAU,GAAG,IAAI,CAACA,UAAU;EAClC;EAEAH,OAAOA,CAACI,OAAO,EAAE;IAChB,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;EAClD;EAEAxB,WAAWA,CAACyB,IAAI,EAAE;IACjB,OAAO,IAAI,CAACN,OAAO,CAAC;MACnBN,IAAI,EAAE,IAAI,CAACA,IAAI;MACfC,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BN,IAAI,EAAE,IAAI,CAACI,KAAK;MAChBa,IAAI,EAAEA;IACP,CAAC,CAAC;EACH;EAEAC,IAAIA,CAACD,IAAI,EAAEF,OAAO,EAAEI,EAAE,EAAE;IACvB,IAAI,OAAOJ,OAAO,KAAK,QAAQ,EAAE;MAChCA,OAAO,GAAG;QACTZ,IAAI,EAAEY,OAAO,CAACK,IAAI,CAAC;MACpB,CAAC;IACF,CAAC,MAAM,IAAI,OAAOL,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EAAE;MAC3D,MAAM,IAAIC,KAAK,CAAC,qBAAqB,CAAC;IACvC;IACA,IAAI,OAAOD,OAAO,CAACZ,IAAI,KAAK,QAAQ,IAAIY,OAAO,CAACZ,IAAI,KAAK,EAAE,EAAE;MAC5D,MAAM,IAAIa,KAAK,CAAC,sBAAsB,CAAC;IACxC;IACA,IAAI,OAAOD,OAAO,CAACM,OAAO,KAAK,WAAW,EAAE;MAC3CjC,gBAAgB,CAAC,CAAC;IACnB;IACA2B,OAAO,GAAGO,MAAM,CAACC,MAAM,CAAC;MAAEN,IAAI;MAAEE;IAAG,CAAC,EAAEJ,OAAO,CAAC;IAC9CA,OAAO,GAAG,IAAI,CAACS,wBAAwB,CAACT,OAAO,CAAC;IAChD,IAAI,CAACU,OAAO,CAACV,OAAO,CAAC;EACtB;EAEAH,GAAGA,CAACG,OAAO,EAAEI,EAAE,EAAE;IAChB,IAAI,CAACD,IAAI,CAAC,MAAM,EAAEH,OAAO,EAAEI,EAAE,CAAC;EAC/B;EAEAN,QAAQA,CAACE,OAAO,EAAEI,EAAE,EAAE;IACrB,IAAI,CAACD,IAAI,CAAC,OAAO,EAAEH,OAAO,EAAEI,EAAE,CAAC;EAChC;EAEAL,UAAUA,CAACC,OAAO,EAAEI,EAAE,EAAE;IACvB,IAAI,CAACD,IAAI,CAAC,SAAS,EAAEH,OAAO,EAAEI,EAAE,CAAC;EAClC;EAEAK,wBAAwBA,CAACT,OAAO,EAAE;IACjC,KAAK,MAAMW,WAAW,IAAI,IAAI,CAACpB,YAAY,EAAE;MAC5C,IAAIoB,WAAW,CAACC,QAAQ,EAAE;QACzB,MAAMC,UAAU,GAAGF,WAAW,CAACC,QAAQ,CAACZ,OAAO,CAAC;QAChD,IAAIa,UAAU,KAAK1B,SAAS,EAAE;UAC7Ba,OAAO,GAAGa,UAAU;QACrB;MACD;IACD;IACA,OAAOb,OAAO;EACf;EAEAc,WAAWA,CAACd,OAAO,EAAE;IACpB,MAAMe,YAAY,GAAGC,GAAG,IACvBT,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAER,OAAO,EAAE,OAAOgB,GAAG,KAAK,QAAQ,GAAG;MAAE5B,IAAI,EAAE4B;IAAI,CAAC,GAAGA,GAAG,CAAC;IAE1E,OAAO;MACN5B,IAAI,EAAE,IAAI,CAACA,IAAI;MACfS,GAAG,EAAEA,CAACmB,GAAG,EAAEZ,EAAE,KAAK,IAAI,CAACP,GAAG,CAACkB,YAAY,CAACC,GAAG,CAAC,EAAEZ,EAAE,CAAC;MACjDN,QAAQ,EAAEA,CAACkB,GAAG,EAAEZ,EAAE,KAAK,IAAI,CAACN,QAAQ,CAACiB,YAAY,CAACC,GAAG,CAAC,EAAEZ,EAAE,CAAC;MAC3DL,UAAU,EAAEA,CAACiB,GAAG,EAAEZ,EAAE,KAAK,IAAI,CAACL,UAAU,CAACgB,YAAY,CAACC,GAAG,CAAC,EAAEZ,EAAE,CAAC;MAC/Da,SAAS,EAAEN,WAAW,IAAI,IAAI,CAACM,SAAS,CAACN,WAAW,CAAC;MACrDO,MAAM,EAAEA,CAAA,KAAM,IAAI,CAACA,MAAM,CAAC,CAAC;MAC3BJ,WAAW,EAAEE,GAAG,IAAI,IAAI,CAACF,WAAW,CAACC,YAAY,CAACC,GAAG,CAAC;IACvD,CAAC;EACF;EAEAE,MAAMA,CAAA,EAAG;IACR,OAAO,IAAI,CAAC5B,IAAI,CAACJ,MAAM,GAAG,CAAC,IAAI,IAAI,CAACK,YAAY,CAACL,MAAM,GAAG,CAAC;EAC5D;EAEA+B,SAASA,CAACN,WAAW,EAAE;IACtB,IAAI,CAACQ,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAAC5B,YAAY,CAAC6B,IAAI,CAACb,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEG,WAAW,CAAC,CAAC;IACtD,IAAIA,WAAW,CAACC,QAAQ,EAAE;MACzB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC/B,IAAI,CAACJ,MAAM,EAAEmC,CAAC,EAAE,EAAE;QAC1C,IAAI,CAAC/B,IAAI,CAAC+B,CAAC,CAAC,GAAGV,WAAW,CAACC,QAAQ,CAAC,IAAI,CAACtB,IAAI,CAAC+B,CAAC,CAAC,CAAC;MAClD;IACD;EACD;EAEAF,iBAAiBA,CAAA,EAAG;IACnB,IAAI,CAAC3C,IAAI,GAAG,IAAI,CAACgB,KAAK;IACtB,IAAI,CAACZ,SAAS,GAAG,IAAI,CAACa,UAAU;IAChC,IAAI,CAACX,OAAO,GAAG,IAAI,CAACY,QAAQ;EAC7B;EAEAgB,OAAOA,CAACY,IAAI,EAAE;IACb,IAAI,CAACH,iBAAiB,CAAC,CAAC;IACxB,IAAII,MAAM;IACV,IAAI,OAAOD,IAAI,CAACC,MAAM,KAAK,QAAQ,EAAE;MACpCA,MAAM,GAAG,IAAIC,GAAG,CAAC,CAACF,IAAI,CAACC,MAAM,CAAC,CAAC;IAChC,CAAC,MAAM,IAAIE,KAAK,CAACC,OAAO,CAACJ,IAAI,CAACC,MAAM,CAAC,EAAE;MACtCA,MAAM,GAAG,IAAIC,GAAG,CAACF,IAAI,CAACC,MAAM,CAAC;IAC9B;IACA,IAAII,KAAK,GAAG,CAAC;IACb,IAAI,OAAOL,IAAI,CAACK,KAAK,KAAK,QAAQ,EAAE;MACnCA,KAAK,GAAGL,IAAI,CAACK,KAAK;IACnB;IACA,IAAIN,CAAC,GAAG,IAAI,CAAC/B,IAAI,CAACJ,MAAM;IACxB,OAAOmC,CAAC,GAAG,CAAC,EAAE;MACbA,CAAC,EAAE;MACH,MAAMO,CAAC,GAAG,IAAI,CAACtC,IAAI,CAAC+B,CAAC,CAAC;MACtB,IAAI,CAAC/B,IAAI,CAAC+B,CAAC,GAAG,CAAC,CAAC,GAAGO,CAAC;MACpB,MAAMC,MAAM,GAAGD,CAAC,CAACD,KAAK,IAAI,CAAC;MAC3B,IAAIJ,MAAM,EAAE;QACX,IAAIA,MAAM,CAACO,GAAG,CAACF,CAAC,CAACxC,IAAI,CAAC,EAAE;UACvBmC,MAAM,CAACQ,MAAM,CAACH,CAAC,CAACxC,IAAI,CAAC;UACrB;QACD;QACA,IAAImC,MAAM,CAACS,IAAI,GAAG,CAAC,EAAE;UACpB;QACD;MACD;MACA,IAAIH,MAAM,GAAGF,KAAK,EAAE;QACnB;MACD;MACAN,CAAC,EAAE;MACH;IACD;IACA,IAAI,CAAC/B,IAAI,CAAC+B,CAAC,CAAC,GAAGC,IAAI;EACpB;AACD;AAEAf,MAAM,CAAC0B,cAAc,CAAClD,IAAI,CAACmD,SAAS,EAAE,IAAI,CAAC;AAE3CC,MAAM,CAACC,OAAO,GAAGrD,IAAI"},"metadata":{},"sourceType":"script","externalDependencies":[]}