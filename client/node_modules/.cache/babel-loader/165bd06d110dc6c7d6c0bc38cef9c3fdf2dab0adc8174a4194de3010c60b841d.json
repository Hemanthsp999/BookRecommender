{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst {\n  first\n} = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n  compareModulesById,\n  compareIterables,\n  compareModulesByIdentifier,\n  concatComparators,\n  compareSelect,\n  compareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n  RuntimeSpecMap,\n  RuntimeSpecSet,\n  runtimeToString,\n  mergeRuntime,\n  forEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\nconst ZERO_BIG_INT = BigInt(0);\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n  constructor(hash, renderedHash) {\n    this.hash = hash;\n    this.renderedHash = renderedHash;\n  }\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nconst getArray = set => {\n  return Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nconst getModuleRuntimes = chunks => {\n  const runtimes = new RuntimeSpecSet();\n  for (const chunk of chunks) {\n    runtimes.add(chunk.runtime);\n  }\n  return runtimes;\n};\n\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\nconst modulesBySourceType = sourceTypesByModule => set => {\n  /** @type {Map<string, SortableSet<Module>>} */\n  const map = new Map();\n  for (const module of set) {\n    const sourceTypes = sourceTypesByModule && sourceTypesByModule.get(module) || module.getSourceTypes();\n    for (const sourceType of sourceTypes) {\n      let innerSet = map.get(sourceType);\n      if (innerSet === undefined) {\n        innerSet = new SortableSet();\n        map.set(sourceType, innerSet);\n      }\n      innerSet.add(module);\n    }\n  }\n  for (const [key, innerSet] of map) {\n    // When all modules have the source type, we reuse the original SortableSet\n    // to benefit from the shared cache (especially for sorting)\n    if (innerSet.size === set.size) {\n      map.set(key, set);\n    }\n  }\n  return map;\n};\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nconst createOrderedArrayFunction = comparator => {\n  /** @type {SetToArrayFunction<T>} */\n  let fn = createOrderedArrayFunctionMap.get(comparator);\n  if (fn !== undefined) return fn;\n  fn = set => {\n    set.sortWith(comparator);\n    return Array.from(set);\n  };\n  createOrderedArrayFunctionMap.set(comparator, fn);\n  return fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = modules => {\n  let size = 0;\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      size += module.size(type);\n    }\n  }\n  return size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nconst getModulesSizes = modules => {\n  let sizes = Object.create(null);\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      sizes[type] = (sizes[type] || 0) + module.size(type);\n    }\n  }\n  return sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nconst isAvailableChunk = (a, b) => {\n  const queue = new Set(b.groupsIterable);\n  for (const chunkGroup of queue) {\n    if (a.isInGroup(chunkGroup)) continue;\n    if (chunkGroup.isInitial()) return false;\n    for (const parent of chunkGroup.parentsIterable) {\n      queue.add(parent);\n    }\n  }\n  return true;\n};\nclass ChunkGraphModule {\n  constructor() {\n    /** @type {SortableSet<Chunk>} */\n    this.chunks = new SortableSet();\n    /** @type {Set<Chunk> | undefined} */\n    this.entryInChunks = undefined;\n    /** @type {Set<Chunk> | undefined} */\n    this.runtimeInChunks = undefined;\n    /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n    this.hashes = undefined;\n    /** @type {string | number} */\n    this.id = null;\n    /** @type {RuntimeSpecMap<Set<string>> | undefined} */\n    this.runtimeRequirements = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n    this.graphHashes = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n    this.graphHashesWithConnections = undefined;\n  }\n}\nclass ChunkGraphChunk {\n  constructor() {\n    /** @type {SortableSet<Module>} */\n    this.modules = new SortableSet();\n    /** @type {WeakMap<Module, Set<string>> | undefined} */\n    this.sourceTypesByModule = undefined;\n    /** @type {Map<Module, Entrypoint>} */\n    this.entryModules = new Map();\n    /** @type {SortableSet<RuntimeModule>} */\n    this.runtimeModules = new SortableSet();\n    /** @type {Set<RuntimeModule> | undefined} */\n    this.fullHashModules = undefined;\n    /** @type {Set<RuntimeModule> | undefined} */\n    this.dependentHashModules = undefined;\n    /** @type {Set<string> | undefined} */\n    this.runtimeRequirements = undefined;\n    /** @type {Set<string>} */\n    this.runtimeRequirementsInTree = new Set();\n    this._modulesBySourceType = defaultModulesBySourceType;\n  }\n}\nclass ChunkGraph {\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor(moduleGraph) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    /** @private @type {WeakMap<Module, ChunkGraphModule>} */\n    this._modules = new WeakMap();\n    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n    this._chunks = new WeakMap();\n    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n    this._blockChunkGroups = new WeakMap();\n    /** @private @type {Map<string, string | number>} */\n    this._runtimeIds = new Map();\n    /** @type {ModuleGraph} */\n    this.moduleGraph = moduleGraph;\n    this._hashFunction = hashFunction;\n    this._getGraphRoots = this._getGraphRoots.bind(this);\n  }\n\n  /**\n   * @private\n   * @param {Module} module the module\n   * @returns {ChunkGraphModule} internal module\n   */\n  _getChunkGraphModule(module) {\n    let cgm = this._modules.get(module);\n    if (cgm === undefined) {\n      cgm = new ChunkGraphModule();\n      this._modules.set(module, cgm);\n    }\n    return cgm;\n  }\n\n  /**\n   * @private\n   * @param {Chunk} chunk the chunk\n   * @returns {ChunkGraphChunk} internal chunk\n   */\n  _getChunkGraphChunk(chunk) {\n    let cgc = this._chunks.get(chunk);\n    if (cgc === undefined) {\n      cgc = new ChunkGraphChunk();\n      this._chunks.set(chunk, cgc);\n    }\n    return cgc;\n  }\n\n  /**\n   * @param {SortableSet<Module>} set the sortable Set to get the roots of\n   * @returns {Module[]} the graph roots\n   */\n  _getGraphRoots(set) {\n    const {\n      moduleGraph\n    } = this;\n    return Array.from(findGraphRoots(set, module => {\n      /** @type {Set<Module>} */\n      const set = new Set();\n      const addDependencies = module => {\n        for (const connection of moduleGraph.getOutgoingConnections(module)) {\n          if (!connection.module) continue;\n          const activeState = connection.getActiveState(undefined);\n          if (activeState === false) continue;\n          if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n            addDependencies(connection.module);\n            continue;\n          }\n          set.add(connection.module);\n        }\n      };\n      addDependencies(module);\n      return set;\n    })).sort(compareModulesByIdentifier);\n  }\n\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n  connectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgm.chunks.add(chunk);\n    cgc.modules.add(module);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n  disconnectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgc.modules.delete(module);\n    // No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n    if (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n    cgm.chunks.delete(chunk);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk which will be disconnected\n   * @returns {void}\n   */\n  disconnectChunk(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of cgc.modules) {\n      const cgm = this._getChunkGraphModule(module);\n      cgm.chunks.delete(chunk);\n    }\n    cgc.modules.clear();\n    chunk.disconnectFromGroups();\n    ChunkGraph.clearChunkGraphForChunk(chunk);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<Module>} modules the modules\n   * @returns {void}\n   */\n  attachModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of modules) {\n      cgc.modules.add(module);\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the runtime modules\n   * @returns {void}\n   */\n  attachRuntimeModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of modules) {\n      cgc.runtimeModules.add(module);\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n  attachFullHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n    for (const module of modules) {\n      cgc.fullHashModules.add(module);\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n  attachDependentHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n    for (const module of modules) {\n      cgc.dependentHashModules.add(module);\n    }\n  }\n\n  /**\n   * @param {Module} oldModule the replaced module\n   * @param {Module} newModule the replacing module\n   * @returns {void}\n   */\n  replaceModule(oldModule, newModule) {\n    const oldCgm = this._getChunkGraphModule(oldModule);\n    const newCgm = this._getChunkGraphModule(newModule);\n    for (const chunk of oldCgm.chunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n      cgc.modules.delete(oldModule);\n      cgc.modules.add(newModule);\n      newCgm.chunks.add(chunk);\n    }\n    oldCgm.chunks.clear();\n    if (oldCgm.entryInChunks !== undefined) {\n      if (newCgm.entryInChunks === undefined) {\n        newCgm.entryInChunks = new Set();\n      }\n      for (const chunk of oldCgm.entryInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n        const old = cgc.entryModules.get(oldModule);\n        /** @type {Map<Module, Entrypoint>} */\n        const newEntryModules = new Map();\n        for (const [m, cg] of cgc.entryModules) {\n          if (m === oldModule) {\n            newEntryModules.set(newModule, old);\n          } else {\n            newEntryModules.set(m, cg);\n          }\n        }\n        cgc.entryModules = newEntryModules;\n        newCgm.entryInChunks.add(chunk);\n      }\n      oldCgm.entryInChunks = undefined;\n    }\n    if (oldCgm.runtimeInChunks !== undefined) {\n      if (newCgm.runtimeInChunks === undefined) {\n        newCgm.runtimeInChunks = new Set();\n      }\n      for (const chunk of oldCgm.runtimeInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n        cgc.runtimeModules.delete( /** @type {RuntimeModule} */oldModule);\n        cgc.runtimeModules.add( /** @type {RuntimeModule} */newModule);\n        newCgm.runtimeInChunks.add(chunk);\n        if (cgc.fullHashModules !== undefined && cgc.fullHashModules.has( /** @type {RuntimeModule} */oldModule)) {\n          cgc.fullHashModules.delete( /** @type {RuntimeModule} */oldModule);\n          cgc.fullHashModules.add( /** @type {RuntimeModule} */newModule);\n        }\n        if (cgc.dependentHashModules !== undefined && cgc.dependentHashModules.has( /** @type {RuntimeModule} */oldModule)) {\n          cgc.dependentHashModules.delete( /** @type {RuntimeModule} */oldModule);\n          cgc.dependentHashModules.add( /** @type {RuntimeModule} */newModule);\n        }\n      }\n      oldCgm.runtimeInChunks = undefined;\n    }\n  }\n\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module\n   */\n  isModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.has(module);\n  }\n\n  /**\n   * @param {Module} module the checked module\n   * @param {ChunkGroup} chunkGroup the checked chunk group\n   * @returns {boolean} true, if the chunk contains the module\n   */\n  isModuleInChunkGroup(module, chunkGroup) {\n    for (const chunk of chunkGroup.chunks) {\n      if (this.isModuleInChunk(module, chunk)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module} module the checked module\n   * @returns {boolean} true, if the module is entry of any chunk\n   */\n  isEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.entryInChunks !== undefined;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n  getModuleChunksIterable(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n  getOrderedModuleChunksIterable(module, sortFn) {\n    const cgm = this._getChunkGraphModule(module);\n    cgm.chunks.sortWith(sortFn);\n    return cgm.chunks;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {Chunk[]} array of chunks (cached, do not modify)\n   */\n  getModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks.getFromCache(getArray);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {number} the number of chunk which contain the module\n   */\n  getNumberOfModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks.size;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {RuntimeSpecSet} runtimes\n   */\n  getModuleRuntimes(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of modules which are contained in this chunk\n   */\n  getNumberOfChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.size;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of full hash modules which are contained in this chunk\n   */\n  getNumberOfChunkFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n  getChunkModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n  getChunkModulesIterableBySourceType(chunk, sourceType) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    return modulesWithSourceType;\n  }\n\n  /**\n   * @param {Chunk} chunk chunk\n   * @param {Module} module chunk module\n   * @param {Set<string>} sourceTypes source types\n   */\n  setChunkModuleSourceTypes(chunk, module, sourceTypes) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.sourceTypesByModule === undefined) {\n      cgc.sourceTypesByModule = new WeakMap();\n    }\n    cgc.sourceTypesByModule.set(module, sourceTypes);\n    // Update cgc._modulesBySourceType to invalidate the cache\n    cgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n  }\n\n  /**\n   * @param {Chunk} chunk chunk\n   * @param {Module} module chunk module\n   * @returns {Set<string>} source types\n   */\n  getChunkModuleSourceTypes(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.sourceTypesByModule === undefined) {\n      return module.getSourceTypes();\n    }\n    return cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n  }\n\n  /**\n   * @param {Module} module module\n   * @returns {Set<string>} source types\n   */\n  getModuleSourceTypes(module) {\n    return this._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes();\n  }\n\n  /**\n   * @param {Module} module module\n   * @returns {Set<string> | undefined} source types\n   */\n  _getOverwrittenModuleSourceTypes(module) {\n    let newSet = false;\n    let sourceTypes;\n    for (const chunk of this.getModuleChunksIterable(module)) {\n      const cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.sourceTypesByModule === undefined) return;\n      const st = cgc.sourceTypesByModule.get(module);\n      if (st === undefined) return;\n      if (!sourceTypes) {\n        sourceTypes = st;\n        continue;\n      } else if (!newSet) {\n        for (const type of st) {\n          if (!newSet) {\n            if (!sourceTypes.has(type)) {\n              newSet = true;\n              sourceTypes = new Set(sourceTypes);\n              sourceTypes.add(type);\n            }\n          } else {\n            sourceTypes.add(type);\n          }\n        }\n      } else {\n        for (const type of st) sourceTypes.add(type);\n      }\n    }\n    return sourceTypes;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n  getOrderedChunkModulesIterable(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgc.modules.sortWith(comparator);\n    return cgc.modules;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n  getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    if (modulesWithSourceType === undefined) return undefined;\n    modulesWithSourceType.sortWith(comparator);\n    return modulesWithSourceType;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n  getChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(getArray);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n  getOrderedChunkModules(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const arrayFunction = createOrderedArrayFunction(comparator);\n    return cgc.modules.getFromUnorderedCache(arrayFunction);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n   */\n  getChunkModuleIdMap(chunk, filterFn) {\n    let includeAllChunks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n          const moduleId = this.getModuleId(module);\n          array.push(moduleId);\n        }\n      }\n    }\n    return chunkModuleIdMap;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {number} hashLength length of the hash\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n   */\n  getChunkModuleRenderedHashMap(chunk, filterFn) {\n    let hashLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let includeAllChunks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    /** @type {Record<string|number, Record<string|number, string>>} */\n    const chunkModuleHashMap = Object.create(null);\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {Record<string|number, string>} */\n      let idToHashMap;\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (idToHashMap === undefined) {\n            idToHashMap = Object.create(null);\n            chunkModuleHashMap[asyncChunk.id] = idToHashMap;\n          }\n          const moduleId = this.getModuleId(module);\n          const hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n          idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n        }\n      }\n    }\n    return chunkModuleHashMap;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n   * @returns {Record<string|number, boolean>} chunk map\n   */\n  getChunkConditionMap(chunk, filterFn) {\n    const map = Object.create(null);\n    for (const c of chunk.getAllReferencedChunks()) {\n      map[c.id] = filterFn(c, this);\n    }\n    return map;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n  hasModuleInGraph(chunk, filterFn, filterChunkFn) {\n    const queue = new Set(chunk.groupsIterable);\n    const chunksProcessed = new Set();\n    for (const chunkGroup of queue) {\n      for (const innerChunk of chunkGroup.chunks) {\n        if (!chunksProcessed.has(innerChunk)) {\n          chunksProcessed.add(innerChunk);\n          if (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n            for (const module of this.getChunkModulesIterable(innerChunk)) {\n              if (filterFn(module)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {Chunk} chunkA first chunk\n   * @param {Chunk} chunkB second chunk\n   * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n   */\n  compareChunks(chunkA, chunkB) {\n    const cgcA = this._getChunkGraphChunk(chunkA);\n    const cgcB = this._getChunkGraphChunk(chunkB);\n    if (cgcA.modules.size > cgcB.modules.size) return -1;\n    if (cgcA.modules.size < cgcB.modules.size) return 1;\n    cgcA.modules.sortWith(compareModulesByIdentifier);\n    cgcB.modules.sortWith(compareModulesByIdentifier);\n    return compareModuleIterables(cgcA.modules, cgcB.modules);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} total size of all modules in the chunk\n   */\n  getChunkModulesSize(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(getModulesSize);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n   */\n  getChunkModulesSizes(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(getModulesSizes);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} root modules of the chunks (ordered by identifier)\n   */\n  getChunkRootModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk\n   */\n  getChunkSize(chunk) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const cgc = this._getChunkGraphChunk(chunk);\n    const modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk or false if chunks can't be integrated\n   */\n  getIntegratedChunksSize(chunkA, chunkB) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const cgcA = this._getChunkGraphChunk(chunkA);\n    const cgcB = this._getChunkGraphChunk(chunkB);\n    const allModules = new Set(cgcA.modules);\n    for (const m of cgcB.modules) allModules.add(m);\n    let modulesSize = getModulesSize(allModules);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @returns {boolean} true, if chunks could be integrated\n   */\n  canChunksBeIntegrated(chunkA, chunkB) {\n    if (chunkA.preventIntegration || chunkB.preventIntegration) {\n      return false;\n    }\n    const hasRuntimeA = chunkA.hasRuntime();\n    const hasRuntimeB = chunkB.hasRuntime();\n    if (hasRuntimeA !== hasRuntimeB) {\n      if (hasRuntimeA) {\n        return isAvailableChunk(chunkA, chunkB);\n      } else if (hasRuntimeB) {\n        return isAvailableChunk(chunkB, chunkA);\n      } else {\n        return false;\n      }\n    }\n    if (this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @param {Chunk} chunkA the target chunk\n   * @param {Chunk} chunkB the chunk to integrate\n   * @returns {void}\n   */\n  integrateChunks(chunkA, chunkB) {\n    // Decide for one name (deterministic)\n    if (chunkA.name && chunkB.name) {\n      if (this.getNumberOfEntryModules(chunkA) > 0 === this.getNumberOfEntryModules(chunkB) > 0) {\n        // When both chunks have entry modules or none have one, use\n        // shortest name\n        if (chunkA.name.length !== chunkB.name.length) {\n          chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n        } else {\n          chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n        }\n      } else if (this.getNumberOfEntryModules(chunkB) > 0) {\n        // Pick the name of the chunk with the entry module\n        chunkA.name = chunkB.name;\n      }\n    } else if (chunkB.name) {\n      chunkA.name = chunkB.name;\n    }\n\n    // Merge id name hints\n    for (const hint of chunkB.idNameHints) {\n      chunkA.idNameHints.add(hint);\n    }\n\n    // Merge runtime\n    chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n    // getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n    for (const module of this.getChunkModules(chunkB)) {\n      this.disconnectChunkAndModule(chunkB, module);\n      this.connectChunkAndModule(chunkA, module);\n    }\n    for (const [module, chunkGroup] of Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB))) {\n      this.disconnectChunkAndEntryModule(chunkB, module);\n      this.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n    }\n    for (const chunkGroup of chunkB.groupsIterable) {\n      chunkGroup.replaceChunk(chunkB, chunkA);\n      chunkA.addGroup(chunkGroup);\n      chunkB.removeGroup(chunkGroup);\n    }\n    ChunkGraph.clearChunkGraphForChunk(chunkB);\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk to upgrade\n   * @returns {void}\n   */\n  upgradeDependentToFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.dependentHashModules === undefined) return;\n    if (cgc.fullHashModules === undefined) {\n      cgc.fullHashModules = cgc.dependentHashModules;\n    } else {\n      for (const m of cgc.dependentHashModules) {\n        cgc.fullHashModules.add(m);\n      }\n      cgc.dependentHashModules = undefined;\n    }\n  }\n\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module as entry\n   */\n  isEntryModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules.has(module);\n  }\n\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n   * @returns {void}\n   */\n  connectChunkAndEntryModule(chunk, module, entrypoint) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgm.entryInChunks === undefined) {\n      cgm.entryInChunks = new Set();\n    }\n    cgm.entryInChunks.add(chunk);\n    cgc.entryModules.set(module, entrypoint);\n  }\n\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n  connectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgm.runtimeInChunks === undefined) {\n      cgm.runtimeInChunks = new Set();\n    }\n    cgm.runtimeInChunks.add(chunk);\n    cgc.runtimeModules.add(module);\n  }\n\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n  addFullHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n    cgc.fullHashModules.add(module);\n  }\n\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n  addDependentHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n    cgc.dependentHashModules.add(module);\n  }\n\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @returns {void}\n   */\n  disconnectChunkAndEntryModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgm.entryInChunks.delete(chunk);\n    if (cgm.entryInChunks.size === 0) {\n      cgm.entryInChunks = undefined;\n    }\n    cgc.entryModules.delete(module);\n  }\n\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n  disconnectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n    const cgc = this._getChunkGraphChunk(chunk);\n    cgm.runtimeInChunks.delete(chunk);\n    if (cgm.runtimeInChunks.size === 0) {\n      cgm.runtimeInChunks = undefined;\n    }\n    cgc.runtimeModules.delete(module);\n  }\n\n  /**\n   * @param {Module} module the entry module, it will no longer be entry\n   * @returns {void}\n   */\n  disconnectEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n    for (const chunk of cgm.entryInChunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n      cgc.entryModules.delete(module);\n    }\n    cgm.entryInChunks = undefined;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk, for which all entries will be removed\n   * @returns {void}\n   */\n  disconnectEntries(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const module of cgc.entryModules.keys()) {\n      const cgm = this._getChunkGraphModule(module);\n      cgm.entryInChunks.delete(chunk);\n      if (cgm.entryInChunks.size === 0) {\n        cgm.entryInChunks = undefined;\n      }\n    }\n    cgc.entryModules.clear();\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n  getNumberOfEntryModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules.size;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n  getNumberOfRuntimeModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.runtimeModules.size;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} iterable of modules (do not modify)\n   */\n  getChunkEntryModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules.keys();\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Chunk>} iterable of chunks\n   */\n  getChunkEntryDependentChunksIterable(chunk) {\n    /** @type {Set<Chunk>} */\n    const set = new Set();\n    for (const chunkGroup of chunk.groupsIterable) {\n      if (chunkGroup instanceof Entrypoint) {\n        const entrypointChunk = chunkGroup.getEntrypointChunk();\n        const cgc = this._getChunkGraphChunk(entrypointChunk);\n        for (const chunkGroup of cgc.entryModules.values()) {\n          for (const c of chunkGroup.chunks) {\n            if (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n              set.add(c);\n            }\n          }\n        }\n      }\n    }\n    return set;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {boolean} true, when it has dependent chunks\n   */\n  hasChunkEntryDependentChunks(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    for (const chunkGroup of cgc.entryModules.values()) {\n      for (const c of chunkGroup.chunks) {\n        if (c !== chunk) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n   */\n  getChunkRuntimeModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.runtimeModules;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {RuntimeModule[]} array of modules in order of execution\n   */\n  getChunkRuntimeModulesInOrder(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const array = Array.from(cgc.runtimeModules);\n    array.sort(concatComparators(compareSelect(\n    /**\n     * @param {RuntimeModule} r runtime module\n     * @returns {number=} stage\n     */\n    r => r.stage, compareIds), compareModulesByIdentifier));\n    return array;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n  getChunkFullHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.fullHashModules;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n   */\n  getChunkFullHashModulesSet(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.fullHashModules;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n  getChunkDependentHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.dependentHashModules;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n   */\n  getChunkEntryModulesWithChunkGroupIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.entryModules;\n  }\n\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @returns {ChunkGroup} the chunk group\n   */\n  getBlockChunkGroup(depBlock) {\n    return this._blockChunkGroups.get(depBlock);\n  }\n\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n  connectBlockAndChunkGroup(depBlock, chunkGroup) {\n    this._blockChunkGroups.set(depBlock, chunkGroup);\n    chunkGroup.addBlock(depBlock);\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n  disconnectChunkGroup(chunkGroup) {\n    for (const block of chunkGroup.blocksIterable) {\n      this._blockChunkGroups.delete(block);\n    }\n    // TODO refactor by moving blocks list into ChunkGraph\n    chunkGroup._blocks.clear();\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {string | number} the id of the module\n   */\n  getModuleId(module) {\n    const cgm = this._getChunkGraphModule(module);\n    return cgm.id;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {string | number} id the id of the module\n   * @returns {void}\n   */\n  setModuleId(module, id) {\n    const cgm = this._getChunkGraphModule(module);\n    cgm.id = id;\n  }\n\n  /**\n   * @param {string} runtime runtime\n   * @returns {string | number} the id of the runtime\n   */\n  getRuntimeId(runtime) {\n    return this._runtimeIds.get(runtime);\n  }\n\n  /**\n   * @param {string} runtime runtime\n   * @param {string | number} id the id of the runtime\n   * @returns {void}\n   */\n  setRuntimeId(runtime, id) {\n    this._runtimeIds.set(runtime, id);\n  }\n\n  /**\n   * @template T\n   * @param {Module} module the module\n   * @param {RuntimeSpecMap<T>} hashes hashes data\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {T} hash\n   */\n  _getModuleHashInfo(module, hashes, runtime) {\n    if (!hashes) {\n      throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (hashes not set at all)`);\n    } else if (runtime === undefined) {\n      const hashInfoItems = new Set(hashes.values());\n      if (hashInfoItems.size !== 1) {\n        throw new Error(`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(hashes.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n      }\n      return first(hashInfoItems);\n    } else {\n      const hashInfo = hashes.get(runtime);\n      if (!hashInfo) {\n        throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (available runtimes ${Array.from(hashes.keys(), runtimeToString).join(\", \")})`);\n      }\n      return hashInfo;\n    }\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, if the module has hashes for this runtime\n   */\n  hasModuleHashes(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const hashes = cgm.hashes;\n    return hashes && hashes.has(runtime);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n  getModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).hash;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n  getRenderedModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {string} hash the full hash\n   * @param {string} renderedHash the shortened hash for rendering\n   * @returns {void}\n   */\n  setModuleHashes(module, runtime, hash, renderedHash) {\n    const cgm = this._getChunkGraphModule(module);\n    if (cgm.hashes === undefined) {\n      cgm.hashes = new RuntimeSpecMap();\n    }\n    cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n   * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n   * @returns {void}\n   */\n  addModuleRuntimeRequirements(module, runtime, items) {\n    let transferOwnership = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const cgm = this._getChunkGraphModule(module);\n    const runtimeRequirementsMap = cgm.runtimeRequirements;\n    if (runtimeRequirementsMap === undefined) {\n      const map = new RuntimeSpecMap();\n      // TODO avoid cloning item and track ownership instead\n      map.set(runtime, transferOwnership ? items : new Set(items));\n      cgm.runtimeRequirements = map;\n      return;\n    }\n    runtimeRequirementsMap.update(runtime, runtimeRequirements => {\n      if (runtimeRequirements === undefined) {\n        return transferOwnership ? items : new Set(items);\n      } else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n        for (const item of items) runtimeRequirements.add(item);\n        return runtimeRequirements;\n      } else {\n        for (const item of runtimeRequirements) items.add(item);\n        return items;\n      }\n    });\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n   * @returns {void}\n   */\n  addChunkRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const runtimeRequirements = cgc.runtimeRequirements;\n    if (runtimeRequirements === undefined) {\n      cgc.runtimeRequirements = items;\n    } else if (runtimeRequirements.size >= items.size) {\n      for (const item of items) runtimeRequirements.add(item);\n    } else {\n      for (const item of runtimeRequirements) items.add(item);\n      cgc.runtimeRequirements = items;\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<string>} items runtime requirements to be added\n   * @returns {void}\n   */\n  addTreeRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const runtimeRequirements = cgc.runtimeRequirementsInTree;\n    for (const item of items) runtimeRequirements.add(item);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n  getModuleRuntimeRequirements(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n    const runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n  getChunkRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    const runtimeRequirements = cgc.runtimeRequirements;\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {string} hash\n   */\n  getModuleGraphHash(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const cgm = this._getChunkGraphModule(module);\n    return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {bigint} hash\n   */\n  getModuleGraphHashBigInt(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const cgm = this._getChunkGraphModule(module);\n    return withConnections ? BigInt(`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`) : this._getModuleGraphHashBigInt(cgm, module, runtime);\n  }\n\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {bigint} hash as big int\n   */\n  _getModuleGraphHashBigInt(cgm, module, runtime) {\n    if (cgm.graphHashes === undefined) {\n      cgm.graphHashes = new RuntimeSpecMap();\n    }\n    const graphHash = cgm.graphHashes.provide(runtime, () => {\n      const hash = createHash(this._hashFunction);\n      hash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n      const sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n      if (sourceTypes !== undefined) {\n        for (const type of sourceTypes) hash.update(type);\n      }\n      this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n      return BigInt(`0x${/** @type {string} */hash.digest(\"hex\")}`);\n    });\n    return graphHash;\n  }\n\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n  _getModuleGraphHashWithConnections(cgm, module, runtime) {\n    if (cgm.graphHashesWithConnections === undefined) {\n      cgm.graphHashesWithConnections = new RuntimeSpecMap();\n    }\n    const activeStateToString = state => {\n      if (state === false) return \"F\";\n      if (state === true) return \"T\";\n      if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n      throw new Error(\"Not implemented active state\");\n    };\n    const strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n    return cgm.graphHashesWithConnections.provide(runtime, () => {\n      const graphHash = this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n      const connections = this.moduleGraph.getOutgoingConnections(module);\n      /** @type {Set<Module>} */\n      const activeNamespaceModules = new Set();\n      /** @type {Map<string, Module | Set<Module>>} */\n      const connectedModules = new Map();\n      const processConnection = (connection, stateInfo) => {\n        const module = connection.module;\n        stateInfo += module.getExportsType(this.moduleGraph, strict);\n        // cspell:word Tnamespace\n        if (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);else {\n          const oldModule = connectedModules.get(stateInfo);\n          if (oldModule === undefined) {\n            connectedModules.set(stateInfo, module);\n          } else if (oldModule instanceof Set) {\n            oldModule.add(module);\n          } else if (oldModule !== module) {\n            connectedModules.set(stateInfo, new Set([oldModule, module]));\n          }\n        }\n      };\n      if (runtime === undefined || typeof runtime === \"string\") {\n        for (const connection of connections) {\n          const state = connection.getActiveState(runtime);\n          if (state === false) continue;\n          processConnection(connection, state === true ? \"T\" : \"O\");\n        }\n      } else {\n        // cspell:word Tnamespace\n        for (const connection of connections) {\n          const states = new Set();\n          let stateInfo = \"\";\n          forEachRuntime(runtime, runtime => {\n            const state = connection.getActiveState(runtime);\n            states.add(state);\n            stateInfo += activeStateToString(state) + runtime;\n          }, true);\n          if (states.size === 1) {\n            const state = first(states);\n            if (state === false) continue;\n            stateInfo = activeStateToString(state);\n          }\n          processConnection(connection, stateInfo);\n        }\n      }\n      // cspell:word Tnamespace\n      if (activeNamespaceModules.size === 0 && connectedModules.size === 0) return graphHash;\n      const connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort((_ref, _ref2) => {\n        let [a] = _ref;\n        let [b] = _ref2;\n        return a < b ? -1 : 1;\n      }) : connectedModules;\n      const hash = createHash(this._hashFunction);\n      const addModuleToHash = module => {\n        hash.update(this._getModuleGraphHashBigInt(this._getChunkGraphModule(module), module, runtime).toString(16));\n      };\n      const addModulesToHash = modules => {\n        let xor = ZERO_BIG_INT;\n        for (const m of modules) {\n          xor = xor ^ this._getModuleGraphHashBigInt(this._getChunkGraphModule(m), m, runtime);\n        }\n        hash.update(xor.toString(16));\n      };\n      if (activeNamespaceModules.size === 1) addModuleToHash(activeNamespaceModules.values().next().value);else if (activeNamespaceModules.size > 1) addModulesToHash(activeNamespaceModules);\n      for (const [stateInfo, modules] of connectedModulesInOrder) {\n        hash.update(stateInfo);\n        if (modules instanceof Set) {\n          addModulesToHash(modules);\n        } else {\n          addModuleToHash(modules);\n        }\n      }\n      hash.update(graphHash);\n      return (/** @type {string} */hash.digest(\"hex\")\n      );\n    });\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n  getTreeRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n    return cgc.runtimeRequirementsInTree;\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Module} module the module\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n  static getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n    if (fn) return fn(module);\n    const newFn = util.deprecate(\n    /**\n     * @param {Module} module the module\n     * @returns {ChunkGraph} the chunk graph\n     */\n    module => {\n      const chunkGraph = chunkGraphForModuleMap.get(module);\n      if (!chunkGraph) throw new Error(deprecateMessage + \": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n    return newFn(module);\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Module} module the module\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n  static setChunkGraphForModule(module, chunkGraph) {\n    chunkGraphForModuleMap.set(module, chunkGraph);\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n  static clearChunkGraphForModule(module) {\n    chunkGraphForModuleMap.delete(module);\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n  static getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n    if (fn) return fn(chunk);\n    const newFn = util.deprecate(\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ChunkGraph} the chunk graph\n     */\n    chunk => {\n      const chunkGraph = chunkGraphForChunkMap.get(chunk);\n      if (!chunkGraph) throw new Error(deprecateMessage + \"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n    return newFn(chunk);\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n  static setChunkGraphForChunk(chunk, chunkGraph) {\n    chunkGraphForChunkMap.set(chunk, chunkGraph);\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {void}\n   */\n  static clearChunkGraphForChunk(chunk) {\n    chunkGraphForChunkMap.delete(chunk);\n  }\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\nmodule.exports = ChunkGraph;","map":{"version":3,"names":["util","require","Entrypoint","ModuleGraphConnection","first","SortableSet","compareModulesById","compareIterables","compareModulesByIdentifier","concatComparators","compareSelect","compareIds","createHash","findGraphRoots","RuntimeSpecMap","RuntimeSpecSet","runtimeToString","mergeRuntime","forEachRuntime","EMPTY_SET","Set","ZERO_BIG_INT","BigInt","compareModuleIterables","ModuleHashInfo","constructor","hash","renderedHash","getArray","set","Array","from","getModuleRuntimes","chunks","runtimes","chunk","add","runtime","modulesBySourceType","sourceTypesByModule","map","Map","module","sourceTypes","get","getSourceTypes","sourceType","innerSet","undefined","key","size","defaultModulesBySourceType","createOrderedArrayFunctionMap","WeakMap","createOrderedArrayFunction","comparator","fn","sortWith","getModulesSize","modules","type","getModulesSizes","sizes","Object","create","isAvailableChunk","a","b","queue","groupsIterable","chunkGroup","isInGroup","isInitial","parent","parentsIterable","ChunkGraphModule","entryInChunks","runtimeInChunks","hashes","id","runtimeRequirements","graphHashes","graphHashesWithConnections","ChunkGraphChunk","entryModules","runtimeModules","fullHashModules","dependentHashModules","runtimeRequirementsInTree","_modulesBySourceType","ChunkGraph","moduleGraph","hashFunction","arguments","length","_modules","_chunks","_blockChunkGroups","_runtimeIds","_hashFunction","_getGraphRoots","bind","_getChunkGraphModule","cgm","_getChunkGraphChunk","cgc","addDependencies","connection","getOutgoingConnections","activeState","getActiveState","TRANSITIVE_ONLY","sort","connectChunkAndModule","disconnectChunkAndModule","delete","disconnectChunk","clear","disconnectFromGroups","clearChunkGraphForChunk","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","replaceModule","oldModule","newModule","oldCgm","newCgm","old","newEntryModules","m","cg","has","isModuleInChunk","isModuleInChunkGroup","isEntryModule","getModuleChunksIterable","getOrderedModuleChunksIterable","sortFn","getModuleChunks","getFromCache","getNumberOfModuleChunks","getFromUnorderedCache","getNumberOfChunkModules","getNumberOfChunkFullHashModules","getChunkModulesIterable","getChunkModulesIterableBySourceType","modulesWithSourceType","setChunkModuleSourceTypes","getChunkModuleSourceTypes","getModuleSourceTypes","_getOverwrittenModuleSourceTypes","newSet","st","getOrderedChunkModulesIterable","getOrderedChunkModulesIterableBySourceType","getChunkModules","getOrderedChunkModules","arrayFunction","getChunkModuleIdMap","filterFn","includeAllChunks","chunkModuleIdMap","asyncChunk","getAllReferencedChunks","getAllAsyncChunks","array","moduleId","getModuleId","push","getChunkModuleRenderedHashMap","hashLength","chunkModuleHashMap","idToHashMap","getRenderedModuleHash","slice","getChunkConditionMap","c","hasModuleInGraph","filterChunkFn","chunksProcessed","innerChunk","child","childrenIterable","compareChunks","chunkA","chunkB","cgcA","cgcB","getChunkModulesSize","getChunkModulesSizes","getChunkRootModules","getChunkSize","options","modulesSize","chunkOverhead","entryChunkMultiplicator","canBeInitial","getIntegratedChunksSize","allModules","canChunksBeIntegrated","preventIntegration","hasRuntimeA","hasRuntime","hasRuntimeB","getNumberOfEntryModules","integrateChunks","name","hint","idNameHints","getChunkEntryModulesWithChunkGroupIterable","disconnectChunkAndEntryModule","connectChunkAndEntryModule","replaceChunk","addGroup","removeGroup","upgradeDependentToFullHashModules","isEntryModuleInChunk","entrypoint","connectChunkAndRuntimeModule","addFullHashModuleToChunk","addDependentHashModuleToChunk","disconnectChunkAndRuntimeModule","disconnectEntryModule","disconnectEntries","keys","getNumberOfRuntimeModules","getChunkEntryModulesIterable","getChunkEntryDependentChunksIterable","entrypointChunk","getEntrypointChunk","values","hasChunkEntryDependentChunks","getChunkRuntimeModulesIterable","getChunkRuntimeModulesInOrder","r","stage","getChunkFullHashModulesIterable","getChunkFullHashModulesSet","getChunkDependentHashModulesIterable","getBlockChunkGroup","depBlock","connectBlockAndChunkGroup","addBlock","disconnectChunkGroup","block","blocksIterable","_blocks","setModuleId","getRuntimeId","setRuntimeId","_getModuleHashInfo","Error","identifier","hashInfoItems","join","hashInfo","hasModuleHashes","getModuleHash","setModuleHashes","addModuleRuntimeRequirements","items","transferOwnership","runtimeRequirementsMap","update","item","addChunkRuntimeRequirements","addTreeRuntimeRequirements","getModuleRuntimeRequirements","getChunkRuntimeRequirements","getModuleGraphHash","withConnections","_getModuleGraphHashWithConnections","_getModuleGraphHashBigInt","toString","getModuleGraphHashBigInt","graphHash","provide","isAsync","getExportsInfo","updateHash","digest","activeStateToString","state","strict","buildMeta","strictHarmonyModule","connections","activeNamespaceModules","connectedModules","processConnection","stateInfo","getExportsType","states","connectedModulesInOrder","_ref","_ref2","addModuleToHash","addModulesToHash","xor","next","value","getTreeRuntimeRequirements","getChunkGraphForModule","deprecateMessage","deprecationCode","deprecateGetChunkGraphForModuleMap","newFn","deprecate","chunkGraph","chunkGraphForModuleMap","setChunkGraphForModule","clearChunkGraphForModule","getChunkGraphForChunk","deprecateGetChunkGraphForChunkMap","chunkGraphForChunkMap","setChunkGraphForChunk","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/ChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { first } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareModulesById,\n\tcompareIterables,\n\tcompareModulesByIdentifier,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n\tRuntimeSpecMap,\n\tRuntimeSpecSet,\n\truntimeToString,\n\tmergeRuntime,\n\tforEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\n\nconst ZERO_BIG_INT = BigInt(0);\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n\tconstructor(hash, renderedHash) {\n\t\tthis.hash = hash;\n\t\tthis.renderedHash = renderedHash;\n\t}\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nconst getArray = set => {\n\treturn Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nconst getModuleRuntimes = chunks => {\n\tconst runtimes = new RuntimeSpecSet();\n\tfor (const chunk of chunks) {\n\t\truntimes.add(chunk.runtime);\n\t}\n\treturn runtimes;\n};\n\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\nconst modulesBySourceType = sourceTypesByModule => set => {\n\t/** @type {Map<string, SortableSet<Module>>} */\n\tconst map = new Map();\n\tfor (const module of set) {\n\t\tconst sourceTypes =\n\t\t\t(sourceTypesByModule && sourceTypesByModule.get(module)) ||\n\t\t\tmodule.getSourceTypes();\n\t\tfor (const sourceType of sourceTypes) {\n\t\t\tlet innerSet = map.get(sourceType);\n\t\t\tif (innerSet === undefined) {\n\t\t\t\tinnerSet = new SortableSet();\n\t\t\t\tmap.set(sourceType, innerSet);\n\t\t\t}\n\t\t\tinnerSet.add(module);\n\t\t}\n\t}\n\tfor (const [key, innerSet] of map) {\n\t\t// When all modules have the source type, we reuse the original SortableSet\n\t\t// to benefit from the shared cache (especially for sorting)\n\t\tif (innerSet.size === set.size) {\n\t\t\tmap.set(key, set);\n\t\t}\n\t}\n\treturn map;\n};\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nconst createOrderedArrayFunction = comparator => {\n\t/** @type {SetToArrayFunction<T>} */\n\tlet fn = createOrderedArrayFunctionMap.get(comparator);\n\tif (fn !== undefined) return fn;\n\tfn = set => {\n\t\tset.sortWith(comparator);\n\t\treturn Array.from(set);\n\t};\n\tcreateOrderedArrayFunctionMap.set(comparator, fn);\n\treturn fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = modules => {\n\tlet size = 0;\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t}\n\treturn size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nconst getModulesSizes = modules => {\n\tlet sizes = Object.create(null);\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsizes[type] = (sizes[type] || 0) + module.size(type);\n\t\t}\n\t}\n\treturn sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nconst isAvailableChunk = (a, b) => {\n\tconst queue = new Set(b.groupsIterable);\n\tfor (const chunkGroup of queue) {\n\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\tif (chunkGroup.isInitial()) return false;\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tqueue.add(parent);\n\t\t}\n\t}\n\treturn true;\n};\n\nclass ChunkGraphModule {\n\tconstructor() {\n\t\t/** @type {SortableSet<Chunk>} */\n\t\tthis.chunks = new SortableSet();\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.entryInChunks = undefined;\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.runtimeInChunks = undefined;\n\t\t/** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\t\tthis.hashes = undefined;\n\t\t/** @type {string | number} */\n\t\tthis.id = null;\n\t\t/** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashes = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashesWithConnections = undefined;\n\t}\n}\n\nclass ChunkGraphChunk {\n\tconstructor() {\n\t\t/** @type {SortableSet<Module>} */\n\t\tthis.modules = new SortableSet();\n\t\t/** @type {WeakMap<Module, Set<string>> | undefined} */\n\t\tthis.sourceTypesByModule = undefined;\n\t\t/** @type {Map<Module, Entrypoint>} */\n\t\tthis.entryModules = new Map();\n\t\t/** @type {SortableSet<RuntimeModule>} */\n\t\tthis.runtimeModules = new SortableSet();\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.fullHashModules = undefined;\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.dependentHashModules = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.runtimeRequirementsInTree = new Set();\n\n\t\tthis._modulesBySourceType = defaultModulesBySourceType;\n\t}\n}\n\nclass ChunkGraph {\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(moduleGraph, hashFunction = \"md4\") {\n\t\t/** @private @type {WeakMap<Module, ChunkGraphModule>} */\n\t\tthis._modules = new WeakMap();\n\t\t/** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\t\tthis._chunks = new WeakMap();\n\t\t/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\t\tthis._blockChunkGroups = new WeakMap();\n\t\t/** @private @type {Map<string, string | number>} */\n\t\tthis._runtimeIds = new Map();\n\t\t/** @type {ModuleGraph} */\n\t\tthis.moduleGraph = moduleGraph;\n\n\t\tthis._hashFunction = hashFunction;\n\n\t\tthis._getGraphRoots = this._getGraphRoots.bind(this);\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} module the module\n\t * @returns {ChunkGraphModule} internal module\n\t */\n\t_getChunkGraphModule(module) {\n\t\tlet cgm = this._modules.get(module);\n\t\tif (cgm === undefined) {\n\t\t\tcgm = new ChunkGraphModule();\n\t\t\tthis._modules.set(module, cgm);\n\t\t}\n\t\treturn cgm;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ChunkGraphChunk} internal chunk\n\t */\n\t_getChunkGraphChunk(chunk) {\n\t\tlet cgc = this._chunks.get(chunk);\n\t\tif (cgc === undefined) {\n\t\t\tcgc = new ChunkGraphChunk();\n\t\t\tthis._chunks.set(chunk, cgc);\n\t\t}\n\t\treturn cgc;\n\t}\n\n\t/**\n\t * @param {SortableSet<Module>} set the sortable Set to get the roots of\n\t * @returns {Module[]} the graph roots\n\t */\n\t_getGraphRoots(set) {\n\t\tconst { moduleGraph } = this;\n\t\treturn Array.from(\n\t\t\tfindGraphRoots(set, module => {\n\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\tconst set = new Set();\n\t\t\t\tconst addDependencies = module => {\n\t\t\t\t\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\t\t\t\t\tif (!connection.module) continue;\n\t\t\t\t\t\tconst activeState = connection.getActiveState(undefined);\n\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\taddDependencies(connection.module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(connection.module);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\taddDependencies(module);\n\t\t\t\treturn set;\n\t\t\t})\n\t\t).sort(compareModulesByIdentifier);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.chunks.add(chunk);\n\t\tcgc.modules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.delete(module);\n\t\t// No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n\t\tif (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n\t\tcgm.chunks.delete(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk which will be disconnected\n\t * @returns {void}\n\t */\n\tdisconnectChunk(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.modules) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.chunks.delete(chunk);\n\t\t}\n\t\tcgc.modules.clear();\n\t\tchunk.disconnectFromGroups();\n\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<Module>} modules the modules\n\t * @returns {void}\n\t */\n\tattachModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.modules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the runtime modules\n\t * @returns {void}\n\t */\n\tattachRuntimeModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.runtimeModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachFullHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.fullHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachDependentHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.dependentHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the replaced module\n\t * @param {Module} newModule the replacing module\n\t * @returns {void}\n\t */\n\treplaceModule(oldModule, newModule) {\n\t\tconst oldCgm = this._getChunkGraphModule(oldModule);\n\t\tconst newCgm = this._getChunkGraphModule(newModule);\n\n\t\tfor (const chunk of oldCgm.chunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.modules.delete(oldModule);\n\t\t\tcgc.modules.add(newModule);\n\t\t\tnewCgm.chunks.add(chunk);\n\t\t}\n\t\toldCgm.chunks.clear();\n\n\t\tif (oldCgm.entryInChunks !== undefined) {\n\t\t\tif (newCgm.entryInChunks === undefined) {\n\t\t\t\tnewCgm.entryInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.entryInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tconst old = cgc.entryModules.get(oldModule);\n\t\t\t\t/** @type {Map<Module, Entrypoint>} */\n\t\t\t\tconst newEntryModules = new Map();\n\t\t\t\tfor (const [m, cg] of cgc.entryModules) {\n\t\t\t\t\tif (m === oldModule) {\n\t\t\t\t\t\tnewEntryModules.set(newModule, old);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewEntryModules.set(m, cg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcgc.entryModules = newEntryModules;\n\t\t\t\tnewCgm.entryInChunks.add(chunk);\n\t\t\t}\n\t\t\toldCgm.entryInChunks = undefined;\n\t\t}\n\n\t\tif (oldCgm.runtimeInChunks !== undefined) {\n\t\t\tif (newCgm.runtimeInChunks === undefined) {\n\t\t\t\tnewCgm.runtimeInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.runtimeInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tcgc.runtimeModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\tcgc.runtimeModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\tnewCgm.runtimeInChunks.add(chunk);\n\t\t\t\tif (\n\t\t\t\t\tcgc.fullHashModules !== undefined &&\n\t\t\t\t\tcgc.fullHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.fullHashModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\t\tcgc.fullHashModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tcgc.dependentHashModules !== undefined &&\n\t\t\t\t\tcgc.dependentHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.dependentHashModules.delete(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (oldModule)\n\t\t\t\t\t);\n\t\t\t\t\tcgc.dependentHashModules.add(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (newModule)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\toldCgm.runtimeInChunks = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.has(module);\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {ChunkGroup} chunkGroup the checked chunk group\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunkGroup(module, chunkGroup) {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tif (this.isModuleInChunk(module, chunk)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @returns {boolean} true, if the module is entry of any chunk\n\t */\n\tisEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.entryInChunks !== undefined;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetModuleChunksIterable(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetOrderedModuleChunksIterable(module, sortFn) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.chunks.sortWith(sortFn);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Chunk[]} array of chunks (cached, do not modify)\n\t */\n\tgetModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromCache(getArray);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the number of chunk which contain the module\n\t */\n\tgetNumberOfModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.size;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {RuntimeSpecSet} runtimes\n\t */\n\tgetModuleRuntimes(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of full hash modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetChunkModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetChunkModulesIterableBySourceType(chunk, sourceType) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @param {Set<string>} sourceTypes source types\n\t */\n\tsetChunkModuleSourceTypes(chunk, module, sourceTypes) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\tcgc.sourceTypesByModule = new WeakMap();\n\t\t}\n\t\tcgc.sourceTypesByModule.set(module, sourceTypes);\n\t\t// Update cgc._modulesBySourceType to invalidate the cache\n\t\tcgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @returns {Set<string>} source types\n\t */\n\tgetChunkModuleSourceTypes(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\treturn module.getSourceTypes();\n\t\t}\n\t\treturn cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string>} source types\n\t */\n\tgetModuleSourceTypes(module) {\n\t\treturn (\n\t\t\tthis._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes()\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string> | undefined} source types\n\t */\n\t_getOverwrittenModuleSourceTypes(module) {\n\t\tlet newSet = false;\n\t\tlet sourceTypes;\n\t\tfor (const chunk of this.getModuleChunksIterable(module)) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tif (cgc.sourceTypesByModule === undefined) return;\n\t\t\tconst st = cgc.sourceTypesByModule.get(module);\n\t\t\tif (st === undefined) return;\n\t\t\tif (!sourceTypes) {\n\t\t\t\tsourceTypes = st;\n\t\t\t\tcontinue;\n\t\t\t} else if (!newSet) {\n\t\t\t\tfor (const type of st) {\n\t\t\t\t\tif (!newSet) {\n\t\t\t\t\t\tif (!sourceTypes.has(type)) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tsourceTypes = new Set(sourceTypes);\n\t\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const type of st) sourceTypes.add(type);\n\t\t\t}\n\t\t}\n\n\t\treturn sourceTypes;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterable(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.sortWith(comparator);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\tif (modulesWithSourceType === undefined) return undefined;\n\t\tmodulesWithSourceType.sortWith(comparator);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getArray);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetOrderedChunkModules(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst arrayFunction = createOrderedArrayFunction(comparator);\n\t\treturn cgc.modules.getFromUnorderedCache(arrayFunction);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n\t */\n\tgetChunkModuleIdMap(chunk, filterFn, includeAllChunks = false) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleIdMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {number} hashLength length of the hash\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n\t */\n\tgetChunkModuleRenderedHashMap(\n\t\tchunk,\n\t\tfilterFn,\n\t\thashLength = 0,\n\t\tincludeAllChunks = false\n\t) {\n\t\t/** @type {Record<string|number, Record<string|number, string>>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {Record<string|number, string>} */\n\t\t\tlet idToHashMap;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (idToHashMap === undefined) {\n\t\t\t\t\t\tidToHashMap = Object.create(null);\n\t\t\t\t\t\tchunkModuleHashMap[asyncChunk.id] = idToHashMap;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tconst hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n\t\t\t\t\tidToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleHashMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n\t * @returns {Record<string|number, boolean>} chunk map\n\t */\n\tgetChunkConditionMap(chunk, filterFn) {\n\t\tconst map = Object.create(null);\n\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\tmap[c.id] = filterFn(c, this);\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(chunk, filterFn, filterChunkFn) {\n\t\tconst queue = new Set(chunk.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const innerChunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(innerChunk)) {\n\t\t\t\t\tchunksProcessed.add(innerChunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n\t\t\t\t\t\tfor (const module of this.getChunkModulesIterable(innerChunk)) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA first chunk\n\t * @param {Chunk} chunkB second chunk\n\t * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareChunks(chunkA, chunkB) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tif (cgcA.modules.size > cgcB.modules.size) return -1;\n\t\tif (cgcA.modules.size < cgcB.modules.size) return 1;\n\t\tcgcA.modules.sortWith(compareModulesByIdentifier);\n\t\tcgcB.modules.sortWith(compareModulesByIdentifier);\n\t\treturn compareModuleIterables(cgcA.modules, cgcB.modules);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} total size of all modules in the chunk\n\t */\n\tgetChunkModulesSize(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n\t */\n\tgetChunkModulesSizes(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSizes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} root modules of the chunks (ordered by identifier)\n\t */\n\tgetChunkRootModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk\n\t */\n\tgetChunkSize(chunk, options = {}) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if chunks can't be integrated\n\t */\n\tgetIntegratedChunksSize(chunkA, chunkB, options = {}) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tconst allModules = new Set(cgcA.modules);\n\t\tfor (const m of cgcB.modules) allModules.add(m);\n\t\tlet modulesSize = getModulesSize(allModules);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize *\n\t\t\t\t(chunkA.canBeInitial() || chunkB.canBeInitial()\n\t\t\t\t\t? entryChunkMultiplicator\n\t\t\t\t\t: 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanChunksBeIntegrated(chunkA, chunkB) {\n\t\tif (chunkA.preventIntegration || chunkB.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasRuntimeA = chunkA.hasRuntime();\n\t\tconst hasRuntimeB = chunkB.hasRuntime();\n\n\t\tif (hasRuntimeA !== hasRuntimeB) {\n\t\t\tif (hasRuntimeA) {\n\t\t\t\treturn isAvailableChunk(chunkA, chunkB);\n\t\t\t} else if (hasRuntimeB) {\n\t\t\t\treturn isAvailableChunk(chunkB, chunkA);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ||\n\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA the target chunk\n\t * @param {Chunk} chunkB the chunk to integrate\n\t * @returns {void}\n\t */\n\tintegrateChunks(chunkA, chunkB) {\n\t\t// Decide for one name (deterministic)\n\t\tif (chunkA.name && chunkB.name) {\n\t\t\tif (\n\t\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ===\n\t\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t\t) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (chunkA.name.length !== chunkB.name.length) {\n\t\t\t\t\tchunkA.name =\n\t\t\t\t\t\tchunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n\t\t\t\t} else {\n\t\t\t\t\tchunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n\t\t\t\t}\n\t\t\t} else if (this.getNumberOfEntryModules(chunkB) > 0) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tchunkA.name = chunkB.name;\n\t\t\t}\n\t\t} else if (chunkB.name) {\n\t\t\tchunkA.name = chunkB.name;\n\t\t}\n\n\t\t// Merge id name hints\n\t\tfor (const hint of chunkB.idNameHints) {\n\t\t\tchunkA.idNameHints.add(hint);\n\t\t}\n\n\t\t// Merge runtime\n\t\tchunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n\t\t// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\t\tfor (const module of this.getChunkModules(chunkB)) {\n\t\t\tthis.disconnectChunkAndModule(chunkB, module);\n\t\t\tthis.connectChunkAndModule(chunkA, module);\n\t\t}\n\n\t\tfor (const [module, chunkGroup] of Array.from(\n\t\t\tthis.getChunkEntryModulesWithChunkGroupIterable(chunkB)\n\t\t)) {\n\t\t\tthis.disconnectChunkAndEntryModule(chunkB, module);\n\t\t\tthis.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n\t\t}\n\n\t\tfor (const chunkGroup of chunkB.groupsIterable) {\n\t\t\tchunkGroup.replaceChunk(chunkB, chunkA);\n\t\t\tchunkA.addGroup(chunkGroup);\n\t\t\tchunkB.removeGroup(chunkGroup);\n\t\t}\n\t\tChunkGraph.clearChunkGraphForChunk(chunkB);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to upgrade\n\t * @returns {void}\n\t */\n\tupgradeDependentToFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined) return;\n\t\tif (cgc.fullHashModules === undefined) {\n\t\t\tcgc.fullHashModules = cgc.dependentHashModules;\n\t\t} else {\n\t\t\tfor (const m of cgc.dependentHashModules) {\n\t\t\t\tcgc.fullHashModules.add(m);\n\t\t\t}\n\t\t\tcgc.dependentHashModules = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module as entry\n\t */\n\tisEntryModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.has(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n\t * @returns {void}\n\t */\n\tconnectChunkAndEntryModule(chunk, module, entrypoint) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.entryInChunks === undefined) {\n\t\t\tcgm.entryInChunks = new Set();\n\t\t}\n\t\tcgm.entryInChunks.add(chunk);\n\t\tcgc.entryModules.set(module, entrypoint);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.runtimeInChunks === undefined) {\n\t\t\tcgm.runtimeInChunks = new Set();\n\t\t}\n\t\tcgm.runtimeInChunks.add(chunk);\n\t\tcgc.runtimeModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddFullHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tcgc.fullHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddDependentHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tcgc.dependentHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndEntryModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.entryInChunks.delete(chunk);\n\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\tcgm.entryInChunks = undefined;\n\t\t}\n\t\tcgc.entryModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.runtimeInChunks.delete(chunk);\n\t\tif (cgm.runtimeInChunks.size === 0) {\n\t\t\tcgm.runtimeInChunks = undefined;\n\t\t}\n\t\tcgc.runtimeModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Module} module the entry module, it will no longer be entry\n\t * @returns {void}\n\t */\n\tdisconnectEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tfor (const chunk of cgm.entryInChunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.entryModules.delete(module);\n\t\t}\n\t\tcgm.entryInChunks = undefined;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk, for which all entries will be removed\n\t * @returns {void}\n\t */\n\tdisconnectEntries(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.entryModules.keys()) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.entryInChunks.delete(chunk);\n\t\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\t\tcgm.entryInChunks = undefined;\n\t\t\t}\n\t\t}\n\t\tcgc.entryModules.clear();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfEntryModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfRuntimeModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.keys();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Chunk>} iterable of chunks\n\t */\n\tgetChunkEntryDependentChunksIterable(chunk) {\n\t\t/** @type {Set<Chunk>} */\n\t\tconst set = new Set();\n\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\tconst entrypointChunk = chunkGroup.getEntrypointChunk();\n\t\t\t\tconst cgc = this._getChunkGraphChunk(entrypointChunk);\n\t\t\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\t\t\tif (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n\t\t\t\t\t\t\tset.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {boolean} true, when it has dependent chunks\n\t */\n\thasChunkEntryDependentChunks(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\tif (c !== chunk) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n\t */\n\tgetChunkRuntimeModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {RuntimeModule[]} array of modules in order of execution\n\t */\n\tgetChunkRuntimeModulesInOrder(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst array = Array.from(cgc.runtimeModules);\n\t\tarray.sort(\n\t\t\tconcatComparators(\n\t\t\t\tcompareSelect(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {RuntimeModule} r runtime module\n\t\t\t\t\t * @returns {number=} stage\n\t\t\t\t\t */\n\t\t\t\t\tr => r.stage,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareModulesByIdentifier\n\t\t\t)\n\t\t);\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesSet(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkDependentHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.dependentHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesWithChunkGroupIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @returns {ChunkGroup} the chunk group\n\t */\n\tgetBlockChunkGroup(depBlock) {\n\t\treturn this._blockChunkGroups.get(depBlock);\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tconnectBlockAndChunkGroup(depBlock, chunkGroup) {\n\t\tthis._blockChunkGroups.set(depBlock, chunkGroup);\n\t\tchunkGroup.addBlock(depBlock);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tdisconnectChunkGroup(chunkGroup) {\n\t\tfor (const block of chunkGroup.blocksIterable) {\n\t\t\tthis._blockChunkGroups.delete(block);\n\t\t}\n\t\t// TODO refactor by moving blocks list into ChunkGraph\n\t\tchunkGroup._blocks.clear();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {string | number} the id of the module\n\t */\n\tgetModuleId(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.id;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string | number} id the id of the module\n\t * @returns {void}\n\t */\n\tsetModuleId(module, id) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.id = id;\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @returns {string | number} the id of the runtime\n\t */\n\tgetRuntimeId(runtime) {\n\t\treturn this._runtimeIds.get(runtime);\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @param {string | number} id the id of the runtime\n\t * @returns {void}\n\t */\n\tsetRuntimeId(runtime, id) {\n\t\tthis._runtimeIds.set(runtime, id);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {Module} module the module\n\t * @param {RuntimeSpecMap<T>} hashes hashes data\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {T} hash\n\t */\n\t_getModuleHashInfo(module, hashes, runtime) {\n\t\tif (!hashes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} (hashes not set at all)`\n\t\t\t);\n\t\t} else if (runtime === undefined) {\n\t\t\tconst hashInfoItems = new Set(hashes.values());\n\t\t\tif (hashInfoItems.size !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn first(hashInfoItems);\n\t\t} else {\n\t\t\tconst hashInfo = hashes.get(runtime);\n\t\t\tif (!hashInfo) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\t\truntime\n\t\t\t\t\t)} (available runtimes ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\truntimeToString\n\t\t\t\t\t).join(\", \")})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn hashInfo;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the module has hashes for this runtime\n\t */\n\thasModuleHashes(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn hashes && hashes.has(runtime);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).hash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetRenderedModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {string} hash the full hash\n\t * @param {string} renderedHash the shortened hash for rendering\n\t * @returns {void}\n\t */\n\tsetModuleHashes(module, runtime, hash, renderedHash) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tif (cgm.hashes === undefined) {\n\t\t\tcgm.hashes = new RuntimeSpecMap();\n\t\t}\n\t\tcgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n\t * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n\t * @returns {void}\n\t */\n\taddModuleRuntimeRequirements(\n\t\tmodule,\n\t\truntime,\n\t\titems,\n\t\ttransferOwnership = true\n\t) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirementsMap = cgm.runtimeRequirements;\n\t\tif (runtimeRequirementsMap === undefined) {\n\t\t\tconst map = new RuntimeSpecMap();\n\t\t\t// TODO avoid cloning item and track ownership instead\n\t\t\tmap.set(runtime, transferOwnership ? items : new Set(items));\n\t\t\tcgm.runtimeRequirements = map;\n\t\t\treturn;\n\t\t}\n\t\truntimeRequirementsMap.update(runtime, runtimeRequirements => {\n\t\t\tif (runtimeRequirements === undefined) {\n\t\t\t\treturn transferOwnership ? items : new Set(items);\n\t\t\t} else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n\t\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t\t\treturn runtimeRequirements;\n\t\t\t} else {\n\t\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n\t * @returns {void}\n\t */\n\taddChunkRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\tif (runtimeRequirements === undefined) {\n\t\t\tcgc.runtimeRequirements = items;\n\t\t} else if (runtimeRequirements.size >= items.size) {\n\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t} else {\n\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\tcgc.runtimeRequirements = items;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<string>} items runtime requirements to be added\n\t * @returns {void}\n\t */\n\taddTreeRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirementsInTree;\n\t\tfor (const item of items) runtimeRequirements.add(item);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetModuleRuntimeRequirements(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirements =\n\t\t\tcgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetChunkRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {string} hash\n\t */\n\tgetModuleGraphHash(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? this._getModuleGraphHashWithConnections(cgm, module, runtime)\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {bigint} hash\n\t */\n\tgetModuleGraphHashBigInt(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? BigInt(\n\t\t\t\t\t`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`\n\t\t\t  )\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime);\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {bigint} hash as big int\n\t */\n\t_getModuleGraphHashBigInt(cgm, module, runtime) {\n\t\tif (cgm.graphHashes === undefined) {\n\t\t\tcgm.graphHashes = new RuntimeSpecMap();\n\t\t}\n\t\tconst graphHash = cgm.graphHashes.provide(runtime, () => {\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\thash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\t\t\tconst sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n\t\t\tif (sourceTypes !== undefined) {\n\t\t\t\tfor (const type of sourceTypes) hash.update(type);\n\t\t\t}\n\t\t\tthis.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n\t\t\treturn BigInt(`0x${/** @type {string} */ (hash.digest(\"hex\"))}`);\n\t\t});\n\t\treturn graphHash;\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\t_getModuleGraphHashWithConnections(cgm, module, runtime) {\n\t\tif (cgm.graphHashesWithConnections === undefined) {\n\t\t\tcgm.graphHashesWithConnections = new RuntimeSpecMap();\n\t\t}\n\t\tconst activeStateToString = state => {\n\t\t\tif (state === false) return \"F\";\n\t\t\tif (state === true) return \"T\";\n\t\t\tif (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n\t\t\tthrow new Error(\"Not implemented active state\");\n\t\t};\n\t\tconst strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n\t\treturn cgm.graphHashesWithConnections.provide(runtime, () => {\n\t\t\tconst graphHash = this._getModuleGraphHashBigInt(\n\t\t\t\tcgm,\n\t\t\t\tmodule,\n\t\t\t\truntime\n\t\t\t).toString(16);\n\t\t\tconst connections = this.moduleGraph.getOutgoingConnections(module);\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst activeNamespaceModules = new Set();\n\t\t\t/** @type {Map<string, Module | Set<Module>>} */\n\t\t\tconst connectedModules = new Map();\n\t\t\tconst processConnection = (connection, stateInfo) => {\n\t\t\t\tconst module = connection.module;\n\t\t\t\tstateInfo += module.getExportsType(this.moduleGraph, strict);\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tif (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);\n\t\t\t\telse {\n\t\t\t\t\tconst oldModule = connectedModules.get(stateInfo);\n\t\t\t\t\tif (oldModule === undefined) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, module);\n\t\t\t\t\t} else if (oldModule instanceof Set) {\n\t\t\t\t\t\toldModule.add(module);\n\t\t\t\t\t} else if (oldModule !== module) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, new Set([oldModule, module]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (runtime === undefined || typeof runtime === \"string\") {\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\tprocessConnection(connection, state === true ? \"T\" : \"O\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst states = new Set();\n\t\t\t\t\tlet stateInfo = \"\";\n\t\t\t\t\tforEachRuntime(\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntime => {\n\t\t\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\t\t\tstates.add(state);\n\t\t\t\t\t\t\tstateInfo += activeStateToString(state) + runtime;\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tif (states.size === 1) {\n\t\t\t\t\t\tconst state = first(states);\n\t\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\t\tstateInfo = activeStateToString(state);\n\t\t\t\t\t}\n\t\t\t\t\tprocessConnection(connection, stateInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cspell:word Tnamespace\n\t\t\tif (activeNamespaceModules.size === 0 && connectedModules.size === 0)\n\t\t\t\treturn graphHash;\n\t\t\tconst connectedModulesInOrder =\n\t\t\t\tconnectedModules.size > 1\n\t\t\t\t\t? Array.from(connectedModules).sort(([a], [b]) => (a < b ? -1 : 1))\n\t\t\t\t\t: connectedModules;\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\tconst addModuleToHash = module => {\n\t\t\t\thash.update(\n\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\tthis._getChunkGraphModule(module),\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntime\n\t\t\t\t\t).toString(16)\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst addModulesToHash = modules => {\n\t\t\t\tlet xor = ZERO_BIG_INT;\n\t\t\t\tfor (const m of modules) {\n\t\t\t\t\txor =\n\t\t\t\t\t\txor ^\n\t\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\t\tthis._getChunkGraphModule(m),\n\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\thash.update(xor.toString(16));\n\t\t\t};\n\t\t\tif (activeNamespaceModules.size === 1)\n\t\t\t\taddModuleToHash(activeNamespaceModules.values().next().value);\n\t\t\telse if (activeNamespaceModules.size > 1)\n\t\t\t\taddModulesToHash(activeNamespaceModules);\n\t\t\tfor (const [stateInfo, modules] of connectedModulesInOrder) {\n\t\t\t\thash.update(stateInfo);\n\t\t\t\tif (modules instanceof Set) {\n\t\t\t\t\taddModulesToHash(modules);\n\t\t\t\t} else {\n\t\t\t\t\taddModuleToHash(modules);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.update(graphHash);\n\t\t\treturn /** @type {string} */ (hash.digest(\"hex\"));\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetTreeRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeRequirementsInTree;\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n\t\tif (fn) return fn(module);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tmodule => {\n\t\t\t\tconst chunkGraph = chunkGraphForModuleMap.get(module);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n\t\treturn newFn(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForModule(module, chunkGraph) {\n\t\tchunkGraphForModuleMap.set(module, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForModule(module) {\n\t\tchunkGraphForModuleMap.delete(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n\t\tif (fn) return fn(chunk);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tchunk => {\n\t\t\t\tconst chunkGraph = chunkGraphForChunkMap.get(chunk);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n\t\treturn newFn(chunk);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForChunk(chunk, chunkGraph) {\n\t\tchunkGraphForChunkMap.set(chunk, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForChunk(chunk) {\n\t\tchunkGraphForChunkMap.delete(chunk);\n\t}\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\n\nmodule.exports = ChunkGraph;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}