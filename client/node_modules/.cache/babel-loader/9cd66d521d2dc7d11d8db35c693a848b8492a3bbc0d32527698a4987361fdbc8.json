{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  join,\n  dirname,\n  readJson\n} = require(\"../util/fs\");\n\n/** @typedef {import(\"../util/fs\").InputFileSystem} InputFileSystem */\n\n// Extreme shorthand only for github. eg: foo/bar\nconst RE_URL_GITHUB_EXTREME_SHORT = /^[^/@:.\\s][^/@:\\s]*\\/[^@:\\s]*[^/@:\\s]#\\S+/;\n\n// Short url with specific protocol. eg: github:foo/bar\nconst RE_GIT_URL_SHORT = /^(github|gitlab|bitbucket|gist):\\/?[^/.]+\\/?/i;\n\n// Currently supported protocols\nconst RE_PROTOCOL = /^((git\\+)?(ssh|https?|file)|git|github|gitlab|bitbucket|gist):$/i;\n\n// Has custom protocol\nconst RE_CUSTOM_PROTOCOL = /^((git\\+)?(ssh|https?|file)|git):\\/\\//i;\n\n// Valid hash format for npm / yarn ...\nconst RE_URL_HASH_VERSION = /#(?:semver:)?(.+)/;\n\n// Simple hostname validate\nconst RE_HOSTNAME = /^(?:[^/.]+(\\.[^/]+)+|localhost)$/;\n\n// For hostname with colon. eg: ssh://user@github.com:foo/bar\nconst RE_HOSTNAME_WITH_COLON = /([^/@#:.]+(?:\\.[^/@#:.]+)+|localhost):([^#/0-9]+)/;\n\n// Reg for url without protocol\nconst RE_NO_PROTOCOL = /^([^/@#:.]+(?:\\.[^/@#:.]+)+)/;\n\n// RegExp for version string\nconst VERSION_PATTERN_REGEXP = /^([\\d^=v<>~]|[*xX]$)/;\n\n// Specific protocol for short url without normal hostname\nconst PROTOCOLS_FOR_SHORT = [\"github:\", \"gitlab:\", \"bitbucket:\", \"gist:\", \"file:\"];\n\n// Default protocol for git url\nconst DEF_GIT_PROTOCOL = \"git+ssh://\";\n\n// thanks to https://github.com/npm/hosted-git-info/blob/latest/git-host-info.js\nconst extractCommithashByDomain = {\n  \"github.com\": (pathname, hash) => {\n    let [, user, project, type, commithash] = pathname.split(\"/\", 5);\n    if (type && type !== \"tree\") {\n      return;\n    }\n    if (!type) {\n      commithash = hash;\n    } else {\n      commithash = \"#\" + commithash;\n    }\n    if (project && project.endsWith(\".git\")) {\n      project = project.slice(0, -4);\n    }\n    if (!user || !project) {\n      return;\n    }\n    return commithash;\n  },\n  \"gitlab.com\": (pathname, hash) => {\n    const path = pathname.slice(1);\n    if (path.includes(\"/-/\") || path.includes(\"/archive.tar.gz\")) {\n      return;\n    }\n    const segments = path.split(\"/\");\n    let project = segments.pop();\n    if (project.endsWith(\".git\")) {\n      project = project.slice(0, -4);\n    }\n    const user = segments.join(\"/\");\n    if (!user || !project) {\n      return;\n    }\n    return hash;\n  },\n  \"bitbucket.org\": (pathname, hash) => {\n    let [, user, project, aux] = pathname.split(\"/\", 4);\n    if ([\"get\"].includes(aux)) {\n      return;\n    }\n    if (project && project.endsWith(\".git\")) {\n      project = project.slice(0, -4);\n    }\n    if (!user || !project) {\n      return;\n    }\n    return hash;\n  },\n  \"gist.github.com\": (pathname, hash) => {\n    let [, user, project, aux] = pathname.split(\"/\", 4);\n    if (aux === \"raw\") {\n      return;\n    }\n    if (!project) {\n      if (!user) {\n        return;\n      }\n      project = user;\n      user = null;\n    }\n    if (project.endsWith(\".git\")) {\n      project = project.slice(0, -4);\n    }\n    return hash;\n  }\n};\n\n/**\n * extract commit hash from parsed url\n *\n * @inner\n * @param {Object} urlParsed parsed url\n * @returns {string} commithash\n */\nfunction getCommithash(urlParsed) {\n  let {\n    hostname,\n    pathname,\n    hash\n  } = urlParsed;\n  hostname = hostname.replace(/^www\\./, \"\");\n  try {\n    hash = decodeURIComponent(hash);\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  if (extractCommithashByDomain[hostname]) {\n    return extractCommithashByDomain[hostname](pathname, hash) || \"\";\n  }\n  return hash;\n}\n\n/**\n * make url right for URL parse\n *\n * @inner\n * @param {string} gitUrl git url\n * @returns {string} fixed url\n */\nfunction correctUrl(gitUrl) {\n  // like:\n  // proto://hostname.com:user/repo -> proto://hostname.com/user/repo\n  return gitUrl.replace(RE_HOSTNAME_WITH_COLON, \"$1/$2\");\n}\n\n/**\n * make url protocol right for URL parse\n *\n * @inner\n * @param {string} gitUrl git url\n * @returns {string} fixed url\n */\nfunction correctProtocol(gitUrl) {\n  // eg: github:foo/bar#v1.0. Should not add double slash, in case of error parsed `pathname`\n  if (RE_GIT_URL_SHORT.test(gitUrl)) {\n    return gitUrl;\n  }\n\n  // eg: user@github.com:foo/bar\n  if (!RE_CUSTOM_PROTOCOL.test(gitUrl)) {\n    return `${DEF_GIT_PROTOCOL}${gitUrl}`;\n  }\n  return gitUrl;\n}\n\n/**\n * extract git dep version from hash\n *\n * @inner\n * @param {string} hash hash\n * @returns {string} git dep version\n */\nfunction getVersionFromHash(hash) {\n  const matched = hash.match(RE_URL_HASH_VERSION);\n  return matched && matched[1] || \"\";\n}\n\n/**\n * if string can be decoded\n *\n * @inner\n * @param {string} str str to be checked\n * @returns {boolean} if can be decoded\n */\nfunction canBeDecoded(str) {\n  try {\n    decodeURIComponent(str);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * get right dep version from git url\n *\n * @inner\n * @param {string} gitUrl git url\n * @returns {string} dep version\n */\nfunction getGitUrlVersion(gitUrl) {\n  let oriGitUrl = gitUrl;\n  // github extreme shorthand\n  if (RE_URL_GITHUB_EXTREME_SHORT.test(gitUrl)) {\n    gitUrl = \"github:\" + gitUrl;\n  } else {\n    gitUrl = correctProtocol(gitUrl);\n  }\n  gitUrl = correctUrl(gitUrl);\n  let parsed;\n  try {\n    parsed = new URL(gitUrl);\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  if (!parsed) {\n    return \"\";\n  }\n  const {\n    protocol,\n    hostname,\n    pathname,\n    username,\n    password\n  } = parsed;\n  if (!RE_PROTOCOL.test(protocol)) {\n    return \"\";\n  }\n\n  // pathname shouldn't be empty or URL malformed\n  if (!pathname || !canBeDecoded(pathname)) {\n    return \"\";\n  }\n\n  // without protocol, there should have auth info\n  if (RE_NO_PROTOCOL.test(oriGitUrl) && !username && !password) {\n    return \"\";\n  }\n  if (!PROTOCOLS_FOR_SHORT.includes(protocol.toLowerCase())) {\n    if (!RE_HOSTNAME.test(hostname)) {\n      return \"\";\n    }\n    const commithash = getCommithash(parsed);\n    return getVersionFromHash(commithash) || commithash;\n  }\n\n  // for protocol short\n  return getVersionFromHash(gitUrl);\n}\n\n/**\n * @param {string} str maybe required version\n * @returns {boolean} true, if it looks like a version\n */\nfunction isRequiredVersion(str) {\n  return VERSION_PATTERN_REGEXP.test(str);\n}\nexports.isRequiredVersion = isRequiredVersion;\n\n/**\n * @see https://docs.npmjs.com/cli/v7/configuring-npm/package-json#urls-as-dependencies\n * @param {string} versionDesc version to be normalized\n * @returns {string} normalized version\n */\nfunction normalizeVersion(versionDesc) {\n  versionDesc = versionDesc && versionDesc.trim() || \"\";\n  if (isRequiredVersion(versionDesc)) {\n    return versionDesc;\n  }\n\n  // add handle for URL Dependencies\n  return getGitUrlVersion(versionDesc.toLowerCase());\n}\nexports.normalizeVersion = normalizeVersion;\n\n/**\n *\n * @param {InputFileSystem} fs file system\n * @param {string} directory directory to start looking into\n * @param {string[]} descriptionFiles possible description filenames\n * @param {function((Error | null)=, {data: object, path: string}=): void} callback callback\n */\nconst getDescriptionFile = (fs, directory, descriptionFiles, callback) => {\n  let i = 0;\n  const tryLoadCurrent = () => {\n    if (i >= descriptionFiles.length) {\n      const parentDirectory = dirname(fs, directory);\n      if (!parentDirectory || parentDirectory === directory) return callback();\n      return getDescriptionFile(fs, parentDirectory, descriptionFiles, callback);\n    }\n    const filePath = join(fs, directory, descriptionFiles[i]);\n    readJson(fs, filePath, (err, data) => {\n      if (err) {\n        if (\"code\" in err && err.code === \"ENOENT\") {\n          i++;\n          return tryLoadCurrent();\n        }\n        return callback(err);\n      }\n      if (!data || typeof data !== \"object\" || Array.isArray(data)) {\n        return callback(new Error(`Description file ${filePath} is not an object`));\n      }\n      callback(null, {\n        data,\n        path: filePath\n      });\n    });\n  };\n  tryLoadCurrent();\n};\nexports.getDescriptionFile = getDescriptionFile;\nexports.getRequiredVersionFromDescriptionFile = (data, packageName) => {\n  if (data.optionalDependencies && typeof data.optionalDependencies === \"object\" && packageName in data.optionalDependencies) {\n    return normalizeVersion(data.optionalDependencies[packageName]);\n  }\n  if (data.dependencies && typeof data.dependencies === \"object\" && packageName in data.dependencies) {\n    return normalizeVersion(data.dependencies[packageName]);\n  }\n  if (data.peerDependencies && typeof data.peerDependencies === \"object\" && packageName in data.peerDependencies) {\n    return normalizeVersion(data.peerDependencies[packageName]);\n  }\n  if (data.devDependencies && typeof data.devDependencies === \"object\" && packageName in data.devDependencies) {\n    return normalizeVersion(data.devDependencies[packageName]);\n  }\n};","map":{"version":3,"names":["join","dirname","readJson","require","RE_URL_GITHUB_EXTREME_SHORT","RE_GIT_URL_SHORT","RE_PROTOCOL","RE_CUSTOM_PROTOCOL","RE_URL_HASH_VERSION","RE_HOSTNAME","RE_HOSTNAME_WITH_COLON","RE_NO_PROTOCOL","VERSION_PATTERN_REGEXP","PROTOCOLS_FOR_SHORT","DEF_GIT_PROTOCOL","extractCommithashByDomain","github.com","pathname","hash","user","project","type","commithash","split","endsWith","slice","gitlab.com","path","includes","segments","pop","bitbucket.org","aux","gist.github.com","getCommithash","urlParsed","hostname","replace","decodeURIComponent","e","correctUrl","gitUrl","correctProtocol","test","getVersionFromHash","matched","match","canBeDecoded","str","getGitUrlVersion","oriGitUrl","parsed","URL","protocol","username","password","toLowerCase","isRequiredVersion","exports","normalizeVersion","versionDesc","trim","getDescriptionFile","fs","directory","descriptionFiles","callback","i","tryLoadCurrent","length","parentDirectory","filePath","err","data","code","Array","isArray","Error","getRequiredVersionFromDescriptionFile","packageName","optionalDependencies","dependencies","peerDependencies","devDependencies"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/sharing/utils.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { join, dirname, readJson } = require(\"../util/fs\");\n\n/** @typedef {import(\"../util/fs\").InputFileSystem} InputFileSystem */\n\n// Extreme shorthand only for github. eg: foo/bar\nconst RE_URL_GITHUB_EXTREME_SHORT = /^[^/@:.\\s][^/@:\\s]*\\/[^@:\\s]*[^/@:\\s]#\\S+/;\n\n// Short url with specific protocol. eg: github:foo/bar\nconst RE_GIT_URL_SHORT = /^(github|gitlab|bitbucket|gist):\\/?[^/.]+\\/?/i;\n\n// Currently supported protocols\nconst RE_PROTOCOL =\n\t/^((git\\+)?(ssh|https?|file)|git|github|gitlab|bitbucket|gist):$/i;\n\n// Has custom protocol\nconst RE_CUSTOM_PROTOCOL = /^((git\\+)?(ssh|https?|file)|git):\\/\\//i;\n\n// Valid hash format for npm / yarn ...\nconst RE_URL_HASH_VERSION = /#(?:semver:)?(.+)/;\n\n// Simple hostname validate\nconst RE_HOSTNAME = /^(?:[^/.]+(\\.[^/]+)+|localhost)$/;\n\n// For hostname with colon. eg: ssh://user@github.com:foo/bar\nconst RE_HOSTNAME_WITH_COLON =\n\t/([^/@#:.]+(?:\\.[^/@#:.]+)+|localhost):([^#/0-9]+)/;\n\n// Reg for url without protocol\nconst RE_NO_PROTOCOL = /^([^/@#:.]+(?:\\.[^/@#:.]+)+)/;\n\n// RegExp for version string\nconst VERSION_PATTERN_REGEXP = /^([\\d^=v<>~]|[*xX]$)/;\n\n// Specific protocol for short url without normal hostname\nconst PROTOCOLS_FOR_SHORT = [\n\t\"github:\",\n\t\"gitlab:\",\n\t\"bitbucket:\",\n\t\"gist:\",\n\t\"file:\"\n];\n\n// Default protocol for git url\nconst DEF_GIT_PROTOCOL = \"git+ssh://\";\n\n// thanks to https://github.com/npm/hosted-git-info/blob/latest/git-host-info.js\nconst extractCommithashByDomain = {\n\t\"github.com\": (pathname, hash) => {\n\t\tlet [, user, project, type, commithash] = pathname.split(\"/\", 5);\n\t\tif (type && type !== \"tree\") {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!type) {\n\t\t\tcommithash = hash;\n\t\t} else {\n\t\t\tcommithash = \"#\" + commithash;\n\t\t}\n\n\t\tif (project && project.endsWith(\".git\")) {\n\t\t\tproject = project.slice(0, -4);\n\t\t}\n\n\t\tif (!user || !project) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn commithash;\n\t},\n\t\"gitlab.com\": (pathname, hash) => {\n\t\tconst path = pathname.slice(1);\n\t\tif (path.includes(\"/-/\") || path.includes(\"/archive.tar.gz\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst segments = path.split(\"/\");\n\t\tlet project = segments.pop();\n\t\tif (project.endsWith(\".git\")) {\n\t\t\tproject = project.slice(0, -4);\n\t\t}\n\n\t\tconst user = segments.join(\"/\");\n\t\tif (!user || !project) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn hash;\n\t},\n\t\"bitbucket.org\": (pathname, hash) => {\n\t\tlet [, user, project, aux] = pathname.split(\"/\", 4);\n\t\tif ([\"get\"].includes(aux)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (project && project.endsWith(\".git\")) {\n\t\t\tproject = project.slice(0, -4);\n\t\t}\n\n\t\tif (!user || !project) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn hash;\n\t},\n\t\"gist.github.com\": (pathname, hash) => {\n\t\tlet [, user, project, aux] = pathname.split(\"/\", 4);\n\t\tif (aux === \"raw\") {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!project) {\n\t\t\tif (!user) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tproject = user;\n\t\t\tuser = null;\n\t\t}\n\n\t\tif (project.endsWith(\".git\")) {\n\t\t\tproject = project.slice(0, -4);\n\t\t}\n\n\t\treturn hash;\n\t}\n};\n\n/**\n * extract commit hash from parsed url\n *\n * @inner\n * @param {Object} urlParsed parsed url\n * @returns {string} commithash\n */\nfunction getCommithash(urlParsed) {\n\tlet { hostname, pathname, hash } = urlParsed;\n\thostname = hostname.replace(/^www\\./, \"\");\n\n\ttry {\n\t\thash = decodeURIComponent(hash);\n\t\t// eslint-disable-next-line no-empty\n\t} catch (e) {}\n\n\tif (extractCommithashByDomain[hostname]) {\n\t\treturn extractCommithashByDomain[hostname](pathname, hash) || \"\";\n\t}\n\n\treturn hash;\n}\n\n/**\n * make url right for URL parse\n *\n * @inner\n * @param {string} gitUrl git url\n * @returns {string} fixed url\n */\nfunction correctUrl(gitUrl) {\n\t// like:\n\t// proto://hostname.com:user/repo -> proto://hostname.com/user/repo\n\treturn gitUrl.replace(RE_HOSTNAME_WITH_COLON, \"$1/$2\");\n}\n\n/**\n * make url protocol right for URL parse\n *\n * @inner\n * @param {string} gitUrl git url\n * @returns {string} fixed url\n */\nfunction correctProtocol(gitUrl) {\n\t// eg: github:foo/bar#v1.0. Should not add double slash, in case of error parsed `pathname`\n\tif (RE_GIT_URL_SHORT.test(gitUrl)) {\n\t\treturn gitUrl;\n\t}\n\n\t// eg: user@github.com:foo/bar\n\tif (!RE_CUSTOM_PROTOCOL.test(gitUrl)) {\n\t\treturn `${DEF_GIT_PROTOCOL}${gitUrl}`;\n\t}\n\n\treturn gitUrl;\n}\n\n/**\n * extract git dep version from hash\n *\n * @inner\n * @param {string} hash hash\n * @returns {string} git dep version\n */\nfunction getVersionFromHash(hash) {\n\tconst matched = hash.match(RE_URL_HASH_VERSION);\n\n\treturn (matched && matched[1]) || \"\";\n}\n\n/**\n * if string can be decoded\n *\n * @inner\n * @param {string} str str to be checked\n * @returns {boolean} if can be decoded\n */\nfunction canBeDecoded(str) {\n\ttry {\n\t\tdecodeURIComponent(str);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * get right dep version from git url\n *\n * @inner\n * @param {string} gitUrl git url\n * @returns {string} dep version\n */\nfunction getGitUrlVersion(gitUrl) {\n\tlet oriGitUrl = gitUrl;\n\t// github extreme shorthand\n\tif (RE_URL_GITHUB_EXTREME_SHORT.test(gitUrl)) {\n\t\tgitUrl = \"github:\" + gitUrl;\n\t} else {\n\t\tgitUrl = correctProtocol(gitUrl);\n\t}\n\n\tgitUrl = correctUrl(gitUrl);\n\n\tlet parsed;\n\ttry {\n\t\tparsed = new URL(gitUrl);\n\t\t// eslint-disable-next-line no-empty\n\t} catch (e) {}\n\n\tif (!parsed) {\n\t\treturn \"\";\n\t}\n\n\tconst { protocol, hostname, pathname, username, password } = parsed;\n\tif (!RE_PROTOCOL.test(protocol)) {\n\t\treturn \"\";\n\t}\n\n\t// pathname shouldn't be empty or URL malformed\n\tif (!pathname || !canBeDecoded(pathname)) {\n\t\treturn \"\";\n\t}\n\n\t// without protocol, there should have auth info\n\tif (RE_NO_PROTOCOL.test(oriGitUrl) && !username && !password) {\n\t\treturn \"\";\n\t}\n\n\tif (!PROTOCOLS_FOR_SHORT.includes(protocol.toLowerCase())) {\n\t\tif (!RE_HOSTNAME.test(hostname)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tconst commithash = getCommithash(parsed);\n\t\treturn getVersionFromHash(commithash) || commithash;\n\t}\n\n\t// for protocol short\n\treturn getVersionFromHash(gitUrl);\n}\n\n/**\n * @param {string} str maybe required version\n * @returns {boolean} true, if it looks like a version\n */\nfunction isRequiredVersion(str) {\n\treturn VERSION_PATTERN_REGEXP.test(str);\n}\n\nexports.isRequiredVersion = isRequiredVersion;\n\n/**\n * @see https://docs.npmjs.com/cli/v7/configuring-npm/package-json#urls-as-dependencies\n * @param {string} versionDesc version to be normalized\n * @returns {string} normalized version\n */\nfunction normalizeVersion(versionDesc) {\n\tversionDesc = (versionDesc && versionDesc.trim()) || \"\";\n\n\tif (isRequiredVersion(versionDesc)) {\n\t\treturn versionDesc;\n\t}\n\n\t// add handle for URL Dependencies\n\treturn getGitUrlVersion(versionDesc.toLowerCase());\n}\n\nexports.normalizeVersion = normalizeVersion;\n\n/**\n *\n * @param {InputFileSystem} fs file system\n * @param {string} directory directory to start looking into\n * @param {string[]} descriptionFiles possible description filenames\n * @param {function((Error | null)=, {data: object, path: string}=): void} callback callback\n */\nconst getDescriptionFile = (fs, directory, descriptionFiles, callback) => {\n\tlet i = 0;\n\tconst tryLoadCurrent = () => {\n\t\tif (i >= descriptionFiles.length) {\n\t\t\tconst parentDirectory = dirname(fs, directory);\n\t\t\tif (!parentDirectory || parentDirectory === directory) return callback();\n\t\t\treturn getDescriptionFile(\n\t\t\t\tfs,\n\t\t\t\tparentDirectory,\n\t\t\t\tdescriptionFiles,\n\t\t\t\tcallback\n\t\t\t);\n\t\t}\n\t\tconst filePath = join(fs, directory, descriptionFiles[i]);\n\t\treadJson(fs, filePath, (err, data) => {\n\t\t\tif (err) {\n\t\t\t\tif (\"code\" in err && err.code === \"ENOENT\") {\n\t\t\t\t\ti++;\n\t\t\t\t\treturn tryLoadCurrent();\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tif (!data || typeof data !== \"object\" || Array.isArray(data)) {\n\t\t\t\treturn callback(\n\t\t\t\t\tnew Error(`Description file ${filePath} is not an object`)\n\t\t\t\t);\n\t\t\t}\n\t\t\tcallback(null, { data, path: filePath });\n\t\t});\n\t};\n\ttryLoadCurrent();\n};\nexports.getDescriptionFile = getDescriptionFile;\n\nexports.getRequiredVersionFromDescriptionFile = (data, packageName) => {\n\tif (\n\t\tdata.optionalDependencies &&\n\t\ttypeof data.optionalDependencies === \"object\" &&\n\t\tpackageName in data.optionalDependencies\n\t) {\n\t\treturn normalizeVersion(data.optionalDependencies[packageName]);\n\t}\n\tif (\n\t\tdata.dependencies &&\n\t\ttypeof data.dependencies === \"object\" &&\n\t\tpackageName in data.dependencies\n\t) {\n\t\treturn normalizeVersion(data.dependencies[packageName]);\n\t}\n\tif (\n\t\tdata.peerDependencies &&\n\t\ttypeof data.peerDependencies === \"object\" &&\n\t\tpackageName in data.peerDependencies\n\t) {\n\t\treturn normalizeVersion(data.peerDependencies[packageName]);\n\t}\n\tif (\n\t\tdata.devDependencies &&\n\t\ttypeof data.devDependencies === \"object\" &&\n\t\tpackageName in data.devDependencies\n\t) {\n\t\treturn normalizeVersion(data.devDependencies[packageName]);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}