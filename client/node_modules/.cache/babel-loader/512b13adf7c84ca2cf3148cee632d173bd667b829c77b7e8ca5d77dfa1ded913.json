{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_DYNAMIC,\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"./ModuleTypeConstants\");\nconst CachedConstDependency = require(\"./dependencies/CachedConstDependency\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst {\n  evaluateToString\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst {\n  parseResource\n} = require(\"./util/identifier\");\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nconst collectDeclaration = (declarations, pattern) => {\n  const stack = [pattern];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    switch (node.type) {\n      case \"Identifier\":\n        declarations.add(node.name);\n        break;\n      case \"ArrayPattern\":\n        for (const element of node.elements) {\n          if (element) {\n            stack.push(element);\n          }\n        }\n        break;\n      case \"AssignmentPattern\":\n        stack.push(node.left);\n        break;\n      case \"ObjectPattern\":\n        for (const property of node.properties) {\n          stack.push(property.value);\n        }\n        break;\n      case \"RestElement\":\n        stack.push(node.argument);\n        break;\n    }\n  }\n};\nconst getHoistedDeclarations = (branch, includeFunctionDeclarations) => {\n  const declarations = new Set();\n  const stack = [branch];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    // Some node could be `null` or `undefined`.\n    if (!node) continue;\n    switch (node.type) {\n      // Walk through control statements to look for hoisted declarations.\n      // Some branches are skipped since they do not allow declarations.\n      case \"BlockStatement\":\n        for (const stmt of node.body) {\n          stack.push(stmt);\n        }\n        break;\n      case \"IfStatement\":\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n        break;\n      case \"ForStatement\":\n        stack.push(node.init);\n        stack.push(node.body);\n        break;\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        stack.push(node.left);\n        stack.push(node.body);\n        break;\n      case \"DoWhileStatement\":\n      case \"WhileStatement\":\n      case \"LabeledStatement\":\n        stack.push(node.body);\n        break;\n      case \"SwitchStatement\":\n        for (const cs of node.cases) {\n          for (const consequent of cs.consequent) {\n            stack.push(consequent);\n          }\n        }\n        break;\n      case \"TryStatement\":\n        stack.push(node.block);\n        if (node.handler) {\n          stack.push(node.handler.body);\n        }\n        stack.push(node.finalizer);\n        break;\n      case \"FunctionDeclaration\":\n        if (includeFunctionDeclarations) {\n          collectDeclaration(declarations, node.id);\n        }\n        break;\n      case \"VariableDeclaration\":\n        if (node.kind === \"var\") {\n          for (const decl of node.declarations) {\n            collectDeclaration(declarations, decl.id);\n          }\n        }\n        break;\n    }\n  }\n  return Array.from(declarations);\n};\nconst PLUGIN_NAME = \"ConstPlugin\";\nclass ConstPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const cachedParseResource = parseResource.bindCache(compiler.root);\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      compilation.dependencyTemplates.set(CachedConstDependency, new CachedConstDependency.Template());\n      const handler = parser => {\n        parser.hooks.statementIf.tap(PLUGIN_NAME, statement => {\n          if (parser.scope.isAsmJs) return;\n          const param = parser.evaluateExpression(statement.test);\n          const bool = param.asBool();\n          if (typeof bool === \"boolean\") {\n            if (!param.couldHaveSideEffects()) {\n              const dep = new ConstDependency(`${bool}`, param.range);\n              dep.loc = statement.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            } else {\n              parser.walkExpression(statement.test);\n            }\n            const branchToRemove = bool ? statement.alternate : statement.consequent;\n            if (branchToRemove) {\n              // Before removing the dead branch, the hoisted declarations\n              // must be collected.\n              //\n              // Given the following code:\n              //\n              //     if (true) f() else g()\n              //     if (false) {\n              //       function f() {}\n              //       const g = function g() {}\n              //       if (someTest) {\n              //         let a = 1\n              //         var x, {y, z} = obj\n              //       }\n              //     } else {\n              //       …\n              //     }\n              //\n              // the generated code is:\n              //\n              //     if (true) f() else {}\n              //     if (false) {\n              //       var f, x, y, z;   (in loose mode)\n              //       var x, y, z;      (in strict mode)\n              //     } else {\n              //       …\n              //     }\n              //\n              // NOTE: When code runs in strict mode, `var` declarations\n              // are hoisted but `function` declarations don't.\n              //\n              let declarations;\n              if (parser.scope.isStrict) {\n                // If the code runs in strict mode, variable declarations\n                // using `var` must be hoisted.\n                declarations = getHoistedDeclarations(branchToRemove, false);\n              } else {\n                // Otherwise, collect all hoisted declaration.\n                declarations = getHoistedDeclarations(branchToRemove, true);\n              }\n              let replacement;\n              if (declarations.length > 0) {\n                replacement = `{ var ${declarations.join(\", \")}; }`;\n              } else {\n                replacement = \"{}\";\n              }\n              const dep = new ConstDependency(replacement, branchToRemove.range);\n              dep.loc = branchToRemove.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            }\n            return bool;\n          }\n        });\n        parser.hooks.expressionConditionalOperator.tap(PLUGIN_NAME, expression => {\n          if (parser.scope.isAsmJs) return;\n          const param = parser.evaluateExpression(expression.test);\n          const bool = param.asBool();\n          if (typeof bool === \"boolean\") {\n            if (!param.couldHaveSideEffects()) {\n              const dep = new ConstDependency(` ${bool}`, param.range);\n              dep.loc = expression.loc;\n              parser.state.module.addPresentationalDependency(dep);\n            } else {\n              parser.walkExpression(expression.test);\n            }\n            // Expressions do not hoist.\n            // It is safe to remove the dead branch.\n            //\n            // Given the following code:\n            //\n            //   false ? someExpression() : otherExpression();\n            //\n            // the generated code is:\n            //\n            //   false ? 0 : otherExpression();\n            //\n            const branchToRemove = bool ? expression.alternate : expression.consequent;\n            const dep = new ConstDependency(\"0\", branchToRemove.range);\n            dep.loc = branchToRemove.loc;\n            parser.state.module.addPresentationalDependency(dep);\n            return bool;\n          }\n        });\n        parser.hooks.expressionLogicalOperator.tap(PLUGIN_NAME, expression => {\n          if (parser.scope.isAsmJs) return;\n          if (expression.operator === \"&&\" || expression.operator === \"||\") {\n            const param = parser.evaluateExpression(expression.left);\n            const bool = param.asBool();\n            if (typeof bool === \"boolean\") {\n              // Expressions do not hoist.\n              // It is safe to remove the dead branch.\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   falsyExpression() && someExpression();\n              //\n              // the generated code is:\n              //\n              //   falsyExpression() && false;\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   truthyExpression() && someExpression();\n              //\n              // the generated code is:\n              //\n              //   true && someExpression();\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   truthyExpression() || someExpression();\n              //\n              // the generated code is:\n              //\n              //   truthyExpression() || false;\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   falsyExpression() || someExpression();\n              //\n              // the generated code is:\n              //\n              //   false && someExpression();\n              //\n              const keepRight = expression.operator === \"&&\" && bool || expression.operator === \"||\" && !bool;\n              if (!param.couldHaveSideEffects() && (param.isBoolean() || keepRight)) {\n                // for case like\n                //\n                //   return'development'===process.env.NODE_ENV&&'foo'\n                //\n                // we need a space before the bool to prevent result like\n                //\n                //   returnfalse&&'foo'\n                //\n                const dep = new ConstDependency(` ${bool}`, param.range);\n                dep.loc = expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n              } else {\n                parser.walkExpression(expression.left);\n              }\n              if (!keepRight) {\n                const dep = new ConstDependency(\"0\", expression.right.range);\n                dep.loc = expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n              }\n              return keepRight;\n            }\n          } else if (expression.operator === \"??\") {\n            const param = parser.evaluateExpression(expression.left);\n            const keepRight = param.asNullish();\n            if (typeof keepRight === \"boolean\") {\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   nonNullish ?? someExpression();\n              //\n              // the generated code is:\n              //\n              //   nonNullish ?? 0;\n              //\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   nullish ?? someExpression();\n              //\n              // the generated code is:\n              //\n              //   null ?? someExpression();\n              //\n              if (!param.couldHaveSideEffects() && keepRight) {\n                // cspell:word returnnull\n                // for case like\n                //\n                //   return('development'===process.env.NODE_ENV&&null)??'foo'\n                //\n                // we need a space before the bool to prevent result like\n                //\n                //   returnnull??'foo'\n                //\n                const dep = new ConstDependency(\" null\", param.range);\n                dep.loc = expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n              } else {\n                const dep = new ConstDependency(\"0\", expression.right.range);\n                dep.loc = expression.loc;\n                parser.state.module.addPresentationalDependency(dep);\n                parser.walkExpression(expression.left);\n              }\n              return keepRight;\n            }\n          }\n        });\n        parser.hooks.optionalChaining.tap(PLUGIN_NAME, expr => {\n          /** @type {ExpressionNode[]} */\n          const optionalExpressionsStack = [];\n          /** @type {ExpressionNode|SuperNode} */\n          let next = expr.expression;\n          while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n            if (next.type === \"MemberExpression\") {\n              if (next.optional) {\n                // SuperNode can not be optional\n                optionalExpressionsStack.push( /** @type {ExpressionNode} */next.object);\n              }\n              next = next.object;\n            } else {\n              if (next.optional) {\n                // SuperNode can not be optional\n                optionalExpressionsStack.push( /** @type {ExpressionNode} */next.callee);\n              }\n              next = next.callee;\n            }\n          }\n          while (optionalExpressionsStack.length) {\n            const expression = optionalExpressionsStack.pop();\n            const evaluated = parser.evaluateExpression(expression);\n            if (evaluated.asNullish()) {\n              // ------------------------------------------\n              //\n              // Given the following code:\n              //\n              //   nullishMemberChain?.a.b();\n              //\n              // the generated code is:\n              //\n              //   undefined;\n              //\n              // ------------------------------------------\n              //\n              const dep = new ConstDependency(\" undefined\", expr.range);\n              dep.loc = expr.loc;\n              parser.state.module.addPresentationalDependency(dep);\n              return true;\n            }\n          }\n        });\n        parser.hooks.evaluateIdentifier.for(\"__resourceQuery\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          return evaluateToString(cachedParseResource(parser.state.module.resource).query)(expr);\n        });\n        parser.hooks.expression.for(\"__resourceQuery\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          const dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).query), expr.range, \"__resourceQuery\");\n          dep.loc = expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n          return true;\n        });\n        parser.hooks.evaluateIdentifier.for(\"__resourceFragment\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          return evaluateToString(cachedParseResource(parser.state.module.resource).fragment)(expr);\n        });\n        parser.hooks.expression.for(\"__resourceFragment\").tap(PLUGIN_NAME, expr => {\n          if (parser.scope.isAsmJs) return;\n          if (!parser.state.module) return;\n          const dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).fragment), expr.range, \"__resourceFragment\");\n          dep.loc = expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n          return true;\n        });\n      };\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, handler);\n    });\n  }\n}\nmodule.exports = ConstPlugin;","map":{"version":3,"names":["JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_DYNAMIC","JAVASCRIPT_MODULE_TYPE_ESM","require","CachedConstDependency","ConstDependency","evaluateToString","parseResource","collectDeclaration","declarations","pattern","stack","length","node","pop","type","add","name","element","elements","push","left","property","properties","value","argument","getHoistedDeclarations","branch","includeFunctionDeclarations","Set","stmt","body","consequent","alternate","init","cs","cases","block","handler","finalizer","id","kind","decl","Array","from","PLUGIN_NAME","ConstPlugin","apply","compiler","cachedParseResource","bindCache","root","hooks","compilation","tap","_ref","normalModuleFactory","dependencyTemplates","set","Template","parser","statementIf","statement","scope","isAsmJs","param","evaluateExpression","test","bool","asBool","couldHaveSideEffects","dep","range","loc","state","module","addPresentationalDependency","walkExpression","branchToRemove","isStrict","replacement","join","expressionConditionalOperator","expression","expressionLogicalOperator","operator","keepRight","isBoolean","right","asNullish","optionalChaining","expr","optionalExpressionsStack","next","optional","object","callee","evaluated","evaluateIdentifier","for","resource","query","JSON","stringify","fragment","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/ConstPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_DYNAMIC,\n\tJAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"./ModuleTypeConstants\");\nconst CachedConstDependency = require(\"./dependencies/CachedConstDependency\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst { evaluateToString } = require(\"./javascript/JavascriptParserHelpers\");\nconst { parseResource } = require(\"./util/identifier\");\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nconst collectDeclaration = (declarations, pattern) => {\n\tconst stack = [pattern];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop();\n\t\tswitch (node.type) {\n\t\t\tcase \"Identifier\":\n\t\t\t\tdeclarations.add(node.name);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tfor (const element of node.elements) {\n\t\t\t\t\tif (element) {\n\t\t\t\t\t\tstack.push(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tfor (const property of node.properties) {\n\t\t\t\t\tstack.push(property.value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tstack.push(node.argument);\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\nconst getHoistedDeclarations = (branch, includeFunctionDeclarations) => {\n\tconst declarations = new Set();\n\tconst stack = [branch];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop();\n\t\t// Some node could be `null` or `undefined`.\n\t\tif (!node) continue;\n\t\tswitch (node.type) {\n\t\t\t// Walk through control statements to look for hoisted declarations.\n\t\t\t// Some branches are skipped since they do not allow declarations.\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tfor (const stmt of node.body) {\n\t\t\t\t\tstack.push(stmt);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tstack.push(node.consequent);\n\t\t\t\tstack.push(node.alternate);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tstack.push(node.init);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\tcase \"WhileStatement\":\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tfor (const cs of node.cases) {\n\t\t\t\t\tfor (const consequent of cs.consequent) {\n\t\t\t\t\t\tstack.push(consequent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tstack.push(node.block);\n\t\t\t\tif (node.handler) {\n\t\t\t\t\tstack.push(node.handler.body);\n\t\t\t\t}\n\t\t\t\tstack.push(node.finalizer);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tif (includeFunctionDeclarations) {\n\t\t\t\t\tcollectDeclaration(declarations, node.id);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tif (node.kind === \"var\") {\n\t\t\t\t\tfor (const decl of node.declarations) {\n\t\t\t\t\t\tcollectDeclaration(declarations, decl.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn Array.from(declarations);\n};\n\nconst PLUGIN_NAME = \"ConstPlugin\";\n\nclass ConstPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedParseResource = parseResource.bindCache(compiler.root);\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tCachedConstDependency,\n\t\t\t\t\tnew CachedConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tparser.hooks.statementIf.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\tconst param = parser.evaluateExpression(statement.test);\n\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\tif (!param.couldHaveSideEffects()) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(`${bool}`, param.range);\n\t\t\t\t\t\t\t\tdep.loc = statement.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.walkExpression(statement.test);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t? statement.alternate\n\t\t\t\t\t\t\t\t: statement.consequent;\n\t\t\t\t\t\t\tif (branchToRemove) {\n\t\t\t\t\t\t\t\t// Before removing the dead branch, the hoisted declarations\n\t\t\t\t\t\t\t\t// must be collected.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else g()\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       function f() {}\n\t\t\t\t\t\t\t\t//       const g = function g() {}\n\t\t\t\t\t\t\t\t//       if (someTest) {\n\t\t\t\t\t\t\t\t//         let a = 1\n\t\t\t\t\t\t\t\t//         var x, {y, z} = obj\n\t\t\t\t\t\t\t\t//       }\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else {}\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       var f, x, y, z;   (in loose mode)\n\t\t\t\t\t\t\t\t//       var x, y, z;      (in strict mode)\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// NOTE: When code runs in strict mode, `var` declarations\n\t\t\t\t\t\t\t\t// are hoisted but `function` declarations don't.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tlet declarations;\n\t\t\t\t\t\t\t\tif (parser.scope.isStrict) {\n\t\t\t\t\t\t\t\t\t// If the code runs in strict mode, variable declarations\n\t\t\t\t\t\t\t\t\t// using `var` must be hoisted.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, false);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Otherwise, collect all hoisted declaration.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet replacement;\n\t\t\t\t\t\t\t\tif (declarations.length > 0) {\n\t\t\t\t\t\t\t\t\treplacement = `{ var ${declarations.join(\", \")}; }`;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treplacement = \"{}\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\treplacement,\n\t\t\t\t\t\t\t\t\tbranchToRemove.range\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = branchToRemove.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expressionConditionalOperator.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.test);\n\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\tif (!param.couldHaveSideEffects()) {\n\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(` ${bool}`, param.range);\n\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.test);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? someExpression() : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? 0 : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t\t? expression.alternate\n\t\t\t\t\t\t\t\t\t: expression.consequent;\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\"0\", branchToRemove.range);\n\t\t\t\t\t\t\t\tdep.loc = branchToRemove.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.expressionLogicalOperator.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\texpression.operator === \"&&\" ||\n\t\t\t\t\t\t\t\texpression.operator === \"||\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.left);\n\t\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   true && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   false && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tconst keepRight =\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"&&\" && bool) ||\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"||\" && !bool);\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!param.couldHaveSideEffects() &&\n\t\t\t\t\t\t\t\t\t\t(param.isBoolean() || keepRight)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t// for case like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   return'development'===process.env.NODE_ENV&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// we need a space before the bool to prevent result like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   returnfalse&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(` ${bool}`, param.range);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.left);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!keepRight) {\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\t\t\t\t\texpression.right.range\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn keepRight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (expression.operator === \"??\") {\n\t\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.left);\n\t\t\t\t\t\t\t\tconst keepRight = param.asNullish();\n\t\t\t\t\t\t\t\tif (typeof keepRight === \"boolean\") {\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nonNullish ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nonNullish ?? 0;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nullish ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   null ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tif (!param.couldHaveSideEffects() && keepRight) {\n\t\t\t\t\t\t\t\t\t\t// cspell:word returnnull\n\t\t\t\t\t\t\t\t\t\t// for case like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   return('development'===process.env.NODE_ENV&&null)??'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// we need a space before the bool to prevent result like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   returnnull??'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\" null\", param.range);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\t\t\t\t\texpression.right.range\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.left);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn keepRight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.optionalChaining.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t/** @type {ExpressionNode[]} */\n\t\t\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t\t\t/** @type {ExpressionNode|SuperNode} */\n\t\t\t\t\t\tlet next = expr.expression;\n\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.object)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.callee)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile (optionalExpressionsStack.length) {\n\t\t\t\t\t\t\tconst expression = optionalExpressionsStack.pop();\n\t\t\t\t\t\t\tconst evaluated = parser.evaluateExpression(expression);\n\n\t\t\t\t\t\t\tif (evaluated.asNullish()) {\n\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   nullishMemberChain?.a.b();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   undefined;\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\" undefined\", expr.range);\n\t\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\treturn evaluateToString(\n\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).query\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\tconst dep = new CachedConstDependency(\n\t\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).query\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\texpr.range,\n\t\t\t\t\t\t\t\t\"__resourceQuery\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t.for(\"__resourceFragment\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\treturn evaluateToString(\n\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).fragment\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"__resourceFragment\")\n\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\tconst dep = new CachedConstDependency(\n\t\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).fragment\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\texpr.range,\n\t\t\t\t\t\t\t\t\"__resourceFragment\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = ConstPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}