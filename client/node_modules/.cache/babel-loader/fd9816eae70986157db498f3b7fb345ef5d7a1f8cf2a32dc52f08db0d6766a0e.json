{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst AMDDefineDependency = require(\"./AMDDefineDependency\");\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst {\n  addLocalModule,\n  getLocalModule\n} = require(\"./LocalModulesHelpers\");\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\nconst isBoundFunctionExpression = expr => {\n  if (expr.type !== \"CallExpression\") return false;\n  if (expr.callee.type !== \"MemberExpression\") return false;\n  if (expr.callee.computed) return false;\n  if (expr.callee.object.type !== \"FunctionExpression\") return false;\n  if (expr.callee.property.type !== \"Identifier\") return false;\n  if (expr.callee.property.name !== \"bind\") return false;\n  return true;\n};\nconst isUnboundFunctionExpression = expr => {\n  if (expr.type === \"FunctionExpression\") return true;\n  if (expr.type === \"ArrowFunctionExpression\") return true;\n  return false;\n};\nconst isCallable = expr => {\n  if (isUnboundFunctionExpression(expr)) return true;\n  if (isBoundFunctionExpression(expr)) return true;\n  return false;\n};\nclass AMDDefineDependencyParserPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n  apply(parser) {\n    parser.hooks.call.for(\"define\").tap(\"AMDDefineDependencyParserPlugin\", this.processCallDefine.bind(this, parser));\n  }\n  processArray(parser, expr, param, identifiers, namedModule) {\n    if (param.isArray()) {\n      param.items.forEach((param, idx) => {\n        if (param.isString() && [\"require\", \"module\", \"exports\"].includes(param.string)) identifiers[idx] = param.string;\n        const result = this.processItem(parser, expr, param, namedModule);\n        if (result === undefined) {\n          this.processContext(parser, expr, param);\n        }\n      });\n      return true;\n    } else if (param.isConstArray()) {\n      const deps = [];\n      param.array.forEach((request, idx) => {\n        let dep;\n        let localModule;\n        if (request === \"require\") {\n          identifiers[idx] = request;\n          dep = RuntimeGlobals.require;\n        } else if ([\"exports\", \"module\"].includes(request)) {\n          identifiers[idx] = request;\n          dep = request;\n        } else if (localModule = getLocalModule(parser.state, request)) {\n          localModule.flagUsed();\n          dep = new LocalModuleDependency(localModule, undefined, false);\n          dep.loc = expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n        } else {\n          dep = this.newRequireItemDependency(request);\n          dep.loc = expr.loc;\n          dep.optional = !!parser.scope.inTry;\n          parser.state.current.addDependency(dep);\n        }\n        deps.push(dep);\n      });\n      const dep = this.newRequireArrayDependency(deps, param.range);\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }\n  }\n  processItem(parser, expr, param, namedModule) {\n    if (param.isConditional()) {\n      param.options.forEach(param => {\n        const result = this.processItem(parser, expr, param);\n        if (result === undefined) {\n          this.processContext(parser, expr, param);\n        }\n      });\n      return true;\n    } else if (param.isString()) {\n      let dep, localModule;\n      if (param.string === \"require\") {\n        dep = new ConstDependency(RuntimeGlobals.require, param.range, [RuntimeGlobals.require]);\n      } else if (param.string === \"exports\") {\n        dep = new ConstDependency(\"exports\", param.range, [RuntimeGlobals.exports]);\n      } else if (param.string === \"module\") {\n        dep = new ConstDependency(\"module\", param.range, [RuntimeGlobals.module]);\n      } else if (localModule = getLocalModule(parser.state, param.string, namedModule)) {\n        localModule.flagUsed();\n        dep = new LocalModuleDependency(localModule, param.range, false);\n      } else {\n        dep = this.newRequireItemDependency(param.string, param.range);\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n      dep.loc = expr.loc;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }\n  }\n  processContext(parser, expr, param) {\n    const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {\n      category: \"amd\"\n    }, parser);\n    if (!dep) return;\n    dep.loc = expr.loc;\n    dep.optional = !!parser.scope.inTry;\n    parser.state.current.addDependency(dep);\n    return true;\n  }\n  processCallDefine(parser, expr) {\n    let array, fn, obj, namedModule;\n    switch (expr.arguments.length) {\n      case 1:\n        if (isCallable(expr.arguments[0])) {\n          // define(f() {…})\n          fn = expr.arguments[0];\n        } else if (expr.arguments[0].type === \"ObjectExpression\") {\n          // define({…})\n          obj = expr.arguments[0];\n        } else {\n          // define(expr)\n          // unclear if function or object\n          obj = fn = expr.arguments[0];\n        }\n        break;\n      case 2:\n        if (expr.arguments[0].type === \"Literal\") {\n          namedModule = expr.arguments[0].value;\n          // define(\"…\", …)\n          if (isCallable(expr.arguments[1])) {\n            // define(\"…\", f() {…})\n            fn = expr.arguments[1];\n          } else if (expr.arguments[1].type === \"ObjectExpression\") {\n            // define(\"…\", {…})\n            obj = expr.arguments[1];\n          } else {\n            // define(\"…\", expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[1];\n          }\n        } else {\n          array = expr.arguments[0];\n          if (isCallable(expr.arguments[1])) {\n            // define([…], f() {})\n            fn = expr.arguments[1];\n          } else if (expr.arguments[1].type === \"ObjectExpression\") {\n            // define([…], {…})\n            obj = expr.arguments[1];\n          } else {\n            // define([…], expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[1];\n          }\n        }\n        break;\n      case 3:\n        // define(\"…\", […], f() {…})\n        namedModule = expr.arguments[0].value;\n        array = expr.arguments[1];\n        if (isCallable(expr.arguments[2])) {\n          // define(\"…\", […], f() {})\n          fn = expr.arguments[2];\n        } else if (expr.arguments[2].type === \"ObjectExpression\") {\n          // define(\"…\", […], {…})\n          obj = expr.arguments[2];\n        } else {\n          // define(\"…\", […], expr)\n          // unclear if function or object\n          obj = fn = expr.arguments[2];\n        }\n        break;\n      default:\n        return;\n    }\n    DynamicExports.bailout(parser.state);\n    let fnParams = null;\n    let fnParamsOffset = 0;\n    if (fn) {\n      if (isUnboundFunctionExpression(fn)) {\n        fnParams = fn.params;\n      } else if (isBoundFunctionExpression(fn)) {\n        fnParams = fn.callee.object.params;\n        fnParamsOffset = fn.arguments.length - 1;\n        if (fnParamsOffset < 0) {\n          fnParamsOffset = 0;\n        }\n      }\n    }\n    let fnRenames = new Map();\n    if (array) {\n      const identifiers = {};\n      const param = parser.evaluateExpression(array);\n      const result = this.processArray(parser, expr, param, identifiers, namedModule);\n      if (!result) return;\n      if (fnParams) {\n        fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n          if (identifiers[idx]) {\n            fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n            return false;\n          }\n          return true;\n        });\n      }\n    } else {\n      const identifiers = [\"require\", \"exports\", \"module\"];\n      if (fnParams) {\n        fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n          if (identifiers[idx]) {\n            fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n            return false;\n          }\n          return true;\n        });\n      }\n    }\n    let inTry;\n    if (fn && isUnboundFunctionExpression(fn)) {\n      inTry = parser.scope.inTry;\n      parser.inScope(fnParams, () => {\n        for (const [name, varInfo] of fnRenames) {\n          parser.setVariable(name, varInfo);\n        }\n        parser.scope.inTry = inTry;\n        if (fn.body.type === \"BlockStatement\") {\n          parser.detectMode(fn.body.body);\n          const prev = parser.prevStatement;\n          parser.preWalkStatement(fn.body);\n          parser.prevStatement = prev;\n          parser.walkStatement(fn.body);\n        } else {\n          parser.walkExpression(fn.body);\n        }\n      });\n    } else if (fn && isBoundFunctionExpression(fn)) {\n      inTry = parser.scope.inTry;\n      parser.inScope(fn.callee.object.params.filter(i => ![\"require\", \"module\", \"exports\"].includes(i.name)), () => {\n        for (const [name, varInfo] of fnRenames) {\n          parser.setVariable(name, varInfo);\n        }\n        parser.scope.inTry = inTry;\n        if (fn.callee.object.body.type === \"BlockStatement\") {\n          parser.detectMode(fn.callee.object.body.body);\n          const prev = parser.prevStatement;\n          parser.preWalkStatement(fn.callee.object.body);\n          parser.prevStatement = prev;\n          parser.walkStatement(fn.callee.object.body);\n        } else {\n          parser.walkExpression(fn.callee.object.body);\n        }\n      });\n      if (fn.arguments) {\n        parser.walkExpressions(fn.arguments);\n      }\n    } else if (fn || obj) {\n      parser.walkExpression(fn || obj);\n    }\n    const dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule ? namedModule : null);\n    dep.loc = expr.loc;\n    if (namedModule) {\n      dep.localModule = addLocalModule(parser.state, namedModule);\n    }\n    parser.state.module.addPresentationalDependency(dep);\n    return true;\n  }\n  newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {\n    return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);\n  }\n  newRequireArrayDependency(depsArray, range) {\n    return new AMDRequireArrayDependency(depsArray, range);\n  }\n  newRequireItemDependency(request, range) {\n    return new AMDRequireItemDependency(request, range);\n  }\n}\nmodule.exports = AMDDefineDependencyParserPlugin;","map":{"version":3,"names":["RuntimeGlobals","require","AMDDefineDependency","AMDRequireArrayDependency","AMDRequireContextDependency","AMDRequireItemDependency","ConstDependency","ContextDependencyHelpers","DynamicExports","LocalModuleDependency","addLocalModule","getLocalModule","isBoundFunctionExpression","expr","type","callee","computed","object","property","name","isUnboundFunctionExpression","isCallable","AMDDefineDependencyParserPlugin","constructor","options","apply","parser","hooks","call","for","tap","processCallDefine","bind","processArray","param","identifiers","namedModule","isArray","items","forEach","idx","isString","includes","string","result","processItem","undefined","processContext","isConstArray","deps","array","request","dep","localModule","state","flagUsed","loc","module","addPresentationalDependency","newRequireItemDependency","optional","scope","inTry","current","addDependency","push","newRequireArrayDependency","range","isConditional","exports","create","category","fn","obj","arguments","length","value","bailout","fnParams","fnParamsOffset","params","fnRenames","Map","evaluateExpression","slice","filter","set","getVariableInfo","inScope","varInfo","setVariable","body","detectMode","prev","prevStatement","preWalkStatement","walkStatement","walkExpression","i","walkExpressions","newDefineDependency","arrayRange","functionRange","objectRange","depsArray"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/dependencies/AMDDefineDependencyParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst AMDDefineDependency = require(\"./AMDDefineDependency\");\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst { addLocalModule, getLocalModule } = require(\"./LocalModulesHelpers\");\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\nconst isBoundFunctionExpression = expr => {\n\tif (expr.type !== \"CallExpression\") return false;\n\tif (expr.callee.type !== \"MemberExpression\") return false;\n\tif (expr.callee.computed) return false;\n\tif (expr.callee.object.type !== \"FunctionExpression\") return false;\n\tif (expr.callee.property.type !== \"Identifier\") return false;\n\tif (expr.callee.property.name !== \"bind\") return false;\n\treturn true;\n};\n\nconst isUnboundFunctionExpression = expr => {\n\tif (expr.type === \"FunctionExpression\") return true;\n\tif (expr.type === \"ArrowFunctionExpression\") return true;\n\treturn false;\n};\n\nconst isCallable = expr => {\n\tif (isUnboundFunctionExpression(expr)) return true;\n\tif (isBoundFunctionExpression(expr)) return true;\n\treturn false;\n};\n\nclass AMDDefineDependencyParserPlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"define\")\n\t\t\t.tap(\n\t\t\t\t\"AMDDefineDependencyParserPlugin\",\n\t\t\t\tthis.processCallDefine.bind(this, parser)\n\t\t\t);\n\t}\n\n\tprocessArray(parser, expr, param, identifiers, namedModule) {\n\t\tif (param.isArray()) {\n\t\t\tparam.items.forEach((param, idx) => {\n\t\t\t\tif (\n\t\t\t\t\tparam.isString() &&\n\t\t\t\t\t[\"require\", \"module\", \"exports\"].includes(param.string)\n\t\t\t\t)\n\t\t\t\t\tidentifiers[idx] = param.string;\n\t\t\t\tconst result = this.processItem(parser, expr, param, namedModule);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isConstArray()) {\n\t\t\tconst deps = [];\n\t\t\tparam.array.forEach((request, idx) => {\n\t\t\t\tlet dep;\n\t\t\t\tlet localModule;\n\t\t\t\tif (request === \"require\") {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = RuntimeGlobals.require;\n\t\t\t\t} else if ([\"exports\", \"module\"].includes(request)) {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = request;\n\t\t\t\t} else if ((localModule = getLocalModule(parser.state, request))) {\n\t\t\t\t\tlocalModule.flagUsed();\n\t\t\t\t\tdep = new LocalModuleDependency(localModule, undefined, false);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t} else {\n\t\t\t\t\tdep = this.newRequireItemDependency(request);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t}\n\t\t\t\tdeps.push(dep);\n\t\t\t});\n\t\t\tconst dep = this.newRequireArrayDependency(deps, param.range);\n\t\t\tdep.loc = expr.loc;\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessItem(parser, expr, param, namedModule) {\n\t\tif (param.isConditional()) {\n\t\t\tparam.options.forEach(param => {\n\t\t\t\tconst result = this.processItem(parser, expr, param);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isString()) {\n\t\t\tlet dep, localModule;\n\t\t\tif (param.string === \"require\") {\n\t\t\t\tdep = new ConstDependency(RuntimeGlobals.require, param.range, [\n\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t]);\n\t\t\t} else if (param.string === \"exports\") {\n\t\t\t\tdep = new ConstDependency(\"exports\", param.range, [\n\t\t\t\t\tRuntimeGlobals.exports\n\t\t\t\t]);\n\t\t\t} else if (param.string === \"module\") {\n\t\t\t\tdep = new ConstDependency(\"module\", param.range, [\n\t\t\t\t\tRuntimeGlobals.module\n\t\t\t\t]);\n\t\t\t} else if (\n\t\t\t\t(localModule = getLocalModule(parser.state, param.string, namedModule))\n\t\t\t) {\n\t\t\t\tlocalModule.flagUsed();\n\t\t\t\tdep = new LocalModuleDependency(localModule, param.range, false);\n\t\t\t} else {\n\t\t\t\tdep = this.newRequireItemDependency(param.string, param.range);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessContext(parser, expr, param) {\n\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\tAMDRequireContextDependency,\n\t\t\tparam.range,\n\t\t\tparam,\n\t\t\texpr,\n\t\t\tthis.options,\n\t\t\t{\n\t\t\t\tcategory: \"amd\"\n\t\t\t},\n\t\t\tparser\n\t\t);\n\t\tif (!dep) return;\n\t\tdep.loc = expr.loc;\n\t\tdep.optional = !!parser.scope.inTry;\n\t\tparser.state.current.addDependency(dep);\n\t\treturn true;\n\t}\n\n\tprocessCallDefine(parser, expr) {\n\t\tlet array, fn, obj, namedModule;\n\t\tswitch (expr.arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tif (isCallable(expr.arguments[0])) {\n\t\t\t\t\t// define(f() {…})\n\t\t\t\t\tfn = expr.arguments[0];\n\t\t\t\t} else if (expr.arguments[0].type === \"ObjectExpression\") {\n\t\t\t\t\t// define({…})\n\t\t\t\t\tobj = expr.arguments[0];\n\t\t\t\t} else {\n\t\t\t\t\t// define(expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (expr.arguments[0].type === \"Literal\") {\n\t\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\t\t// define(\"…\", …)\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define(\"…\", f() {…})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define(\"…\", {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define(\"…\", expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tarray = expr.arguments[0];\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define([…], f() {})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define([…], {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define([…], expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// define(\"…\", […], f() {…})\n\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\tarray = expr.arguments[1];\n\t\t\t\tif (isCallable(expr.arguments[2])) {\n\t\t\t\t\t// define(\"…\", […], f() {})\n\t\t\t\t\tfn = expr.arguments[2];\n\t\t\t\t} else if (expr.arguments[2].type === \"ObjectExpression\") {\n\t\t\t\t\t// define(\"…\", […], {…})\n\t\t\t\t\tobj = expr.arguments[2];\n\t\t\t\t} else {\n\t\t\t\t\t// define(\"…\", […], expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t\tDynamicExports.bailout(parser.state);\n\t\tlet fnParams = null;\n\t\tlet fnParamsOffset = 0;\n\t\tif (fn) {\n\t\t\tif (isUnboundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.params;\n\t\t\t} else if (isBoundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.callee.object.params;\n\t\t\t\tfnParamsOffset = fn.arguments.length - 1;\n\t\t\t\tif (fnParamsOffset < 0) {\n\t\t\t\t\tfnParamsOffset = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet fnRenames = new Map();\n\t\tif (array) {\n\t\t\tconst identifiers = {};\n\t\t\tconst param = parser.evaluateExpression(array);\n\t\t\tconst result = this.processArray(\n\t\t\t\tparser,\n\t\t\t\texpr,\n\t\t\t\tparam,\n\t\t\t\tidentifiers,\n\t\t\t\tnamedModule\n\t\t\t);\n\t\t\tif (!result) return;\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst identifiers = [\"require\", \"exports\", \"module\"];\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tlet inTry;\n\t\tif (fn && isUnboundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(fnParams, () => {\n\t\t\t\tfor (const [name, varInfo] of fnRenames) {\n\t\t\t\t\tparser.setVariable(name, varInfo);\n\t\t\t\t}\n\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\tif (fn.body.type === \"BlockStatement\") {\n\t\t\t\t\tparser.detectMode(fn.body.body);\n\t\t\t\t\tconst prev = parser.prevStatement;\n\t\t\t\t\tparser.preWalkStatement(fn.body);\n\t\t\t\t\tparser.prevStatement = prev;\n\t\t\t\t\tparser.walkStatement(fn.body);\n\t\t\t\t} else {\n\t\t\t\t\tparser.walkExpression(fn.body);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (fn && isBoundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(\n\t\t\t\tfn.callee.object.params.filter(\n\t\t\t\t\ti => ![\"require\", \"module\", \"exports\"].includes(i.name)\n\t\t\t\t),\n\t\t\t\t() => {\n\t\t\t\t\tfor (const [name, varInfo] of fnRenames) {\n\t\t\t\t\t\tparser.setVariable(name, varInfo);\n\t\t\t\t\t}\n\t\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\t\tif (fn.callee.object.body.type === \"BlockStatement\") {\n\t\t\t\t\t\tparser.detectMode(fn.callee.object.body.body);\n\t\t\t\t\t\tconst prev = parser.prevStatement;\n\t\t\t\t\t\tparser.preWalkStatement(fn.callee.object.body);\n\t\t\t\t\t\tparser.prevStatement = prev;\n\t\t\t\t\t\tparser.walkStatement(fn.callee.object.body);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparser.walkExpression(fn.callee.object.body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (fn.arguments) {\n\t\t\t\tparser.walkExpressions(fn.arguments);\n\t\t\t}\n\t\t} else if (fn || obj) {\n\t\t\tparser.walkExpression(fn || obj);\n\t\t}\n\n\t\tconst dep = this.newDefineDependency(\n\t\t\texpr.range,\n\t\t\tarray ? array.range : null,\n\t\t\tfn ? fn.range : null,\n\t\t\tobj ? obj.range : null,\n\t\t\tnamedModule ? namedModule : null\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tif (namedModule) {\n\t\t\tdep.localModule = addLocalModule(parser.state, namedModule);\n\t\t}\n\t\tparser.state.module.addPresentationalDependency(dep);\n\t\treturn true;\n\t}\n\n\tnewDefineDependency(\n\t\trange,\n\t\tarrayRange,\n\t\tfunctionRange,\n\t\tobjectRange,\n\t\tnamedModule\n\t) {\n\t\treturn new AMDDefineDependency(\n\t\t\trange,\n\t\t\tarrayRange,\n\t\t\tfunctionRange,\n\t\t\tobjectRange,\n\t\t\tnamedModule\n\t\t);\n\t}\n\tnewRequireArrayDependency(depsArray, range) {\n\t\treturn new AMDRequireArrayDependency(depsArray, range);\n\t}\n\tnewRequireItemDependency(request, range) {\n\t\treturn new AMDRequireItemDependency(request, range);\n\t}\n}\nmodule.exports = AMDDefineDependencyParserPlugin;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,cAAc,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AACnD,MAAMC,mBAAmB,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAC5D,MAAME,yBAAyB,GAAGF,OAAO,CAAC,6BAA6B,CAAC;AACxE,MAAMG,2BAA2B,GAAGH,OAAO,CAAC,+BAA+B,CAAC;AAC5E,MAAMI,wBAAwB,GAAGJ,OAAO,CAAC,4BAA4B,CAAC;AACtE,MAAMK,eAAe,GAAGL,OAAO,CAAC,mBAAmB,CAAC;AACpD,MAAMM,wBAAwB,GAAGN,OAAO,CAAC,4BAA4B,CAAC;AACtE,MAAMO,cAAc,GAAGP,OAAO,CAAC,kBAAkB,CAAC;AAClD,MAAMQ,qBAAqB,GAAGR,OAAO,CAAC,yBAAyB,CAAC;AAChE,MAAM;EAAES,cAAc;EAAEC;AAAe,CAAC,GAAGV,OAAO,CAAC,uBAAuB,CAAC;;AAE3E;;AAEA,MAAMW,yBAAyB,GAAGC,IAAI,IAAI;EACzC,IAAIA,IAAI,CAACC,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAChD,IAAID,IAAI,CAACE,MAAM,CAACD,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EACzD,IAAID,IAAI,CAACE,MAAM,CAACC,QAAQ,EAAE,OAAO,KAAK;EACtC,IAAIH,IAAI,CAACE,MAAM,CAACE,MAAM,CAACH,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAClE,IAAID,IAAI,CAACE,MAAM,CAACG,QAAQ,CAACJ,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAC5D,IAAID,IAAI,CAACE,MAAM,CAACG,QAAQ,CAACC,IAAI,KAAK,MAAM,EAAE,OAAO,KAAK;EACtD,OAAO,IAAI;AACZ,CAAC;AAED,MAAMC,2BAA2B,GAAGP,IAAI,IAAI;EAC3C,IAAIA,IAAI,CAACC,IAAI,KAAK,oBAAoB,EAAE,OAAO,IAAI;EACnD,IAAID,IAAI,CAACC,IAAI,KAAK,yBAAyB,EAAE,OAAO,IAAI;EACxD,OAAO,KAAK;AACb,CAAC;AAED,MAAMO,UAAU,GAAGR,IAAI,IAAI;EAC1B,IAAIO,2BAA2B,CAACP,IAAI,CAAC,EAAE,OAAO,IAAI;EAClD,IAAID,yBAAyB,CAACC,IAAI,CAAC,EAAE,OAAO,IAAI;EAChD,OAAO,KAAK;AACb,CAAC;AAED,MAAMS,+BAA+B,CAAC;EACrCC,WAAWA,CAACC,OAAO,EAAE;IACpB,IAAI,CAACA,OAAO,GAAGA,OAAO;EACvB;;EAEA;AACD;AACA;AACA;EACCC,KAAKA,CAACC,MAAM,EAAE;IACbA,MAAM,CAACC,KAAK,CAACC,IAAI,CACfC,GAAG,CAAC,QAAQ,CAAC,CACbC,GAAG,CACH,iCAAiC,EACjC,IAAI,CAACC,iBAAiB,CAACC,IAAI,CAAC,IAAI,EAAEN,MAAM,CACzC,CAAC;EACH;EAEAO,YAAYA,CAACP,MAAM,EAAEb,IAAI,EAAEqB,KAAK,EAAEC,WAAW,EAAEC,WAAW,EAAE;IAC3D,IAAIF,KAAK,CAACG,OAAO,CAAC,CAAC,EAAE;MACpBH,KAAK,CAACI,KAAK,CAACC,OAAO,CAAC,CAACL,KAAK,EAAEM,GAAG,KAAK;QACnC,IACCN,KAAK,CAACO,QAAQ,CAAC,CAAC,IAChB,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAACC,QAAQ,CAACR,KAAK,CAACS,MAAM,CAAC,EAEvDR,WAAW,CAACK,GAAG,CAAC,GAAGN,KAAK,CAACS,MAAM;QAChC,MAAMC,MAAM,GAAG,IAAI,CAACC,WAAW,CAACnB,MAAM,EAAEb,IAAI,EAAEqB,KAAK,EAAEE,WAAW,CAAC;QACjE,IAAIQ,MAAM,KAAKE,SAAS,EAAE;UACzB,IAAI,CAACC,cAAc,CAACrB,MAAM,EAAEb,IAAI,EAAEqB,KAAK,CAAC;QACzC;MACD,CAAC,CAAC;MACF,OAAO,IAAI;IACZ,CAAC,MAAM,IAAIA,KAAK,CAACc,YAAY,CAAC,CAAC,EAAE;MAChC,MAAMC,IAAI,GAAG,EAAE;MACff,KAAK,CAACgB,KAAK,CAACX,OAAO,CAAC,CAACY,OAAO,EAAEX,GAAG,KAAK;QACrC,IAAIY,GAAG;QACP,IAAIC,WAAW;QACf,IAAIF,OAAO,KAAK,SAAS,EAAE;UAC1BhB,WAAW,CAACK,GAAG,CAAC,GAAGW,OAAO;UAC1BC,GAAG,GAAGpD,cAAc,CAACC,OAAO;QAC7B,CAAC,MAAM,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,CAACyC,QAAQ,CAACS,OAAO,CAAC,EAAE;UACnDhB,WAAW,CAACK,GAAG,CAAC,GAAGW,OAAO;UAC1BC,GAAG,GAAGD,OAAO;QACd,CAAC,MAAM,IAAKE,WAAW,GAAG1C,cAAc,CAACe,MAAM,CAAC4B,KAAK,EAAEH,OAAO,CAAC,EAAG;UACjEE,WAAW,CAACE,QAAQ,CAAC,CAAC;UACtBH,GAAG,GAAG,IAAI3C,qBAAqB,CAAC4C,WAAW,EAAEP,SAAS,EAAE,KAAK,CAAC;UAC9DM,GAAG,CAACI,GAAG,GAAG3C,IAAI,CAAC2C,GAAG;UAClB9B,MAAM,CAAC4B,KAAK,CAACG,MAAM,CAACC,2BAA2B,CAACN,GAAG,CAAC;QACrD,CAAC,MAAM;UACNA,GAAG,GAAG,IAAI,CAACO,wBAAwB,CAACR,OAAO,CAAC;UAC5CC,GAAG,CAACI,GAAG,GAAG3C,IAAI,CAAC2C,GAAG;UAClBJ,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAClC,MAAM,CAACmC,KAAK,CAACC,KAAK;UACnCpC,MAAM,CAAC4B,KAAK,CAACS,OAAO,CAACC,aAAa,CAACZ,GAAG,CAAC;QACxC;QACAH,IAAI,CAACgB,IAAI,CAACb,GAAG,CAAC;MACf,CAAC,CAAC;MACF,MAAMA,GAAG,GAAG,IAAI,CAACc,yBAAyB,CAACjB,IAAI,EAAEf,KAAK,CAACiC,KAAK,CAAC;MAC7Df,GAAG,CAACI,GAAG,GAAG3C,IAAI,CAAC2C,GAAG;MAClBJ,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAClC,MAAM,CAACmC,KAAK,CAACC,KAAK;MACnCpC,MAAM,CAAC4B,KAAK,CAACG,MAAM,CAACC,2BAA2B,CAACN,GAAG,CAAC;MACpD,OAAO,IAAI;IACZ;EACD;EACAP,WAAWA,CAACnB,MAAM,EAAEb,IAAI,EAAEqB,KAAK,EAAEE,WAAW,EAAE;IAC7C,IAAIF,KAAK,CAACkC,aAAa,CAAC,CAAC,EAAE;MAC1BlC,KAAK,CAACV,OAAO,CAACe,OAAO,CAACL,KAAK,IAAI;QAC9B,MAAMU,MAAM,GAAG,IAAI,CAACC,WAAW,CAACnB,MAAM,EAAEb,IAAI,EAAEqB,KAAK,CAAC;QACpD,IAAIU,MAAM,KAAKE,SAAS,EAAE;UACzB,IAAI,CAACC,cAAc,CAACrB,MAAM,EAAEb,IAAI,EAAEqB,KAAK,CAAC;QACzC;MACD,CAAC,CAAC;MACF,OAAO,IAAI;IACZ,CAAC,MAAM,IAAIA,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE;MAC5B,IAAIW,GAAG,EAAEC,WAAW;MACpB,IAAInB,KAAK,CAACS,MAAM,KAAK,SAAS,EAAE;QAC/BS,GAAG,GAAG,IAAI9C,eAAe,CAACN,cAAc,CAACC,OAAO,EAAEiC,KAAK,CAACiC,KAAK,EAAE,CAC9DnE,cAAc,CAACC,OAAO,CACtB,CAAC;MACH,CAAC,MAAM,IAAIiC,KAAK,CAACS,MAAM,KAAK,SAAS,EAAE;QACtCS,GAAG,GAAG,IAAI9C,eAAe,CAAC,SAAS,EAAE4B,KAAK,CAACiC,KAAK,EAAE,CACjDnE,cAAc,CAACqE,OAAO,CACtB,CAAC;MACH,CAAC,MAAM,IAAInC,KAAK,CAACS,MAAM,KAAK,QAAQ,EAAE;QACrCS,GAAG,GAAG,IAAI9C,eAAe,CAAC,QAAQ,EAAE4B,KAAK,CAACiC,KAAK,EAAE,CAChDnE,cAAc,CAACyD,MAAM,CACrB,CAAC;MACH,CAAC,MAAM,IACLJ,WAAW,GAAG1C,cAAc,CAACe,MAAM,CAAC4B,KAAK,EAAEpB,KAAK,CAACS,MAAM,EAAEP,WAAW,CAAC,EACrE;QACDiB,WAAW,CAACE,QAAQ,CAAC,CAAC;QACtBH,GAAG,GAAG,IAAI3C,qBAAqB,CAAC4C,WAAW,EAAEnB,KAAK,CAACiC,KAAK,EAAE,KAAK,CAAC;MACjE,CAAC,MAAM;QACNf,GAAG,GAAG,IAAI,CAACO,wBAAwB,CAACzB,KAAK,CAACS,MAAM,EAAET,KAAK,CAACiC,KAAK,CAAC;QAC9Df,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAClC,MAAM,CAACmC,KAAK,CAACC,KAAK;QACnCpC,MAAM,CAAC4B,KAAK,CAACS,OAAO,CAACC,aAAa,CAACZ,GAAG,CAAC;QACvC,OAAO,IAAI;MACZ;MACAA,GAAG,CAACI,GAAG,GAAG3C,IAAI,CAAC2C,GAAG;MAClB9B,MAAM,CAAC4B,KAAK,CAACG,MAAM,CAACC,2BAA2B,CAACN,GAAG,CAAC;MACpD,OAAO,IAAI;IACZ;EACD;EACAL,cAAcA,CAACrB,MAAM,EAAEb,IAAI,EAAEqB,KAAK,EAAE;IACnC,MAAMkB,GAAG,GAAG7C,wBAAwB,CAAC+D,MAAM,CAC1ClE,2BAA2B,EAC3B8B,KAAK,CAACiC,KAAK,EACXjC,KAAK,EACLrB,IAAI,EACJ,IAAI,CAACW,OAAO,EACZ;MACC+C,QAAQ,EAAE;IACX,CAAC,EACD7C,MACD,CAAC;IACD,IAAI,CAAC0B,GAAG,EAAE;IACVA,GAAG,CAACI,GAAG,GAAG3C,IAAI,CAAC2C,GAAG;IAClBJ,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAClC,MAAM,CAACmC,KAAK,CAACC,KAAK;IACnCpC,MAAM,CAAC4B,KAAK,CAACS,OAAO,CAACC,aAAa,CAACZ,GAAG,CAAC;IACvC,OAAO,IAAI;EACZ;EAEArB,iBAAiBA,CAACL,MAAM,EAAEb,IAAI,EAAE;IAC/B,IAAIqC,KAAK,EAAEsB,EAAE,EAAEC,GAAG,EAAErC,WAAW;IAC/B,QAAQvB,IAAI,CAAC6D,SAAS,CAACC,MAAM;MAC5B,KAAK,CAAC;QACL,IAAItD,UAAU,CAACR,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;UAClC;UACAF,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;QACvB,CAAC,MAAM,IAAI7D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC5D,IAAI,KAAK,kBAAkB,EAAE;UACzD;UACA2D,GAAG,GAAG5D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;QACxB,CAAC,MAAM;UACN;UACA;UACAD,GAAG,GAAGD,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;QAC7B;QACA;MACD,KAAK,CAAC;QACL,IAAI7D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC5D,IAAI,KAAK,SAAS,EAAE;UACzCsB,WAAW,GAAGvB,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAACE,KAAK;UACrC;UACA,IAAIvD,UAAU,CAACR,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;YAClC;YACAF,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;UACvB,CAAC,MAAM,IAAI7D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC5D,IAAI,KAAK,kBAAkB,EAAE;YACzD;YACA2D,GAAG,GAAG5D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;UACxB,CAAC,MAAM;YACN;YACA;YACAD,GAAG,GAAGD,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;UAC7B;QACD,CAAC,MAAM;UACNxB,KAAK,GAAGrC,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;UACzB,IAAIrD,UAAU,CAACR,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;YAClC;YACAF,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;UACvB,CAAC,MAAM,IAAI7D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC5D,IAAI,KAAK,kBAAkB,EAAE;YACzD;YACA2D,GAAG,GAAG5D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;UACxB,CAAC,MAAM;YACN;YACA;YACAD,GAAG,GAAGD,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;UAC7B;QACD;QACA;MACD,KAAK,CAAC;QACL;QACAtC,WAAW,GAAGvB,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAACE,KAAK;QACrC1B,KAAK,GAAGrC,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;QACzB,IAAIrD,UAAU,CAACR,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;UAClC;UACAF,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;QACvB,CAAC,MAAM,IAAI7D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC,CAAC5D,IAAI,KAAK,kBAAkB,EAAE;UACzD;UACA2D,GAAG,GAAG5D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;QACxB,CAAC,MAAM;UACN;UACA;UACAD,GAAG,GAAGD,EAAE,GAAG3D,IAAI,CAAC6D,SAAS,CAAC,CAAC,CAAC;QAC7B;QACA;MACD;QACC;IACF;IACAlE,cAAc,CAACqE,OAAO,CAACnD,MAAM,CAAC4B,KAAK,CAAC;IACpC,IAAIwB,QAAQ,GAAG,IAAI;IACnB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAIP,EAAE,EAAE;MACP,IAAIpD,2BAA2B,CAACoD,EAAE,CAAC,EAAE;QACpCM,QAAQ,GAAGN,EAAE,CAACQ,MAAM;MACrB,CAAC,MAAM,IAAIpE,yBAAyB,CAAC4D,EAAE,CAAC,EAAE;QACzCM,QAAQ,GAAGN,EAAE,CAACzD,MAAM,CAACE,MAAM,CAAC+D,MAAM;QAClCD,cAAc,GAAGP,EAAE,CAACE,SAAS,CAACC,MAAM,GAAG,CAAC;QACxC,IAAII,cAAc,GAAG,CAAC,EAAE;UACvBA,cAAc,GAAG,CAAC;QACnB;MACD;IACD;IACA,IAAIE,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;IACzB,IAAIhC,KAAK,EAAE;MACV,MAAMf,WAAW,GAAG,CAAC,CAAC;MACtB,MAAMD,KAAK,GAAGR,MAAM,CAACyD,kBAAkB,CAACjC,KAAK,CAAC;MAC9C,MAAMN,MAAM,GAAG,IAAI,CAACX,YAAY,CAC/BP,MAAM,EACNb,IAAI,EACJqB,KAAK,EACLC,WAAW,EACXC,WACD,CAAC;MACD,IAAI,CAACQ,MAAM,EAAE;MACb,IAAIkC,QAAQ,EAAE;QACbA,QAAQ,GAAGA,QAAQ,CAACM,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAAC,CAACnD,KAAK,EAAEM,GAAG,KAAK;UAChE,IAAIL,WAAW,CAACK,GAAG,CAAC,EAAE;YACrByC,SAAS,CAACK,GAAG,CAACpD,KAAK,CAACf,IAAI,EAAEO,MAAM,CAAC6D,eAAe,CAACpD,WAAW,CAACK,GAAG,CAAC,CAAC,CAAC;YACnE,OAAO,KAAK;UACb;UACA,OAAO,IAAI;QACZ,CAAC,CAAC;MACH;IACD,CAAC,MAAM;MACN,MAAML,WAAW,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,QAAQ,CAAC;MACpD,IAAI2C,QAAQ,EAAE;QACbA,QAAQ,GAAGA,QAAQ,CAACM,KAAK,CAACL,cAAc,CAAC,CAACM,MAAM,CAAC,CAACnD,KAAK,EAAEM,GAAG,KAAK;UAChE,IAAIL,WAAW,CAACK,GAAG,CAAC,EAAE;YACrByC,SAAS,CAACK,GAAG,CAACpD,KAAK,CAACf,IAAI,EAAEO,MAAM,CAAC6D,eAAe,CAACpD,WAAW,CAACK,GAAG,CAAC,CAAC,CAAC;YACnE,OAAO,KAAK;UACb;UACA,OAAO,IAAI;QACZ,CAAC,CAAC;MACH;IACD;IACA,IAAIsB,KAAK;IACT,IAAIU,EAAE,IAAIpD,2BAA2B,CAACoD,EAAE,CAAC,EAAE;MAC1CV,KAAK,GAAGpC,MAAM,CAACmC,KAAK,CAACC,KAAK;MAC1BpC,MAAM,CAAC8D,OAAO,CAACV,QAAQ,EAAE,MAAM;QAC9B,KAAK,MAAM,CAAC3D,IAAI,EAAEsE,OAAO,CAAC,IAAIR,SAAS,EAAE;UACxCvD,MAAM,CAACgE,WAAW,CAACvE,IAAI,EAAEsE,OAAO,CAAC;QAClC;QACA/D,MAAM,CAACmC,KAAK,CAACC,KAAK,GAAGA,KAAK;QAC1B,IAAIU,EAAE,CAACmB,IAAI,CAAC7E,IAAI,KAAK,gBAAgB,EAAE;UACtCY,MAAM,CAACkE,UAAU,CAACpB,EAAE,CAACmB,IAAI,CAACA,IAAI,CAAC;UAC/B,MAAME,IAAI,GAAGnE,MAAM,CAACoE,aAAa;UACjCpE,MAAM,CAACqE,gBAAgB,CAACvB,EAAE,CAACmB,IAAI,CAAC;UAChCjE,MAAM,CAACoE,aAAa,GAAGD,IAAI;UAC3BnE,MAAM,CAACsE,aAAa,CAACxB,EAAE,CAACmB,IAAI,CAAC;QAC9B,CAAC,MAAM;UACNjE,MAAM,CAACuE,cAAc,CAACzB,EAAE,CAACmB,IAAI,CAAC;QAC/B;MACD,CAAC,CAAC;IACH,CAAC,MAAM,IAAInB,EAAE,IAAI5D,yBAAyB,CAAC4D,EAAE,CAAC,EAAE;MAC/CV,KAAK,GAAGpC,MAAM,CAACmC,KAAK,CAACC,KAAK;MAC1BpC,MAAM,CAAC8D,OAAO,CACbhB,EAAE,CAACzD,MAAM,CAACE,MAAM,CAAC+D,MAAM,CAACK,MAAM,CAC7Ba,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAACxD,QAAQ,CAACwD,CAAC,CAAC/E,IAAI,CACvD,CAAC,EACD,MAAM;QACL,KAAK,MAAM,CAACA,IAAI,EAAEsE,OAAO,CAAC,IAAIR,SAAS,EAAE;UACxCvD,MAAM,CAACgE,WAAW,CAACvE,IAAI,EAAEsE,OAAO,CAAC;QAClC;QACA/D,MAAM,CAACmC,KAAK,CAACC,KAAK,GAAGA,KAAK;QAC1B,IAAIU,EAAE,CAACzD,MAAM,CAACE,MAAM,CAAC0E,IAAI,CAAC7E,IAAI,KAAK,gBAAgB,EAAE;UACpDY,MAAM,CAACkE,UAAU,CAACpB,EAAE,CAACzD,MAAM,CAACE,MAAM,CAAC0E,IAAI,CAACA,IAAI,CAAC;UAC7C,MAAME,IAAI,GAAGnE,MAAM,CAACoE,aAAa;UACjCpE,MAAM,CAACqE,gBAAgB,CAACvB,EAAE,CAACzD,MAAM,CAACE,MAAM,CAAC0E,IAAI,CAAC;UAC9CjE,MAAM,CAACoE,aAAa,GAAGD,IAAI;UAC3BnE,MAAM,CAACsE,aAAa,CAACxB,EAAE,CAACzD,MAAM,CAACE,MAAM,CAAC0E,IAAI,CAAC;QAC5C,CAAC,MAAM;UACNjE,MAAM,CAACuE,cAAc,CAACzB,EAAE,CAACzD,MAAM,CAACE,MAAM,CAAC0E,IAAI,CAAC;QAC7C;MACD,CACD,CAAC;MACD,IAAInB,EAAE,CAACE,SAAS,EAAE;QACjBhD,MAAM,CAACyE,eAAe,CAAC3B,EAAE,CAACE,SAAS,CAAC;MACrC;IACD,CAAC,MAAM,IAAIF,EAAE,IAAIC,GAAG,EAAE;MACrB/C,MAAM,CAACuE,cAAc,CAACzB,EAAE,IAAIC,GAAG,CAAC;IACjC;IAEA,MAAMrB,GAAG,GAAG,IAAI,CAACgD,mBAAmB,CACnCvF,IAAI,CAACsD,KAAK,EACVjB,KAAK,GAAGA,KAAK,CAACiB,KAAK,GAAG,IAAI,EAC1BK,EAAE,GAAGA,EAAE,CAACL,KAAK,GAAG,IAAI,EACpBM,GAAG,GAAGA,GAAG,CAACN,KAAK,GAAG,IAAI,EACtB/B,WAAW,GAAGA,WAAW,GAAG,IAC7B,CAAC;IACDgB,GAAG,CAACI,GAAG,GAAG3C,IAAI,CAAC2C,GAAG;IAClB,IAAIpB,WAAW,EAAE;MAChBgB,GAAG,CAACC,WAAW,GAAG3C,cAAc,CAACgB,MAAM,CAAC4B,KAAK,EAAElB,WAAW,CAAC;IAC5D;IACAV,MAAM,CAAC4B,KAAK,CAACG,MAAM,CAACC,2BAA2B,CAACN,GAAG,CAAC;IACpD,OAAO,IAAI;EACZ;EAEAgD,mBAAmBA,CAClBjC,KAAK,EACLkC,UAAU,EACVC,aAAa,EACbC,WAAW,EACXnE,WAAW,EACV;IACD,OAAO,IAAIlC,mBAAmB,CAC7BiE,KAAK,EACLkC,UAAU,EACVC,aAAa,EACbC,WAAW,EACXnE,WACD,CAAC;EACF;EACA8B,yBAAyBA,CAACsC,SAAS,EAAErC,KAAK,EAAE;IAC3C,OAAO,IAAIhE,yBAAyB,CAACqG,SAAS,EAAErC,KAAK,CAAC;EACvD;EACAR,wBAAwBA,CAACR,OAAO,EAAEgB,KAAK,EAAE;IACxC,OAAO,IAAI9D,wBAAwB,CAAC8C,OAAO,EAAEgB,KAAK,CAAC;EACpD;AACD;AACAV,MAAM,CAACY,OAAO,GAAG/C,+BAA+B"},"metadata":{},"sourceType":"script","externalDependencies":[]}