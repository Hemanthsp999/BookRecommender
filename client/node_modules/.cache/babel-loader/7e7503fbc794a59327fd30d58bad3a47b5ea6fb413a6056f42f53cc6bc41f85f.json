{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst {\n  SyncHook,\n  MultiHook\n} = require(\"tapable\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n  /**\n   * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n   * @param {MultiCompilerOptions} options options\n   */\n  constructor(compilers, options) {\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(name => {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[MultiStats]>} */\n      done: new SyncHook([\"stats\"]),\n      /** @type {MultiHook<SyncHook<[string | null, number]>>} */\n      invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      run: new MultiHook(compilers.map(c => c.hooks.run)),\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n      /** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n      infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))\n    });\n    this.compilers = compilers;\n    /** @type {MultiCompilerOptions} */\n    this._options = {\n      parallelism: options.parallelism || Infinity\n    };\n    /** @type {WeakMap<Compiler, string[]>} */\n    this.dependencies = new WeakMap();\n    this.running = false;\n\n    /** @type {Stats[]} */\n    const compilerStats = this.compilers.map(() => null);\n    let doneCompilers = 0;\n    for (let index = 0; index < this.compilers.length; index++) {\n      const compiler = this.compilers[index];\n      const compilerIndex = index;\n      let compilerDone = false;\n      compiler.hooks.done.tap(\"MultiCompiler\", stats => {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n        compilerStats[compilerIndex] = stats;\n        if (doneCompilers === this.compilers.length) {\n          this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      });\n      compiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    }\n  }\n  get options() {\n    return Object.assign(this.compilers.map(c => c.options), this._options);\n  }\n  get outputPath() {\n    let commonPath = this.compilers[0].outputPath;\n    for (const compiler of this.compilers) {\n      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n        commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n      }\n    }\n    if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n    return commonPath;\n  }\n  get inputFileSystem() {\n    throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n  }\n  get outputFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n  get watchFileSystem() {\n    throw new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n  }\n  get intermediateFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  /**\n   * @param {InputFileSystem} value the new input file system\n   */\n  set inputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.inputFileSystem = value;\n    }\n  }\n\n  /**\n   * @param {OutputFileSystem} value the new output file system\n   */\n  set outputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.outputFileSystem = value;\n    }\n  }\n\n  /**\n   * @param {WatchFileSystem} value the new watch file system\n   */\n  set watchFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.watchFileSystem = value;\n    }\n  }\n\n  /**\n   * @param {IntermediateFileSystem} value the new intermediate file system\n   */\n  set intermediateFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.intermediateFileSystem = value;\n    }\n  }\n  getInfrastructureLogger(name) {\n    return this.compilers[0].getInfrastructureLogger(name);\n  }\n\n  /**\n   * @param {Compiler} compiler the child compiler\n   * @param {string[]} dependencies its dependencies\n   * @returns {void}\n   */\n  setDependencies(compiler, dependencies) {\n    this.dependencies.set(compiler, dependencies);\n  }\n\n  /**\n   * @param {Callback<MultiStats>} callback signals when the validation is complete\n   * @returns {boolean} true if the dependencies are valid\n   */\n  validateDependencies(callback) {\n    /** @type {Set<{source: Compiler, target: Compiler}>} */\n    const edges = new Set();\n    /** @type {string[]} */\n    const missing = [];\n    const targetFound = compiler => {\n      for (const edge of edges) {\n        if (edge.target === compiler) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const sortEdges = (e1, e2) => {\n      return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n    };\n    for (const source of this.compilers) {\n      const dependencies = this.dependencies.get(source);\n      if (dependencies) {\n        for (const dep of dependencies) {\n          const target = this.compilers.find(c => c.name === dep);\n          if (!target) {\n            missing.push(dep);\n          } else {\n            edges.add({\n              source,\n              target\n            });\n          }\n        }\n      }\n    }\n    /** @type {string[]} */\n    const errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n    const stack = this.compilers.filter(c => !targetFound(c));\n    while (stack.length > 0) {\n      const current = stack.pop();\n      for (const edge of edges) {\n        if (edge.source === current) {\n          edges.delete(edge);\n          const target = edge.target;\n          if (!targetFound(target)) {\n            stack.push(target);\n          }\n        }\n      }\n    }\n    if (edges.size > 0) {\n      /** @type {string[]} */\n      const lines = Array.from(edges).sort(sortEdges).map(edge => `${edge.source.name} -> ${edge.target.name}`);\n      lines.unshift(\"Circular dependency found in compiler dependencies.\");\n      errors.unshift(lines.join(\"\\n\"));\n    }\n    if (errors.length > 0) {\n      const message = errors.join(\"\\n\");\n      callback(new Error(message));\n      return false;\n    }\n    return true;\n  }\n\n  // TODO webpack 6 remove\n  /**\n   * @deprecated This method should have been private\n   * @param {Compiler[]} compilers the child compilers\n   * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n   * @param {Callback<MultiStats>} callback the compiler's handler\n   * @returns {void}\n   */\n  runWithDependencies(compilers, fn, callback) {\n    const fulfilledNames = new Set();\n    let remainingCompilers = compilers;\n    const isDependencyFulfilled = d => fulfilledNames.has(d);\n    const getReadyCompilers = () => {\n      let readyCompilers = [];\n      let list = remainingCompilers;\n      remainingCompilers = [];\n      for (const c of list) {\n        const dependencies = this.dependencies.get(c);\n        const ready = !dependencies || dependencies.every(isDependencyFulfilled);\n        if (ready) {\n          readyCompilers.push(c);\n        } else {\n          remainingCompilers.push(c);\n        }\n      }\n      return readyCompilers;\n    };\n    const runCompilers = callback => {\n      if (remainingCompilers.length === 0) return callback();\n      asyncLib.map(getReadyCompilers(), (compiler, callback) => {\n        fn(compiler, err => {\n          if (err) return callback(err);\n          fulfilledNames.add(compiler.name);\n          runCompilers(callback);\n        });\n      }, callback);\n    };\n    runCompilers(callback);\n  }\n\n  /**\n   * @template SetupResult\n   * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n   * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n   * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n   * @returns {SetupResult[]} result of setup\n   */\n  _runGraph(setup, run, callback) {\n    /** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n    // State transitions for nodes:\n    // -> blocked (initial)\n    // blocked -> starting [running++] (when all parents done)\n    // queued -> starting [running++] (when processing the queue)\n    // starting -> running (when run has been called)\n    // running -> done [running--] (when compilation is done)\n    // done -> pending (when invalidated from file change)\n    // pending -> blocked [add to queue] (when invalidated from aggregated changes)\n    // done -> blocked [add to queue] (when invalidated, from parent invalidation)\n    // running -> running-outdated (when invalidated, either from change or parent invalidation)\n    // running-outdated -> blocked [running--] (when compilation is done)\n\n    /** @type {Node[]} */\n    const nodes = this.compilers.map(compiler => ({\n      compiler,\n      setupResult: undefined,\n      result: undefined,\n      state: \"blocked\",\n      children: [],\n      parents: []\n    }));\n    /** @type {Map<string, Node>} */\n    const compilerToNode = new Map();\n    for (const node of nodes) compilerToNode.set(node.compiler.name, node);\n    for (const node of nodes) {\n      const dependencies = this.dependencies.get(node.compiler);\n      if (!dependencies) continue;\n      for (const dep of dependencies) {\n        const parent = compilerToNode.get(dep);\n        node.parents.push(parent);\n        parent.children.push(node);\n      }\n    }\n    /** @type {ArrayQueue<Node>} */\n    const queue = new ArrayQueue();\n    for (const node of nodes) {\n      if (node.parents.length === 0) {\n        node.state = \"queued\";\n        queue.enqueue(node);\n      }\n    }\n    let errored = false;\n    let running = 0;\n    const parallelism = this._options.parallelism;\n    /**\n     * @param {Node} node node\n     * @param {Error=} err error\n     * @param {Stats=} stats result\n     * @returns {void}\n     */\n    const nodeDone = (node, err, stats) => {\n      if (errored) return;\n      if (err) {\n        errored = true;\n        return asyncLib.each(nodes, (node, callback) => {\n          if (node.compiler.watching) {\n            node.compiler.watching.close(callback);\n          } else {\n            callback();\n          }\n        }, () => callback(err));\n      }\n      node.result = stats;\n      running--;\n      if (node.state === \"running\") {\n        node.state = \"done\";\n        for (const child of node.children) {\n          if (child.state === \"blocked\") queue.enqueue(child);\n        }\n      } else if (node.state === \"running-outdated\") {\n        node.state = \"blocked\";\n        queue.enqueue(node);\n      }\n      processQueue();\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n    const nodeInvalidFromParent = node => {\n      if (node.state === \"done\") {\n        node.state = \"blocked\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n    const nodeInvalid = node => {\n      if (node.state === \"done\") {\n        node.state = \"pending\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n    const nodeChange = node => {\n      nodeInvalid(node);\n      if (node.state === \"pending\") {\n        node.state = \"blocked\";\n      }\n      if (node.state === \"blocked\") {\n        queue.enqueue(node);\n        processQueue();\n      }\n    };\n    const setupResults = [];\n    nodes.forEach((node, i) => {\n      setupResults.push(node.setupResult = setup(node.compiler, i, nodeDone.bind(null, node), () => node.state !== \"starting\" && node.state !== \"running\", () => nodeChange(node), () => nodeInvalid(node)));\n    });\n    let processing = true;\n    const processQueue = () => {\n      if (processing) return;\n      processing = true;\n      process.nextTick(processQueueWorker);\n    };\n    const processQueueWorker = () => {\n      while (running < parallelism && queue.length > 0 && !errored) {\n        const node = queue.dequeue();\n        if (node.state === \"queued\" || node.state === \"blocked\" && node.parents.every(p => p.state === \"done\")) {\n          running++;\n          node.state = \"starting\";\n          run(node.compiler, node.setupResult, nodeDone.bind(null, node));\n          node.state = \"running\";\n        }\n      }\n      processing = false;\n      if (!errored && running === 0 && nodes.every(node => node.state === \"done\")) {\n        const stats = [];\n        for (const node of nodes) {\n          const result = node.result;\n          if (result) {\n            node.result = undefined;\n            stats.push(result);\n          }\n        }\n        if (stats.length > 0) {\n          callback(null, new MultiStats(stats));\n        }\n      }\n    };\n    processQueueWorker();\n    return setupResults;\n  }\n\n  /**\n   * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n   * @param {Callback<MultiStats>} handler signals when the call finishes\n   * @returns {MultiWatching} a compiler watcher\n   */\n  watch(watchOptions, handler) {\n    if (this.running) {\n      return handler(new ConcurrentCompilationError());\n    }\n    this.running = true;\n    if (this.validateDependencies(handler)) {\n      const watchings = this._runGraph((compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n        const watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions, callback);\n        if (watching) {\n          watching._onInvalid = setInvalid;\n          watching._onChange = setChanged;\n          watching._isBlocked = isBlocked;\n        }\n        return watching;\n      }, (compiler, watching, callback) => {\n        if (compiler.watching !== watching) return;\n        if (!watching.running) watching.invalidate();\n      }, handler);\n      return new MultiWatching(watchings, this);\n    }\n    return new MultiWatching([], this);\n  }\n\n  /**\n   * @param {Callback<MultiStats>} callback signals when the call finishes\n   * @returns {void}\n   */\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n    this.running = true;\n    if (this.validateDependencies(callback)) {\n      this._runGraph(() => {}, (compiler, setupResult, callback) => compiler.run(callback), (err, stats) => {\n        this.running = false;\n        if (callback !== undefined) {\n          return callback(err, stats);\n        }\n      });\n    }\n  }\n  purgeInputFileSystem() {\n    for (const compiler of this.compilers) {\n      if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n        compiler.inputFileSystem.purge();\n      }\n    }\n  }\n\n  /**\n   * @param {Callback<void>} callback signals when the compiler closes\n   * @returns {void}\n   */\n  close(callback) {\n    asyncLib.each(this.compilers, (compiler, callback) => {\n      compiler.close(callback);\n    }, callback);\n  }\n};","map":{"version":3,"names":["asyncLib","require","SyncHook","MultiHook","ConcurrentCompilationError","MultiStats","MultiWatching","ArrayQueue","module","exports","MultiCompiler","constructor","compilers","options","Array","isArray","Object","keys","map","name","hooks","freeze","done","invalid","c","run","watchClose","watchRun","infrastructureLog","_options","parallelism","Infinity","dependencies","WeakMap","running","compilerStats","doneCompilers","index","length","compiler","compilerIndex","compilerDone","tap","stats","call","assign","outputPath","commonPath","indexOf","test","replace","inputFileSystem","Error","outputFileSystem","watchFileSystem","intermediateFileSystem","value","getInfrastructureLogger","setDependencies","set","validateDependencies","callback","edges","Set","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","get","dep","find","push","add","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","runWithDependencies","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","has","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","_runGraph","setup","nodes","setupResult","undefined","result","state","children","parents","compilerToNode","Map","node","parent","queue","enqueue","errored","nodeDone","each","watching","close","child","processQueue","nodeInvalidFromParent","nodeInvalid","nodeChange","setupResults","forEach","i","bind","processing","process","nextTick","processQueueWorker","dequeue","p","watch","watchOptions","handler","watchings","idx","isBlocked","setChanged","setInvalid","_onInvalid","_onChange","_isBlocked","invalidate","purgeInputFileSystem","purge"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/MultiCompiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncHook, MultiHook } = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n\t/**\n\t * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n\t * @param {MultiCompilerOptions} options options\n\t */\n\tconstructor(compilers, options) {\n\t\tif (!Array.isArray(compilers)) {\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\tcompilers[name].name = name;\n\t\t\t\treturn compilers[name];\n\t\t\t});\n\t\t}\n\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[MultiStats]>} */\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {MultiHook<SyncHook<[string | null, number]>>} */\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\t/** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t});\n\t\tthis.compilers = compilers;\n\t\t/** @type {MultiCompilerOptions} */\n\t\tthis._options = {\n\t\t\tparallelism: options.parallelism || Infinity\n\t\t};\n\t\t/** @type {WeakMap<Compiler, string[]>} */\n\t\tthis.dependencies = new WeakMap();\n\t\tthis.running = false;\n\n\t\t/** @type {Stats[]} */\n\t\tconst compilerStats = this.compilers.map(() => null);\n\t\tlet doneCompilers = 0;\n\t\tfor (let index = 0; index < this.compilers.length; index++) {\n\t\t\tconst compiler = this.compilers[index];\n\t\t\tconst compilerIndex = index;\n\t\t\tlet compilerDone = false;\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(new MultiStats(compilerStats));\n\t\t\t\t}\n\t\t\t});\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tget options() {\n\t\treturn Object.assign(\n\t\t\tthis.compilers.map(c => c.options),\n\t\t\tthis._options\n\t\t);\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\tget watchFileSystem() {\n\t\tthrow new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n\t}\n\n\tget intermediateFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {InputFileSystem} value the new input file system\n\t */\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {OutputFileSystem} value the new output file system\n\t */\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchFileSystem} value the new watch file system\n\t */\n\tset watchFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.watchFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IntermediateFileSystem} value the new intermediate file system\n\t */\n\tset intermediateFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.intermediateFileSystem = value;\n\t\t}\n\t}\n\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the child compiler\n\t * @param {string[]} dependencies its dependencies\n\t * @returns {void}\n\t */\n\tsetDependencies(compiler, dependencies) {\n\t\tthis.dependencies.set(compiler, dependencies);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the validation is complete\n\t * @returns {boolean} true if the dependencies are valid\n\t */\n\tvalidateDependencies(callback) {\n\t\t/** @type {Set<{source: Compiler, target: Compiler}>} */\n\t\tconst edges = new Set();\n\t\t/** @type {string[]} */\n\t\tconst missing = [];\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst sortEdges = (e1, e2) => {\n\t\t\treturn (\n\t\t\t\te1.source.name.localeCompare(e2.source.name) ||\n\t\t\t\te1.target.name.localeCompare(e2.target.name)\n\t\t\t);\n\t\t};\n\t\tfor (const source of this.compilers) {\n\t\t\tconst dependencies = this.dependencies.get(source);\n\t\t\tif (dependencies) {\n\t\t\t\tfor (const dep of dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {string[]} */\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\t/** @type {string[]} */\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// TODO webpack 6 remove\n\t/**\n\t * @deprecated This method should have been private\n\t * @param {Compiler[]} compilers the child compilers\n\t * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n\t * @param {Callback<MultiStats>} callback the compiler's handler\n\t * @returns {void}\n\t */\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\tconst getReadyCompilers = () => {\n\t\t\tlet readyCompilers = [];\n\t\t\tlet list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst dependencies = this.dependencies.get(c);\n\t\t\t\tconst ready =\n\t\t\t\t\t!dependencies || dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback();\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\t/**\n\t * @template SetupResult\n\t * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n\t * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n\t * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n\t * @returns {SetupResult[]} result of setup\n\t */\n\t_runGraph(setup, run, callback) {\n\t\t/** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n\t\t// State transitions for nodes:\n\t\t// -> blocked (initial)\n\t\t// blocked -> starting [running++] (when all parents done)\n\t\t// queued -> starting [running++] (when processing the queue)\n\t\t// starting -> running (when run has been called)\n\t\t// running -> done [running--] (when compilation is done)\n\t\t// done -> pending (when invalidated from file change)\n\t\t// pending -> blocked [add to queue] (when invalidated from aggregated changes)\n\t\t// done -> blocked [add to queue] (when invalidated, from parent invalidation)\n\t\t// running -> running-outdated (when invalidated, either from change or parent invalidation)\n\t\t// running-outdated -> blocked [running--] (when compilation is done)\n\n\t\t/** @type {Node[]} */\n\t\tconst nodes = this.compilers.map(compiler => ({\n\t\t\tcompiler,\n\t\t\tsetupResult: undefined,\n\t\t\tresult: undefined,\n\t\t\tstate: \"blocked\",\n\t\t\tchildren: [],\n\t\t\tparents: []\n\t\t}));\n\t\t/** @type {Map<string, Node>} */\n\t\tconst compilerToNode = new Map();\n\t\tfor (const node of nodes) compilerToNode.set(node.compiler.name, node);\n\t\tfor (const node of nodes) {\n\t\t\tconst dependencies = this.dependencies.get(node.compiler);\n\t\t\tif (!dependencies) continue;\n\t\t\tfor (const dep of dependencies) {\n\t\t\t\tconst parent = compilerToNode.get(dep);\n\t\t\t\tnode.parents.push(parent);\n\t\t\t\tparent.children.push(node);\n\t\t\t}\n\t\t}\n\t\t/** @type {ArrayQueue<Node>} */\n\t\tconst queue = new ArrayQueue();\n\t\tfor (const node of nodes) {\n\t\t\tif (node.parents.length === 0) {\n\t\t\t\tnode.state = \"queued\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t}\n\t\tlet errored = false;\n\t\tlet running = 0;\n\t\tconst parallelism = this._options.parallelism;\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @param {Error=} err error\n\t\t * @param {Stats=} stats result\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeDone = (node, err, stats) => {\n\t\t\tif (errored) return;\n\t\t\tif (err) {\n\t\t\t\terrored = true;\n\t\t\t\treturn asyncLib.each(\n\t\t\t\t\tnodes,\n\t\t\t\t\t(node, callback) => {\n\t\t\t\t\t\tif (node.compiler.watching) {\n\t\t\t\t\t\t\tnode.compiler.watching.close(callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => callback(err)\n\t\t\t\t);\n\t\t\t}\n\t\t\tnode.result = stats;\n\t\t\trunning--;\n\t\t\tif (node.state === \"running\") {\n\t\t\t\tnode.state = \"done\";\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tif (child.state === \"blocked\") queue.enqueue(child);\n\t\t\t\t}\n\t\t\t} else if (node.state === \"running-outdated\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t\tprocessQueue();\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalidFromParent = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalid = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"pending\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeChange = node => {\n\t\t\tnodeInvalid(node);\n\t\t\tif (node.state === \"pending\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t}\n\t\t\tif (node.state === \"blocked\") {\n\t\t\t\tqueue.enqueue(node);\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t};\n\n\t\tconst setupResults = [];\n\t\tnodes.forEach((node, i) => {\n\t\t\tsetupResults.push(\n\t\t\t\t(node.setupResult = setup(\n\t\t\t\t\tnode.compiler,\n\t\t\t\t\ti,\n\t\t\t\t\tnodeDone.bind(null, node),\n\t\t\t\t\t() => node.state !== \"starting\" && node.state !== \"running\",\n\t\t\t\t\t() => nodeChange(node),\n\t\t\t\t\t() => nodeInvalid(node)\n\t\t\t\t))\n\t\t\t);\n\t\t});\n\t\tlet processing = true;\n\t\tconst processQueue = () => {\n\t\t\tif (processing) return;\n\t\t\tprocessing = true;\n\t\t\tprocess.nextTick(processQueueWorker);\n\t\t};\n\t\tconst processQueueWorker = () => {\n\t\t\twhile (running < parallelism && queue.length > 0 && !errored) {\n\t\t\t\tconst node = queue.dequeue();\n\t\t\t\tif (\n\t\t\t\t\tnode.state === \"queued\" ||\n\t\t\t\t\t(node.state === \"blocked\" &&\n\t\t\t\t\t\tnode.parents.every(p => p.state === \"done\"))\n\t\t\t\t) {\n\t\t\t\t\trunning++;\n\t\t\t\t\tnode.state = \"starting\";\n\t\t\t\t\trun(node.compiler, node.setupResult, nodeDone.bind(null, node));\n\t\t\t\t\tnode.state = \"running\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessing = false;\n\t\t\tif (\n\t\t\t\t!errored &&\n\t\t\t\trunning === 0 &&\n\t\t\t\tnodes.every(node => node.state === \"done\")\n\t\t\t) {\n\t\t\t\tconst stats = [];\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tconst result = node.result;\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tnode.result = undefined;\n\t\t\t\t\t\tstats.push(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stats.length > 0) {\n\t\t\t\t\tcallback(null, new MultiStats(stats));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tprocessQueueWorker();\n\t\treturn setupResults;\n\t}\n\n\t/**\n\t * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n\t * @param {Callback<MultiStats>} handler signals when the call finishes\n\t * @returns {MultiWatching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tconst watchings = this._runGraph(\n\t\t\t\t(compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n\t\t\t\t\tconst watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions) ? watchOptions[idx] : watchOptions,\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t\tif (watching) {\n\t\t\t\t\t\twatching._onInvalid = setInvalid;\n\t\t\t\t\t\twatching._onChange = setChanged;\n\t\t\t\t\t\twatching._isBlocked = isBlocked;\n\t\t\t\t\t}\n\t\t\t\t\treturn watching;\n\t\t\t\t},\n\t\t\t\t(compiler, watching, callback) => {\n\t\t\t\t\tif (compiler.watching !== watching) return;\n\t\t\t\t\tif (!watching.running) watching.invalidate();\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t\treturn new MultiWatching(watchings, this);\n\t\t}\n\n\t\treturn new MultiWatching([], this);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis._runGraph(\n\t\t\t\t() => {},\n\t\t\t\t(compiler, setupResult, callback) => compiler.run(callback),\n\t\t\t\t(err, stats) => {\n\t\t\t\t\tthis.running = false;\n\n\t\t\t\t\tif (callback !== undefined) {\n\t\t\t\t\t\treturn callback(err, stats);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tasyncLib.each(\n\t\t\tthis.compilers,\n\t\t\t(compiler, callback) => {\n\t\t\t\tcompiler.close(callback);\n\t\t\t},\n\t\t\tcallback\n\t\t);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}