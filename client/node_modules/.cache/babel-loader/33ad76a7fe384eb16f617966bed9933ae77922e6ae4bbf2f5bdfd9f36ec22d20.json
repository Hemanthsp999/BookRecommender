{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst BUILD_DEPENDENCIES_KEY = Symbol();\nclass IdleFileCachePlugin {\n  /**\n   * @param {TODO} strategy cache strategy\n   * @param {number} idleTimeout timeout\n   * @param {number} idleTimeoutForInitialStore initial timeout\n   * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n   */\n  constructor(strategy, idleTimeout, idleTimeoutForInitialStore, idleTimeoutAfterLargeChanges) {\n    this.strategy = strategy;\n    this.idleTimeout = idleTimeout;\n    this.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n    this.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    let strategy = this.strategy;\n    const idleTimeout = this.idleTimeout;\n    const idleTimeoutForInitialStore = Math.min(idleTimeout, this.idleTimeoutForInitialStore);\n    const idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n    const resolvedPromise = Promise.resolve();\n    let timeSpendInBuild = 0;\n    let timeSpendInStore = 0;\n    let avgTimeSpendInStore = 0;\n\n    /** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n    const pendingIdleTasks = new Map();\n    compiler.cache.hooks.store.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, (identifier, etag, data) => {\n      pendingIdleTasks.set(identifier, () => strategy.store(identifier, etag, data));\n    });\n    compiler.cache.hooks.get.tapPromise({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, (identifier, etag, gotHandlers) => {\n      const restore = () => strategy.restore(identifier, etag).then(cacheEntry => {\n        if (cacheEntry === undefined) {\n          gotHandlers.push((result, callback) => {\n            if (result !== undefined) {\n              pendingIdleTasks.set(identifier, () => strategy.store(identifier, etag, result));\n            }\n            callback();\n          });\n        } else {\n          return cacheEntry;\n        }\n      });\n      const pendingTask = pendingIdleTasks.get(identifier);\n      if (pendingTask !== undefined) {\n        pendingIdleTasks.delete(identifier);\n        return pendingTask().then(restore);\n      }\n      return restore();\n    });\n    compiler.cache.hooks.storeBuildDependencies.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, dependencies => {\n      pendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, () => strategy.storeBuildDependencies(dependencies));\n    });\n    compiler.cache.hooks.shutdown.tapPromise({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      if (idleTimer) {\n        clearTimeout(idleTimer);\n        idleTimer = undefined;\n      }\n      isIdle = false;\n      const reportProgress = ProgressPlugin.getReporter(compiler);\n      const jobs = Array.from(pendingIdleTasks.values());\n      if (reportProgress) reportProgress(0, \"process pending cache items\");\n      const promises = jobs.map(fn => fn());\n      pendingIdleTasks.clear();\n      promises.push(currentIdlePromise);\n      const promise = Promise.all(promises);\n      currentIdlePromise = promise.then(() => strategy.afterAllStored());\n      if (reportProgress) {\n        currentIdlePromise = currentIdlePromise.then(() => {\n          reportProgress(1, `stored`);\n        });\n      }\n      return currentIdlePromise.then(() => {\n        // Reset strategy\n        if (strategy.clear) strategy.clear();\n      });\n    });\n\n    /** @type {Promise<any>} */\n    let currentIdlePromise = resolvedPromise;\n    let isIdle = false;\n    let isInitialStore = true;\n    const processIdleTasks = () => {\n      if (isIdle) {\n        const startTime = Date.now();\n        if (pendingIdleTasks.size > 0) {\n          const promises = [currentIdlePromise];\n          const maxTime = startTime + 100;\n          let maxCount = 100;\n          for (const [filename, factory] of pendingIdleTasks) {\n            pendingIdleTasks.delete(filename);\n            promises.push(factory());\n            if (maxCount-- <= 0 || Date.now() > maxTime) break;\n          }\n          currentIdlePromise = Promise.all(promises);\n          currentIdlePromise.then(() => {\n            timeSpendInStore += Date.now() - startTime;\n            // Allow to exit the process between\n            idleTimer = setTimeout(processIdleTasks, 0);\n            idleTimer.unref();\n          });\n          return;\n        }\n        currentIdlePromise = currentIdlePromise.then(async () => {\n          await strategy.afterAllStored();\n          timeSpendInStore += Date.now() - startTime;\n          avgTimeSpendInStore = Math.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 + timeSpendInStore * 0.1;\n          timeSpendInStore = 0;\n          timeSpendInBuild = 0;\n        }).catch(err => {\n          const logger = compiler.getInfrastructureLogger(\"IdleFileCachePlugin\");\n          logger.warn(`Background tasks during idle failed: ${err.message}`);\n          logger.debug(err.stack);\n        });\n        isInitialStore = false;\n      }\n    };\n    let idleTimer = undefined;\n    compiler.cache.hooks.beginIdle.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      const isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n      if (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n        compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(`Initial cache was generated and cache will be persisted in ${idleTimeoutForInitialStore / 1000}s.`);\n      } else if (isLargeChange && idleTimeoutAfterLargeChanges < idleTimeout) {\n        compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(`Spend ${Math.round(timeSpendInBuild) / 1000}s in build and ${Math.round(avgTimeSpendInStore) / 1000}s in average in cache store. This is considered as large change and cache will be persisted in ${idleTimeoutAfterLargeChanges / 1000}s.`);\n      }\n      idleTimer = setTimeout(() => {\n        idleTimer = undefined;\n        isIdle = true;\n        resolvedPromise.then(processIdleTasks);\n      }, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n      idleTimer.unref();\n    });\n    compiler.cache.hooks.endIdle.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      if (idleTimer) {\n        clearTimeout(idleTimer);\n        idleTimer = undefined;\n      }\n      isIdle = false;\n    });\n    compiler.hooks.done.tap(\"IdleFileCachePlugin\", stats => {\n      // 10% build overhead is ignored, as it's not cacheable\n      timeSpendInBuild *= 0.9;\n      timeSpendInBuild += stats.endTime - stats.startTime;\n    });\n  }\n}\nmodule.exports = IdleFileCachePlugin;","map":{"version":3,"names":["Cache","require","ProgressPlugin","BUILD_DEPENDENCIES_KEY","Symbol","IdleFileCachePlugin","constructor","strategy","idleTimeout","idleTimeoutForInitialStore","idleTimeoutAfterLargeChanges","apply","compiler","Math","min","resolvedPromise","Promise","resolve","timeSpendInBuild","timeSpendInStore","avgTimeSpendInStore","pendingIdleTasks","Map","cache","hooks","store","tap","name","stage","STAGE_DISK","identifier","etag","data","set","get","tapPromise","gotHandlers","restore","then","cacheEntry","undefined","push","result","callback","pendingTask","delete","storeBuildDependencies","dependencies","shutdown","idleTimer","clearTimeout","isIdle","reportProgress","getReporter","jobs","Array","from","values","promises","map","fn","clear","currentIdlePromise","promise","all","afterAllStored","isInitialStore","processIdleTasks","startTime","Date","now","size","maxTime","maxCount","filename","factory","setTimeout","unref","max","catch","err","logger","getInfrastructureLogger","warn","message","debug","stack","beginIdle","isLargeChange","log","round","Infinity","endIdle","done","stats","endTime","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/cache/IdleFileCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst BUILD_DEPENDENCIES_KEY = Symbol();\n\nclass IdleFileCachePlugin {\n\t/**\n\t * @param {TODO} strategy cache strategy\n\t * @param {number} idleTimeout timeout\n\t * @param {number} idleTimeoutForInitialStore initial timeout\n\t * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n\t */\n\tconstructor(\n\t\tstrategy,\n\t\tidleTimeout,\n\t\tidleTimeoutForInitialStore,\n\t\tidleTimeoutAfterLargeChanges\n\t) {\n\t\tthis.strategy = strategy;\n\t\tthis.idleTimeout = idleTimeout;\n\t\tthis.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n\t\tthis.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tlet strategy = this.strategy;\n\t\tconst idleTimeout = this.idleTimeout;\n\t\tconst idleTimeoutForInitialStore = Math.min(\n\t\t\tidleTimeout,\n\t\t\tthis.idleTimeoutForInitialStore\n\t\t);\n\t\tconst idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n\t\tconst resolvedPromise = Promise.resolve();\n\n\t\tlet timeSpendInBuild = 0;\n\t\tlet timeSpendInStore = 0;\n\t\tlet avgTimeSpendInStore = 0;\n\n\t\t/** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n\t\tconst pendingIdleTasks = new Map();\n\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\tstrategy.store(identifier, etag, data)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.get.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst restore = () =>\n\t\t\t\t\tstrategy.restore(identifier, etag).then(cacheEntry => {\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\t\t\t\t\t\tstrategy.store(identifier, etag, result)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn cacheEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tconst pendingTask = pendingIdleTasks.get(identifier);\n\t\t\t\tif (pendingTask !== undefined) {\n\t\t\t\t\tpendingIdleTasks.delete(identifier);\n\t\t\t\t\treturn pendingTask().then(restore);\n\t\t\t\t}\n\t\t\t\treturn restore();\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.storeBuildDependencies.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\tdependencies => {\n\t\t\t\tpendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, () =>\n\t\t\t\t\tstrategy.storeBuildDependencies(dependencies)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.shutdown.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t\tconst reportProgress = ProgressPlugin.getReporter(compiler);\n\t\t\t\tconst jobs = Array.from(pendingIdleTasks.values());\n\t\t\t\tif (reportProgress) reportProgress(0, \"process pending cache items\");\n\t\t\t\tconst promises = jobs.map(fn => fn());\n\t\t\t\tpendingIdleTasks.clear();\n\t\t\t\tpromises.push(currentIdlePromise);\n\t\t\t\tconst promise = Promise.all(promises);\n\t\t\t\tcurrentIdlePromise = promise.then(() => strategy.afterAllStored());\n\t\t\t\tif (reportProgress) {\n\t\t\t\t\tcurrentIdlePromise = currentIdlePromise.then(() => {\n\t\t\t\t\t\treportProgress(1, `stored`);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn currentIdlePromise.then(() => {\n\t\t\t\t\t// Reset strategy\n\t\t\t\t\tif (strategy.clear) strategy.clear();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\n\t\t/** @type {Promise<any>} */\n\t\tlet currentIdlePromise = resolvedPromise;\n\t\tlet isIdle = false;\n\t\tlet isInitialStore = true;\n\t\tconst processIdleTasks = () => {\n\t\t\tif (isIdle) {\n\t\t\t\tconst startTime = Date.now();\n\t\t\t\tif (pendingIdleTasks.size > 0) {\n\t\t\t\t\tconst promises = [currentIdlePromise];\n\t\t\t\t\tconst maxTime = startTime + 100;\n\t\t\t\t\tlet maxCount = 100;\n\t\t\t\t\tfor (const [filename, factory] of pendingIdleTasks) {\n\t\t\t\t\t\tpendingIdleTasks.delete(filename);\n\t\t\t\t\t\tpromises.push(factory());\n\t\t\t\t\t\tif (maxCount-- <= 0 || Date.now() > maxTime) break;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentIdlePromise = Promise.all(promises);\n\t\t\t\t\tcurrentIdlePromise.then(() => {\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\t// Allow to exit the process between\n\t\t\t\t\t\tidleTimer = setTimeout(processIdleTasks, 0);\n\t\t\t\t\t\tidleTimer.unref();\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentIdlePromise = currentIdlePromise\n\t\t\t\t\t.then(async () => {\n\t\t\t\t\t\tawait strategy.afterAllStored();\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\tavgTimeSpendInStore =\n\t\t\t\t\t\t\tMath.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 +\n\t\t\t\t\t\t\ttimeSpendInStore * 0.1;\n\t\t\t\t\t\ttimeSpendInStore = 0;\n\t\t\t\t\t\ttimeSpendInBuild = 0;\n\t\t\t\t\t})\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tconst logger = compiler.getInfrastructureLogger(\n\t\t\t\t\t\t\t\"IdleFileCachePlugin\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlogger.warn(`Background tasks during idle failed: ${err.message}`);\n\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t});\n\t\t\t\tisInitialStore = false;\n\t\t\t}\n\t\t};\n\t\tlet idleTimer = undefined;\n\t\tcompiler.cache.hooks.beginIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tconst isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n\t\t\t\tif (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Initial cache was generated and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutForInitialStore / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\tisLargeChange &&\n\t\t\t\t\tidleTimeoutAfterLargeChanges < idleTimeout\n\t\t\t\t) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Spend ${Math.round(timeSpendInBuild) / 1000}s in build and ${\n\t\t\t\t\t\t\t\tMath.round(avgTimeSpendInStore) / 1000\n\t\t\t\t\t\t\t}s in average in cache store. This is considered as large change and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutAfterLargeChanges / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tidleTimer = setTimeout(() => {\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t\tisIdle = true;\n\t\t\t\t\tresolvedPromise.then(processIdleTasks);\n\t\t\t\t}, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n\t\t\t\tidleTimer.unref();\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.endIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t}\n\t\t);\n\t\tcompiler.hooks.done.tap(\"IdleFileCachePlugin\", stats => {\n\t\t\t// 10% build overhead is ignored, as it's not cacheable\n\t\t\ttimeSpendInBuild *= 0.9;\n\t\t\ttimeSpendInBuild += stats.endTime - stats.startTime;\n\t\t});\n\t}\n}\n\nmodule.exports = IdleFileCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}