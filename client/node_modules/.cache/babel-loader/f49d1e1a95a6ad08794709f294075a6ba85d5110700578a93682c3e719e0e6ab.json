{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\nconst patternRegEx = /\\*/g;\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(exportsField) {\n  return createFieldProcessor(buildExportsField(exportsField), request => request.length === 0 ? \".\" : \"./\" + request, assertExportsFieldRequest, assertExportTarget);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(importsField) {\n  return createFieldProcessor(buildImportsField(importsField), request => \"#\" + request, assertImportsFieldRequest, assertImportTarget);\n};\n\n/**\n * @param {ExportsField | ImportsField} field root\n * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(field, normalizeRequest, assertRequest, assertTarget) {\n  return function fieldProcessor(request, conditionNames) {\n    request = assertRequest(request);\n    const match = findMatch(normalizeRequest(request), field);\n    if (match === null) return [];\n    const [mapping, remainingRequest, isSubpathMapping, isPattern] = match;\n\n    /** @type {DirectMapping|null} */\n    let direct = null;\n    if (isConditionalMapping(mapping)) {\n      direct = conditionalMapping( /** @type {ConditionalMapping} */mapping, conditionNames);\n\n      // matching not found\n      if (direct === null) return [];\n    } else {\n      direct = /** @type {DirectMapping} */mapping;\n    }\n    return directMapping(remainingRequest, isPattern, isSubpathMapping, direct, conditionNames, assertTarget);\n  };\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== dotCode) {\n    throw new Error('Request should be relative path and start with \".\"');\n  }\n  if (request.length === 1) return \"\";\n  if (request.charCodeAt(1) !== slashCode) {\n    throw new Error('Request should be relative path and start with \"./\"');\n  }\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n  return request.slice(2);\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== hashCode) {\n    throw new Error('Request should start with \"#\"');\n  }\n  if (request.length === 1) {\n    throw new Error(\"Request should have at least 2 characters\");\n  }\n  if (request.charCodeAt(1) === slashCode) {\n    throw new Error('Request should not start with \"#/\"');\n  }\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n  return request.slice(1);\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n  if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) {\n    throw new Error(`Export should be relative path and start with \"./\", got ${JSON.stringify(exp)}.`);\n  }\n  const isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with \"/\"`);\n  }\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n  const isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with \"/\"`);\n  }\n}\n\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {number} compare result\n */\nfunction patternKeyCompare(a, b) {\n  const aPatternIndex = a.indexOf(\"*\");\n  const bPatternIndex = b.indexOf(\"*\");\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {ExportsField | ImportsField} field exports or import field\n * @returns {[MappingValue, string, boolean, boolean]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, field) {\n  if (Object.prototype.hasOwnProperty.call(field, request) && !request.includes(\"*\") && !request.endsWith(\"/\")) {\n    const target = /** @type {{[k: string]: MappingValue}} */field[request];\n    return [target, \"\", false, false];\n  }\n\n  /** @type {string} */\n  let bestMatch = \"\";\n  /** @type {string|undefined} */\n  let bestMatchSubpath;\n  const keys = Object.getOwnPropertyNames(field);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = key.indexOf(\"*\");\n    if (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {\n      const patternTrailer = key.slice(patternIndex + 1);\n      if (request.length >= key.length && request.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf(\"*\") === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = request.slice(patternIndex, request.length - patternTrailer.length);\n      }\n    }\n    // For legacy `./foo/`\n    else if (key[key.length - 1] === \"/\" && request.startsWith(key) && patternKeyCompare(bestMatch, key) === 1) {\n      bestMatch = key;\n      bestMatchSubpath = request.slice(key.length);\n    }\n  }\n  if (bestMatch === \"\") return null;\n  const target = /** @type {{[k: string]: MappingValue}} */field[bestMatch];\n  const isSubpathMapping = bestMatch.endsWith(\"/\");\n  const isPattern = bestMatch.includes(\"*\");\n  return [target, /** @type {string} */bestMatchSubpath, isSubpathMapping, isPattern];\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n  return mapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, conditionNames, assert) {\n  if (mappingTarget === null) return [];\n  if (typeof mappingTarget === \"string\") {\n    return [targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert)];\n  }\n\n  /** @type {string[]} */\n  const targets = [];\n  for (const exp of mappingTarget) {\n    if (typeof exp === \"string\") {\n      targets.push(targetMapping(remainingRequest, isPattern, isSubpathMapping, exp, assert));\n      continue;\n    }\n    const mapping = conditionalMapping(exp, conditionNames);\n    if (!mapping) continue;\n    const innerExports = directMapping(remainingRequest, isPattern, isSubpathMapping, mapping, conditionNames, assert);\n    for (const innerExport of innerExports) {\n      targets.push(innerExport);\n    }\n  }\n  return targets;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert) {\n  if (remainingRequest === undefined) {\n    assert(mappingTarget, false);\n    return mappingTarget;\n  }\n  if (isSubpathMapping) {\n    assert(mappingTarget, true);\n    return mappingTarget + remainingRequest;\n  }\n  assert(mappingTarget, false);\n  let result = mappingTarget;\n  if (isPattern) {\n    result = result.replace(patternRegEx, remainingRequest.replace(/\\$/g, \"$$\"));\n  }\n  return result;\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n  /** @type {[ConditionalMapping, string[], number][]} */\n  let lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n  loop: while (lookup.length > 0) {\n    const [mapping, conditions, j] = lookup[lookup.length - 1];\n    const last = conditions.length - 1;\n    for (let i = j; i < conditions.length; i++) {\n      const condition = conditions[i];\n\n      // assert default. Could be last only\n      if (i !== last) {\n        if (condition === \"default\") {\n          throw new Error(\"Default condition should be last one\");\n        }\n      } else if (condition === \"default\") {\n        const innerMapping = mapping[condition];\n        // is nested\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping = /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n        return (/** @type {DirectMapping} */innerMapping\n        );\n      }\n      if (conditionNames.has(condition)) {\n        const innerMapping = mapping[condition];\n        // is nested\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping = /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n        return (/** @type {DirectMapping} */innerMapping\n        );\n      }\n    }\n    lookup.pop();\n  }\n  return null;\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {ExportsField} normalized exports field\n */\nfunction buildExportsField(field) {\n  // handle syntax sugar, if exports field is direct mapping for \".\"\n  if (typeof field === \"string\" || Array.isArray(field)) {\n    return {\n      \".\": field\n    };\n  }\n  const keys = Object.keys(field);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key.charCodeAt(0) !== dotCode) {\n      // handle syntax sugar, if exports field is conditional mapping for \".\"\n      if (i === 0) {\n        while (i < keys.length) {\n          const charCode = keys[i].charCodeAt(0);\n          if (charCode === dotCode || charCode === slashCode) {\n            throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n          }\n          i++;\n        }\n        return {\n          \".\": field\n        };\n      }\n      throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n    }\n    if (key.length === 1) {\n      continue;\n    }\n    if (key.charCodeAt(1) !== slashCode) {\n      throw new Error(`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(key)})`);\n    }\n  }\n  return field;\n}\n\n/**\n * @param {ImportsField} field imports field\n * @returns {ImportsField} normalized imports field\n */\nfunction buildImportsField(field) {\n  const keys = Object.keys(field);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key.charCodeAt(0) !== hashCode) {\n      throw new Error(`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`);\n    }\n    if (key.length === 1) {\n      throw new Error(`Imports field key should have at least 2 characters (key: ${JSON.stringify(key)})`);\n    }\n    if (key.charCodeAt(1) === slashCode) {\n      throw new Error(`Imports field key should not start with \"#/\" (key: ${JSON.stringify(key)})`);\n    }\n  }\n  return field;\n}","map":{"version":3,"names":["slashCode","charCodeAt","dotCode","hashCode","patternRegEx","module","exports","processExportsField","exportsField","createFieldProcessor","buildExportsField","request","length","assertExportsFieldRequest","assertExportTarget","processImportsField","importsField","buildImportsField","assertImportsFieldRequest","assertImportTarget","field","normalizeRequest","assertRequest","assertTarget","fieldProcessor","conditionNames","match","findMatch","mapping","remainingRequest","isSubpathMapping","isPattern","direct","isConditionalMapping","conditionalMapping","directMapping","Error","slice","exp","expectFolder","JSON","stringify","isFolder","imp","patternKeyCompare","a","b","aPatternIndex","indexOf","bPatternIndex","baseLenA","baseLenB","Object","prototype","hasOwnProperty","call","includes","endsWith","target","bestMatch","bestMatchSubpath","keys","getOwnPropertyNames","i","key","patternIndex","startsWith","patternTrailer","lastIndexOf","Array","isArray","mappingTarget","assert","targetMapping","targets","push","innerExports","innerExport","undefined","result","replace","conditionalMapping_","lookup","loop","conditions","j","last","condition","innerMapping","has","pop","charCode"],"sources":["/home/hemanth/react-project/client/node_modules/enhanced-resolve/lib/util/entrypoints.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\nconst patternRegEx = /\\*/g;\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(\n\texportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildExportsField(exportsField),\n\t\trequest => (request.length === 0 ? \".\" : \"./\" + request),\n\t\tassertExportsFieldRequest,\n\t\tassertExportTarget\n\t);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(\n\timportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildImportsField(importsField),\n\t\trequest => \"#\" + request,\n\t\tassertImportsFieldRequest,\n\t\tassertImportTarget\n\t);\n};\n\n/**\n * @param {ExportsField | ImportsField} field root\n * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(\n\tfield,\n\tnormalizeRequest,\n\tassertRequest,\n\tassertTarget\n) {\n\treturn function fieldProcessor(request, conditionNames) {\n\t\trequest = assertRequest(request);\n\n\t\tconst match = findMatch(normalizeRequest(request), field);\n\n\t\tif (match === null) return [];\n\n\t\tconst [mapping, remainingRequest, isSubpathMapping, isPattern] = match;\n\n\t\t/** @type {DirectMapping|null} */\n\t\tlet direct = null;\n\n\t\tif (isConditionalMapping(mapping)) {\n\t\t\tdirect = conditionalMapping(\n\t\t\t\t/** @type {ConditionalMapping} */ (mapping),\n\t\t\t\tconditionNames\n\t\t\t);\n\n\t\t\t// matching not found\n\t\t\tif (direct === null) return [];\n\t\t} else {\n\t\t\tdirect = /** @type {DirectMapping} */ (mapping);\n\t\t}\n\n\t\treturn directMapping(\n\t\t\tremainingRequest,\n\t\t\tisPattern,\n\t\t\tisSubpathMapping,\n\t\t\tdirect,\n\t\t\tconditionNames,\n\t\t\tassertTarget\n\t\t);\n\t};\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== dotCode) {\n\t\tthrow new Error('Request should be relative path and start with \".\"');\n\t}\n\tif (request.length === 1) return \"\";\n\tif (request.charCodeAt(1) !== slashCode) {\n\t\tthrow new Error('Request should be relative path and start with \"./\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(2);\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== hashCode) {\n\t\tthrow new Error('Request should start with \"#\"');\n\t}\n\tif (request.length === 1) {\n\t\tthrow new Error(\"Request should have at least 2 characters\");\n\t}\n\tif (request.charCodeAt(1) === slashCode) {\n\t\tthrow new Error('Request should not start with \"#/\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(1);\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n\tif (\n\t\texp.charCodeAt(0) === slashCode ||\n\t\t(exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode)\n\t) {\n\t\tthrow new Error(\n\t\t\t`Export should be relative path and start with \"./\", got ${JSON.stringify(\n\t\t\t\texp\n\t\t\t)}.`\n\t\t);\n\t}\n\n\tconst isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n\tconst isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {number} compare result\n */\nfunction patternKeyCompare(a, b) {\n\tconst aPatternIndex = a.indexOf(\"*\");\n\tconst bPatternIndex = b.indexOf(\"*\");\n\tconst baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n\tconst baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n\n\tif (baseLenA > baseLenB) return -1;\n\tif (baseLenB > baseLenA) return 1;\n\tif (aPatternIndex === -1) return 1;\n\tif (bPatternIndex === -1) return -1;\n\tif (a.length > b.length) return -1;\n\tif (b.length > a.length) return 1;\n\n\treturn 0;\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {ExportsField | ImportsField} field exports or import field\n * @returns {[MappingValue, string, boolean, boolean]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, field) {\n\tif (\n\t\tObject.prototype.hasOwnProperty.call(field, request) &&\n\t\t!request.includes(\"*\") &&\n\t\t!request.endsWith(\"/\")\n\t) {\n\t\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[request];\n\n\t\treturn [target, \"\", false, false];\n\t}\n\n\t/** @type {string} */\n\tlet bestMatch = \"\";\n\t/** @type {string|undefined} */\n\tlet bestMatchSubpath;\n\n\tconst keys = Object.getOwnPropertyNames(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst patternIndex = key.indexOf(\"*\");\n\n\t\tif (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {\n\t\t\tconst patternTrailer = key.slice(patternIndex + 1);\n\n\t\t\tif (\n\t\t\t\trequest.length >= key.length &&\n\t\t\t\trequest.endsWith(patternTrailer) &&\n\t\t\t\tpatternKeyCompare(bestMatch, key) === 1 &&\n\t\t\t\tkey.lastIndexOf(\"*\") === patternIndex\n\t\t\t) {\n\t\t\t\tbestMatch = key;\n\t\t\t\tbestMatchSubpath = request.slice(\n\t\t\t\t\tpatternIndex,\n\t\t\t\t\trequest.length - patternTrailer.length\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// For legacy `./foo/`\n\t\telse if (\n\t\t\tkey[key.length - 1] === \"/\" &&\n\t\t\trequest.startsWith(key) &&\n\t\t\tpatternKeyCompare(bestMatch, key) === 1\n\t\t) {\n\t\t\tbestMatch = key;\n\t\t\tbestMatchSubpath = request.slice(key.length);\n\t\t}\n\t}\n\n\tif (bestMatch === \"\") return null;\n\n\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[bestMatch];\n\tconst isSubpathMapping = bestMatch.endsWith(\"/\");\n\tconst isPattern = bestMatch.includes(\"*\");\n\n\treturn [\n\t\ttarget,\n\t\t/** @type {string} */ (bestMatchSubpath),\n\t\tisSubpathMapping,\n\t\tisPattern\n\t];\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n\treturn (\n\t\tmapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping)\n\t);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tconditionNames,\n\tassert\n) {\n\tif (mappingTarget === null) return [];\n\n\tif (typeof mappingTarget === \"string\") {\n\t\treturn [\n\t\t\ttargetMapping(\n\t\t\t\tremainingRequest,\n\t\t\t\tisPattern,\n\t\t\t\tisSubpathMapping,\n\t\t\t\tmappingTarget,\n\t\t\t\tassert\n\t\t\t)\n\t\t];\n\t}\n\n\t/** @type {string[]} */\n\tconst targets = [];\n\n\tfor (const exp of mappingTarget) {\n\t\tif (typeof exp === \"string\") {\n\t\t\ttargets.push(\n\t\t\t\ttargetMapping(\n\t\t\t\t\tremainingRequest,\n\t\t\t\t\tisPattern,\n\t\t\t\t\tisSubpathMapping,\n\t\t\t\t\texp,\n\t\t\t\t\tassert\n\t\t\t\t)\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst mapping = conditionalMapping(exp, conditionNames);\n\t\tif (!mapping) continue;\n\t\tconst innerExports = directMapping(\n\t\t\tremainingRequest,\n\t\t\tisPattern,\n\t\t\tisSubpathMapping,\n\t\t\tmapping,\n\t\t\tconditionNames,\n\t\t\tassert\n\t\t);\n\t\tfor (const innerExport of innerExports) {\n\t\t\ttargets.push(innerExport);\n\t\t}\n\t}\n\n\treturn targets;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tassert\n) {\n\tif (remainingRequest === undefined) {\n\t\tassert(mappingTarget, false);\n\n\t\treturn mappingTarget;\n\t}\n\n\tif (isSubpathMapping) {\n\t\tassert(mappingTarget, true);\n\n\t\treturn mappingTarget + remainingRequest;\n\t}\n\n\tassert(mappingTarget, false);\n\n\tlet result = mappingTarget;\n\n\tif (isPattern) {\n\t\tresult = result.replace(\n\t\t\tpatternRegEx,\n\t\t\tremainingRequest.replace(/\\$/g, \"$$\")\n\t\t);\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n\t/** @type {[ConditionalMapping, string[], number][]} */\n\tlet lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n\tloop: while (lookup.length > 0) {\n\t\tconst [mapping, conditions, j] = lookup[lookup.length - 1];\n\t\tconst last = conditions.length - 1;\n\n\t\tfor (let i = j; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\n\t\t\t// assert default. Could be last only\n\t\t\tif (i !== last) {\n\t\t\t\tif (condition === \"default\") {\n\t\t\t\t\tthrow new Error(\"Default condition should be last one\");\n\t\t\t\t}\n\t\t\t} else if (condition === \"default\") {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\n\t\t\tif (conditionNames.has(condition)) {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\t\t}\n\n\t\tlookup.pop();\n\t}\n\n\treturn null;\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {ExportsField} normalized exports field\n */\nfunction buildExportsField(field) {\n\t// handle syntax sugar, if exports field is direct mapping for \".\"\n\tif (typeof field === \"string\" || Array.isArray(field)) {\n\t\treturn { \".\": field };\n\t}\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== dotCode) {\n\t\t\t// handle syntax sugar, if exports field is conditional mapping for \".\"\n\t\t\tif (i === 0) {\n\t\t\t\twhile (i < keys.length) {\n\t\t\t\t\tconst charCode = keys[i].charCodeAt(0);\n\t\t\t\t\tif (charCode === dotCode || charCode === slashCode) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn { \".\": field };\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.charCodeAt(1) !== slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn field;\n}\n\n/**\n * @param {ImportsField} field imports field\n * @returns {ImportsField} normalized imports field\n */\nfunction buildImportsField(field) {\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== hashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should have at least 2 characters (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.charCodeAt(1) === slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should not start with \"#/\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn field;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,SAAS,GAAG,GAAG,CAACC,UAAU,CAAC,CAAC,CAAC;AACnC,MAAMC,OAAO,GAAG,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC;AACjC,MAAME,QAAQ,GAAG,GAAG,CAACF,UAAU,CAAC,CAAC,CAAC;AAClC,MAAMG,YAAY,GAAG,KAAK;;AAE1B;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,CAACC,mBAAmB,GAAG,SAASA,mBAAmBA,CAChEC,YAAY,EACX;EACD,OAAOC,oBAAoB,CAC1BC,iBAAiB,CAACF,YAAY,CAAC,EAC/BG,OAAO,IAAKA,OAAO,CAACC,MAAM,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI,GAAGD,OAAQ,EACxDE,yBAAyB,EACzBC,kBACD,CAAC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACAT,MAAM,CAACC,OAAO,CAACS,mBAAmB,GAAG,SAASA,mBAAmBA,CAChEC,YAAY,EACX;EACD,OAAOP,oBAAoB,CAC1BQ,iBAAiB,CAACD,YAAY,CAAC,EAC/BL,OAAO,IAAI,GAAG,GAAGA,OAAO,EACxBO,yBAAyB,EACzBC,kBACD,CAAC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASV,oBAAoBA,CAC5BW,KAAK,EACLC,gBAAgB,EAChBC,aAAa,EACbC,YAAY,EACX;EACD,OAAO,SAASC,cAAcA,CAACb,OAAO,EAAEc,cAAc,EAAE;IACvDd,OAAO,GAAGW,aAAa,CAACX,OA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}