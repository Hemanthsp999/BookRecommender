{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\nconst BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\nclass BulkUpdateDecorator extends Hash {\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    super();\n    this.hashKey = hashKey;\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n    this.buffer = \"\";\n  }\n\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n  update(data, inputEncoding) {\n    if (inputEncoding !== undefined || typeof data !== \"string\" || data.length > BULK_SIZE) {\n      if (this.hash === undefined) this.hash = this.hashFactory();\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) this.hash = this.hashFactory();\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n  digest(encoding) {\n    let digestCache;\n    const buffer = this.buffer;\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n      digestCache = digestCaches[cacheKey];\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n      const cacheEntry = digestCache.get(buffer);\n      if (cacheEntry !== undefined) return cacheEntry;\n      this.hash = this.hashFactory();\n    }\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n    const digestResult = this.hash.digest(encoding);\n    const result = typeof digestResult === \"string\" ? digestResult : digestResult.toString();\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, result);\n    }\n    return result;\n  }\n}\n\n/* istanbul ignore next */\nclass DebugHash extends Hash {\n  constructor() {\n    super();\n    this.string = \"\";\n  }\n\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n  update(data, inputEncoding) {\n    if (typeof data !== \"string\") data = data.toString(\"utf-8\");\n    const prefix = Buffer.from(\"@webpack-debug-digest@\").toString(\"hex\");\n    if (data.startsWith(prefix)) {\n      data = Buffer.from(data.slice(prefix.length), \"hex\").toString();\n    }\n    this.string += `[${data}](${new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n    return this;\n  }\n\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n  digest(encoding) {\n    return Buffer.from(\"@webpack-debug-digest@\" + this.string).toString(\"hex\");\n  }\n}\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\nmodule.exports = algorithm => {\n  if (typeof algorithm === \"function\") {\n    return new BulkUpdateDecorator(() => new algorithm());\n  }\n  switch (algorithm) {\n    // TODO add non-cryptographic algorithm here\n    case \"debug\":\n      return new DebugHash();\n    case \"xxhash64\":\n      if (createXXHash64 === undefined) {\n        createXXHash64 = require(\"./hash/xxhash64\");\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n      return new BatchedHash(createXXHash64());\n    case \"md4\":\n      if (createMd4 === undefined) {\n        createMd4 = require(\"./hash/md4\");\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n      return new BatchedHash(createMd4());\n    case \"native-md4\":\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n    default:\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() => crypto.createHash(algorithm), algorithm);\n  }\n};","map":{"version":3,"names":["Hash","require","BULK_SIZE","digestCaches","BulkUpdateDecorator","constructor","hashOrFactory","hashKey","hashFactory","hash","undefined","buffer","update","data","inputEncoding","length","digest","encoding","digestCache","cacheKey","Map","cacheEntry","get","digestResult","result","toString","set","DebugHash","string","prefix","Buffer","from","startsWith","slice","Error","stack","split","crypto","createXXHash64","createMd4","BatchedHash","module","exports","algorithm","createHash"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/createHash.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\n\nclass BulkUpdateDecorator extends Hash {\n\t/**\n\t * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n\t * @param {string=} hashKey key for caching\n\t */\n\tconstructor(hashOrFactory, hashKey) {\n\t\tsuper();\n\t\tthis.hashKey = hashKey;\n\t\tif (typeof hashOrFactory === \"function\") {\n\t\t\tthis.hashFactory = hashOrFactory;\n\t\t\tthis.hash = undefined;\n\t\t} else {\n\t\t\tthis.hashFactory = undefined;\n\t\t\tthis.hash = hashOrFactory;\n\t\t}\n\t\tthis.buffer = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (\n\t\t\tinputEncoding !== undefined ||\n\t\t\ttypeof data !== \"string\" ||\n\t\t\tdata.length > BULK_SIZE\n\t\t) {\n\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\tif (this.buffer.length > 0) {\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t\tthis.hash.update(data, inputEncoding);\n\t\t} else {\n\t\t\tthis.buffer += data;\n\t\t\tif (this.buffer.length > BULK_SIZE) {\n\t\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\tlet digestCache;\n\t\tconst buffer = this.buffer;\n\t\tif (this.hash === undefined) {\n\t\t\t// short data for hash, we can use caching\n\t\t\tconst cacheKey = `${this.hashKey}-${encoding}`;\n\t\t\tdigestCache = digestCaches[cacheKey];\n\t\t\tif (digestCache === undefined) {\n\t\t\t\tdigestCache = digestCaches[cacheKey] = new Map();\n\t\t\t}\n\t\t\tconst cacheEntry = digestCache.get(buffer);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tthis.hash = this.hashFactory();\n\t\t}\n\t\tif (buffer.length > 0) {\n\t\t\tthis.hash.update(buffer);\n\t\t}\n\t\tconst digestResult = this.hash.digest(encoding);\n\t\tconst result =\n\t\t\ttypeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\t\tif (digestCache !== undefined) {\n\t\t\tdigestCache.set(buffer, result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/* istanbul ignore next */\nclass DebugHash extends Hash {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.string = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\t\tconst prefix = Buffer.from(\"@webpack-debug-digest@\").toString(\"hex\");\n\t\tif (data.startsWith(prefix)) {\n\t\t\tdata = Buffer.from(data.slice(prefix.length), \"hex\").toString();\n\t\t}\n\t\tthis.string += `[${data}](${new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\treturn Buffer.from(\"@webpack-debug-digest@\" + this.string).toString(\"hex\");\n\t}\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\nmodule.exports = algorithm => {\n\tif (typeof algorithm === \"function\") {\n\t\treturn new BulkUpdateDecorator(() => new algorithm());\n\t}\n\tswitch (algorithm) {\n\t\t// TODO add non-cryptographic algorithm here\n\t\tcase \"debug\":\n\t\t\treturn new DebugHash();\n\t\tcase \"xxhash64\":\n\t\t\tif (createXXHash64 === undefined) {\n\t\t\t\tcreateXXHash64 = require(\"./hash/xxhash64\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createXXHash64());\n\t\tcase \"md4\":\n\t\t\tif (createMd4 === undefined) {\n\t\t\t\tcreateMd4 = require(\"./hash/md4\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createMd4());\n\t\tcase \"native-md4\":\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n\t\tdefault:\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(\n\t\t\t\t() => crypto.createHash(algorithm),\n\t\t\t\talgorithm\n\t\t\t);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}