{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  compareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst {\n  assignAscendingModuleIds,\n  getUsedModuleIdsAndModules\n} = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../../declarations/plugins/ids/OccurrenceModuleIdsPlugin\").OccurrenceModuleIdsPluginOptions} OccurrenceModuleIdsPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.check.js\"), () => require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.json\"), {\n  name: \"Occurrence Order Module Ids Plugin\",\n  baseDataPath: \"options\"\n});\nclass OccurrenceModuleIdsPlugin {\n  /**\n   * @param {OccurrenceModuleIdsPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.options = options;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const prioritiseInitial = this.options.prioritiseInitial;\n    compiler.hooks.compilation.tap(\"OccurrenceModuleIdsPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.moduleIds.tap(\"OccurrenceModuleIdsPlugin\", () => {\n        const chunkGraph = compilation.chunkGraph;\n        const [usedIds, modulesInOccurrenceOrder] = getUsedModuleIdsAndModules(compilation);\n        const occursInInitialChunksMap = new Map();\n        const occursInAllChunksMap = new Map();\n        const initialChunkChunkMap = new Map();\n        const entryCountMap = new Map();\n        for (const m of modulesInOccurrenceOrder) {\n          let initial = 0;\n          let entry = 0;\n          for (const c of chunkGraph.getModuleChunksIterable(m)) {\n            if (c.canBeInitial()) initial++;\n            if (chunkGraph.isEntryModuleInChunk(m, c)) entry++;\n          }\n          initialChunkChunkMap.set(m, initial);\n          entryCountMap.set(m, entry);\n        }\n\n        /**\n         * @param {Module} module module\n         * @returns {number} count of occurs\n         */\n        const countOccursInEntry = module => {\n          let sum = 0;\n          for (const [originModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n            if (!originModule) continue;\n            if (!connections.some(c => c.isTargetActive(undefined))) continue;\n            sum += initialChunkChunkMap.get(originModule) || 0;\n          }\n          return sum;\n        };\n\n        /**\n         * @param {Module} module module\n         * @returns {number} count of occurs\n         */\n        const countOccurs = module => {\n          let sum = 0;\n          for (const [originModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n            if (!originModule) continue;\n            const chunkModules = chunkGraph.getNumberOfModuleChunks(originModule);\n            for (const c of connections) {\n              if (!c.isTargetActive(undefined)) continue;\n              if (!c.dependency) continue;\n              const factor = c.dependency.getNumberOfIdOccurrences();\n              if (factor === 0) continue;\n              sum += factor * chunkModules;\n            }\n          }\n          return sum;\n        };\n        if (prioritiseInitial) {\n          for (const m of modulesInOccurrenceOrder) {\n            const result = countOccursInEntry(m) + initialChunkChunkMap.get(m) + entryCountMap.get(m);\n            occursInInitialChunksMap.set(m, result);\n          }\n        }\n        for (const m of modulesInOccurrenceOrder) {\n          const result = countOccurs(m) + chunkGraph.getNumberOfModuleChunks(m) + entryCountMap.get(m);\n          occursInAllChunksMap.set(m, result);\n        }\n        const naturalCompare = compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph);\n        modulesInOccurrenceOrder.sort((a, b) => {\n          if (prioritiseInitial) {\n            const aEntryOccurs = occursInInitialChunksMap.get(a);\n            const bEntryOccurs = occursInInitialChunksMap.get(b);\n            if (aEntryOccurs > bEntryOccurs) return -1;\n            if (aEntryOccurs < bEntryOccurs) return 1;\n          }\n          const aOccurs = occursInAllChunksMap.get(a);\n          const bOccurs = occursInAllChunksMap.get(b);\n          if (aOccurs > bOccurs) return -1;\n          if (aOccurs < bOccurs) return 1;\n          return naturalCompare(a, b);\n        });\n        assignAscendingModuleIds(usedIds, modulesInOccurrenceOrder, compilation);\n      });\n    });\n  }\n}\nmodule.exports = OccurrenceModuleIdsPlugin;","map":{"version":3,"names":["compareModulesByPreOrderIndexOrIdentifier","require","createSchemaValidation","assignAscendingModuleIds","getUsedModuleIdsAndModules","validate","name","baseDataPath","OccurrenceModuleIdsPlugin","constructor","options","arguments","length","undefined","apply","compiler","prioritiseInitial","hooks","compilation","tap","moduleGraph","moduleIds","chunkGraph","usedIds","modulesInOccurrenceOrder","occursInInitialChunksMap","Map","occursInAllChunksMap","initialChunkChunkMap","entryCountMap","m","initial","entry","c","getModuleChunksIterable","canBeInitial","isEntryModuleInChunk","set","countOccursInEntry","module","sum","originModule","connections","getIncomingConnectionsByOriginModule","some","isTargetActive","get","countOccurs","chunkModules","getNumberOfModuleChunks","dependency","factor","getNumberOfIdOccurrences","result","naturalCompare","sort","a","b","aEntryOccurs","bEntryOccurs","aOccurs","bOccurs","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/ids/OccurrenceModuleIdsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tcompareModulesByPreOrderIndexOrIdentifier\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst {\n\tassignAscendingModuleIds,\n\tgetUsedModuleIdsAndModules\n} = require(\"./IdHelpers\");\n\n/** @typedef {import(\"../../declarations/plugins/ids/OccurrenceModuleIdsPlugin\").OccurrenceModuleIdsPluginOptions} OccurrenceModuleIdsPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/ids/OccurrenceModuleIdsPlugin.json\"),\n\t{\n\t\tname: \"Occurrence Order Module Ids Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nclass OccurrenceModuleIdsPlugin {\n\t/**\n\t * @param {OccurrenceModuleIdsPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst prioritiseInitial = this.options.prioritiseInitial;\n\t\tcompiler.hooks.compilation.tap(\"OccurrenceModuleIdsPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\t\tcompilation.hooks.moduleIds.tap(\"OccurrenceModuleIdsPlugin\", () => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\n\t\t\t\tconst [usedIds, modulesInOccurrenceOrder] =\n\t\t\t\t\tgetUsedModuleIdsAndModules(compilation);\n\n\t\t\t\tconst occursInInitialChunksMap = new Map();\n\t\t\t\tconst occursInAllChunksMap = new Map();\n\n\t\t\t\tconst initialChunkChunkMap = new Map();\n\t\t\t\tconst entryCountMap = new Map();\n\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\tlet initial = 0;\n\t\t\t\t\tlet entry = 0;\n\t\t\t\t\tfor (const c of chunkGraph.getModuleChunksIterable(m)) {\n\t\t\t\t\t\tif (c.canBeInitial()) initial++;\n\t\t\t\t\t\tif (chunkGraph.isEntryModuleInChunk(m, c)) entry++;\n\t\t\t\t\t}\n\t\t\t\t\tinitialChunkChunkMap.set(m, initial);\n\t\t\t\t\tentryCountMap.set(m, entry);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * @param {Module} module module\n\t\t\t\t * @returns {number} count of occurs\n\t\t\t\t */\n\t\t\t\tconst countOccursInEntry = module => {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\tconnections\n\t\t\t\t\t] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n\t\t\t\t\t\tif (!originModule) continue;\n\t\t\t\t\t\tif (!connections.some(c => c.isTargetActive(undefined))) continue;\n\t\t\t\t\t\tsum += initialChunkChunkMap.get(originModule) || 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {Module} module module\n\t\t\t\t * @returns {number} count of occurs\n\t\t\t\t */\n\t\t\t\tconst countOccurs = module => {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\tconnections\n\t\t\t\t\t] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {\n\t\t\t\t\t\tif (!originModule) continue;\n\t\t\t\t\t\tconst chunkModules =\n\t\t\t\t\t\t\tchunkGraph.getNumberOfModuleChunks(originModule);\n\t\t\t\t\t\tfor (const c of connections) {\n\t\t\t\t\t\t\tif (!c.isTargetActive(undefined)) continue;\n\t\t\t\t\t\t\tif (!c.dependency) continue;\n\t\t\t\t\t\t\tconst factor = c.dependency.getNumberOfIdOccurrences();\n\t\t\t\t\t\t\tif (factor === 0) continue;\n\t\t\t\t\t\t\tsum += factor * chunkModules;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn sum;\n\t\t\t\t};\n\n\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\tcountOccursInEntry(m) +\n\t\t\t\t\t\t\tinitialChunkChunkMap.get(m) +\n\t\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\t\toccursInInitialChunksMap.set(m, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const m of modulesInOccurrenceOrder) {\n\t\t\t\t\tconst result =\n\t\t\t\t\t\tcountOccurs(m) +\n\t\t\t\t\t\tchunkGraph.getNumberOfModuleChunks(m) +\n\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\toccursInAllChunksMap.set(m, result);\n\t\t\t\t}\n\n\t\t\t\tconst naturalCompare = compareModulesByPreOrderIndexOrIdentifier(\n\t\t\t\t\tcompilation.moduleGraph\n\t\t\t\t);\n\n\t\t\t\tmodulesInOccurrenceOrder.sort((a, b) => {\n\t\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\t\tconst aEntryOccurs = occursInInitialChunksMap.get(a);\n\t\t\t\t\t\tconst bEntryOccurs = occursInInitialChunksMap.get(b);\n\t\t\t\t\t\tif (aEntryOccurs > bEntryOccurs) return -1;\n\t\t\t\t\t\tif (aEntryOccurs < bEntryOccurs) return 1;\n\t\t\t\t\t}\n\t\t\t\t\tconst aOccurs = occursInAllChunksMap.get(a);\n\t\t\t\t\tconst bOccurs = occursInAllChunksMap.get(b);\n\t\t\t\t\tif (aOccurs > bOccurs) return -1;\n\t\t\t\t\tif (aOccurs < bOccurs) return 1;\n\t\t\t\t\treturn naturalCompare(a, b);\n\t\t\t\t});\n\n\t\t\t\tassignAscendingModuleIds(\n\t\t\t\t\tusedIds,\n\t\t\t\t\tmodulesInOccurrenceOrder,\n\t\t\t\t\tcompilation\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = OccurrenceModuleIdsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}