{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\nconst {\n  UsageState\n} = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst {\n  STAGE_DEFAULT\n} = require(\"./OptimizationStages\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\nconst TupleQueue = require(\"./util/TupleQueue\");\nconst {\n  getEntryRuntime,\n  mergeRuntimeOwned\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst {\n  NO_EXPORTS_REFERENCED,\n  EXPORTS_OBJECT_REFERENCED\n} = Dependency;\nconst PLUGIN_NAME = \"FlagDependencyUsagePlugin\";\nconst PLUGIN_LOGGER_NAME = `webpack.${PLUGIN_NAME}`;\nclass FlagDependencyUsagePlugin {\n  /**\n   * @param {boolean} global do a global analysis instead of per runtime\n   */\n  constructor(global) {\n    this.global = global;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.optimizeDependencies.tap({\n        name: PLUGIN_NAME,\n        stage: STAGE_DEFAULT\n      }, modules => {\n        if (compilation.moduleMemCaches) {\n          throw new Error(\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\");\n        }\n        const logger = compilation.getLogger(PLUGIN_LOGGER_NAME);\n        /** @type {Map<ExportsInfo, Module>} */\n        const exportInfoToModuleMap = new Map();\n\n        /** @type {TupleQueue<[Module, RuntimeSpec]>} */\n        const queue = new TupleQueue();\n\n        /**\n         * @param {Module} module module to process\n         * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n         * @param {RuntimeSpec} runtime part of which runtime\n         * @param {boolean} forceSideEffects always apply side effects\n         * @returns {void}\n         */\n        const processReferencedModule = (module, usedExports, runtime, forceSideEffects) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          if (usedExports.length > 0) {\n            if (!module.buildMeta || !module.buildMeta.exportsType) {\n              if (exportsInfo.setUsedWithoutInfo(runtime)) {\n                queue.enqueue(module, runtime);\n              }\n              return;\n            }\n            for (const usedExportInfo of usedExports) {\n              let usedExport;\n              let canMangle = true;\n              if (Array.isArray(usedExportInfo)) {\n                usedExport = usedExportInfo;\n              } else {\n                usedExport = usedExportInfo.name;\n                canMangle = usedExportInfo.canMangle !== false;\n              }\n              if (usedExport.length === 0) {\n                if (exportsInfo.setUsedInUnknownWay(runtime)) {\n                  queue.enqueue(module, runtime);\n                }\n              } else {\n                let currentExportsInfo = exportsInfo;\n                for (let i = 0; i < usedExport.length; i++) {\n                  const exportInfo = currentExportsInfo.getExportInfo(usedExport[i]);\n                  if (canMangle === false) {\n                    exportInfo.canMangleUse = false;\n                  }\n                  const lastOne = i === usedExport.length - 1;\n                  if (!lastOne) {\n                    const nestedInfo = exportInfo.getNestedExportsInfo();\n                    if (nestedInfo) {\n                      if (exportInfo.setUsedConditionally(used => used === UsageState.Unused, UsageState.OnlyPropertiesUsed, runtime)) {\n                        const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n                        if (currentModule) {\n                          queue.enqueue(currentModule, runtime);\n                        }\n                      }\n                      currentExportsInfo = nestedInfo;\n                      continue;\n                    }\n                  }\n                  if (exportInfo.setUsedConditionally(v => v !== UsageState.Used, UsageState.Used, runtime)) {\n                    const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n                    if (currentModule) {\n                      queue.enqueue(currentModule, runtime);\n                    }\n                  }\n                  break;\n                }\n              }\n            }\n          } else {\n            // for a module without side effects we stop tracking usage here when no export is used\n            // This module won't be evaluated in this case\n            // TODO webpack 6 remove this check\n            if (!forceSideEffects && module.factoryMeta !== undefined && module.factoryMeta.sideEffectFree) {\n              return;\n            }\n            if (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n              queue.enqueue(module, runtime);\n            }\n          }\n        };\n\n        /**\n         * @param {DependenciesBlock} module the module\n         * @param {RuntimeSpec} runtime part of which runtime\n         * @param {boolean} forceSideEffects always apply side effects\n         * @returns {void}\n         */\n        const processModule = (module, runtime, forceSideEffects) => {\n          /** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n          const map = new Map();\n\n          /** @type {ArrayQueue<DependenciesBlock>} */\n          const queue = new ArrayQueue();\n          queue.enqueue(module);\n          for (;;) {\n            const block = queue.dequeue();\n            if (block === undefined) break;\n            for (const b of block.blocks) {\n              if (!this.global && b.groupOptions && b.groupOptions.entryOptions) {\n                processModule(b, b.groupOptions.entryOptions.runtime || undefined, true);\n              } else {\n                queue.enqueue(b);\n              }\n            }\n            for (const dep of block.dependencies) {\n              const connection = moduleGraph.getConnection(dep);\n              if (!connection || !connection.module) {\n                continue;\n              }\n              const activeState = connection.getActiveState(runtime);\n              if (activeState === false) continue;\n              const {\n                module\n              } = connection;\n              if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n                processModule(module, runtime, false);\n                continue;\n              }\n              const oldReferencedExports = map.get(module);\n              if (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n                continue;\n              }\n              const referencedExports = compilation.getDependencyReferencedExports(dep, runtime);\n              if (oldReferencedExports === undefined || oldReferencedExports === NO_EXPORTS_REFERENCED || referencedExports === EXPORTS_OBJECT_REFERENCED) {\n                map.set(module, referencedExports);\n              } else if (oldReferencedExports !== undefined && referencedExports === NO_EXPORTS_REFERENCED) {\n                continue;\n              } else {\n                let exportsMap;\n                if (Array.isArray(oldReferencedExports)) {\n                  exportsMap = new Map();\n                  for (const item of oldReferencedExports) {\n                    if (Array.isArray(item)) {\n                      exportsMap.set(item.join(\"\\n\"), item);\n                    } else {\n                      exportsMap.set(item.name.join(\"\\n\"), item);\n                    }\n                  }\n                  map.set(module, exportsMap);\n                } else {\n                  exportsMap = oldReferencedExports;\n                }\n                for (const item of referencedExports) {\n                  if (Array.isArray(item)) {\n                    const key = item.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n                    if (oldItem === undefined) {\n                      exportsMap.set(key, item);\n                    }\n                    // if oldItem is already an array we have to do nothing\n                    // if oldItem is an ReferencedExport object, we don't have to do anything\n                    // as canMangle defaults to true for arrays\n                  } else {\n                    const key = item.name.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n                    if (oldItem === undefined || Array.isArray(oldItem)) {\n                      exportsMap.set(key, item);\n                    } else {\n                      exportsMap.set(key, {\n                        name: item.name,\n                        canMangle: item.canMangle && oldItem.canMangle\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n          for (const [module, referencedExports] of map) {\n            if (Array.isArray(referencedExports)) {\n              processReferencedModule(module, referencedExports, runtime, forceSideEffects);\n            } else {\n              processReferencedModule(module, Array.from(referencedExports.values()), runtime, forceSideEffects);\n            }\n          }\n        };\n        logger.time(\"initialize exports usage\");\n        for (const module of modules) {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          exportInfoToModuleMap.set(exportsInfo, module);\n          exportsInfo.setHasUseInfo();\n        }\n        logger.timeEnd(\"initialize exports usage\");\n        logger.time(\"trace exports usage in graph\");\n\n        /**\n         * @param {Dependency} dep dependency\n         * @param {RuntimeSpec} runtime runtime\n         */\n        const processEntryDependency = (dep, runtime) => {\n          const module = moduleGraph.getModule(dep);\n          if (module) {\n            processReferencedModule(module, NO_EXPORTS_REFERENCED, runtime, true);\n          }\n        };\n        /** @type {RuntimeSpec} */\n        let globalRuntime = undefined;\n        for (const [entryName, {\n          dependencies: deps,\n          includeDependencies: includeDeps,\n          options\n        }] of compilation.entries) {\n          const runtime = this.global ? undefined : getEntryRuntime(compilation, entryName, options);\n          for (const dep of deps) {\n            processEntryDependency(dep, runtime);\n          }\n          for (const dep of includeDeps) {\n            processEntryDependency(dep, runtime);\n          }\n          globalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n        }\n        for (const dep of compilation.globalEntry.dependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n        for (const dep of compilation.globalEntry.includeDependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n        while (queue.length) {\n          const [module, runtime] = queue.dequeue();\n          processModule(module, runtime, false);\n        }\n        logger.timeEnd(\"trace exports usage in graph\");\n      });\n    });\n  }\n}\nmodule.exports = FlagDependencyUsagePlugin;","map":{"version":3,"names":["Dependency","require","UsageState","ModuleGraphConnection","STAGE_DEFAULT","ArrayQueue","TupleQueue","getEntryRuntime","mergeRuntimeOwned","NO_EXPORTS_REFERENCED","EXPORTS_OBJECT_REFERENCED","PLUGIN_NAME","PLUGIN_LOGGER_NAME","FlagDependencyUsagePlugin","constructor","global","apply","compiler","hooks","compilation","tap","moduleGraph","optimizeDependencies","name","stage","modules","moduleMemCaches","Error","logger","getLogger","exportInfoToModuleMap","Map","queue","processReferencedModule","module","usedExports","runtime","forceSideEffects","exportsInfo","getExportsInfo","length","buildMeta","exportsType","setUsedWithoutInfo","enqueue","usedExportInfo","usedExport","canMangle","Array","isArray","setUsedInUnknownWay","currentExportsInfo","i","exportInfo","getExportInfo","canMangleUse","lastOne","nestedInfo","getNestedExportsInfo","setUsedConditionally","used","Unused","OnlyPropertiesUsed","currentModule","get","v","Used","factoryMeta","undefined","sideEffectFree","setUsedForSideEffectsOnly","processModule","map","block","dequeue","b","blocks","groupOptions","entryOptions","dep","dependencies","connection","getConnection","activeState","getActiveState","TRANSITIVE_ONLY","oldReferencedExports","referencedExports","getDependencyReferencedExports","set","exportsMap","item","join","key","oldItem","from","values","time","setHasUseInfo","timeEnd","processEntryDependency","getModule","globalRuntime","entryName","deps","includeDependencies","includeDeps","options","entries","globalEntry","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/FlagDependencyUsagePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\nconst { UsageState } = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { STAGE_DEFAULT } = require(\"./OptimizationStages\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\nconst TupleQueue = require(\"./util/TupleQueue\");\nconst { getEntryRuntime, mergeRuntimeOwned } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst { NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED } = Dependency;\n\nconst PLUGIN_NAME = \"FlagDependencyUsagePlugin\";\nconst PLUGIN_LOGGER_NAME = `webpack.${PLUGIN_NAME}`;\n\nclass FlagDependencyUsagePlugin {\n\t/**\n\t * @param {boolean} global do a global analysis instead of per runtime\n\t */\n\tconstructor(global) {\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t{ name: PLUGIN_NAME, stage: STAGE_DEFAULT },\n\t\t\t\tmodules => {\n\t\t\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst logger = compilation.getLogger(PLUGIN_LOGGER_NAME);\n\t\t\t\t\t/** @type {Map<ExportsInfo, Module>} */\n\t\t\t\t\tconst exportInfoToModuleMap = new Map();\n\n\t\t\t\t\t/** @type {TupleQueue<[Module, RuntimeSpec]>} */\n\t\t\t\t\tconst queue = new TupleQueue();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module module to process\n\t\t\t\t\t * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processReferencedModule = (\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tusedExports,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t) => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tif (usedExports.length > 0) {\n\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\tif (exportsInfo.setUsedWithoutInfo(runtime)) {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const usedExportInfo of usedExports) {\n\t\t\t\t\t\t\t\tlet usedExport;\n\t\t\t\t\t\t\t\tlet canMangle = true;\n\t\t\t\t\t\t\t\tif (Array.isArray(usedExportInfo)) {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo.name;\n\t\t\t\t\t\t\t\t\tcanMangle = usedExportInfo.canMangle !== false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (usedExport.length === 0) {\n\t\t\t\t\t\t\t\t\tif (exportsInfo.setUsedInUnknownWay(runtime)) {\n\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet currentExportsInfo = exportsInfo;\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < usedExport.length; i++) {\n\t\t\t\t\t\t\t\t\t\tconst exportInfo = currentExportsInfo.getExportInfo(\n\t\t\t\t\t\t\t\t\t\t\tusedExport[i]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (canMangle === false) {\n\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleUse = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst lastOne = i === usedExport.length - 1;\n\t\t\t\t\t\t\t\t\t\tif (!lastOne) {\n\t\t\t\t\t\t\t\t\t\t\tconst nestedInfo = exportInfo.getNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\tif (nestedInfo) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tused => used === UsageState.Unused,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsageState.OnlyPropertiesUsed,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo = nestedInfo;\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\tv => v !== UsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\tUsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for a module without side effects we stop tracking usage here when no export is used\n\t\t\t\t\t\t\t// This module won't be evaluated in this case\n\t\t\t\t\t\t\t// TODO webpack 6 remove this check\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!forceSideEffects &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta !== undefined &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {DependenciesBlock} module the module\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processModule = (module, runtime, forceSideEffects) => {\n\t\t\t\t\t\t/** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n\t\t\t\t\t\tconst map = new Map();\n\n\t\t\t\t\t\t/** @type {ArrayQueue<DependenciesBlock>} */\n\t\t\t\t\t\tconst queue = new ArrayQueue();\n\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\tconst block = queue.dequeue();\n\t\t\t\t\t\t\tif (block === undefined) break;\n\t\t\t\t\t\t\tfor (const b of block.blocks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!this.global &&\n\t\t\t\t\t\t\t\t\tb.groupOptions &&\n\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tprocessModule(\n\t\t\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions.runtime || undefined,\n\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const dep of block.dependencies) {\n\t\t\t\t\t\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t\t\t\t\t\tif (!connection || !connection.module) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst activeState = connection.getActiveState(runtime);\n\t\t\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\t\t\tconst { module } = connection;\n\t\t\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst oldReferencedExports = map.get(module);\n\t\t\t\t\t\t\t\tif (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedExports =\n\t\t\t\t\t\t\t\t\tcompilation.getDependencyReferencedExports(dep, runtime);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\toldReferencedExports === undefined ||\n\t\t\t\t\t\t\t\t\toldReferencedExports === NO_EXPORTS_REFERENCED ||\n\t\t\t\t\t\t\t\t\treferencedExports === EXPORTS_OBJECT_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tmap.set(module, referencedExports);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\toldReferencedExports !== undefined &&\n\t\t\t\t\t\t\t\t\treferencedExports === NO_EXPORTS_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet exportsMap;\n\t\t\t\t\t\t\t\t\tif (Array.isArray(oldReferencedExports)) {\n\t\t\t\t\t\t\t\t\t\texportsMap = new Map();\n\t\t\t\t\t\t\t\t\t\tfor (const item of oldReferencedExports) {\n\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.name.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tmap.set(module, exportsMap);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\texportsMap = oldReferencedExports;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (const item of referencedExports) {\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is already an array we have to do nothing\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is an ReferencedExport object, we don't have to do anything\n\t\t\t\t\t\t\t\t\t\t\t// as canMangle defaults to true for arrays\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.name.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined || Array.isArray(oldItem)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: item.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle: item.canMangle && oldItem.canMangle\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const [module, referencedExports] of map) {\n\t\t\t\t\t\t\tif (Array.isArray(referencedExports)) {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\treferencedExports,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tArray.from(referencedExports.values()),\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.time(\"initialize exports usage\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\texportInfoToModuleMap.set(exportsInfo, module);\n\t\t\t\t\t\texportsInfo.setHasUseInfo();\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"initialize exports usage\");\n\n\t\t\t\t\tlogger.time(\"trace exports usage in graph\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t * @param {RuntimeSpec} runtime runtime\n\t\t\t\t\t */\n\t\t\t\t\tconst processEntryDependency = (dep, runtime) => {\n\t\t\t\t\t\tconst module = moduleGraph.getModule(dep);\n\t\t\t\t\t\tif (module) {\n\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tNO_EXPORTS_REFERENCED,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {RuntimeSpec} */\n\t\t\t\t\tlet globalRuntime = undefined;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\tentryName,\n\t\t\t\t\t\t{ dependencies: deps, includeDependencies: includeDeps, options }\n\t\t\t\t\t] of compilation.entries) {\n\t\t\t\t\t\tconst runtime = this.global\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: getEntryRuntime(compilation, entryName, options);\n\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const dep of includeDeps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tglobalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.dependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.includeDependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (queue.length) {\n\t\t\t\t\t\tconst [module, runtime] = queue.dequeue();\n\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"trace exports usage in graph\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = FlagDependencyUsagePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}