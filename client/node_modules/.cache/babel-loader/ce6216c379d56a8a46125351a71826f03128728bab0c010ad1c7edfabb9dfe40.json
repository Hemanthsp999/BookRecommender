{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\nconst Source = require(\"./Source\");\nclass RawSource extends Source {\n  constructor(value) {\n    let convertToString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    super();\n    const isBuffer = Buffer.isBuffer(value);\n    if (!isBuffer && typeof value !== \"string\") {\n      throw new TypeError(\"argument 'value' must be either string of Buffer\");\n    }\n    this._valueIsBuffer = !convertToString && isBuffer;\n    this._value = convertToString && isBuffer ? undefined : value;\n    this._valueAsBuffer = isBuffer ? value : undefined;\n    this._valueAsString = isBuffer ? undefined : value;\n  }\n  isBuffer() {\n    return this._valueIsBuffer;\n  }\n  source() {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n    return this._value;\n  }\n  buffer() {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n    return this._valueAsBuffer;\n  }\n  map(options) {\n    return null;\n  }\n\n  /**\n   * @param {object} options options\n   * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n   * @param {function(number, string, string)} onSource called for each source\n   * @param {function(number, string)} onName called for each name\n   * @returns {void}\n   */\n  streamChunks(options, onChunk, onSource, onName) {\n    if (this._value === undefined) {\n      this._value = Buffer.from(this._valueAsBuffer, \"utf-8\");\n    }\n    if (this._valueAsString === undefined) {\n      this._valueAsString = typeof this._value === \"string\" ? this._value : this._value.toString(\"utf-8\");\n    }\n    return streamChunksOfRawSource(this._valueAsString, onChunk, onSource, onName, !!(options && options.finalSource));\n  }\n  updateHash(hash) {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n    hash.update(\"RawSource\");\n    hash.update(this._valueAsBuffer);\n  }\n}\nmodule.exports = RawSource;","map":{"version":3,"names":["streamChunksOfRawSource","require","Source","RawSource","constructor","value","convertToString","arguments","length","undefined","isBuffer","Buffer","TypeError","_valueIsBuffer","_value","_valueAsBuffer","_valueAsString","source","toString","buffer","from","map","options","streamChunks","onChunk","onSource","onName","finalSource","updateHash","hash","update","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack-sources/lib/RawSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst streamChunksOfRawSource = require(\"./helpers/streamChunksOfRawSource\");\nconst Source = require(\"./Source\");\n\nclass RawSource extends Source {\n\tconstructor(value, convertToString = false) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tif (!isBuffer && typeof value !== \"string\") {\n\t\t\tthrow new TypeError(\"argument 'value' must be either string of Buffer\");\n\t\t}\n\t\tthis._valueIsBuffer = !convertToString && isBuffer;\n\t\tthis._value = convertToString && isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._valueAsString = isBuffer ? undefined : value;\n\t}\n\n\tisBuffer() {\n\t\treturn this._valueIsBuffer;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = Buffer.from(this._valueAsBuffer, \"utf-8\");\n\t\t}\n\t\tif (this._valueAsString === undefined) {\n\t\t\tthis._valueAsString =\n\t\t\t\ttypeof this._value === \"string\"\n\t\t\t\t\t? this._value\n\t\t\t\t\t: this._value.toString(\"utf-8\");\n\t\t}\n\t\treturn streamChunksOfRawSource(\n\t\t\tthis._valueAsString,\n\t\t\tonChunk,\n\t\t\tonSource,\n\t\t\tonName,\n\t\t\t!!(options && options.finalSource)\n\t\t);\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"RawSource\");\n\t\thash.update(this._valueAsBuffer);\n\t}\n}\n\nmodule.exports = RawSource;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,uBAAuB,GAAGC,OAAO,CAAC,mCAAmC,CAAC;AAC5E,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAElC,MAAME,SAAS,SAASD,MAAM,CAAC;EAC9BE,WAAWA,CAACC,KAAK,EAA2B;IAAA,IAAzBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;IACzC,KAAK,CAAC,CAAC;IACP,MAAMG,QAAQ,GAAGC,MAAM,CAACD,QAAQ,CAACL,KAAK,CAAC;IACvC,IAAI,CAACK,QAAQ,IAAI,OAAOL,KAAK,KAAK,QAAQ,EAAE;MAC3C,MAAM,IAAIO,SAAS,CAAC,kDAAkD,CAAC;IACxE;IACA,IAAI,CAACC,cAAc,GAAG,CAACP,eAAe,IAAII,QAAQ;IAClD,IAAI,CAACI,MAAM,GAAGR,eAAe,IAAII,QAAQ,GAAGD,SAAS,GAAGJ,KAAK;IAC7D,IAAI,CAACU,cAAc,GAAGL,QAAQ,GAAGL,KAAK,GAAGI,SAAS;IAClD,IAAI,CAACO,cAAc,GAAGN,QAAQ,GAAGD,SAAS,GAAGJ,KAAK;EACnD;EAEAK,QAAQA,CAAA,EAAG;IACV,OAAO,IAAI,CAACG,cAAc;EAC3B;EAEAI,MAAMA,CAAA,EAAG;IACR,IAAI,IAAI,CAACH,MAAM,KAAKL,SAAS,EAAE;MAC9B,IAAI,CAACK,MAAM,GAAG,IAAI,CAACC,cAAc,CAACG,QAAQ,CAAC,OAAO,CAAC;IACpD;IACA,OAAO,IAAI,CAACJ,MAAM;EACnB;EAEAK,MAAMA,CAAA,EAAG;IACR,IAAI,IAAI,CAACJ,cAAc,KAAKN,SAAS,EAAE;MACtC,IAAI,CAACM,cAAc,GAAGJ,MAAM,CAACS,IAAI,CAAC,IAAI,CAACN,MAAM,EAAE,OAAO,CAAC;IACxD;IACA,OAAO,IAAI,CAACC,cAAc;EAC3B;EAEAM,GAAGA,CAACC,OAAO,EAAE;IACZ,OAAO,IAAI;EACZ;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EACCC,YAAYA,CAACD,OAAO,EAAEE,OAAO,EAAEC,QAAQ,EAAEC,MAAM,EAAE;IAChD,IAAI,IAAI,CAACZ,MAAM,KAAKL,SAAS,EAAE;MAC9B,IAAI,CAACK,MAAM,GAAGH,MAAM,CAACS,IAAI,CAAC,IAAI,CAACL,cAAc,EAAE,OAAO,CAAC;IACxD;IACA,IAAI,IAAI,CAACC,cAAc,KAAKP,SAAS,EAAE;MACtC,IAAI,CAACO,cAAc,GAClB,OAAO,IAAI,CAACF,MAAM,KAAK,QAAQ,GAC5B,IAAI,CAACA,MAAM,GACX,IAAI,CAACA,MAAM,CAACI,QAAQ,CAAC,OAAO,CAAC;IAClC;IACA,OAAOlB,uBAAuB,CAC7B,IAAI,CAACgB,cAAc,EACnBQ,OAAO,EACPC,QAAQ,EACRC,MAAM,EACN,CAAC,EAAEJ,OAAO,IAAIA,OAAO,CAACK,WAAW,CAClC,CAAC;EACF;EAEAC,UAAUA,CAACC,IAAI,EAAE;IAChB,IAAI,IAAI,CAACd,cAAc,KAAKN,SAAS,EAAE;MACtC,IAAI,CAACM,cAAc,GAAGJ,MAAM,CAACS,IAAI,CAAC,IAAI,CAACN,MAAM,EAAE,OAAO,CAAC;IACxD;IACAe,IAAI,CAACC,MAAM,CAAC,WAAW,CAAC;IACxBD,IAAI,CAACC,MAAM,CAAC,IAAI,CAACf,cAAc,CAAC;EACjC;AACD;AAEAgB,MAAM,CAACC,OAAO,GAAG7B,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}