{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst formatLocation = require(\"../formatLocation\");\nconst {\n  evaluateToString\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst CommonJsExportRequireDependency = require(\"./CommonJsExportRequireDependency\");\nconst CommonJsExportsDependency = require(\"./CommonJsExportsDependency\");\nconst CommonJsSelfReferenceDependency = require(\"./CommonJsSelfReferenceDependency\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst HarmonyExports = require(\"./HarmonyExports\");\nconst ModuleDecoratorDependency = require(\"./ModuleDecoratorDependency\");\n\n/** @typedef {import(\"estree\").AssignmentExpression} AssignmentExpression */\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").Super} Super */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./CommonJsDependencyHelpers\").CommonJSDependencyBaseKeywords} CommonJSDependencyBaseKeywords */\n\n/**\n * This function takes a generic expression and detects whether it is an ObjectExpression.\n * This is used in the context of parsing CommonJS exports to get the value of the property descriptor\n * when the `exports` object is assigned to `Object.defineProperty`.\n *\n * In CommonJS modules, the `exports` object can be assigned to `Object.defineProperty` and therefore\n * webpack has to detect this case and get the value key of the property descriptor. See the following example\n * for more information: https://astexplorer.net/#/gist/83ce51a4e96e59d777df315a6d111da6/8058ead48a1bb53c097738225db0967ef7f70e57\n *\n * This would be an example of a CommonJS module that exports an object with a property descriptor:\n * ```js\n * Object.defineProperty(exports, \"__esModule\", { value: true });\n * exports.foo = void 0;\n * exports.foo = \"bar\";\n * ```\n *\n * @param {TODO} expr expression\n * @returns {Expression} returns the value of property descriptor\n */\nconst getValueOfPropertyDescription = expr => {\n  if (expr.type !== \"ObjectExpression\") return;\n  for (const property of expr.properties) {\n    if (property.computed) continue;\n    const key = property.key;\n    if (key.type !== \"Identifier\" || key.name !== \"value\") continue;\n    return property.value;\n  }\n};\n\n/**\n * The purpose of this function is to check whether an expression is a truthy literal or not. This is\n * useful when parsing CommonJS exports, because CommonJS modules can export any value, including falsy\n * values like `null` and `false`. However, exports should only be created if the exported value is truthy.\n *\n * @param {Expression} expr expression being checked\n * @returns {boolean} true, when the expression is a truthy literal\n *\n */\nconst isTruthyLiteral = expr => {\n  switch (expr.type) {\n    case \"Literal\":\n      return !!expr.value;\n    case \"UnaryExpression\":\n      if (expr.operator === \"!\") return isFalsyLiteral(expr.argument);\n  }\n  return false;\n};\n\n/**\n * The purpose of this function is to check whether an expression is a falsy literal or not. This is\n * useful when parsing CommonJS exports, because CommonJS modules can export any value, including falsy\n * values like `null` and `false`. However, exports should only be created if the exported value is truthy.\n *\n * @param {Expression} expr expression being checked\n * @returns {boolean} true, when the expression is a falsy literal\n */\nconst isFalsyLiteral = expr => {\n  switch (expr.type) {\n    case \"Literal\":\n      return !expr.value;\n    case \"UnaryExpression\":\n      if (expr.operator === \"!\") return isTruthyLiteral(expr.argument);\n  }\n  return false;\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {Expression} expr expression\n * @returns {{ argument: BasicEvaluatedExpression, ids: string[] } | undefined} parsed call\n */\nconst parseRequireCall = (parser, expr) => {\n  const ids = [];\n  while (expr.type === \"MemberExpression\") {\n    if (expr.object.type === \"Super\") return;\n    if (!expr.property) return;\n    const prop = expr.property;\n    if (expr.computed) {\n      if (prop.type !== \"Literal\") return;\n      ids.push(`${prop.value}`);\n    } else {\n      if (prop.type !== \"Identifier\") return;\n      ids.push(prop.name);\n    }\n    expr = expr.object;\n  }\n  if (expr.type !== \"CallExpression\" || expr.arguments.length !== 1) return;\n  const callee = expr.callee;\n  if (callee.type !== \"Identifier\" || parser.getVariableInfo(callee.name) !== \"require\") {\n    return;\n  }\n  const arg = expr.arguments[0];\n  if (arg.type === \"SpreadElement\") return;\n  const argValue = parser.evaluateExpression(arg);\n  return {\n    argument: argValue,\n    ids: ids.reverse()\n  };\n};\nclass CommonJsExportsParserPlugin {\n  constructor(moduleGraph) {\n    this.moduleGraph = moduleGraph;\n  }\n\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n  apply(parser) {\n    const enableStructuredExports = () => {\n      DynamicExports.enable(parser.state);\n    };\n\n    /**\n     * @param {boolean} topLevel true, when the export is on top level\n     * @param {string[]} members members of the export\n     * @param {Expression} valueExpr expression for the value\n     * @returns {void}\n     */\n    const checkNamespace = (topLevel, members, valueExpr) => {\n      if (!DynamicExports.isEnabled(parser.state)) return;\n      if (members.length > 0 && members[0] === \"__esModule\") {\n        if (valueExpr && isTruthyLiteral(valueExpr) && topLevel) {\n          DynamicExports.setFlagged(parser.state);\n        } else {\n          DynamicExports.setDynamic(parser.state);\n        }\n      }\n    };\n    const bailout = reason => {\n      DynamicExports.bailout(parser.state);\n      if (reason) bailoutHint(reason);\n    };\n    const bailoutHint = reason => {\n      this.moduleGraph.getOptimizationBailout(parser.state.module).push(`CommonJS bailout: ${reason}`);\n    };\n\n    // metadata //\n    parser.hooks.evaluateTypeof.for(\"module\").tap(\"CommonJsExportsParserPlugin\", evaluateToString(\"object\"));\n    parser.hooks.evaluateTypeof.for(\"exports\").tap(\"CommonJsPlugin\", evaluateToString(\"object\"));\n\n    // exporting //\n\n    /**\n     * @param {AssignmentExpression} expr expression\n     * @param {CommonJSDependencyBaseKeywords} base commonjs base keywords\n     * @param {string[]} members members of the export\n     * @returns {boolean} true, when the expression was handled\n     */\n    const handleAssignExport = (expr, base, members) => {\n      if (HarmonyExports.isEnabled(parser.state)) return;\n      // Handle reexporting\n      const requireCall = parseRequireCall(parser, expr.right);\n      if (requireCall && requireCall.argument.isString() && (members.length === 0 || members[0] !== \"__esModule\")) {\n        enableStructuredExports();\n        // It's possible to reexport __esModule, so we must convert to a dynamic module\n        if (members.length === 0) DynamicExports.setDynamic(parser.state);\n        const dep = new CommonJsExportRequireDependency(expr.range, null, base, members, requireCall.argument.string, requireCall.ids, !parser.isStatementLevelExpression(expr));\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.module.addDependency(dep);\n        return true;\n      }\n      if (members.length === 0) return;\n      enableStructuredExports();\n      const remainingMembers = members;\n      checkNamespace(parser.statementPath.length === 1 && parser.isStatementLevelExpression(expr), remainingMembers, expr.right);\n      const dep = new CommonJsExportsDependency(expr.left.range, null, base, remainingMembers);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n      parser.walkExpression(expr.right);\n      return true;\n    };\n    parser.hooks.assignMemberChain.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      return handleAssignExport(expr, \"exports\", members);\n    });\n    parser.hooks.assignMemberChain.for(\"this\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAssignExport(expr, \"this\", members);\n    });\n    parser.hooks.assignMemberChain.for(\"module\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (members[0] !== \"exports\") return;\n      return handleAssignExport(expr, \"module.exports\", members.slice(1));\n    });\n    parser.hooks.call.for(\"Object.defineProperty\").tap(\"CommonJsExportsParserPlugin\", expression => {\n      const expr = /** @type {CallExpression} */expression;\n      if (!parser.isStatementLevelExpression(expr)) return;\n      if (expr.arguments.length !== 3) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      if (expr.arguments[1].type === \"SpreadElement\") return;\n      if (expr.arguments[2].type === \"SpreadElement\") return;\n      const exportsArg = parser.evaluateExpression(expr.arguments[0]);\n      if (!exportsArg.isIdentifier()) return;\n      if (exportsArg.identifier !== \"exports\" && exportsArg.identifier !== \"module.exports\" && (exportsArg.identifier !== \"this\" || !parser.scope.topLevelScope)) {\n        return;\n      }\n      const propertyArg = parser.evaluateExpression(expr.arguments[1]);\n      const property = propertyArg.asString();\n      if (typeof property !== \"string\") return;\n      enableStructuredExports();\n      const descArg = expr.arguments[2];\n      checkNamespace(parser.statementPath.length === 1, [property], getValueOfPropertyDescription(descArg));\n      const dep = new CommonJsExportsDependency(expr.range, expr.arguments[2].range, `Object.defineProperty(${exportsArg.identifier})`, [property]);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n      parser.walkExpression(expr.arguments[2]);\n      return true;\n    });\n\n    // Self reference //\n\n    /**\n     * @param {Expression | Super} expr expression\n     * @param {CommonJSDependencyBaseKeywords} base commonjs base keywords\n     * @param {string[]} members members of the export\n     * @param {CallExpression} call call expression\n     * @returns {boolean} true, when the expression was handled\n     */\n    const handleAccessExport = function (expr, base, members) {\n      let call = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n      if (HarmonyExports.isEnabled(parser.state)) return;\n      if (members.length === 0) {\n        bailout(`${base} is used directly at ${formatLocation(expr.loc)}`);\n      }\n      if (call && members.length === 1) {\n        bailoutHint(`${base}${propertyAccess(members)}(...) prevents optimization as ${base} is passed as call context at ${formatLocation(expr.loc)}`);\n      }\n      const dep = new CommonJsSelfReferenceDependency(expr.range, base, members, !!call);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n      if (call) {\n        parser.walkExpressions(call.arguments);\n      }\n      return true;\n    };\n    parser.hooks.callMemberChain.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      return handleAccessExport(expr.callee, \"exports\", members, expr);\n    });\n    parser.hooks.expressionMemberChain.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      return handleAccessExport(expr, \"exports\", members);\n    });\n    parser.hooks.expression.for(\"exports\").tap(\"CommonJsExportsParserPlugin\", expr => {\n      return handleAccessExport(expr, \"exports\", []);\n    });\n    parser.hooks.callMemberChain.for(\"module\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (members[0] !== \"exports\") return;\n      return handleAccessExport(expr.callee, \"module.exports\", members.slice(1), expr);\n    });\n    parser.hooks.expressionMemberChain.for(\"module\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (members[0] !== \"exports\") return;\n      return handleAccessExport(expr, \"module.exports\", members.slice(1));\n    });\n    parser.hooks.expression.for(\"module.exports\").tap(\"CommonJsExportsParserPlugin\", expr => {\n      return handleAccessExport(expr, \"module.exports\", []);\n    });\n    parser.hooks.callMemberChain.for(\"this\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAccessExport(expr.callee, \"this\", members, expr);\n    });\n    parser.hooks.expressionMemberChain.for(\"this\").tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAccessExport(expr, \"this\", members);\n    });\n    parser.hooks.expression.for(\"this\").tap(\"CommonJsExportsParserPlugin\", expr => {\n      if (!parser.scope.topLevelScope) return;\n      return handleAccessExport(expr, \"this\", []);\n    });\n\n    // Bailouts //\n    parser.hooks.expression.for(\"module\").tap(\"CommonJsPlugin\", expr => {\n      bailout();\n      const isHarmony = HarmonyExports.isEnabled(parser.state);\n      const dep = new ModuleDecoratorDependency(isHarmony ? RuntimeGlobals.harmonyModuleDecorator : RuntimeGlobals.nodeModuleDecorator, !isHarmony);\n      dep.loc = expr.loc;\n      parser.state.module.addDependency(dep);\n      return true;\n    });\n  }\n}\nmodule.exports = CommonJsExportsParserPlugin;","map":{"version":3,"names":["RuntimeGlobals","require","formatLocation","evaluateToString","propertyAccess","CommonJsExportRequireDependency","CommonJsExportsDependency","CommonJsSelfReferenceDependency","DynamicExports","HarmonyExports","ModuleDecoratorDependency","getValueOfPropertyDescription","expr","type","property","properties","computed","key","name","value","isTruthyLiteral","operator","isFalsyLiteral","argument","parseRequireCall","parser","ids","object","prop","push","arguments","length","callee","getVariableInfo","arg","argValue","evaluateExpression","reverse","CommonJsExportsParserPlugin","constructor","moduleGraph","apply","enableStructuredExports","enable","state","checkNamespace","topLevel","members","valueExpr","isEnabled","setFlagged","setDynamic","bailout","reason","bailoutHint","getOptimizationBailout","module","hooks","evaluateTypeof","for","tap","handleAssignExport","base","requireCall","right","isString","dep","range","string","isStatementLevelExpression","loc","optional","scope","inTry","addDependency","remainingMembers","statementPath","left","walkExpression","assignMemberChain","topLevelScope","slice","call","expression","exportsArg","isIdentifier","identifier","propertyArg","asString","descArg","handleAccessExport","undefined","walkExpressions","callMemberChain","expressionMemberChain","isHarmony","harmonyModuleDecorator","nodeModuleDecorator","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/dependencies/CommonJsExportsParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst formatLocation = require(\"../formatLocation\");\nconst { evaluateToString } = require(\"../javascript/JavascriptParserHelpers\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst CommonJsExportRequireDependency = require(\"./CommonJsExportRequireDependency\");\nconst CommonJsExportsDependency = require(\"./CommonJsExportsDependency\");\nconst CommonJsSelfReferenceDependency = require(\"./CommonJsSelfReferenceDependency\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst HarmonyExports = require(\"./HarmonyExports\");\nconst ModuleDecoratorDependency = require(\"./ModuleDecoratorDependency\");\n\n/** @typedef {import(\"estree\").AssignmentExpression} AssignmentExpression */\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").Super} Super */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./CommonJsDependencyHelpers\").CommonJSDependencyBaseKeywords} CommonJSDependencyBaseKeywords */\n\n/**\n * This function takes a generic expression and detects whether it is an ObjectExpression.\n * This is used in the context of parsing CommonJS exports to get the value of the property descriptor\n * when the `exports` object is assigned to `Object.defineProperty`.\n *\n * In CommonJS modules, the `exports` object can be assigned to `Object.defineProperty` and therefore\n * webpack has to detect this case and get the value key of the property descriptor. See the following example\n * for more information: https://astexplorer.net/#/gist/83ce51a4e96e59d777df315a6d111da6/8058ead48a1bb53c097738225db0967ef7f70e57\n *\n * This would be an example of a CommonJS module that exports an object with a property descriptor:\n * ```js\n * Object.defineProperty(exports, \"__esModule\", { value: true });\n * exports.foo = void 0;\n * exports.foo = \"bar\";\n * ```\n *\n * @param {TODO} expr expression\n * @returns {Expression} returns the value of property descriptor\n */\nconst getValueOfPropertyDescription = expr => {\n\tif (expr.type !== \"ObjectExpression\") return;\n\tfor (const property of expr.properties) {\n\t\tif (property.computed) continue;\n\t\tconst key = property.key;\n\t\tif (key.type !== \"Identifier\" || key.name !== \"value\") continue;\n\t\treturn property.value;\n\t}\n};\n\n/**\n * The purpose of this function is to check whether an expression is a truthy literal or not. This is\n * useful when parsing CommonJS exports, because CommonJS modules can export any value, including falsy\n * values like `null` and `false`. However, exports should only be created if the exported value is truthy.\n *\n * @param {Expression} expr expression being checked\n * @returns {boolean} true, when the expression is a truthy literal\n *\n */\nconst isTruthyLiteral = expr => {\n\tswitch (expr.type) {\n\t\tcase \"Literal\":\n\t\t\treturn !!expr.value;\n\t\tcase \"UnaryExpression\":\n\t\t\tif (expr.operator === \"!\") return isFalsyLiteral(expr.argument);\n\t}\n\treturn false;\n};\n\n/**\n * The purpose of this function is to check whether an expression is a falsy literal or not. This is\n * useful when parsing CommonJS exports, because CommonJS modules can export any value, including falsy\n * values like `null` and `false`. However, exports should only be created if the exported value is truthy.\n *\n * @param {Expression} expr expression being checked\n * @returns {boolean} true, when the expression is a falsy literal\n */\nconst isFalsyLiteral = expr => {\n\tswitch (expr.type) {\n\t\tcase \"Literal\":\n\t\t\treturn !expr.value;\n\t\tcase \"UnaryExpression\":\n\t\t\tif (expr.operator === \"!\") return isTruthyLiteral(expr.argument);\n\t}\n\treturn false;\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {Expression} expr expression\n * @returns {{ argument: BasicEvaluatedExpression, ids: string[] } | undefined} parsed call\n */\nconst parseRequireCall = (parser, expr) => {\n\tconst ids = [];\n\twhile (expr.type === \"MemberExpression\") {\n\t\tif (expr.object.type === \"Super\") return;\n\t\tif (!expr.property) return;\n\t\tconst prop = expr.property;\n\t\tif (expr.computed) {\n\t\t\tif (prop.type !== \"Literal\") return;\n\t\t\tids.push(`${prop.value}`);\n\t\t} else {\n\t\t\tif (prop.type !== \"Identifier\") return;\n\t\t\tids.push(prop.name);\n\t\t}\n\t\texpr = expr.object;\n\t}\n\tif (expr.type !== \"CallExpression\" || expr.arguments.length !== 1) return;\n\tconst callee = expr.callee;\n\tif (\n\t\tcallee.type !== \"Identifier\" ||\n\t\tparser.getVariableInfo(callee.name) !== \"require\"\n\t) {\n\t\treturn;\n\t}\n\tconst arg = expr.arguments[0];\n\tif (arg.type === \"SpreadElement\") return;\n\tconst argValue = parser.evaluateExpression(arg);\n\treturn { argument: argValue, ids: ids.reverse() };\n};\n\nclass CommonJsExportsParserPlugin {\n\tconstructor(moduleGraph) {\n\t\tthis.moduleGraph = moduleGraph;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tconst enableStructuredExports = () => {\n\t\t\tDynamicExports.enable(parser.state);\n\t\t};\n\n\t\t/**\n\t\t * @param {boolean} topLevel true, when the export is on top level\n\t\t * @param {string[]} members members of the export\n\t\t * @param {Expression} valueExpr expression for the value\n\t\t * @returns {void}\n\t\t */\n\t\tconst checkNamespace = (topLevel, members, valueExpr) => {\n\t\t\tif (!DynamicExports.isEnabled(parser.state)) return;\n\t\t\tif (members.length > 0 && members[0] === \"__esModule\") {\n\t\t\t\tif (valueExpr && isTruthyLiteral(valueExpr) && topLevel) {\n\t\t\t\t\tDynamicExports.setFlagged(parser.state);\n\t\t\t\t} else {\n\t\t\t\t\tDynamicExports.setDynamic(parser.state);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst bailout = reason => {\n\t\t\tDynamicExports.bailout(parser.state);\n\t\t\tif (reason) bailoutHint(reason);\n\t\t};\n\t\tconst bailoutHint = reason => {\n\t\t\tthis.moduleGraph\n\t\t\t\t.getOptimizationBailout(parser.state.module)\n\t\t\t\t.push(`CommonJS bailout: ${reason}`);\n\t\t};\n\n\t\t// metadata //\n\t\tparser.hooks.evaluateTypeof\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", evaluateToString(\"object\"));\n\t\tparser.hooks.evaluateTypeof\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsPlugin\", evaluateToString(\"object\"));\n\n\t\t// exporting //\n\n\t\t/**\n\t\t * @param {AssignmentExpression} expr expression\n\t\t * @param {CommonJSDependencyBaseKeywords} base commonjs base keywords\n\t\t * @param {string[]} members members of the export\n\t\t * @returns {boolean} true, when the expression was handled\n\t\t */\n\t\tconst handleAssignExport = (expr, base, members) => {\n\t\t\tif (HarmonyExports.isEnabled(parser.state)) return;\n\t\t\t// Handle reexporting\n\t\t\tconst requireCall = parseRequireCall(parser, expr.right);\n\t\t\tif (\n\t\t\t\trequireCall &&\n\t\t\t\trequireCall.argument.isString() &&\n\t\t\t\t(members.length === 0 || members[0] !== \"__esModule\")\n\t\t\t) {\n\t\t\t\tenableStructuredExports();\n\t\t\t\t// It's possible to reexport __esModule, so we must convert to a dynamic module\n\t\t\t\tif (members.length === 0) DynamicExports.setDynamic(parser.state);\n\t\t\t\tconst dep = new CommonJsExportRequireDependency(\n\t\t\t\t\texpr.range,\n\t\t\t\t\tnull,\n\t\t\t\t\tbase,\n\t\t\t\t\tmembers,\n\t\t\t\t\trequireCall.argument.string,\n\t\t\t\t\trequireCall.ids,\n\t\t\t\t\t!parser.isStatementLevelExpression(expr)\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (members.length === 0) return;\n\t\t\tenableStructuredExports();\n\t\t\tconst remainingMembers = members;\n\t\t\tcheckNamespace(\n\t\t\t\tparser.statementPath.length === 1 &&\n\t\t\t\t\tparser.isStatementLevelExpression(expr),\n\t\t\t\tremainingMembers,\n\t\t\t\texpr.right\n\t\t\t);\n\t\t\tconst dep = new CommonJsExportsDependency(\n\t\t\t\texpr.left.range,\n\t\t\t\tnull,\n\t\t\t\tbase,\n\t\t\t\tremainingMembers\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addDependency(dep);\n\t\t\tparser.walkExpression(expr.right);\n\t\t\treturn true;\n\t\t};\n\t\tparser.hooks.assignMemberChain\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn handleAssignExport(expr, \"exports\", members);\n\t\t\t});\n\t\tparser.hooks.assignMemberChain\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAssignExport(expr, \"this\", members);\n\t\t\t});\n\t\tparser.hooks.assignMemberChain\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (members[0] !== \"exports\") return;\n\t\t\t\treturn handleAssignExport(expr, \"module.exports\", members.slice(1));\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(\"Object.defineProperty\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expression => {\n\t\t\t\tconst expr = /** @type {CallExpression} */ (expression);\n\t\t\t\tif (!parser.isStatementLevelExpression(expr)) return;\n\t\t\t\tif (expr.arguments.length !== 3) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[2].type === \"SpreadElement\") return;\n\t\t\t\tconst exportsArg = parser.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (!exportsArg.isIdentifier()) return;\n\t\t\t\tif (\n\t\t\t\t\texportsArg.identifier !== \"exports\" &&\n\t\t\t\t\texportsArg.identifier !== \"module.exports\" &&\n\t\t\t\t\t(exportsArg.identifier !== \"this\" || !parser.scope.topLevelScope)\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst propertyArg = parser.evaluateExpression(expr.arguments[1]);\n\t\t\t\tconst property = propertyArg.asString();\n\t\t\t\tif (typeof property !== \"string\") return;\n\t\t\t\tenableStructuredExports();\n\t\t\t\tconst descArg = expr.arguments[2];\n\t\t\t\tcheckNamespace(\n\t\t\t\t\tparser.statementPath.length === 1,\n\t\t\t\t\t[property],\n\t\t\t\t\tgetValueOfPropertyDescription(descArg)\n\t\t\t\t);\n\t\t\t\tconst dep = new CommonJsExportsDependency(\n\t\t\t\t\texpr.range,\n\t\t\t\t\texpr.arguments[2].range,\n\t\t\t\t\t`Object.defineProperty(${exportsArg.identifier})`,\n\t\t\t\t\t[property]\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tparser.state.module.addDependency(dep);\n\n\t\t\t\tparser.walkExpression(expr.arguments[2]);\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t// Self reference //\n\n\t\t/**\n\t\t * @param {Expression | Super} expr expression\n\t\t * @param {CommonJSDependencyBaseKeywords} base commonjs base keywords\n\t\t * @param {string[]} members members of the export\n\t\t * @param {CallExpression} call call expression\n\t\t * @returns {boolean} true, when the expression was handled\n\t\t */\n\t\tconst handleAccessExport = (expr, base, members, call = undefined) => {\n\t\t\tif (HarmonyExports.isEnabled(parser.state)) return;\n\t\t\tif (members.length === 0) {\n\t\t\t\tbailout(`${base} is used directly at ${formatLocation(expr.loc)}`);\n\t\t\t}\n\t\t\tif (call && members.length === 1) {\n\t\t\t\tbailoutHint(\n\t\t\t\t\t`${base}${propertyAccess(\n\t\t\t\t\t\tmembers\n\t\t\t\t\t)}(...) prevents optimization as ${base} is passed as call context at ${formatLocation(\n\t\t\t\t\t\texpr.loc\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst dep = new CommonJsSelfReferenceDependency(\n\t\t\t\texpr.range,\n\t\t\t\tbase,\n\t\t\t\tmembers,\n\t\t\t\t!!call\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addDependency(dep);\n\t\t\tif (call) {\n\t\t\t\tparser.walkExpressions(call.arguments);\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn handleAccessExport(expr.callee, \"exports\", members, expr);\n\t\t\t});\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\treturn handleAccessExport(expr, \"exports\", members);\n\t\t\t});\n\t\tparser.hooks.expression\n\t\t\t.for(\"exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expr => {\n\t\t\t\treturn handleAccessExport(expr, \"exports\", []);\n\t\t\t});\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (members[0] !== \"exports\") return;\n\t\t\t\treturn handleAccessExport(\n\t\t\t\t\texpr.callee,\n\t\t\t\t\t\"module.exports\",\n\t\t\t\t\tmembers.slice(1),\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t});\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(\"module\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (members[0] !== \"exports\") return;\n\t\t\t\treturn handleAccessExport(expr, \"module.exports\", members.slice(1));\n\t\t\t});\n\t\tparser.hooks.expression\n\t\t\t.for(\"module.exports\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expr => {\n\t\t\t\treturn handleAccessExport(expr, \"module.exports\", []);\n\t\t\t});\n\t\tparser.hooks.callMemberChain\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAccessExport(expr.callee, \"this\", members, expr);\n\t\t\t});\n\t\tparser.hooks.expressionMemberChain\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", (expr, members) => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAccessExport(expr, \"this\", members);\n\t\t\t});\n\t\tparser.hooks.expression\n\t\t\t.for(\"this\")\n\t\t\t.tap(\"CommonJsExportsParserPlugin\", expr => {\n\t\t\t\tif (!parser.scope.topLevelScope) return;\n\t\t\t\treturn handleAccessExport(expr, \"this\", []);\n\t\t\t});\n\n\t\t// Bailouts //\n\t\tparser.hooks.expression.for(\"module\").tap(\"CommonJsPlugin\", expr => {\n\t\t\tbailout();\n\t\t\tconst isHarmony = HarmonyExports.isEnabled(parser.state);\n\t\t\tconst dep = new ModuleDecoratorDependency(\n\t\t\t\tisHarmony\n\t\t\t\t\t? RuntimeGlobals.harmonyModuleDecorator\n\t\t\t\t\t: RuntimeGlobals.nodeModuleDecorator,\n\t\t\t\t!isHarmony\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addDependency(dep);\n\t\t\treturn true;\n\t\t});\n\t}\n}\nmodule.exports = CommonJsExportsParserPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}