{"ast":null,"code":"module.exports = function (glob, opts) {\n  if (typeof glob !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  var str = String(glob);\n\n  // The regexp we are building, as a string.\n  var reStr = \"\";\n\n  // Whether we are matching so called \"extended\" globs (like bash) and should\n  // support single character matching, matching ranges of characters, group\n  // matching, etc.\n  var extended = opts ? !!opts.extended : false;\n\n  // When globstar is _false_ (default), '/foo/*' is translated a regexp like\n  // '^\\/foo\\/.*$' which will match any string beginning with '/foo/'\n  // When globstar is _true_, '/foo/*' is translated to regexp like\n  // '^\\/foo\\/[^/]*$' which will match any string beginning with '/foo/' BUT\n  // which does not have a '/' to the right of it.\n  // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but\n  // these will not '/foo/bar/baz', '/foo/bar/baz.txt'\n  // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when\n  // globstar is _false_\n  var globstar = opts ? !!opts.globstar : false;\n\n  // If we are doing extended matching, this boolean is true when we are inside\n  // a group (eg {*.html,*.js}), and false otherwise.\n  var inGroup = false;\n\n  // RegExp flags (eg \"i\" ) to pass in to RegExp constructor.\n  var flags = opts && typeof opts.flags === \"string\" ? opts.flags : \"\";\n  var c;\n  for (var i = 0, len = str.length; i < len; i++) {\n    c = str[i];\n    switch (c) {\n      case \"/\":\n      case \"$\":\n      case \"^\":\n      case \"+\":\n      case \".\":\n      case \"(\":\n      case \")\":\n      case \"=\":\n      case \"!\":\n      case \"|\":\n        reStr += \"\\\\\" + c;\n        break;\n      case \"?\":\n        if (extended) {\n          reStr += \".\";\n          break;\n        }\n      case \"[\":\n      case \"]\":\n        if (extended) {\n          reStr += c;\n          break;\n        }\n      case \"{\":\n        if (extended) {\n          inGroup = true;\n          reStr += \"(\";\n          break;\n        }\n      case \"}\":\n        if (extended) {\n          inGroup = false;\n          reStr += \")\";\n          break;\n        }\n      case \",\":\n        if (inGroup) {\n          reStr += \"|\";\n          break;\n        }\n        reStr += \"\\\\\" + c;\n        break;\n      case \"*\":\n        // Move over all consecutive \"*\"'s.\n        // Also store the previous and next characters\n        var prevChar = str[i - 1];\n        var starCount = 1;\n        while (str[i + 1] === \"*\") {\n          starCount++;\n          i++;\n        }\n        var nextChar = str[i + 1];\n        if (!globstar) {\n          // globstar is disabled, so treat any number of \"*\" as one\n          reStr += \".*\";\n        } else {\n          // globstar is enabled, so determine if this is a globstar segment\n          var isGlobstar = starCount > 1 // multiple \"*\"'s\n          && (prevChar === \"/\" || prevChar === undefined) // from the start of the segment\n          && (nextChar === \"/\" || nextChar === undefined); // to the end of the segment\n\n          if (isGlobstar) {\n            // it's a globstar, so match zero or more path segments\n            reStr += \"((?:[^/]*(?:\\/|$))*)\";\n            i++; // move over the \"/\"\n          } else {\n            // it's not a globstar, so only match one path segment\n            reStr += \"([^/]*)\";\n          }\n        }\n        break;\n      default:\n        reStr += c;\n    }\n  }\n\n  // When regexp 'g' flag is specified don't\n  // constrain the regular expression with ^ & $\n  if (!flags || !~flags.indexOf('g')) {\n    reStr = \"^\" + reStr + \"$\";\n  }\n  return new RegExp(reStr, flags);\n};","map":{"version":3,"names":["module","exports","glob","opts","TypeError","str","String","reStr","extended","globstar","inGroup","flags","c","i","len","length","prevChar","starCount","nextChar","isGlobstar","undefined","indexOf","RegExp"],"sources":["/home/hemanth/react-project/client/node_modules/glob-to-regexp/index.js"],"sourcesContent":["module.exports = function (glob, opts) {\n  if (typeof glob !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  var str = String(glob);\n\n  // The regexp we are building, as a string.\n  var reStr = \"\";\n\n  // Whether we are matching so called \"extended\" globs (like bash) and should\n  // support single character matching, matching ranges of characters, group\n  // matching, etc.\n  var extended = opts ? !!opts.extended : false;\n\n  // When globstar is _false_ (default), '/foo/*' is translated a regexp like\n  // '^\\/foo\\/.*$' which will match any string beginning with '/foo/'\n  // When globstar is _true_, '/foo/*' is translated to regexp like\n  // '^\\/foo\\/[^/]*$' which will match any string beginning with '/foo/' BUT\n  // which does not have a '/' to the right of it.\n  // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but\n  // these will not '/foo/bar/baz', '/foo/bar/baz.txt'\n  // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when\n  // globstar is _false_\n  var globstar = opts ? !!opts.globstar : false;\n\n  // If we are doing extended matching, this boolean is true when we are inside\n  // a group (eg {*.html,*.js}), and false otherwise.\n  var inGroup = false;\n\n  // RegExp flags (eg \"i\" ) to pass in to RegExp constructor.\n  var flags = opts && typeof( opts.flags ) === \"string\" ? opts.flags : \"\";\n\n  var c;\n  for (var i = 0, len = str.length; i < len; i++) {\n    c = str[i];\n\n    switch (c) {\n    case \"/\":\n    case \"$\":\n    case \"^\":\n    case \"+\":\n    case \".\":\n    case \"(\":\n    case \")\":\n    case \"=\":\n    case \"!\":\n    case \"|\":\n      reStr += \"\\\\\" + c;\n      break;\n\n    case \"?\":\n      if (extended) {\n        reStr += \".\";\n\t    break;\n      }\n\n    case \"[\":\n    case \"]\":\n      if (extended) {\n        reStr += c;\n\t    break;\n      }\n\n    case \"{\":\n      if (extended) {\n        inGroup = true;\n\t    reStr += \"(\";\n\t    break;\n      }\n\n    case \"}\":\n      if (extended) {\n        inGroup = false;\n\t    reStr += \")\";\n\t    break;\n      }\n\n    case \",\":\n      if (inGroup) {\n        reStr += \"|\";\n\t    break;\n      }\n      reStr += \"\\\\\" + c;\n      break;\n\n    case \"*\":\n      // Move over all consecutive \"*\"'s.\n      // Also store the previous and next characters\n      var prevChar = str[i - 1];\n      var starCount = 1;\n      while(str[i + 1] === \"*\") {\n        starCount++;\n        i++;\n      }\n      var nextChar = str[i + 1];\n\n      if (!globstar) {\n        // globstar is disabled, so treat any number of \"*\" as one\n        reStr += \".*\";\n      } else {\n        // globstar is enabled, so determine if this is a globstar segment\n        var isGlobstar = starCount > 1                      // multiple \"*\"'s\n          && (prevChar === \"/\" || prevChar === undefined)   // from the start of the segment\n          && (nextChar === \"/\" || nextChar === undefined)   // to the end of the segment\n\n        if (isGlobstar) {\n          // it's a globstar, so match zero or more path segments\n          reStr += \"((?:[^/]*(?:\\/|$))*)\";\n          i++; // move over the \"/\"\n        } else {\n          // it's not a globstar, so only match one path segment\n          reStr += \"([^/]*)\";\n        }\n      }\n      break;\n\n    default:\n      reStr += c;\n    }\n  }\n\n  // When regexp 'g' flag is specified don't\n  // constrain the regular expression with ^ & $\n  if (!flags || !~flags.indexOf('g')) {\n    reStr = \"^\" + reStr + \"$\";\n  }\n\n  return new RegExp(reStr, flags);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}