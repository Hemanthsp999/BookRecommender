{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"estree\").Node} EsTreeNode */\n/** @typedef {import(\"./JavascriptParser\").VariableInfoInterface} VariableInfoInterface */\nconst TypeUnknown = 0;\nconst TypeUndefined = 1;\nconst TypeNull = 2;\nconst TypeString = 3;\nconst TypeNumber = 4;\nconst TypeBoolean = 5;\nconst TypeRegExp = 6;\nconst TypeConditional = 7;\nconst TypeArray = 8;\nconst TypeConstArray = 9;\nconst TypeIdentifier = 10;\nconst TypeWrapped = 11;\nconst TypeTemplateString = 12;\nconst TypeBigInt = 13;\nclass BasicEvaluatedExpression {\n  constructor() {\n    this.type = TypeUnknown;\n    /** @type {[number, number]} */\n    this.range = undefined;\n    /** @type {boolean} */\n    this.falsy = false;\n    /** @type {boolean} */\n    this.truthy = false;\n    /** @type {boolean | undefined} */\n    this.nullish = undefined;\n    /** @type {boolean} */\n    this.sideEffects = true;\n    /** @type {boolean | undefined} */\n    this.bool = undefined;\n    /** @type {number | undefined} */\n    this.number = undefined;\n    /** @type {bigint | undefined} */\n    this.bigint = undefined;\n    /** @type {RegExp | undefined} */\n    this.regExp = undefined;\n    /** @type {string | undefined} */\n    this.string = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n    this.quasis = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n    this.parts = undefined;\n    /** @type {any[] | undefined} */\n    this.array = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n    this.items = undefined;\n    /** @type {BasicEvaluatedExpression[] | undefined} */\n    this.options = undefined;\n    /** @type {BasicEvaluatedExpression | undefined} */\n    this.prefix = undefined;\n    /** @type {BasicEvaluatedExpression | undefined} */\n    this.postfix = undefined;\n    /** @type {BasicEvaluatedExpression[]} */\n    this.wrappedInnerExpressions = undefined;\n    /** @type {string | VariableInfoInterface | undefined} */\n    this.identifier = undefined;\n    /** @type {string | VariableInfoInterface} */\n    this.rootInfo = undefined;\n    /** @type {() => string[]} */\n    this.getMembers = undefined;\n    /** @type {() => boolean[]} */\n    this.getMembersOptionals = undefined;\n    /** @type {EsTreeNode} */\n    this.expression = undefined;\n  }\n  isUnknown() {\n    return this.type === TypeUnknown;\n  }\n  isNull() {\n    return this.type === TypeNull;\n  }\n  isUndefined() {\n    return this.type === TypeUndefined;\n  }\n  isString() {\n    return this.type === TypeString;\n  }\n  isNumber() {\n    return this.type === TypeNumber;\n  }\n  isBigInt() {\n    return this.type === TypeBigInt;\n  }\n  isBoolean() {\n    return this.type === TypeBoolean;\n  }\n  isRegExp() {\n    return this.type === TypeRegExp;\n  }\n  isConditional() {\n    return this.type === TypeConditional;\n  }\n  isArray() {\n    return this.type === TypeArray;\n  }\n  isConstArray() {\n    return this.type === TypeConstArray;\n  }\n  isIdentifier() {\n    return this.type === TypeIdentifier;\n  }\n  isWrapped() {\n    return this.type === TypeWrapped;\n  }\n  isTemplateString() {\n    return this.type === TypeTemplateString;\n  }\n\n  /**\n   * Is expression a primitive or an object type value?\n   * @returns {boolean | undefined} true: primitive type, false: object type, undefined: unknown/runtime-defined\n   */\n  isPrimitiveType() {\n    switch (this.type) {\n      case TypeUndefined:\n      case TypeNull:\n      case TypeString:\n      case TypeNumber:\n      case TypeBoolean:\n      case TypeBigInt:\n      case TypeWrapped:\n      case TypeTemplateString:\n        return true;\n      case TypeRegExp:\n      case TypeArray:\n      case TypeConstArray:\n        return false;\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Is expression a runtime or compile-time value?\n   * @returns {boolean} true: compile time value, false: runtime value\n   */\n  isCompileTimeValue() {\n    switch (this.type) {\n      case TypeUndefined:\n      case TypeNull:\n      case TypeString:\n      case TypeNumber:\n      case TypeBoolean:\n      case TypeRegExp:\n      case TypeConstArray:\n      case TypeBigInt:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Gets the compile-time value of the expression\n   * @returns {any} the javascript value\n   */\n  asCompileTimeValue() {\n    switch (this.type) {\n      case TypeUndefined:\n        return undefined;\n      case TypeNull:\n        return null;\n      case TypeString:\n        return this.string;\n      case TypeNumber:\n        return this.number;\n      case TypeBoolean:\n        return this.bool;\n      case TypeRegExp:\n        return this.regExp;\n      case TypeConstArray:\n        return this.array;\n      case TypeBigInt:\n        return this.bigint;\n      default:\n        throw new Error(\"asCompileTimeValue must only be called for compile-time values\");\n    }\n  }\n  isTruthy() {\n    return this.truthy;\n  }\n  isFalsy() {\n    return this.falsy;\n  }\n  isNullish() {\n    return this.nullish;\n  }\n\n  /**\n   * Can this expression have side effects?\n   * @returns {boolean} false: never has side effects\n   */\n  couldHaveSideEffects() {\n    return this.sideEffects;\n  }\n\n  /**\n   * Creates a boolean representation of this evaluated expression.\n   * @returns {boolean | undefined} true: truthy, false: falsy, undefined: unknown\n   */\n  asBool() {\n    if (this.truthy) return true;\n    if (this.falsy || this.nullish) return false;\n    if (this.isBoolean()) return this.bool;\n    if (this.isNull()) return false;\n    if (this.isUndefined()) return false;\n    if (this.isString()) return this.string !== \"\";\n    if (this.isNumber()) return this.number !== 0;\n    if (this.isBigInt()) return this.bigint !== BigInt(0);\n    if (this.isRegExp()) return true;\n    if (this.isArray()) return true;\n    if (this.isConstArray()) return true;\n    if (this.isWrapped()) {\n      return this.prefix && this.prefix.asBool() || this.postfix && this.postfix.asBool() ? true : undefined;\n    }\n    if (this.isTemplateString()) {\n      const str = this.asString();\n      if (typeof str === \"string\") return str !== \"\";\n    }\n    return undefined;\n  }\n\n  /**\n   * Creates a nullish coalescing representation of this evaluated expression.\n   * @returns {boolean | undefined} true: nullish, false: not nullish, undefined: unknown\n   */\n  asNullish() {\n    const nullish = this.isNullish();\n    if (nullish === true || this.isNull() || this.isUndefined()) return true;\n    if (nullish === false) return false;\n    if (this.isTruthy()) return false;\n    if (this.isBoolean()) return false;\n    if (this.isString()) return false;\n    if (this.isNumber()) return false;\n    if (this.isBigInt()) return false;\n    if (this.isRegExp()) return false;\n    if (this.isArray()) return false;\n    if (this.isConstArray()) return false;\n    if (this.isTemplateString()) return false;\n    if (this.isRegExp()) return false;\n    return undefined;\n  }\n\n  /**\n   * Creates a string representation of this evaluated expression.\n   * @returns {string | undefined} the string representation or undefined if not possible\n   */\n  asString() {\n    if (this.isBoolean()) return `${this.bool}`;\n    if (this.isNull()) return \"null\";\n    if (this.isUndefined()) return \"undefined\";\n    if (this.isString()) return this.string;\n    if (this.isNumber()) return `${this.number}`;\n    if (this.isBigInt()) return `${this.bigint}`;\n    if (this.isRegExp()) return `${this.regExp}`;\n    if (this.isArray()) {\n      let array = [];\n      for (const item of this.items) {\n        const itemStr = item.asString();\n        if (itemStr === undefined) return undefined;\n        array.push(itemStr);\n      }\n      return `${array}`;\n    }\n    if (this.isConstArray()) return `${this.array}`;\n    if (this.isTemplateString()) {\n      let str = \"\";\n      for (const part of this.parts) {\n        const partStr = part.asString();\n        if (partStr === undefined) return undefined;\n        str += partStr;\n      }\n      return str;\n    }\n    return undefined;\n  }\n  setString(string) {\n    this.type = TypeString;\n    this.string = string;\n    this.sideEffects = false;\n    return this;\n  }\n  setUndefined() {\n    this.type = TypeUndefined;\n    this.sideEffects = false;\n    return this;\n  }\n  setNull() {\n    this.type = TypeNull;\n    this.sideEffects = false;\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to a number\n   * @param {number} number number to set\n   * @returns {this} this\n   */\n  setNumber(number) {\n    this.type = TypeNumber;\n    this.number = number;\n    this.sideEffects = false;\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to a BigInt\n   * @param {bigint} bigint bigint to set\n   * @returns {this} this\n   */\n  setBigInt(bigint) {\n    this.type = TypeBigInt;\n    this.bigint = bigint;\n    this.sideEffects = false;\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to a boolean\n   * @param {boolean} bool boolean to set\n   * @returns {this} this\n   */\n  setBoolean(bool) {\n    this.type = TypeBoolean;\n    this.bool = bool;\n    this.sideEffects = false;\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to a regular expression\n   * @param {RegExp} regExp regular expression to set\n   * @returns {this} this\n   */\n  setRegExp(regExp) {\n    this.type = TypeRegExp;\n    this.regExp = regExp;\n    this.sideEffects = false;\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to a particular identifier and its members.\n   *\n   * @param {string | VariableInfoInterface} identifier identifier to set\n   * @param {string | VariableInfoInterface} rootInfo root info\n   * @param {() => string[]} getMembers members\n   * @param {() => boolean[]=} getMembersOptionals optional members\n   * @returns {this} this\n   */\n  setIdentifier(identifier, rootInfo, getMembers, getMembersOptionals) {\n    this.type = TypeIdentifier;\n    this.identifier = identifier;\n    this.rootInfo = rootInfo;\n    this.getMembers = getMembers;\n    this.getMembersOptionals = getMembersOptionals;\n    this.sideEffects = true;\n    return this;\n  }\n\n  /**\n   * Wraps an array of expressions with a prefix and postfix expression.\n   *\n   * @param {BasicEvaluatedExpression | null} prefix Expression to be added before the innerExpressions\n   * @param {BasicEvaluatedExpression} postfix Expression to be added after the innerExpressions\n   * @param {BasicEvaluatedExpression[]} innerExpressions Expressions to be wrapped\n   * @returns {this} this\n   */\n  setWrapped(prefix, postfix, innerExpressions) {\n    this.type = TypeWrapped;\n    this.prefix = prefix;\n    this.postfix = postfix;\n    this.wrappedInnerExpressions = innerExpressions;\n    this.sideEffects = true;\n    return this;\n  }\n\n  /**\n   * Stores the options of a conditional expression.\n   *\n   * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be set\n   * @returns {this} this\n   */\n  setOptions(options) {\n    this.type = TypeConditional;\n    this.options = options;\n    this.sideEffects = true;\n    return this;\n  }\n\n  /**\n   * Adds options to a conditional expression.\n   *\n   * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be added\n   * @returns {this} this\n   */\n  addOptions(options) {\n    if (!this.options) {\n      this.type = TypeConditional;\n      this.options = [];\n      this.sideEffects = true;\n    }\n    for (const item of options) {\n      this.options.push(item);\n    }\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to an array of expressions.\n   *\n   * @param {BasicEvaluatedExpression[]} items expressions to set\n   * @returns {this} this\n   */\n  setItems(items) {\n    this.type = TypeArray;\n    this.items = items;\n    this.sideEffects = items.some(i => i.couldHaveSideEffects());\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to an array of strings.\n   *\n   * @param {string[]} array array to set\n   * @returns {this} this\n   */\n  setArray(array) {\n    this.type = TypeConstArray;\n    this.array = array;\n    this.sideEffects = false;\n    return this;\n  }\n\n  /**\n   * Set's the value of this expression to a processed/unprocessed template string. Used\n   * for evaluating TemplateLiteral expressions in the JavaScript Parser.\n   *\n   * @param {BasicEvaluatedExpression[]} quasis template string quasis\n   * @param {BasicEvaluatedExpression[]} parts template string parts\n   * @param {\"cooked\" | \"raw\"} kind template string kind\n   * @returns {this} this\n   */\n  setTemplateString(quasis, parts, kind) {\n    this.type = TypeTemplateString;\n    this.quasis = quasis;\n    this.parts = parts;\n    this.templateStringKind = kind;\n    this.sideEffects = parts.some(p => p.sideEffects);\n    return this;\n  }\n  setTruthy() {\n    this.falsy = false;\n    this.truthy = true;\n    this.nullish = false;\n    return this;\n  }\n  setFalsy() {\n    this.falsy = true;\n    this.truthy = false;\n    return this;\n  }\n\n  /**\n   * Set's the value of the expression to nullish.\n   *\n   * @param {boolean} value true, if the expression is nullish\n   * @returns {this} this\n   */\n  setNullish(value) {\n    this.nullish = value;\n    if (value) return this.setFalsy();\n    return this;\n  }\n\n  /**\n   * Set's the range for the expression.\n   *\n   * @param {[number, number]} range range to set\n   * @returns {this} this\n   */\n  setRange(range) {\n    this.range = range;\n    return this;\n  }\n\n  /**\n   * Set whether or not the expression has side effects.\n   *\n   * @param {boolean} sideEffects true, if the expression has side effects\n   * @returns {this} this\n   */\n  setSideEffects() {\n    let sideEffects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.sideEffects = sideEffects;\n    return this;\n  }\n\n  /**\n   * Set the expression node for the expression.\n   *\n   * @param {EsTreeNode} expression expression\n   * @returns {this} this\n   */\n  setExpression(expression) {\n    this.expression = expression;\n    return this;\n  }\n}\n\n/**\n * @param {string} flags regexp flags\n * @returns {boolean} is valid flags\n */\nBasicEvaluatedExpression.isValidRegExpFlags = flags => {\n  const len = flags.length;\n  if (len === 0) return true;\n  if (len > 4) return false;\n\n  // cspell:word gimy\n  let remaining = 0b0000; // bit per RegExp flag: gimy\n\n  for (let i = 0; i < len; i++) switch (flags.charCodeAt(i)) {\n    case 103 /* g */:\n      if (remaining & 0b1000) return false;\n      remaining |= 0b1000;\n      break;\n    case 105 /* i */:\n      if (remaining & 0b0100) return false;\n      remaining |= 0b0100;\n      break;\n    case 109 /* m */:\n      if (remaining & 0b0010) return false;\n      remaining |= 0b0010;\n      break;\n    case 121 /* y */:\n      if (remaining & 0b0001) return false;\n      remaining |= 0b0001;\n      break;\n    default:\n      return false;\n  }\n  return true;\n};\nmodule.exports = BasicEvaluatedExpression;","map":{"version":3,"names":["TypeUnknown","TypeUndefined","TypeNull","TypeString","TypeNumber","TypeBoolean","TypeRegExp","TypeConditional","TypeArray","TypeConstArray","TypeIdentifier","TypeWrapped","TypeTemplateString","TypeBigInt","BasicEvaluatedExpression","constructor","type","range","undefined","falsy","truthy","nullish","sideEffects","bool","number","bigint","regExp","string","quasis","parts","array","items","options","prefix","postfix","wrappedInnerExpressions","identifier","rootInfo","getMembers","getMembersOptionals","expression","isUnknown","isNull","isUndefined","isString","isNumber","isBigInt","isBoolean","isRegExp","isConditional","isArray","isConstArray","isIdentifier","isWrapped","isTemplateString","isPrimitiveType","isCompileTimeValue","asCompileTimeValue","Error","isTruthy","isFalsy","isNullish","couldHaveSideEffects","asBool","BigInt","str","asString","asNullish","item","itemStr","push","part","partStr","setString","setUndefined","setNull","setNumber","setBigInt","setBoolean","setRegExp","setIdentifier","setWrapped","innerExpressions","setOptions","addOptions","setItems","some","i","setArray","setTemplateString","kind","templateStringKind","p","setTruthy","setFalsy","setNullish","value","setRange","setSideEffects","arguments","length","setExpression","isValidRegExpFlags","flags","len","remaining","charCodeAt","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/javascript/BasicEvaluatedExpression.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"estree\").Node} EsTreeNode */\n/** @typedef {import(\"./JavascriptParser\").VariableInfoInterface} VariableInfoInterface */\n\nconst TypeUnknown = 0;\nconst TypeUndefined = 1;\nconst TypeNull = 2;\nconst TypeString = 3;\nconst TypeNumber = 4;\nconst TypeBoolean = 5;\nconst TypeRegExp = 6;\nconst TypeConditional = 7;\nconst TypeArray = 8;\nconst TypeConstArray = 9;\nconst TypeIdentifier = 10;\nconst TypeWrapped = 11;\nconst TypeTemplateString = 12;\nconst TypeBigInt = 13;\n\nclass BasicEvaluatedExpression {\n\tconstructor() {\n\t\tthis.type = TypeUnknown;\n\t\t/** @type {[number, number]} */\n\t\tthis.range = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.falsy = false;\n\t\t/** @type {boolean} */\n\t\tthis.truthy = false;\n\t\t/** @type {boolean | undefined} */\n\t\tthis.nullish = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.sideEffects = true;\n\t\t/** @type {boolean | undefined} */\n\t\tthis.bool = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis.number = undefined;\n\t\t/** @type {bigint | undefined} */\n\t\tthis.bigint = undefined;\n\t\t/** @type {RegExp | undefined} */\n\t\tthis.regExp = undefined;\n\t\t/** @type {string | undefined} */\n\t\tthis.string = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.quasis = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.parts = undefined;\n\t\t/** @type {any[] | undefined} */\n\t\tthis.array = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.items = undefined;\n\t\t/** @type {BasicEvaluatedExpression[] | undefined} */\n\t\tthis.options = undefined;\n\t\t/** @type {BasicEvaluatedExpression | undefined} */\n\t\tthis.prefix = undefined;\n\t\t/** @type {BasicEvaluatedExpression | undefined} */\n\t\tthis.postfix = undefined;\n\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\tthis.wrappedInnerExpressions = undefined;\n\t\t/** @type {string | VariableInfoInterface | undefined} */\n\t\tthis.identifier = undefined;\n\t\t/** @type {string | VariableInfoInterface} */\n\t\tthis.rootInfo = undefined;\n\t\t/** @type {() => string[]} */\n\t\tthis.getMembers = undefined;\n\t\t/** @type {() => boolean[]} */\n\t\tthis.getMembersOptionals = undefined;\n\t\t/** @type {EsTreeNode} */\n\t\tthis.expression = undefined;\n\t}\n\n\tisUnknown() {\n\t\treturn this.type === TypeUnknown;\n\t}\n\n\tisNull() {\n\t\treturn this.type === TypeNull;\n\t}\n\n\tisUndefined() {\n\t\treturn this.type === TypeUndefined;\n\t}\n\n\tisString() {\n\t\treturn this.type === TypeString;\n\t}\n\n\tisNumber() {\n\t\treturn this.type === TypeNumber;\n\t}\n\n\tisBigInt() {\n\t\treturn this.type === TypeBigInt;\n\t}\n\n\tisBoolean() {\n\t\treturn this.type === TypeBoolean;\n\t}\n\n\tisRegExp() {\n\t\treturn this.type === TypeRegExp;\n\t}\n\n\tisConditional() {\n\t\treturn this.type === TypeConditional;\n\t}\n\n\tisArray() {\n\t\treturn this.type === TypeArray;\n\t}\n\n\tisConstArray() {\n\t\treturn this.type === TypeConstArray;\n\t}\n\n\tisIdentifier() {\n\t\treturn this.type === TypeIdentifier;\n\t}\n\n\tisWrapped() {\n\t\treturn this.type === TypeWrapped;\n\t}\n\n\tisTemplateString() {\n\t\treturn this.type === TypeTemplateString;\n\t}\n\n\t/**\n\t * Is expression a primitive or an object type value?\n\t * @returns {boolean | undefined} true: primitive type, false: object type, undefined: unknown/runtime-defined\n\t */\n\tisPrimitiveType() {\n\t\tswitch (this.type) {\n\t\t\tcase TypeUndefined:\n\t\t\tcase TypeNull:\n\t\t\tcase TypeString:\n\t\t\tcase TypeNumber:\n\t\t\tcase TypeBoolean:\n\t\t\tcase TypeBigInt:\n\t\t\tcase TypeWrapped:\n\t\t\tcase TypeTemplateString:\n\t\t\t\treturn true;\n\t\t\tcase TypeRegExp:\n\t\t\tcase TypeArray:\n\t\t\tcase TypeConstArray:\n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Is expression a runtime or compile-time value?\n\t * @returns {boolean} true: compile time value, false: runtime value\n\t */\n\tisCompileTimeValue() {\n\t\tswitch (this.type) {\n\t\t\tcase TypeUndefined:\n\t\t\tcase TypeNull:\n\t\t\tcase TypeString:\n\t\t\tcase TypeNumber:\n\t\t\tcase TypeBoolean:\n\t\t\tcase TypeRegExp:\n\t\t\tcase TypeConstArray:\n\t\t\tcase TypeBigInt:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the compile-time value of the expression\n\t * @returns {any} the javascript value\n\t */\n\tasCompileTimeValue() {\n\t\tswitch (this.type) {\n\t\t\tcase TypeUndefined:\n\t\t\t\treturn undefined;\n\t\t\tcase TypeNull:\n\t\t\t\treturn null;\n\t\t\tcase TypeString:\n\t\t\t\treturn this.string;\n\t\t\tcase TypeNumber:\n\t\t\t\treturn this.number;\n\t\t\tcase TypeBoolean:\n\t\t\t\treturn this.bool;\n\t\t\tcase TypeRegExp:\n\t\t\t\treturn this.regExp;\n\t\t\tcase TypeConstArray:\n\t\t\t\treturn this.array;\n\t\t\tcase TypeBigInt:\n\t\t\t\treturn this.bigint;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"asCompileTimeValue must only be called for compile-time values\"\n\t\t\t\t);\n\t\t}\n\t}\n\n\tisTruthy() {\n\t\treturn this.truthy;\n\t}\n\n\tisFalsy() {\n\t\treturn this.falsy;\n\t}\n\n\tisNullish() {\n\t\treturn this.nullish;\n\t}\n\n\t/**\n\t * Can this expression have side effects?\n\t * @returns {boolean} false: never has side effects\n\t */\n\tcouldHaveSideEffects() {\n\t\treturn this.sideEffects;\n\t}\n\n\t/**\n\t * Creates a boolean representation of this evaluated expression.\n\t * @returns {boolean | undefined} true: truthy, false: falsy, undefined: unknown\n\t */\n\tasBool() {\n\t\tif (this.truthy) return true;\n\t\tif (this.falsy || this.nullish) return false;\n\t\tif (this.isBoolean()) return this.bool;\n\t\tif (this.isNull()) return false;\n\t\tif (this.isUndefined()) return false;\n\t\tif (this.isString()) return this.string !== \"\";\n\t\tif (this.isNumber()) return this.number !== 0;\n\t\tif (this.isBigInt()) return this.bigint !== BigInt(0);\n\t\tif (this.isRegExp()) return true;\n\t\tif (this.isArray()) return true;\n\t\tif (this.isConstArray()) return true;\n\t\tif (this.isWrapped()) {\n\t\t\treturn (this.prefix && this.prefix.asBool()) ||\n\t\t\t\t(this.postfix && this.postfix.asBool())\n\t\t\t\t? true\n\t\t\t\t: undefined;\n\t\t}\n\t\tif (this.isTemplateString()) {\n\t\t\tconst str = this.asString();\n\t\t\tif (typeof str === \"string\") return str !== \"\";\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Creates a nullish coalescing representation of this evaluated expression.\n\t * @returns {boolean | undefined} true: nullish, false: not nullish, undefined: unknown\n\t */\n\tasNullish() {\n\t\tconst nullish = this.isNullish();\n\n\t\tif (nullish === true || this.isNull() || this.isUndefined()) return true;\n\n\t\tif (nullish === false) return false;\n\t\tif (this.isTruthy()) return false;\n\t\tif (this.isBoolean()) return false;\n\t\tif (this.isString()) return false;\n\t\tif (this.isNumber()) return false;\n\t\tif (this.isBigInt()) return false;\n\t\tif (this.isRegExp()) return false;\n\t\tif (this.isArray()) return false;\n\t\tif (this.isConstArray()) return false;\n\t\tif (this.isTemplateString()) return false;\n\t\tif (this.isRegExp()) return false;\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Creates a string representation of this evaluated expression.\n\t * @returns {string | undefined} the string representation or undefined if not possible\n\t */\n\tasString() {\n\t\tif (this.isBoolean()) return `${this.bool}`;\n\t\tif (this.isNull()) return \"null\";\n\t\tif (this.isUndefined()) return \"undefined\";\n\t\tif (this.isString()) return this.string;\n\t\tif (this.isNumber()) return `${this.number}`;\n\t\tif (this.isBigInt()) return `${this.bigint}`;\n\t\tif (this.isRegExp()) return `${this.regExp}`;\n\t\tif (this.isArray()) {\n\t\t\tlet array = [];\n\t\t\tfor (const item of this.items) {\n\t\t\t\tconst itemStr = item.asString();\n\t\t\t\tif (itemStr === undefined) return undefined;\n\t\t\t\tarray.push(itemStr);\n\t\t\t}\n\t\t\treturn `${array}`;\n\t\t}\n\t\tif (this.isConstArray()) return `${this.array}`;\n\t\tif (this.isTemplateString()) {\n\t\t\tlet str = \"\";\n\t\t\tfor (const part of this.parts) {\n\t\t\t\tconst partStr = part.asString();\n\t\t\t\tif (partStr === undefined) return undefined;\n\t\t\t\tstr += partStr;\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tsetString(string) {\n\t\tthis.type = TypeString;\n\t\tthis.string = string;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\tsetUndefined() {\n\t\tthis.type = TypeUndefined;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\tsetNull() {\n\t\tthis.type = TypeNull;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a number\n\t * @param {number} number number to set\n\t * @returns {this} this\n\t */\n\tsetNumber(number) {\n\t\tthis.type = TypeNumber;\n\t\tthis.number = number;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a BigInt\n\t * @param {bigint} bigint bigint to set\n\t * @returns {this} this\n\t */\n\tsetBigInt(bigint) {\n\t\tthis.type = TypeBigInt;\n\t\tthis.bigint = bigint;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a boolean\n\t * @param {boolean} bool boolean to set\n\t * @returns {this} this\n\t */\n\tsetBoolean(bool) {\n\t\tthis.type = TypeBoolean;\n\t\tthis.bool = bool;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a regular expression\n\t * @param {RegExp} regExp regular expression to set\n\t * @returns {this} this\n\t */\n\tsetRegExp(regExp) {\n\t\tthis.type = TypeRegExp;\n\t\tthis.regExp = regExp;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a particular identifier and its members.\n\t *\n\t * @param {string | VariableInfoInterface} identifier identifier to set\n\t * @param {string | VariableInfoInterface} rootInfo root info\n\t * @param {() => string[]} getMembers members\n\t * @param {() => boolean[]=} getMembersOptionals optional members\n\t * @returns {this} this\n\t */\n\tsetIdentifier(identifier, rootInfo, getMembers, getMembersOptionals) {\n\t\tthis.type = TypeIdentifier;\n\t\tthis.identifier = identifier;\n\t\tthis.rootInfo = rootInfo;\n\t\tthis.getMembers = getMembers;\n\t\tthis.getMembersOptionals = getMembersOptionals;\n\t\tthis.sideEffects = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wraps an array of expressions with a prefix and postfix expression.\n\t *\n\t * @param {BasicEvaluatedExpression | null} prefix Expression to be added before the innerExpressions\n\t * @param {BasicEvaluatedExpression} postfix Expression to be added after the innerExpressions\n\t * @param {BasicEvaluatedExpression[]} innerExpressions Expressions to be wrapped\n\t * @returns {this} this\n\t */\n\tsetWrapped(prefix, postfix, innerExpressions) {\n\t\tthis.type = TypeWrapped;\n\t\tthis.prefix = prefix;\n\t\tthis.postfix = postfix;\n\t\tthis.wrappedInnerExpressions = innerExpressions;\n\t\tthis.sideEffects = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stores the options of a conditional expression.\n\t *\n\t * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be set\n\t * @returns {this} this\n\t */\n\tsetOptions(options) {\n\t\tthis.type = TypeConditional;\n\t\tthis.options = options;\n\t\tthis.sideEffects = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds options to a conditional expression.\n\t *\n\t * @param {BasicEvaluatedExpression[]} options optional (consequent/alternate) expressions to be added\n\t * @returns {this} this\n\t */\n\taddOptions(options) {\n\t\tif (!this.options) {\n\t\t\tthis.type = TypeConditional;\n\t\t\tthis.options = [];\n\t\t\tthis.sideEffects = true;\n\t\t}\n\t\tfor (const item of options) {\n\t\t\tthis.options.push(item);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to an array of expressions.\n\t *\n\t * @param {BasicEvaluatedExpression[]} items expressions to set\n\t * @returns {this} this\n\t */\n\tsetItems(items) {\n\t\tthis.type = TypeArray;\n\t\tthis.items = items;\n\t\tthis.sideEffects = items.some(i => i.couldHaveSideEffects());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to an array of strings.\n\t *\n\t * @param {string[]} array array to set\n\t * @returns {this} this\n\t */\n\tsetArray(array) {\n\t\tthis.type = TypeConstArray;\n\t\tthis.array = array;\n\t\tthis.sideEffects = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of this expression to a processed/unprocessed template string. Used\n\t * for evaluating TemplateLiteral expressions in the JavaScript Parser.\n\t *\n\t * @param {BasicEvaluatedExpression[]} quasis template string quasis\n\t * @param {BasicEvaluatedExpression[]} parts template string parts\n\t * @param {\"cooked\" | \"raw\"} kind template string kind\n\t * @returns {this} this\n\t */\n\tsetTemplateString(quasis, parts, kind) {\n\t\tthis.type = TypeTemplateString;\n\t\tthis.quasis = quasis;\n\t\tthis.parts = parts;\n\t\tthis.templateStringKind = kind;\n\t\tthis.sideEffects = parts.some(p => p.sideEffects);\n\t\treturn this;\n\t}\n\n\tsetTruthy() {\n\t\tthis.falsy = false;\n\t\tthis.truthy = true;\n\t\tthis.nullish = false;\n\t\treturn this;\n\t}\n\n\tsetFalsy() {\n\t\tthis.falsy = true;\n\t\tthis.truthy = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the value of the expression to nullish.\n\t *\n\t * @param {boolean} value true, if the expression is nullish\n\t * @returns {this} this\n\t */\n\tsetNullish(value) {\n\t\tthis.nullish = value;\n\n\t\tif (value) return this.setFalsy();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set's the range for the expression.\n\t *\n\t * @param {[number, number]} range range to set\n\t * @returns {this} this\n\t */\n\tsetRange(range) {\n\t\tthis.range = range;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set whether or not the expression has side effects.\n\t *\n\t * @param {boolean} sideEffects true, if the expression has side effects\n\t * @returns {this} this\n\t */\n\tsetSideEffects(sideEffects = true) {\n\t\tthis.sideEffects = sideEffects;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the expression node for the expression.\n\t *\n\t * @param {EsTreeNode} expression expression\n\t * @returns {this} this\n\t */\n\tsetExpression(expression) {\n\t\tthis.expression = expression;\n\t\treturn this;\n\t}\n}\n\n/**\n * @param {string} flags regexp flags\n * @returns {boolean} is valid flags\n */\nBasicEvaluatedExpression.isValidRegExpFlags = flags => {\n\tconst len = flags.length;\n\n\tif (len === 0) return true;\n\tif (len > 4) return false;\n\n\t// cspell:word gimy\n\tlet remaining = 0b0000; // bit per RegExp flag: gimy\n\n\tfor (let i = 0; i < len; i++)\n\t\tswitch (flags.charCodeAt(i)) {\n\t\t\tcase 103 /* g */:\n\t\t\t\tif (remaining & 0b1000) return false;\n\t\t\t\tremaining |= 0b1000;\n\t\t\t\tbreak;\n\t\t\tcase 105 /* i */:\n\t\t\t\tif (remaining & 0b0100) return false;\n\t\t\t\tremaining |= 0b0100;\n\t\t\t\tbreak;\n\t\t\tcase 109 /* m */:\n\t\t\t\tif (remaining & 0b0010) return false;\n\t\t\t\tremaining |= 0b0010;\n\t\t\t\tbreak;\n\t\t\tcase 121 /* y */:\n\t\t\t\tif (remaining & 0b0001) return false;\n\t\t\t\tremaining |= 0b0001;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\treturn true;\n};\n\nmodule.exports = BasicEvaluatedExpression;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}