{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst _util_1 = require(\"./_util\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        schemaProp\n      }\n    } = _ref;\n    return schemaProp ? (0, codegen_1.str)`should match case \"${schemaProp}\" schema` : (0, codegen_1.str)`should match default case schema`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        schemaProp\n      }\n    } = _ref2;\n    return schemaProp ? (0, codegen_1._)`{failingCase: ${schemaProp}}` : (0, codegen_1._)`{failingDefault: true}`;\n  }\n};\nfunction getDef(opts) {\n  const metaSchema = (0, _util_1.metaSchemaRef)(opts);\n  return [{\n    keyword: \"select\",\n    schemaType: [\"string\", \"number\", \"boolean\", \"null\"],\n    $data: true,\n    error,\n    dependencies: [\"selectCases\"],\n    code(cxt) {\n      const {\n        gen,\n        schemaCode,\n        parentSchema\n      } = cxt;\n      cxt.block$data(codegen_1.nil, () => {\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        const value = gen.const(\"value\", (0, codegen_1._)`${schemaCode} === null ? \"null\" : ${schemaCode}`);\n        gen.if(false); // optimizer should remove it from generated code\n        for (const schemaProp in parentSchema.selectCases) {\n          cxt.setParams({\n            schemaProp\n          });\n          gen.elseIf((0, codegen_1._)`\"\" + ${value} == ${schemaProp}`); // intentional ==, to match numbers and booleans\n          const schCxt = cxt.subschema({\n            keyword: \"selectCases\",\n            schemaProp\n          }, schValid);\n          cxt.mergeEvaluated(schCxt, codegen_1.Name);\n          gen.assign(valid, schValid);\n        }\n        gen.else();\n        if (parentSchema.selectDefault !== undefined) {\n          cxt.setParams({\n            schemaProp: undefined\n          });\n          const schCxt = cxt.subschema({\n            keyword: \"selectDefault\"\n          }, schValid);\n          cxt.mergeEvaluated(schCxt, codegen_1.Name);\n          gen.assign(valid, schValid);\n        }\n        gen.endIf();\n        cxt.pass(valid);\n      });\n    }\n  }, {\n    keyword: \"selectCases\",\n    dependencies: [\"select\"],\n    metaSchema: {\n      type: \"object\",\n      additionalProperties: metaSchema\n    }\n  }, {\n    keyword: \"selectDefault\",\n    dependencies: [\"select\", \"selectCases\"],\n    metaSchema\n  }];\n}\nexports.default = getDef;\nmodule.exports = getDef;","map":{"version":3,"names":["codegen_1","require","_util_1","error","message","_ref","params","schemaProp","str","_ref2","_","getDef","opts","metaSchema","metaSchemaRef","keyword","schemaType","$data","dependencies","code","cxt","gen","schemaCode","parentSchema","block$data","nil","valid","let","schValid","name","value","const","if","selectCases","setParams","elseIf","schCxt","subschema","mergeEvaluated","Name","assign","else","selectDefault","undefined","endIf","pass","type","additionalProperties","exports","default","module"],"sources":["/home/hemanth/react-project/client/node_modules/webpack-dev-middleware/node_modules/ajv-keywords/src/definitions/select.ts"],"sourcesContent":["import type {KeywordDefinition, KeywordErrorDefinition, KeywordCxt, ErrorObject} from \"ajv\"\nimport {_, str, nil, Name} from \"ajv/dist/compile/codegen\"\nimport type {DefinitionOptions} from \"./_types\"\nimport {metaSchemaRef} from \"./_util\"\n\nexport type SelectError = ErrorObject<\"select\", {failingCase?: string; failingDefault?: true}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {schemaProp}}) =>\n    schemaProp\n      ? str`should match case \"${schemaProp}\" schema`\n      : str`should match default case schema`,\n  params: ({params: {schemaProp}}) =>\n    schemaProp ? _`{failingCase: ${schemaProp}}` : _`{failingDefault: true}`,\n}\n\nexport default function getDef(opts?: DefinitionOptions): KeywordDefinition[] {\n  const metaSchema = metaSchemaRef(opts)\n\n  return [\n    {\n      keyword: \"select\",\n      schemaType: [\"string\", \"number\", \"boolean\", \"null\"],\n      $data: true,\n      error,\n      dependencies: [\"selectCases\"],\n      code(cxt: KeywordCxt) {\n        const {gen, schemaCode, parentSchema} = cxt\n        cxt.block$data(nil, () => {\n          const valid = gen.let(\"valid\", true)\n          const schValid = gen.name(\"_valid\")\n          const value = gen.const(\"value\", _`${schemaCode} === null ? \"null\" : ${schemaCode}`)\n          gen.if(false) // optimizer should remove it from generated code\n          for (const schemaProp in parentSchema.selectCases) {\n            cxt.setParams({schemaProp})\n            gen.elseIf(_`\"\" + ${value} == ${schemaProp}`) // intentional ==, to match numbers and booleans\n            const schCxt = cxt.subschema({keyword: \"selectCases\", schemaProp}, schValid)\n            cxt.mergeEvaluated(schCxt, Name)\n            gen.assign(valid, schValid)\n          }\n          gen.else()\n          if (parentSchema.selectDefault !== undefined) {\n            cxt.setParams({schemaProp: undefined})\n            const schCxt = cxt.subschema({keyword: \"selectDefault\"}, schValid)\n            cxt.mergeEvaluated(schCxt, Name)\n            gen.assign(valid, schValid)\n          }\n          gen.endIf()\n          cxt.pass(valid)\n        })\n      },\n    },\n    {\n      keyword: \"selectCases\",\n      dependencies: [\"select\"],\n      metaSchema: {\n        type: \"object\",\n        additionalProperties: metaSchema,\n      },\n    },\n    {\n      keyword: \"selectDefault\",\n      dependencies: [\"select\", \"selectCases\"],\n      metaSchema,\n    },\n  ]\n}\n\nmodule.exports = getDef\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}