{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\nconst LazySet = require(\"../util/LazySet\");\nconst LoaderDependency = require(\"./LoaderDependency\");\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\nclass LoaderPlugin {\n  /**\n   * @param {Object} options options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);\n      compilation.dependencyFactories.set(LoaderImportDependency, normalModuleFactory);\n    });\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      NormalModule.getCompilationHooks(compilation).loader.tap(\"LoaderPlugin\", loaderContext => {\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {LoadModuleCallback} callback callback returning the loaded module or error\n         * @returns {void}\n         */\n        loaderContext.loadModule = (request, callback) => {\n          const dep = new LoaderDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get( /** @type {DepConstructor} */dep.constructor);\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            context: loaderContext.context,\n            recursive: false\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n            if (err) {\n              return callback(err);\n            }\n            const referencedModule = moduleGraph.getModule(dep);\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n            if (referencedModule.getNumberOfErrors() > 0) {\n              return callback(new Error(\"The loaded module contains errors\"));\n            }\n            const moduleSource = referencedModule.originalSource();\n            if (!moduleSource) {\n              return callback(new Error(\"The module created for a LoaderDependency must have an original source\"));\n            }\n            let source, map;\n            if (moduleSource.sourceAndMap) {\n              const sourceAndMap = moduleSource.sourceAndMap();\n              map = sourceAndMap.map;\n              source = sourceAndMap.source;\n            } else {\n              map = moduleSource.map();\n              source = moduleSource.source();\n            }\n            const fileDependencies = new LazySet();\n            const contextDependencies = new LazySet();\n            const missingDependencies = new LazySet();\n            const buildDependencies = new LazySet();\n            referencedModule.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);\n            for (const d of fileDependencies) {\n              loaderContext.addDependency(d);\n            }\n            for (const d of contextDependencies) {\n              loaderContext.addContextDependency(d);\n            }\n            for (const d of missingDependencies) {\n              loaderContext.addMissingDependency(d);\n            }\n            for (const d of buildDependencies) {\n              loaderContext.addBuildDependency(d);\n            }\n            return callback(null, source, map, referencedModule);\n          });\n        };\n\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions=} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {void}\n         */\n        const importModule = (request, options, callback) => {\n          const dep = new LoaderImportDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get( /** @type {DepConstructor} */dep.constructor);\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            contextInfo: {\n              issuerLayer: options.layer\n            },\n            context: loaderContext.context,\n            connectOrigin: false\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n            if (err) {\n              return callback(err);\n            }\n            const referencedModule = moduleGraph.getModule(dep);\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n            compilation.executeModule(referencedModule, {\n              entryOptions: {\n                baseUri: options.baseUri,\n                publicPath: options.publicPath\n              }\n            }, (err, result) => {\n              if (err) return callback(err);\n              for (const d of result.fileDependencies) {\n                loaderContext.addDependency(d);\n              }\n              for (const d of result.contextDependencies) {\n                loaderContext.addContextDependency(d);\n              }\n              for (const d of result.missingDependencies) {\n                loaderContext.addMissingDependency(d);\n              }\n              for (const d of result.buildDependencies) {\n                loaderContext.addBuildDependency(d);\n              }\n              if (result.cacheable === false) loaderContext.cacheable(false);\n              for (const [name, {\n                source,\n                info\n              }] of result.assets) {\n                const {\n                  buildInfo\n                } = loaderContext._module;\n                if (!buildInfo.assets) {\n                  buildInfo.assets = Object.create(null);\n                  buildInfo.assetsInfo = new Map();\n                }\n                buildInfo.assets[name] = source;\n                buildInfo.assetsInfo.set(name, info);\n              }\n              callback(null, result.exports);\n            });\n          });\n        };\n\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {Promise<any> | void} exports\n         */\n        loaderContext.importModule = (request, options, callback) => {\n          if (!callback) {\n            return new Promise((resolve, reject) => {\n              importModule(request, options || {}, (err, result) => {\n                if (err) reject(err);else resolve(result);\n              });\n            });\n          }\n          return importModule(request, options || {}, callback);\n        };\n      });\n    });\n  }\n}\nmodule.exports = LoaderPlugin;","map":{"version":3,"names":["NormalModule","require","LazySet","LoaderDependency","LoaderImportDependency","LoaderPlugin","constructor","options","arguments","length","undefined","apply","compiler","hooks","compilation","tap","_ref","normalModuleFactory","dependencyFactories","set","moduleGraph","getCompilationHooks","loader","loaderContext","loadModule","request","callback","dep","loc","name","factory","get","Error","buildQueue","increaseParallelism","handleModuleCreation","dependencies","originModule","_module","context","recursive","err","decreaseParallelism","referencedModule","getModule","getNumberOfErrors","moduleSource","originalSource","source","map","sourceAndMap","fileDependencies","contextDependencies","missingDependencies","buildDependencies","addCacheDependencies","d","addDependency","addContextDependency","addMissingDependency","addBuildDependency","importModule","contextInfo","issuerLayer","layer","connectOrigin","executeModule","entryOptions","baseUri","publicPath","result","cacheable","info","assets","buildInfo","Object","create","assetsInfo","Map","exports","Promise","resolve","reject","module"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/dependencies/LoaderPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\nconst LazySet = require(\"../util/LazySet\");\nconst LoaderDependency = require(\"./LoaderDependency\");\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\nclass LoaderPlugin {\n\t/**\n\t * @param {Object} options options\n\t */\n\tconstructor(options = {}) {}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"LoaderPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderImportDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tNormalModule.getCompilationHooks(compilation).loader.tap(\n\t\t\t\t\"LoaderPlugin\",\n\t\t\t\tloaderContext => {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {LoadModuleCallback} callback callback returning the loaded module or error\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.loadModule = (request, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\trecursive: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (referencedModule.getNumberOfErrors() > 0) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\"The loaded module contains errors\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst moduleSource = referencedModule.originalSource();\n\t\t\t\t\t\t\t\tif (!moduleSource) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\"The module created for a LoaderDependency must have an original source\"\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet source, map;\n\t\t\t\t\t\t\t\tif (moduleSource.sourceAndMap) {\n\t\t\t\t\t\t\t\t\tconst sourceAndMap = moduleSource.sourceAndMap();\n\t\t\t\t\t\t\t\t\tmap = sourceAndMap.map;\n\t\t\t\t\t\t\t\t\tsource = sourceAndMap.source;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmap = moduleSource.map();\n\t\t\t\t\t\t\t\t\tsource = moduleSource.source();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst fileDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst contextDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst missingDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst buildDependencies = new LazySet();\n\t\t\t\t\t\t\t\treferencedModule.addCacheDependencies(\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tbuildDependencies\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tfor (const d of fileDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of contextDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of missingDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of buildDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(null, source, map, referencedModule);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions=} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst importModule = (request, options, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderImportDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\t\t\t\tissuerLayer: options.layer\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\tconnectOrigin: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.executeModule(\n\t\t\t\t\t\t\t\t\treferencedModule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tentryOptions: {\n\t\t\t\t\t\t\t\t\t\t\tbaseUri: options.baseUri,\n\t\t\t\t\t\t\t\t\t\t\tpublicPath: options.publicPath\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.buildDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (result.cacheable === false)\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.cacheable(false);\n\t\t\t\t\t\t\t\t\t\tfor (const [name, { source, info }] of result.assets) {\n\t\t\t\t\t\t\t\t\t\t\tconst { buildInfo } = loaderContext._module;\n\t\t\t\t\t\t\t\t\t\t\tif (!buildInfo.assets) {\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets = Object.create(null);\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo = new Map();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets[name] = source;\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo.set(name, info);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback(null, result.exports);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {Promise<any> | void} exports\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.importModule = (request, options, callback) => {\n\t\t\t\t\t\tif (!callback) {\n\t\t\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\timportModule(request, options || {}, (err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\t\t\t\t\telse resolve(result);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn importModule(request, options || {}, callback);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LoaderPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}