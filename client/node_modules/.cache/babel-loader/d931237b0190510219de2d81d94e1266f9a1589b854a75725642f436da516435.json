{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst mimeTypes = require(\"mime-types\");\nconst path = require(\"path\");\nconst {\n  RawSource\n} = require(\"webpack-sources\");\nconst ConcatenationScope = require(\"../ConcatenationScope\");\nconst Generator = require(\"../Generator\");\nconst {\n  ASSET_MODULE_TYPE\n} = require(\"../ModuleTypeConstants\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst createHash = require(\"../util/createHash\");\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\nconst nonNumericOnlyHash = require(\"../util/nonNumericOnlyHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetGeneratorOptions} AssetGeneratorOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetModuleOutputPath} AssetModuleOutputPath */\n/** @typedef {import(\"../../declarations/WebpackOptions\").RawPublicPath} RawPublicPath */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"../Generator\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").ConcatenationBailoutReasonContext} ConcatenationBailoutReasonContext */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../util/Hash\")} Hash */\n\nconst mergeMaybeArrays = (a, b) => {\n  const set = new Set();\n  if (Array.isArray(a)) for (const item of a) set.add(item);else set.add(a);\n  if (Array.isArray(b)) for (const item of b) set.add(item);else set.add(b);\n  return Array.from(set);\n};\nconst mergeAssetInfo = (a, b) => {\n  const result = {\n    ...a,\n    ...b\n  };\n  for (const key of Object.keys(a)) {\n    if (key in b) {\n      if (a[key] === b[key]) continue;\n      switch (key) {\n        case \"fullhash\":\n        case \"chunkhash\":\n        case \"modulehash\":\n        case \"contenthash\":\n          result[key] = mergeMaybeArrays(a[key], b[key]);\n          break;\n        case \"immutable\":\n        case \"development\":\n        case \"hotModuleReplacement\":\n        case \"javascriptModule\":\n          result[key] = a[key] || b[key];\n          break;\n        case \"related\":\n          result[key] = mergeRelatedInfo(a[key], b[key]);\n          break;\n        default:\n          throw new Error(`Can't handle conflicting asset info for ${key}`);\n      }\n    }\n  }\n  return result;\n};\nconst mergeRelatedInfo = (a, b) => {\n  const result = {\n    ...a,\n    ...b\n  };\n  for (const key of Object.keys(a)) {\n    if (key in b) {\n      if (a[key] === b[key]) continue;\n      result[key] = mergeMaybeArrays(a[key], b[key]);\n    }\n  }\n  return result;\n};\nconst encodeDataUri = (encoding, source) => {\n  let encodedContent;\n  switch (encoding) {\n    case \"base64\":\n      {\n        encodedContent = source.buffer().toString(\"base64\");\n        break;\n      }\n    case false:\n      {\n        const content = source.source();\n        if (typeof content !== \"string\") {\n          encodedContent = content.toString(\"utf-8\");\n        }\n        encodedContent = encodeURIComponent(encodedContent).replace(/[!'()*]/g, character => \"%\" + character.codePointAt(0).toString(16));\n        break;\n      }\n    default:\n      throw new Error(`Unsupported encoding '${encoding}'`);\n  }\n  return encodedContent;\n};\nconst decodeDataUriContent = (encoding, content) => {\n  const isBase64 = encoding === \"base64\";\n  if (isBase64) {\n    return Buffer.from(content, \"base64\");\n  }\n\n  // If we can't decode return the original body\n  try {\n    return Buffer.from(decodeURIComponent(content), \"ascii\");\n  } catch (_) {\n    return Buffer.from(content, \"ascii\");\n  }\n};\nconst JS_TYPES = new Set([\"javascript\"]);\nconst JS_AND_ASSET_TYPES = new Set([\"javascript\", ASSET_MODULE_TYPE]);\nconst DEFAULT_ENCODING = \"base64\";\nclass AssetGenerator extends Generator {\n  /**\n   * @param {AssetGeneratorOptions[\"dataUrl\"]=} dataUrlOptions the options for the data url\n   * @param {string=} filename override for output.assetModuleFilename\n   * @param {RawPublicPath=} publicPath override for output.assetModulePublicPath\n   * @param {AssetModuleOutputPath=} outputPath the output path for the emitted file which is not included in the runtime import\n   * @param {boolean=} emit generate output asset\n   */\n  constructor(dataUrlOptions, filename, publicPath, outputPath, emit) {\n    super();\n    this.dataUrlOptions = dataUrlOptions;\n    this.filename = filename;\n    this.publicPath = publicPath;\n    this.outputPath = outputPath;\n    this.emit = emit;\n  }\n\n  /**\n   * @param {NormalModule} module module\n   * @param {RuntimeTemplate} runtimeTemplate runtime template\n   * @returns {string} source file name\n   */\n  getSourceFileName(module, runtimeTemplate) {\n    return makePathsRelative(runtimeTemplate.compilation.compiler.context, module.matchResource || module.resource, runtimeTemplate.compilation.compiler.root).replace(/^\\.\\//, \"\");\n  }\n\n  /**\n   * @param {NormalModule} module module for which the bailout reason should be determined\n   * @param {ConcatenationBailoutReasonContext} context context\n   * @returns {string | undefined} reason why this module can't be concatenated, undefined when it can be concatenated\n   */\n  getConcatenationBailoutReason(module, context) {\n    return undefined;\n  }\n\n  /**\n   * @param {NormalModule} module module\n   * @returns {string} mime type\n   */\n  getMimeType(module) {\n    if (typeof this.dataUrlOptions === \"function\") {\n      throw new Error(\"This method must not be called when dataUrlOptions is a function\");\n    }\n    let mimeType = this.dataUrlOptions.mimetype;\n    if (mimeType === undefined) {\n      const ext = path.extname(module.nameForCondition());\n      if (module.resourceResolveData && module.resourceResolveData.mimetype !== undefined) {\n        mimeType = module.resourceResolveData.mimetype + module.resourceResolveData.parameters;\n      } else if (ext) {\n        mimeType = mimeTypes.lookup(ext);\n        if (typeof mimeType !== \"string\") {\n          throw new Error(\"DataUrl can't be generated automatically, \" + `because there is no mimetype for \"${ext}\" in mimetype database. ` + 'Either pass a mimetype via \"generator.mimetype\" or ' + 'use type: \"asset/resource\" to create a resource file instead of a DataUrl');\n        }\n      }\n    }\n    if (typeof mimeType !== \"string\") {\n      throw new Error(\"DataUrl can't be generated automatically. \" + 'Either pass a mimetype via \"generator.mimetype\" or ' + 'use type: \"asset/resource\" to create a resource file instead of a DataUrl');\n    }\n    return mimeType;\n  }\n\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {GenerateContext} generateContext context for generate\n   * @returns {Source} generated code\n   */\n  generate(module, _ref) {\n    let {\n      runtime,\n      concatenationScope,\n      chunkGraph,\n      runtimeTemplate,\n      runtimeRequirements,\n      type,\n      getData\n    } = _ref;\n    switch (type) {\n      case ASSET_MODULE_TYPE:\n        return module.originalSource();\n      default:\n        {\n          let content;\n          const originalSource = module.originalSource();\n          if (module.buildInfo.dataUrl) {\n            let encodedSource;\n            if (typeof this.dataUrlOptions === \"function\") {\n              encodedSource = this.dataUrlOptions.call(null, originalSource.source(), {\n                filename: module.matchResource || module.resource,\n                module\n              });\n            } else {\n              /** @type {string | false | undefined} */\n              let encoding = this.dataUrlOptions.encoding;\n              if (encoding === undefined) {\n                if (module.resourceResolveData && module.resourceResolveData.encoding !== undefined) {\n                  encoding = module.resourceResolveData.encoding;\n                }\n              }\n              if (encoding === undefined) {\n                encoding = DEFAULT_ENCODING;\n              }\n              const mimeType = this.getMimeType(module);\n              let encodedContent;\n              if (module.resourceResolveData && module.resourceResolveData.encoding === encoding && decodeDataUriContent(module.resourceResolveData.encoding, module.resourceResolveData.encodedContent).equals(originalSource.buffer())) {\n                encodedContent = module.resourceResolveData.encodedContent;\n              } else {\n                encodedContent = encodeDataUri(encoding, originalSource);\n              }\n              encodedSource = `data:${mimeType}${encoding ? `;${encoding}` : \"\"},${encodedContent}`;\n            }\n            const data = getData();\n            data.set(\"url\", Buffer.from(encodedSource));\n            content = JSON.stringify(encodedSource);\n          } else {\n            const assetModuleFilename = this.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n            const hash = createHash(runtimeTemplate.outputOptions.hashFunction);\n            if (runtimeTemplate.outputOptions.hashSalt) {\n              hash.update(runtimeTemplate.outputOptions.hashSalt);\n            }\n            hash.update(originalSource.buffer());\n            const fullHash = /** @type {string} */\n            hash.digest(runtimeTemplate.outputOptions.hashDigest);\n            const contentHash = nonNumericOnlyHash(fullHash, runtimeTemplate.outputOptions.hashDigestLength);\n            module.buildInfo.fullContentHash = fullHash;\n            const sourceFilename = this.getSourceFileName(module, runtimeTemplate);\n            let {\n              path: filename,\n              info: assetInfo\n            } = runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, {\n              module,\n              runtime,\n              filename: sourceFilename,\n              chunkGraph,\n              contentHash\n            });\n            let assetPath;\n            if (this.publicPath !== undefined) {\n              const {\n                path,\n                info\n              } = runtimeTemplate.compilation.getAssetPathWithInfo(this.publicPath, {\n                module,\n                runtime,\n                filename: sourceFilename,\n                chunkGraph,\n                contentHash\n              });\n              assetInfo = mergeAssetInfo(assetInfo, info);\n              assetPath = JSON.stringify(path + filename);\n            } else {\n              runtimeRequirements.add(RuntimeGlobals.publicPath); // add __webpack_require__.p\n              assetPath = runtimeTemplate.concatenation({\n                expr: RuntimeGlobals.publicPath\n              }, filename);\n            }\n            assetInfo = {\n              sourceFilename,\n              ...assetInfo\n            };\n            if (this.outputPath) {\n              const {\n                path: outputPath,\n                info\n              } = runtimeTemplate.compilation.getAssetPathWithInfo(this.outputPath, {\n                module,\n                runtime,\n                filename: sourceFilename,\n                chunkGraph,\n                contentHash\n              });\n              assetInfo = mergeAssetInfo(assetInfo, info);\n              filename = path.posix.join(outputPath, filename);\n            }\n            module.buildInfo.filename = filename;\n            module.buildInfo.assetInfo = assetInfo;\n            if (getData) {\n              // Due to code generation caching module.buildInfo.XXX can't used to store such information\n              // It need to be stored in the code generation results instead, where it's cached too\n              // TODO webpack 6 For back-compat reasons we also store in on module.buildInfo\n              const data = getData();\n              data.set(\"fullContentHash\", fullHash);\n              data.set(\"filename\", filename);\n              data.set(\"assetInfo\", assetInfo);\n            }\n            content = assetPath;\n          }\n          if (concatenationScope) {\n            concatenationScope.registerNamespaceExport(ConcatenationScope.NAMESPACE_OBJECT_EXPORT);\n            return new RawSource(`${runtimeTemplate.supportsConst() ? \"const\" : \"var\"} ${ConcatenationScope.NAMESPACE_OBJECT_EXPORT} = ${content};`);\n          } else {\n            runtimeRequirements.add(RuntimeGlobals.module);\n            return new RawSource(`${RuntimeGlobals.module}.exports = ${content};`);\n          }\n        }\n    }\n  }\n\n  /**\n   * @param {NormalModule} module fresh module\n   * @returns {Set<string>} available types (do not mutate)\n   */\n  getTypes(module) {\n    if (module.buildInfo && module.buildInfo.dataUrl || this.emit === false) {\n      return JS_TYPES;\n    } else {\n      return JS_AND_ASSET_TYPES;\n    }\n  }\n\n  /**\n   * @param {NormalModule} module the module\n   * @param {string=} type source type\n   * @returns {number} estimate size of the module\n   */\n  getSize(module, type) {\n    switch (type) {\n      case ASSET_MODULE_TYPE:\n        {\n          const originalSource = module.originalSource();\n          if (!originalSource) {\n            return 0;\n          }\n          return originalSource.size();\n        }\n      default:\n        if (module.buildInfo && module.buildInfo.dataUrl) {\n          const originalSource = module.originalSource();\n          if (!originalSource) {\n            return 0;\n          }\n\n          // roughly for data url\n          // Example: m.exports=\"data:image/png;base64,ag82/f+2==\"\n          // 4/3 = base64 encoding\n          // 34 = ~ data url header + footer + rounding\n          return originalSource.size() * 1.34 + 36;\n        } else {\n          // it's only estimated so this number is probably fine\n          // Example: m.exports=r.p+\"0123456789012345678901.ext\"\n          return 42;\n        }\n    }\n  }\n\n  /**\n   * @param {Hash} hash hash that will be modified\n   * @param {UpdateHashContext} updateHashContext context for updating hash\n   */\n  updateHash(hash, _ref2) {\n    let {\n      module,\n      runtime,\n      runtimeTemplate,\n      chunkGraph\n    } = _ref2;\n    if (module.buildInfo.dataUrl) {\n      hash.update(\"data-url\");\n      // this.dataUrlOptions as function should be pure and only depend on input source and filename\n      // therefore it doesn't need to be hashed\n      if (typeof this.dataUrlOptions === \"function\") {\n        const ident = /** @type {{ ident?: string }} */this.dataUrlOptions.ident;\n        if (ident) hash.update(ident);\n      } else {\n        if (this.dataUrlOptions.encoding && this.dataUrlOptions.encoding !== DEFAULT_ENCODING) {\n          hash.update(this.dataUrlOptions.encoding);\n        }\n        if (this.dataUrlOptions.mimetype) hash.update(this.dataUrlOptions.mimetype);\n        // computed mimetype depends only on module filename which is already part of the hash\n      }\n    } else {\n      hash.update(\"resource\");\n      const pathData = {\n        module,\n        runtime,\n        filename: this.getSourceFileName(module, runtimeTemplate),\n        chunkGraph,\n        contentHash: runtimeTemplate.contentHashReplacement\n      };\n      if (typeof this.publicPath === \"function\") {\n        hash.update(\"path\");\n        const assetInfo = {};\n        hash.update(this.publicPath(pathData, assetInfo));\n        hash.update(JSON.stringify(assetInfo));\n      } else if (this.publicPath) {\n        hash.update(\"path\");\n        hash.update(this.publicPath);\n      } else {\n        hash.update(\"no-path\");\n      }\n      const assetModuleFilename = this.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n      const {\n        path: filename,\n        info\n      } = runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, pathData);\n      hash.update(filename);\n      hash.update(JSON.stringify(info));\n    }\n  }\n}\nmodule.exports = AssetGenerator;","map":{"version":3,"names":["mimeTypes","require","path","RawSource","ConcatenationScope","Generator","ASSET_MODULE_TYPE","RuntimeGlobals","createHash","makePathsRelative","nonNumericOnlyHash","mergeMaybeArrays","a","b","set","Set","Array","isArray","item","add","from","mergeAssetInfo","result","key","Object","keys","mergeRelatedInfo","Error","encodeDataUri","encoding","source","encodedContent","buffer","toString","content","encodeURIComponent","replace","character","codePointAt","decodeDataUriContent","isBase64","Buffer","decodeURIComponent","_","JS_TYPES","JS_AND_ASSET_TYPES","DEFAULT_ENCODING","AssetGenerator","constructor","dataUrlOptions","filename","publicPath","outputPath","emit","getSourceFileName","module","runtimeTemplate","compilation","compiler","context","matchResource","resource","root","getConcatenationBailoutReason","undefined","getMimeType","mimeType","mimetype","ext","extname","nameForCondition","resourceResolveData","parameters","lookup","generate","_ref","runtime","concatenationScope","chunkGraph","runtimeRequirements","type","getData","originalSource","buildInfo","dataUrl","encodedSource","call","equals","data","JSON","stringify","assetModuleFilename","outputOptions","hash","hashFunction","hashSalt","update","fullHash","digest","hashDigest","contentHash","hashDigestLength","fullContentHash","sourceFilename","info","assetInfo","getAssetPathWithInfo","assetPath","concatenation","expr","posix","join","registerNamespaceExport","NAMESPACE_OBJECT_EXPORT","supportsConst","getTypes","getSize","size","updateHash","_ref2","ident","pathData","contentHashReplacement","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/asset/AssetGenerator.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst mimeTypes = require(\"mime-types\");\nconst path = require(\"path\");\nconst { RawSource } = require(\"webpack-sources\");\nconst ConcatenationScope = require(\"../ConcatenationScope\");\nconst Generator = require(\"../Generator\");\nconst { ASSET_MODULE_TYPE } = require(\"../ModuleTypeConstants\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst createHash = require(\"../util/createHash\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst nonNumericOnlyHash = require(\"../util/nonNumericOnlyHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetGeneratorOptions} AssetGeneratorOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").AssetModuleOutputPath} AssetModuleOutputPath */\n/** @typedef {import(\"../../declarations/WebpackOptions\").RawPublicPath} RawPublicPath */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"../Generator\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").ConcatenationBailoutReasonContext} ConcatenationBailoutReasonContext */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../util/Hash\")} Hash */\n\nconst mergeMaybeArrays = (a, b) => {\n\tconst set = new Set();\n\tif (Array.isArray(a)) for (const item of a) set.add(item);\n\telse set.add(a);\n\tif (Array.isArray(b)) for (const item of b) set.add(item);\n\telse set.add(b);\n\treturn Array.from(set);\n};\n\nconst mergeAssetInfo = (a, b) => {\n\tconst result = { ...a, ...b };\n\tfor (const key of Object.keys(a)) {\n\t\tif (key in b) {\n\t\t\tif (a[key] === b[key]) continue;\n\t\t\tswitch (key) {\n\t\t\t\tcase \"fullhash\":\n\t\t\t\tcase \"chunkhash\":\n\t\t\t\tcase \"modulehash\":\n\t\t\t\tcase \"contenthash\":\n\t\t\t\t\tresult[key] = mergeMaybeArrays(a[key], b[key]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"immutable\":\n\t\t\t\tcase \"development\":\n\t\t\t\tcase \"hotModuleReplacement\":\n\t\t\t\tcase \"javascriptModule\":\n\t\t\t\t\tresult[key] = a[key] || b[key];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"related\":\n\t\t\t\t\tresult[key] = mergeRelatedInfo(a[key], b[key]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Can't handle conflicting asset info for ${key}`);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n};\n\nconst mergeRelatedInfo = (a, b) => {\n\tconst result = { ...a, ...b };\n\tfor (const key of Object.keys(a)) {\n\t\tif (key in b) {\n\t\t\tif (a[key] === b[key]) continue;\n\t\t\tresult[key] = mergeMaybeArrays(a[key], b[key]);\n\t\t}\n\t}\n\treturn result;\n};\n\nconst encodeDataUri = (encoding, source) => {\n\tlet encodedContent;\n\n\tswitch (encoding) {\n\t\tcase \"base64\": {\n\t\t\tencodedContent = source.buffer().toString(\"base64\");\n\t\t\tbreak;\n\t\t}\n\t\tcase false: {\n\t\t\tconst content = source.source();\n\n\t\t\tif (typeof content !== \"string\") {\n\t\t\t\tencodedContent = content.toString(\"utf-8\");\n\t\t\t}\n\n\t\t\tencodedContent = encodeURIComponent(encodedContent).replace(\n\t\t\t\t/[!'()*]/g,\n\t\t\t\tcharacter => \"%\" + character.codePointAt(0).toString(16)\n\t\t\t);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported encoding '${encoding}'`);\n\t}\n\n\treturn encodedContent;\n};\n\nconst decodeDataUriContent = (encoding, content) => {\n\tconst isBase64 = encoding === \"base64\";\n\n\tif (isBase64) {\n\t\treturn Buffer.from(content, \"base64\");\n\t}\n\n\t// If we can't decode return the original body\n\ttry {\n\t\treturn Buffer.from(decodeURIComponent(content), \"ascii\");\n\t} catch (_) {\n\t\treturn Buffer.from(content, \"ascii\");\n\t}\n};\n\nconst JS_TYPES = new Set([\"javascript\"]);\nconst JS_AND_ASSET_TYPES = new Set([\"javascript\", ASSET_MODULE_TYPE]);\nconst DEFAULT_ENCODING = \"base64\";\n\nclass AssetGenerator extends Generator {\n\t/**\n\t * @param {AssetGeneratorOptions[\"dataUrl\"]=} dataUrlOptions the options for the data url\n\t * @param {string=} filename override for output.assetModuleFilename\n\t * @param {RawPublicPath=} publicPath override for output.assetModulePublicPath\n\t * @param {AssetModuleOutputPath=} outputPath the output path for the emitted file which is not included in the runtime import\n\t * @param {boolean=} emit generate output asset\n\t */\n\tconstructor(dataUrlOptions, filename, publicPath, outputPath, emit) {\n\t\tsuper();\n\t\tthis.dataUrlOptions = dataUrlOptions;\n\t\tthis.filename = filename;\n\t\tthis.publicPath = publicPath;\n\t\tthis.outputPath = outputPath;\n\t\tthis.emit = emit;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module\n\t * @param {RuntimeTemplate} runtimeTemplate runtime template\n\t * @returns {string} source file name\n\t */\n\tgetSourceFileName(module, runtimeTemplate) {\n\t\treturn makePathsRelative(\n\t\t\truntimeTemplate.compilation.compiler.context,\n\t\t\tmodule.matchResource || module.resource,\n\t\t\truntimeTemplate.compilation.compiler.root\n\t\t).replace(/^\\.\\//, \"\");\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the bailout reason should be determined\n\t * @param {ConcatenationBailoutReasonContext} context context\n\t * @returns {string | undefined} reason why this module can't be concatenated, undefined when it can be concatenated\n\t */\n\tgetConcatenationBailoutReason(module, context) {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module\n\t * @returns {string} mime type\n\t */\n\tgetMimeType(module) {\n\t\tif (typeof this.dataUrlOptions === \"function\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"This method must not be called when dataUrlOptions is a function\"\n\t\t\t);\n\t\t}\n\n\t\tlet mimeType = this.dataUrlOptions.mimetype;\n\t\tif (mimeType === undefined) {\n\t\t\tconst ext = path.extname(module.nameForCondition());\n\t\t\tif (\n\t\t\t\tmodule.resourceResolveData &&\n\t\t\t\tmodule.resourceResolveData.mimetype !== undefined\n\t\t\t) {\n\t\t\t\tmimeType =\n\t\t\t\t\tmodule.resourceResolveData.mimetype +\n\t\t\t\t\tmodule.resourceResolveData.parameters;\n\t\t\t} else if (ext) {\n\t\t\t\tmimeType = mimeTypes.lookup(ext);\n\n\t\t\t\tif (typeof mimeType !== \"string\") {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"DataUrl can't be generated automatically, \" +\n\t\t\t\t\t\t\t`because there is no mimetype for \"${ext}\" in mimetype database. ` +\n\t\t\t\t\t\t\t'Either pass a mimetype via \"generator.mimetype\" or ' +\n\t\t\t\t\t\t\t'use type: \"asset/resource\" to create a resource file instead of a DataUrl'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof mimeType !== \"string\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"DataUrl can't be generated automatically. \" +\n\t\t\t\t\t'Either pass a mimetype via \"generator.mimetype\" or ' +\n\t\t\t\t\t'use type: \"asset/resource\" to create a resource file instead of a DataUrl'\n\t\t\t);\n\t\t}\n\n\t\treturn mimeType;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {GenerateContext} generateContext context for generate\n\t * @returns {Source} generated code\n\t */\n\tgenerate(\n\t\tmodule,\n\t\t{\n\t\t\truntime,\n\t\t\tconcatenationScope,\n\t\t\tchunkGraph,\n\t\t\truntimeTemplate,\n\t\t\truntimeRequirements,\n\t\t\ttype,\n\t\t\tgetData\n\t\t}\n\t) {\n\t\tswitch (type) {\n\t\t\tcase ASSET_MODULE_TYPE:\n\t\t\t\treturn module.originalSource();\n\t\t\tdefault: {\n\t\t\t\tlet content;\n\t\t\t\tconst originalSource = module.originalSource();\n\t\t\t\tif (module.buildInfo.dataUrl) {\n\t\t\t\t\tlet encodedSource;\n\t\t\t\t\tif (typeof this.dataUrlOptions === \"function\") {\n\t\t\t\t\t\tencodedSource = this.dataUrlOptions.call(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\toriginalSource.source(),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfilename: module.matchResource || module.resource,\n\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/** @type {string | false | undefined} */\n\t\t\t\t\t\tlet encoding = this.dataUrlOptions.encoding;\n\t\t\t\t\t\tif (encoding === undefined) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tmodule.resourceResolveData &&\n\t\t\t\t\t\t\t\tmodule.resourceResolveData.encoding !== undefined\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tencoding = module.resourceResolveData.encoding;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoding === undefined) {\n\t\t\t\t\t\t\tencoding = DEFAULT_ENCODING;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst mimeType = this.getMimeType(module);\n\n\t\t\t\t\t\tlet encodedContent;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tmodule.resourceResolveData &&\n\t\t\t\t\t\t\tmodule.resourceResolveData.encoding === encoding &&\n\t\t\t\t\t\t\tdecodeDataUriContent(\n\t\t\t\t\t\t\t\tmodule.resourceResolveData.encoding,\n\t\t\t\t\t\t\t\tmodule.resourceResolveData.encodedContent\n\t\t\t\t\t\t\t).equals(originalSource.buffer())\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tencodedContent = module.resourceResolveData.encodedContent;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tencodedContent = encodeDataUri(encoding, originalSource);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tencodedSource = `data:${mimeType}${\n\t\t\t\t\t\t\tencoding ? `;${encoding}` : \"\"\n\t\t\t\t\t\t},${encodedContent}`;\n\t\t\t\t\t}\n\t\t\t\t\tconst data = getData();\n\t\t\t\t\tdata.set(\"url\", Buffer.from(encodedSource));\n\t\t\t\t\tcontent = JSON.stringify(encodedSource);\n\t\t\t\t} else {\n\t\t\t\t\tconst assetModuleFilename =\n\t\t\t\t\t\tthis.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n\t\t\t\t\tconst hash = createHash(runtimeTemplate.outputOptions.hashFunction);\n\t\t\t\t\tif (runtimeTemplate.outputOptions.hashSalt) {\n\t\t\t\t\t\thash.update(runtimeTemplate.outputOptions.hashSalt);\n\t\t\t\t\t}\n\t\t\t\t\thash.update(originalSource.buffer());\n\t\t\t\t\tconst fullHash = /** @type {string} */ (\n\t\t\t\t\t\thash.digest(runtimeTemplate.outputOptions.hashDigest)\n\t\t\t\t\t);\n\t\t\t\t\tconst contentHash = nonNumericOnlyHash(\n\t\t\t\t\t\tfullHash,\n\t\t\t\t\t\truntimeTemplate.outputOptions.hashDigestLength\n\t\t\t\t\t);\n\t\t\t\t\tmodule.buildInfo.fullContentHash = fullHash;\n\t\t\t\t\tconst sourceFilename = this.getSourceFileName(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntimeTemplate\n\t\t\t\t\t);\n\t\t\t\t\tlet { path: filename, info: assetInfo } =\n\t\t\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\t\t\tassetModuleFilename,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\tfilename: sourceFilename,\n\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\tcontentHash\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\tlet assetPath;\n\t\t\t\t\tif (this.publicPath !== undefined) {\n\t\t\t\t\t\tconst { path, info } =\n\t\t\t\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\t\t\t\tthis.publicPath,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tfilename: sourceFilename,\n\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\tcontentHash\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tassetInfo = mergeAssetInfo(assetInfo, info);\n\t\t\t\t\t\tassetPath = JSON.stringify(path + filename);\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.publicPath); // add __webpack_require__.p\n\t\t\t\t\t\tassetPath = runtimeTemplate.concatenation(\n\t\t\t\t\t\t\t{ expr: RuntimeGlobals.publicPath },\n\t\t\t\t\t\t\tfilename\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tassetInfo = {\n\t\t\t\t\t\tsourceFilename,\n\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t};\n\t\t\t\t\tif (this.outputPath) {\n\t\t\t\t\t\tconst { path: outputPath, info } =\n\t\t\t\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\t\t\t\tthis.outputPath,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tfilename: sourceFilename,\n\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\tcontentHash\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tassetInfo = mergeAssetInfo(assetInfo, info);\n\t\t\t\t\t\tfilename = path.posix.join(outputPath, filename);\n\t\t\t\t\t}\n\t\t\t\t\tmodule.buildInfo.filename = filename;\n\t\t\t\t\tmodule.buildInfo.assetInfo = assetInfo;\n\t\t\t\t\tif (getData) {\n\t\t\t\t\t\t// Due to code generation caching module.buildInfo.XXX can't used to store such information\n\t\t\t\t\t\t// It need to be stored in the code generation results instead, where it's cached too\n\t\t\t\t\t\t// TODO webpack 6 For back-compat reasons we also store in on module.buildInfo\n\t\t\t\t\t\tconst data = getData();\n\t\t\t\t\t\tdata.set(\"fullContentHash\", fullHash);\n\t\t\t\t\t\tdata.set(\"filename\", filename);\n\t\t\t\t\t\tdata.set(\"assetInfo\", assetInfo);\n\t\t\t\t\t}\n\t\t\t\t\tcontent = assetPath;\n\t\t\t\t}\n\n\t\t\t\tif (concatenationScope) {\n\t\t\t\t\tconcatenationScope.registerNamespaceExport(\n\t\t\t\t\t\tConcatenationScope.NAMESPACE_OBJECT_EXPORT\n\t\t\t\t\t);\n\t\t\t\t\treturn new RawSource(\n\t\t\t\t\t\t`${runtimeTemplate.supportsConst() ? \"const\" : \"var\"} ${\n\t\t\t\t\t\t\tConcatenationScope.NAMESPACE_OBJECT_EXPORT\n\t\t\t\t\t\t} = ${content};`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.module);\n\t\t\t\t\treturn new RawSource(\n\t\t\t\t\t\t`${RuntimeGlobals.module}.exports = ${content};`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {NormalModule} module fresh module\n\t * @returns {Set<string>} available types (do not mutate)\n\t */\n\tgetTypes(module) {\n\t\tif ((module.buildInfo && module.buildInfo.dataUrl) || this.emit === false) {\n\t\t\treturn JS_TYPES;\n\t\t} else {\n\t\t\treturn JS_AND_ASSET_TYPES;\n\t\t}\n\t}\n\n\t/**\n\t * @param {NormalModule} module the module\n\t * @param {string=} type source type\n\t * @returns {number} estimate size of the module\n\t */\n\tgetSize(module, type) {\n\t\tswitch (type) {\n\t\t\tcase ASSET_MODULE_TYPE: {\n\t\t\t\tconst originalSource = module.originalSource();\n\n\t\t\t\tif (!originalSource) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn originalSource.size();\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif (module.buildInfo && module.buildInfo.dataUrl) {\n\t\t\t\t\tconst originalSource = module.originalSource();\n\n\t\t\t\t\tif (!originalSource) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// roughly for data url\n\t\t\t\t\t// Example: m.exports=\"data:image/png;base64,ag82/f+2==\"\n\t\t\t\t\t// 4/3 = base64 encoding\n\t\t\t\t\t// 34 = ~ data url header + footer + rounding\n\t\t\t\t\treturn originalSource.size() * 1.34 + 36;\n\t\t\t\t} else {\n\t\t\t\t\t// it's only estimated so this number is probably fine\n\t\t\t\t\t// Example: m.exports=r.p+\"0123456789012345678901.ext\"\n\t\t\t\t\treturn 42;\n\t\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Hash} hash hash that will be modified\n\t * @param {UpdateHashContext} updateHashContext context for updating hash\n\t */\n\tupdateHash(hash, { module, runtime, runtimeTemplate, chunkGraph }) {\n\t\tif (module.buildInfo.dataUrl) {\n\t\t\thash.update(\"data-url\");\n\t\t\t// this.dataUrlOptions as function should be pure and only depend on input source and filename\n\t\t\t// therefore it doesn't need to be hashed\n\t\t\tif (typeof this.dataUrlOptions === \"function\") {\n\t\t\t\tconst ident = /** @type {{ ident?: string }} */ (this.dataUrlOptions)\n\t\t\t\t\t.ident;\n\t\t\t\tif (ident) hash.update(ident);\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tthis.dataUrlOptions.encoding &&\n\t\t\t\t\tthis.dataUrlOptions.encoding !== DEFAULT_ENCODING\n\t\t\t\t) {\n\t\t\t\t\thash.update(this.dataUrlOptions.encoding);\n\t\t\t\t}\n\t\t\t\tif (this.dataUrlOptions.mimetype)\n\t\t\t\t\thash.update(this.dataUrlOptions.mimetype);\n\t\t\t\t// computed mimetype depends only on module filename which is already part of the hash\n\t\t\t}\n\t\t} else {\n\t\t\thash.update(\"resource\");\n\n\t\t\tconst pathData = {\n\t\t\t\tmodule,\n\t\t\t\truntime,\n\t\t\t\tfilename: this.getSourceFileName(module, runtimeTemplate),\n\t\t\t\tchunkGraph,\n\t\t\t\tcontentHash: runtimeTemplate.contentHashReplacement\n\t\t\t};\n\n\t\t\tif (typeof this.publicPath === \"function\") {\n\t\t\t\thash.update(\"path\");\n\t\t\t\tconst assetInfo = {};\n\t\t\t\thash.update(this.publicPath(pathData, assetInfo));\n\t\t\t\thash.update(JSON.stringify(assetInfo));\n\t\t\t} else if (this.publicPath) {\n\t\t\t\thash.update(\"path\");\n\t\t\t\thash.update(this.publicPath);\n\t\t\t} else {\n\t\t\t\thash.update(\"no-path\");\n\t\t\t}\n\n\t\t\tconst assetModuleFilename =\n\t\t\t\tthis.filename || runtimeTemplate.outputOptions.assetModuleFilename;\n\t\t\tconst { path: filename, info } =\n\t\t\t\truntimeTemplate.compilation.getAssetPathWithInfo(\n\t\t\t\t\tassetModuleFilename,\n\t\t\t\t\tpathData\n\t\t\t\t);\n\t\t\thash.update(filename);\n\t\t\thash.update(JSON.stringify(info));\n\t\t}\n\t}\n}\n\nmodule.exports = AssetGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}