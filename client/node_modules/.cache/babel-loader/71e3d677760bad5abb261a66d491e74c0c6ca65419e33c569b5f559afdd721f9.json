{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {(string|number|undefined|[])[]} SemVerRange */\n\n/**\n * @param {string} str version string\n * @returns {(string|number|undefined|[])[]} parsed version\n */\nconst parseVersion = str => {\n  var splitAndConvert = function (str) {\n    return str.split(\".\").map(function (item) {\n      // eslint-disable-next-line eqeqeq\n      return +item == item ? +item : item;\n    });\n  };\n  var match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n  /** @type {(string|number|undefined|[])[]} */\n  var ver = match[1] ? splitAndConvert(match[1]) : [];\n  if (match[2]) {\n    ver.length++;\n    ver.push.apply(ver, splitAndConvert(match[2]));\n  }\n  if (match[3]) {\n    ver.push([]);\n    ver.push.apply(ver, splitAndConvert(match[3]));\n  }\n  return ver;\n};\nexports.parseVersion = parseVersion;\n\n/* eslint-disable eqeqeq */\n/**\n * @param {string} a version\n * @param {string} b version\n * @returns {boolean} true, iff a < b\n */\nconst versionLt = (a, b) => {\n  // @ts-expect-error\n  a = parseVersion(a);\n  // @ts-expect-error\n  b = parseVersion(b);\n  var i = 0;\n  for (;;) {\n    // a       b  EOA     object  undefined  number  string\n    // EOA        a == b  a < b   b < a      a < b   a < b\n    // object     b < a   (0)     b < a      a < b   a < b\n    // undefined  a < b   a < b   (0)        a < b   a < b\n    // number     b < a   b < a   b < a      (1)     a < b\n    // string     b < a   b < a   b < a      b < a   (1)\n    // EOA end of array\n    // (0) continue on\n    // (1) compare them via \"<\"\n\n    // Handles first row in table\n    if (i >= a.length) return i < b.length && (typeof b[i])[0] != \"u\";\n    var aValue = a[i];\n    var aType = (typeof aValue)[0];\n\n    // Handles first column in table\n    if (i >= b.length) return aType == \"u\";\n    var bValue = b[i];\n    var bType = (typeof bValue)[0];\n    if (aType == bType) {\n      if (aType != \"o\" && aType != \"u\" && aValue != bValue) {\n        return aValue < bValue;\n      }\n      i++;\n    } else {\n      // Handles remaining cases\n      if (aType == \"o\" && bType == \"n\") return true;\n      return bType == \"s\" || aType == \"u\";\n    }\n  }\n};\n/* eslint-enable eqeqeq */\nexports.versionLt = versionLt;\n\n/**\n * @param {string} str range string\n * @returns {SemVerRange} parsed range\n */\nexports.parseRange = str => {\n  const splitAndConvert = str => {\n    return str.split(\".\").map(item => item !== \"NaN\" && `${+item}` === item ? +item : item);\n  };\n  // see https://docs.npmjs.com/misc/semver#range-grammar for grammar\n  const parsePartial = str => {\n    const match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n    /** @type {(string|number|undefined|[])[]} */\n    const ver = match[1] ? [0, ...splitAndConvert(match[1])] : [0];\n    if (match[2]) {\n      ver.length++;\n      ver.push.apply(ver, splitAndConvert(match[2]));\n    }\n\n    // remove trailing any matchers\n    let last = ver[ver.length - 1];\n    while (ver.length && (last === undefined || /^[*xX]$/.test( /** @type {string} */last))) {\n      ver.pop();\n      last = ver[ver.length - 1];\n    }\n    return ver;\n  };\n  const toFixed = range => {\n    if (range.length === 1) {\n      // Special case for \"*\" is \"x.x.x\" instead of \"=\"\n      return [0];\n    } else if (range.length === 2) {\n      // Special case for \"1\" is \"1.x.x\" instead of \"=1\"\n      return [1, ...range.slice(1)];\n    } else if (range.length === 3) {\n      // Special case for \"1.2\" is \"1.2.x\" instead of \"=1.2\"\n      return [2, ...range.slice(1)];\n    } else {\n      return [range.length, ...range.slice(1)];\n    }\n  };\n  const negate = range => {\n    return [-range[0] - 1, ...range.slice(1)];\n  };\n  const parseSimple = str => {\n    // simple       ::= primitive | partial | tilde | caret\n    // primitive    ::= ( '<' | '>' | '>=' | '<=' | '=' | '!' ) ( ' ' ) * partial\n    // tilde        ::= '~' ( ' ' ) * partial\n    // caret        ::= '^' ( ' ' ) * partial\n    const match = /^(\\^|~|<=|<|>=|>|=|v|!)/.exec(str);\n    const start = match ? match[0] : \"\";\n    const remainder = parsePartial(start.length ? str.slice(start.length).trim() : str.trim());\n    switch (start) {\n      case \"^\":\n        if (remainder.length > 1 && remainder[1] === 0) {\n          if (remainder.length > 2 && remainder[2] === 0) {\n            return [3, ...remainder.slice(1)];\n          }\n          return [2, ...remainder.slice(1)];\n        }\n        return [1, ...remainder.slice(1)];\n      case \"~\":\n        return [2, ...remainder.slice(1)];\n      case \">=\":\n        return remainder;\n      case \"=\":\n      case \"v\":\n      case \"\":\n        return toFixed(remainder);\n      case \"<\":\n        return negate(remainder);\n      case \">\":\n        {\n          // and( >=, not( = ) ) => >=, =, not, and\n          const fixed = toFixed(remainder);\n          // eslint-disable-next-line no-sparse-arrays\n          return [, fixed, 0, remainder, 2];\n        }\n      case \"<=\":\n        // or( <, = ) => <, =, or\n        // eslint-disable-next-line no-sparse-arrays\n        return [, toFixed(remainder), negate(remainder), 1];\n      case \"!\":\n        {\n          // not =\n          const fixed = toFixed(remainder);\n          // eslint-disable-next-line no-sparse-arrays\n          return [, fixed, 0];\n        }\n      default:\n        throw new Error(\"Unexpected start value\");\n    }\n  };\n  const combine = (items, fn) => {\n    if (items.length === 1) return items[0];\n    const arr = [];\n    for (const item of items.slice().reverse()) {\n      if (0 in item) {\n        arr.push(item);\n      } else {\n        arr.push(...item.slice(1));\n      }\n    }\n    // eslint-disable-next-line no-sparse-arrays\n    return [, ...arr, ...items.slice(1).map(() => fn)];\n  };\n  const parseRange = str => {\n    // range      ::= hyphen | simple ( ' ' ( ' ' ) * simple ) * | ''\n    // hyphen     ::= partial ( ' ' ) * ' - ' ( ' ' ) * partial\n    const items = str.split(/\\s+-\\s+/);\n    if (items.length === 1) {\n      const items = str.trim().split(/(?<=[-0-9A-Za-z])\\s+/g).map(parseSimple);\n      return combine(items, 2);\n    }\n    const a = parsePartial(items[0]);\n    const b = parsePartial(items[1]);\n    // >=a <=b => and( >=a, or( <b, =b ) ) => >=a, <b, =b, or, and\n    // eslint-disable-next-line no-sparse-arrays\n    return [, toFixed(b), negate(b), 1, a, 2];\n  };\n  const parseLogicalOr = str => {\n    // range-set  ::= range ( logical-or range ) *\n    // logical-or ::= ( ' ' ) * '||' ( ' ' ) *\n    const items = str.split(/\\s*\\|\\|\\s*/).map(parseRange);\n    return combine(items, 1);\n  };\n  return parseLogicalOr(str);\n};\n\n/* eslint-disable eqeqeq */\nconst rangeToString = range => {\n  var fixCount = range[0];\n  var str = \"\";\n  if (range.length === 1) {\n    return \"*\";\n  } else if (fixCount + 0.5) {\n    str += fixCount == 0 ? \">=\" : fixCount == -1 ? \"<\" : fixCount == 1 ? \"^\" : fixCount == 2 ? \"~\" : fixCount > 0 ? \"=\" : \"!=\";\n    var needDot = 1;\n    // eslint-disable-next-line no-redeclare\n    for (var i = 1; i < range.length; i++) {\n      var item = range[i];\n      var t = (typeof item)[0];\n      needDot--;\n      str += t == \"u\" ?\n      // undefined: prerelease marker, add an \"-\"\n      \"-\" :\n      // number or string: add the item, set flag to add an \".\" between two of them\n      (needDot > 0 ? \".\" : \"\") + (needDot = 2, item);\n    }\n    return str;\n  } else {\n    var stack = [];\n    // eslint-disable-next-line no-redeclare\n    for (var i = 1; i < range.length; i++) {\n      // eslint-disable-next-line no-redeclare\n      var item = range[i];\n      stack.push(item === 0 ? \"not(\" + pop() + \")\" : item === 1 ? \"(\" + pop() + \" || \" + pop() + \")\" : item === 2 ? stack.pop() + \" \" + stack.pop() : rangeToString(item));\n    }\n    return pop();\n  }\n  function pop() {\n    return stack.pop().replace(/^\\((.+)\\)$/, \"$1\");\n  }\n};\n/* eslint-enable eqeqeq */\nexports.rangeToString = rangeToString;\n\n/* eslint-disable eqeqeq */\n/**\n * @param {SemVerRange} range version range\n * @param {string} version the version\n * @returns {boolean} if version satisfy the range\n */\nconst satisfy = (range, version) => {\n  if (0 in range) {\n    // @ts-expect-error\n    version = parseVersion(version);\n    var fixCount = /** @type {number} */range[0];\n    // when negated is set it swill set for < instead of >=\n    var negated = fixCount < 0;\n    if (negated) fixCount = -fixCount - 1;\n    for (var i = 0, j = 1, isEqual = true;; j++, i++) {\n      // cspell:word nequal nequ\n\n      // when isEqual = true:\n      // range         version: EOA/object  undefined  number    string\n      // EOA                    equal       block      big-ver   big-ver\n      // undefined              bigger      next       big-ver   big-ver\n      // number                 smaller     block      cmp       big-cmp\n      // fixed number           smaller     block      cmp-fix   differ\n      // string                 smaller     block      differ    cmp\n      // fixed string           smaller     block      small-cmp cmp-fix\n\n      // when isEqual = false:\n      // range         version: EOA/object  undefined  number    string\n      // EOA                    nequal      block      next-ver  next-ver\n      // undefined              nequal      block      next-ver  next-ver\n      // number                 nequal      block      next      next\n      // fixed number           nequal      block      next      next   (this never happens)\n      // string                 nequal      block      next      next\n      // fixed string           nequal      block      next      next   (this never happens)\n\n      // EOA end of array\n      // equal (version is equal range):\n      //   when !negated: return true,\n      //   when negated: return false\n      // bigger (version is bigger as range):\n      //   when fixed: return false,\n      //   when !negated: return true,\n      //   when negated: return false,\n      // smaller (version is smaller as range):\n      //   when !negated: return false,\n      //   when negated: return true\n      // nequal (version is not equal range (> resp <)): return true\n      // block (version is in different prerelease area): return false\n      // differ (version is different from fixed range (string vs. number)): return false\n      // next: continues to the next items\n      // next-ver: when fixed: return false, continues to the next item only for the version, sets isEqual=false\n      // big-ver: when fixed || negated: return false, continues to the next item only for the version, sets isEqual=false\n      // next-nequ: continues to the next items, sets isEqual=false\n      // cmp (negated === false): version < range => return false, version > range => next-nequ, else => next\n      // cmp (negated === true): version > range => return false, version < range => next-nequ, else => next\n      // cmp-fix: version == range => next, else => return false\n      // big-cmp: when negated => return false, else => next-nequ\n      // small-cmp: when negated => next-nequ, else => return false\n\n      var rangeType = j < range.length ? (typeof range[j])[0] : \"\";\n      var versionValue;\n      var versionType;\n\n      // Handles first column in both tables (end of version or object)\n      if (i >= version.length || (versionValue = version[i], (versionType = (typeof versionValue)[0]) == \"o\")) {\n        // Handles nequal\n        if (!isEqual) return true;\n        // Handles bigger\n        if (rangeType == \"u\") return j > fixCount && !negated;\n        // Handles equal and smaller: (range === EOA) XOR negated\n        return rangeType == \"\" != negated; // equal + smaller\n      }\n\n      // Handles second column in both tables (version = undefined)\n      if (versionType == \"u\") {\n        if (!isEqual || rangeType != \"u\") {\n          return false;\n        }\n      }\n\n      // switch between first and second table\n      else if (isEqual) {\n        // Handle diagonal\n        if (rangeType == versionType) {\n          if (j <= fixCount) {\n            // Handles \"cmp-fix\" cases\n            if (versionValue != range[j]) {\n              return false;\n            }\n          } else {\n            // Handles \"cmp\" cases\n            if (negated ? versionValue > range[j] : versionValue < range[j]) {\n              return false;\n            }\n            if (versionValue != range[j]) isEqual = false;\n          }\n        }\n\n        // Handle big-ver\n        else if (rangeType != \"s\" && rangeType != \"n\") {\n          if (negated || j <= fixCount) return false;\n          isEqual = false;\n          j--;\n        }\n\n        // Handle differ, big-cmp and small-cmp\n        else if (j <= fixCount || versionType < rangeType != negated) {\n          return false;\n        } else {\n          isEqual = false;\n        }\n      } else {\n        // Handles all \"next-ver\" cases in the second table\n        if (rangeType != \"s\" && rangeType != \"n\") {\n          isEqual = false;\n          j--;\n        }\n\n        // next is applied by default\n      }\n    }\n  }\n  /** @type {(boolean | number)[]} */\n  var stack = [];\n  var p = stack.pop.bind(stack);\n  // eslint-disable-next-line no-redeclare\n  for (var i = 1; i < range.length; i++) {\n    var item = /** @type {SemVerRange | 0 | 1 | 2} */range[i];\n    stack.push(item == 1 ? p() | p() : item == 2 ? p() & p() : item ? satisfy(item, version) : !p());\n  }\n  return !!p();\n};\n/* eslint-enable eqeqeq */\nexports.satisfy = satisfy;\nexports.stringifyHoley = json => {\n  switch (typeof json) {\n    case \"undefined\":\n      return \"\";\n    case \"object\":\n      if (Array.isArray(json)) {\n        let str = \"[\";\n        for (let i = 0; i < json.length; i++) {\n          if (i !== 0) str += \",\";\n          str += this.stringifyHoley(json[i]);\n        }\n        str += \"]\";\n        return str;\n      } else {\n        return JSON.stringify(json);\n      }\n    default:\n      return JSON.stringify(json);\n  }\n};\n\n//#region runtime code: parseVersion\nexports.parseVersionRuntimeCode = runtimeTemplate => `var parseVersion = ${runtimeTemplate.basicFunction(\"str\", [\"// see webpack/lib/util/semver.js for original code\", `var p=${runtimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"}{return p.split(\".\").map((${runtimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"}{return+p==p?+p:p}))},n=/^([^-+]+)?(?:-([^+]+))?(?:\\\\+(.+))?$/.exec(str),r=n[1]?p(n[1]):[];return n[2]&&(r.length++,r.push.apply(r,p(n[2]))),n[3]&&(r.push([]),r.push.apply(r,p(n[3]))),r;`])}`;\n//#endregion\n\n//#region runtime code: versionLt\nexports.versionLtRuntimeCode = runtimeTemplate => `var versionLt = ${runtimeTemplate.basicFunction(\"a, b\", [\"// see webpack/lib/util/semver.js for original code\", 'a=parseVersion(a),b=parseVersion(b);for(var r=0;;){if(r>=a.length)return r<b.length&&\"u\"!=(typeof b[r])[0];var e=a[r],n=(typeof e)[0];if(r>=b.length)return\"u\"==n;var t=b[r],f=(typeof t)[0];if(n!=f)return\"o\"==n&&\"n\"==f||(\"s\"==f||\"u\"==n);if(\"o\"!=n&&\"u\"!=n&&e!=t)return e<t;r++}'])}`;\n//#endregion\n\n//#region runtime code: rangeToString\nexports.rangeToStringRuntimeCode = runtimeTemplate => `var rangeToString = ${runtimeTemplate.basicFunction(\"range\", [\"// see webpack/lib/util/semver.js for original code\", 'var r=range[0],n=\"\";if(1===range.length)return\"*\";if(r+.5){n+=0==r?\">=\":-1==r?\"<\":1==r?\"^\":2==r?\"~\":r>0?\"=\":\"!=\";for(var e=1,a=1;a<range.length;a++){e--,n+=\"u\"==(typeof(t=range[a]))[0]?\"-\":(e>0?\".\":\"\")+(e=2,t)}return n}var g=[];for(a=1;a<range.length;a++){var t=range[a];g.push(0===t?\"not(\"+o()+\")\":1===t?\"(\"+o()+\" || \"+o()+\")\":2===t?g.pop()+\" \"+g.pop():rangeToString(t))}return o();function o(){return g.pop().replace(/^\\\\((.+)\\\\)$/,\"$1\")}'])}`;\n//#endregion\n\n//#region runtime code: satisfy\nexports.satisfyRuntimeCode = runtimeTemplate => `var satisfy = ${runtimeTemplate.basicFunction(\"range, version\", [\"// see webpack/lib/util/semver.js for original code\", 'if(0 in range){version=parseVersion(version);var e=range[0],r=e<0;r&&(e=-e-1);for(var n=0,i=1,a=!0;;i++,n++){var f,s,g=i<range.length?(typeof range[i])[0]:\"\";if(n>=version.length||\"o\"==(s=(typeof(f=version[n]))[0]))return!a||(\"u\"==g?i>e&&!r:\"\"==g!=r);if(\"u\"==s){if(!a||\"u\"!=g)return!1}else if(a)if(g==s)if(i<=e){if(f!=range[i])return!1}else{if(r?f>range[i]:f<range[i])return!1;f!=range[i]&&(a=!1)}else if(\"s\"!=g&&\"n\"!=g){if(r||i<=e)return!1;a=!1,i--}else{if(i<=e||s<g!=r)return!1;a=!1}else\"s\"!=g&&\"n\"!=g&&(a=!1,i--)}}var t=[],o=t.pop.bind(t);for(n=1;n<range.length;n++){var u=range[n];t.push(1==u?o()|o():2==u?o()&o():u?satisfy(u,version):!o())}return!!o();'])}`;\n//#endregion","map":{"version":3,"names":["parseVersion","str","splitAndConvert","split","map","item","match","exec","ver","length","push","apply","exports","versionLt","a","b","i","aValue","aType","bValue","bType","parseRange","parsePartial","last","undefined","test","pop","toFixed","range","slice","negate","parseSimple","start","remainder","trim","fixed","Error","combine","items","fn","arr","reverse","parseLogicalOr","rangeToString","fixCount","needDot","t","stack","replace","satisfy","version","negated","j","isEqual","rangeType","versionValue","versionType","p","bind","stringifyHoley","json","Array","isArray","JSON","stringify","parseVersionRuntimeCode","runtimeTemplate","basicFunction","supportsArrowFunction","versionLtRuntimeCode","rangeToStringRuntimeCode","satisfyRuntimeCode"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/semver.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {(string|number|undefined|[])[]} SemVerRange */\n\n/**\n * @param {string} str version string\n * @returns {(string|number|undefined|[])[]} parsed version\n */\nconst parseVersion = str => {\n\tvar splitAndConvert = function (str) {\n\t\treturn str.split(\".\").map(function (item) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn +item == item ? +item : item;\n\t\t});\n\t};\n\tvar match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n\t/** @type {(string|number|undefined|[])[]} */\n\tvar ver = match[1] ? splitAndConvert(match[1]) : [];\n\tif (match[2]) {\n\t\tver.length++;\n\t\tver.push.apply(ver, splitAndConvert(match[2]));\n\t}\n\tif (match[3]) {\n\t\tver.push([]);\n\t\tver.push.apply(ver, splitAndConvert(match[3]));\n\t}\n\treturn ver;\n};\nexports.parseVersion = parseVersion;\n\n/* eslint-disable eqeqeq */\n/**\n * @param {string} a version\n * @param {string} b version\n * @returns {boolean} true, iff a < b\n */\nconst versionLt = (a, b) => {\n\t// @ts-expect-error\n\ta = parseVersion(a);\n\t// @ts-expect-error\n\tb = parseVersion(b);\n\tvar i = 0;\n\tfor (;;) {\n\t\t// a       b  EOA     object  undefined  number  string\n\t\t// EOA        a == b  a < b   b < a      a < b   a < b\n\t\t// object     b < a   (0)     b < a      a < b   a < b\n\t\t// undefined  a < b   a < b   (0)        a < b   a < b\n\t\t// number     b < a   b < a   b < a      (1)     a < b\n\t\t// string     b < a   b < a   b < a      b < a   (1)\n\t\t// EOA end of array\n\t\t// (0) continue on\n\t\t// (1) compare them via \"<\"\n\n\t\t// Handles first row in table\n\t\tif (i >= a.length) return i < b.length && (typeof b[i])[0] != \"u\";\n\n\t\tvar aValue = a[i];\n\t\tvar aType = (typeof aValue)[0];\n\n\t\t// Handles first column in table\n\t\tif (i >= b.length) return aType == \"u\";\n\n\t\tvar bValue = b[i];\n\t\tvar bType = (typeof bValue)[0];\n\n\t\tif (aType == bType) {\n\t\t\tif (aType != \"o\" && aType != \"u\" && aValue != bValue) {\n\t\t\t\treturn aValue < bValue;\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\t// Handles remaining cases\n\t\t\tif (aType == \"o\" && bType == \"n\") return true;\n\t\t\treturn bType == \"s\" || aType == \"u\";\n\t\t}\n\t}\n};\n/* eslint-enable eqeqeq */\nexports.versionLt = versionLt;\n\n/**\n * @param {string} str range string\n * @returns {SemVerRange} parsed range\n */\nexports.parseRange = str => {\n\tconst splitAndConvert = str => {\n\t\treturn str\n\t\t\t.split(\".\")\n\t\t\t.map(item => (item !== \"NaN\" && `${+item}` === item ? +item : item));\n\t};\n\t// see https://docs.npmjs.com/misc/semver#range-grammar for grammar\n\tconst parsePartial = str => {\n\t\tconst match = /^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str);\n\t\t/** @type {(string|number|undefined|[])[]} */\n\t\tconst ver = match[1] ? [0, ...splitAndConvert(match[1])] : [0];\n\t\tif (match[2]) {\n\t\t\tver.length++;\n\t\t\tver.push.apply(ver, splitAndConvert(match[2]));\n\t\t}\n\n\t\t// remove trailing any matchers\n\t\tlet last = ver[ver.length - 1];\n\t\twhile (\n\t\t\tver.length &&\n\t\t\t(last === undefined || /^[*xX]$/.test(/** @type {string} */ (last)))\n\t\t) {\n\t\t\tver.pop();\n\t\t\tlast = ver[ver.length - 1];\n\t\t}\n\n\t\treturn ver;\n\t};\n\tconst toFixed = range => {\n\t\tif (range.length === 1) {\n\t\t\t// Special case for \"*\" is \"x.x.x\" instead of \"=\"\n\t\t\treturn [0];\n\t\t} else if (range.length === 2) {\n\t\t\t// Special case for \"1\" is \"1.x.x\" instead of \"=1\"\n\t\t\treturn [1, ...range.slice(1)];\n\t\t} else if (range.length === 3) {\n\t\t\t// Special case for \"1.2\" is \"1.2.x\" instead of \"=1.2\"\n\t\t\treturn [2, ...range.slice(1)];\n\t\t} else {\n\t\t\treturn [range.length, ...range.slice(1)];\n\t\t}\n\t};\n\tconst negate = range => {\n\t\treturn [-range[0] - 1, ...range.slice(1)];\n\t};\n\tconst parseSimple = str => {\n\t\t// simple       ::= primitive | partial | tilde | caret\n\t\t// primitive    ::= ( '<' | '>' | '>=' | '<=' | '=' | '!' ) ( ' ' ) * partial\n\t\t// tilde        ::= '~' ( ' ' ) * partial\n\t\t// caret        ::= '^' ( ' ' ) * partial\n\t\tconst match = /^(\\^|~|<=|<|>=|>|=|v|!)/.exec(str);\n\t\tconst start = match ? match[0] : \"\";\n\t\tconst remainder = parsePartial(\n\t\t\tstart.length ? str.slice(start.length).trim() : str.trim()\n\t\t);\n\t\tswitch (start) {\n\t\t\tcase \"^\":\n\t\t\t\tif (remainder.length > 1 && remainder[1] === 0) {\n\t\t\t\t\tif (remainder.length > 2 && remainder[2] === 0) {\n\t\t\t\t\t\treturn [3, ...remainder.slice(1)];\n\t\t\t\t\t}\n\t\t\t\t\treturn [2, ...remainder.slice(1)];\n\t\t\t\t}\n\t\t\t\treturn [1, ...remainder.slice(1)];\n\t\t\tcase \"~\":\n\t\t\t\treturn [2, ...remainder.slice(1)];\n\t\t\tcase \">=\":\n\t\t\t\treturn remainder;\n\t\t\tcase \"=\":\n\t\t\tcase \"v\":\n\t\t\tcase \"\":\n\t\t\t\treturn toFixed(remainder);\n\t\t\tcase \"<\":\n\t\t\t\treturn negate(remainder);\n\t\t\tcase \">\": {\n\t\t\t\t// and( >=, not( = ) ) => >=, =, not, and\n\t\t\t\tconst fixed = toFixed(remainder);\n\t\t\t\t// eslint-disable-next-line no-sparse-arrays\n\t\t\t\treturn [, fixed, 0, remainder, 2];\n\t\t\t}\n\t\t\tcase \"<=\":\n\t\t\t\t// or( <, = ) => <, =, or\n\t\t\t\t// eslint-disable-next-line no-sparse-arrays\n\t\t\t\treturn [, toFixed(remainder), negate(remainder), 1];\n\t\t\tcase \"!\": {\n\t\t\t\t// not =\n\t\t\t\tconst fixed = toFixed(remainder);\n\t\t\t\t// eslint-disable-next-line no-sparse-arrays\n\t\t\t\treturn [, fixed, 0];\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unexpected start value\");\n\t\t}\n\t};\n\tconst combine = (items, fn) => {\n\t\tif (items.length === 1) return items[0];\n\t\tconst arr = [];\n\t\tfor (const item of items.slice().reverse()) {\n\t\t\tif (0 in item) {\n\t\t\t\tarr.push(item);\n\t\t\t} else {\n\t\t\t\tarr.push(...item.slice(1));\n\t\t\t}\n\t\t}\n\t\t// eslint-disable-next-line no-sparse-arrays\n\t\treturn [, ...arr, ...items.slice(1).map(() => fn)];\n\t};\n\tconst parseRange = str => {\n\t\t// range      ::= hyphen | simple ( ' ' ( ' ' ) * simple ) * | ''\n\t\t// hyphen     ::= partial ( ' ' ) * ' - ' ( ' ' ) * partial\n\t\tconst items = str.split(/\\s+-\\s+/);\n\t\tif (items.length === 1) {\n\t\t\tconst items = str\n\t\t\t\t.trim()\n\t\t\t\t.split(/(?<=[-0-9A-Za-z])\\s+/g)\n\t\t\t\t.map(parseSimple);\n\t\t\treturn combine(items, 2);\n\t\t}\n\t\tconst a = parsePartial(items[0]);\n\t\tconst b = parsePartial(items[1]);\n\t\t// >=a <=b => and( >=a, or( <b, =b ) ) => >=a, <b, =b, or, and\n\t\t// eslint-disable-next-line no-sparse-arrays\n\t\treturn [, toFixed(b), negate(b), 1, a, 2];\n\t};\n\tconst parseLogicalOr = str => {\n\t\t// range-set  ::= range ( logical-or range ) *\n\t\t// logical-or ::= ( ' ' ) * '||' ( ' ' ) *\n\t\tconst items = str.split(/\\s*\\|\\|\\s*/).map(parseRange);\n\t\treturn combine(items, 1);\n\t};\n\treturn parseLogicalOr(str);\n};\n\n/* eslint-disable eqeqeq */\nconst rangeToString = range => {\n\tvar fixCount = range[0];\n\tvar str = \"\";\n\tif (range.length === 1) {\n\t\treturn \"*\";\n\t} else if (fixCount + 0.5) {\n\t\tstr +=\n\t\t\tfixCount == 0\n\t\t\t\t? \">=\"\n\t\t\t\t: fixCount == -1\n\t\t\t\t? \"<\"\n\t\t\t\t: fixCount == 1\n\t\t\t\t? \"^\"\n\t\t\t\t: fixCount == 2\n\t\t\t\t? \"~\"\n\t\t\t\t: fixCount > 0\n\t\t\t\t? \"=\"\n\t\t\t\t: \"!=\";\n\t\tvar needDot = 1;\n\t\t// eslint-disable-next-line no-redeclare\n\t\tfor (var i = 1; i < range.length; i++) {\n\t\t\tvar item = range[i];\n\t\t\tvar t = (typeof item)[0];\n\t\t\tneedDot--;\n\t\t\tstr +=\n\t\t\t\tt == \"u\"\n\t\t\t\t\t? // undefined: prerelease marker, add an \"-\"\n\t\t\t\t\t  \"-\"\n\t\t\t\t\t: // number or string: add the item, set flag to add an \".\" between two of them\n\t\t\t\t\t  (needDot > 0 ? \".\" : \"\") + ((needDot = 2), item);\n\t\t}\n\t\treturn str;\n\t} else {\n\t\tvar stack = [];\n\t\t// eslint-disable-next-line no-redeclare\n\t\tfor (var i = 1; i < range.length; i++) {\n\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\tvar item = range[i];\n\t\t\tstack.push(\n\t\t\t\titem === 0\n\t\t\t\t\t? \"not(\" + pop() + \")\"\n\t\t\t\t\t: item === 1\n\t\t\t\t\t? \"(\" + pop() + \" || \" + pop() + \")\"\n\t\t\t\t\t: item === 2\n\t\t\t\t\t? stack.pop() + \" \" + stack.pop()\n\t\t\t\t\t: rangeToString(item)\n\t\t\t);\n\t\t}\n\t\treturn pop();\n\t}\n\tfunction pop() {\n\t\treturn stack.pop().replace(/^\\((.+)\\)$/, \"$1\");\n\t}\n};\n/* eslint-enable eqeqeq */\nexports.rangeToString = rangeToString;\n\n/* eslint-disable eqeqeq */\n/**\n * @param {SemVerRange} range version range\n * @param {string} version the version\n * @returns {boolean} if version satisfy the range\n */\nconst satisfy = (range, version) => {\n\tif (0 in range) {\n\t\t// @ts-expect-error\n\t\tversion = parseVersion(version);\n\t\tvar fixCount = /** @type {number} */ (range[0]);\n\t\t// when negated is set it swill set for < instead of >=\n\t\tvar negated = fixCount < 0;\n\t\tif (negated) fixCount = -fixCount - 1;\n\t\tfor (var i = 0, j = 1, isEqual = true; ; j++, i++) {\n\t\t\t// cspell:word nequal nequ\n\n\t\t\t// when isEqual = true:\n\t\t\t// range         version: EOA/object  undefined  number    string\n\t\t\t// EOA                    equal       block      big-ver   big-ver\n\t\t\t// undefined              bigger      next       big-ver   big-ver\n\t\t\t// number                 smaller     block      cmp       big-cmp\n\t\t\t// fixed number           smaller     block      cmp-fix   differ\n\t\t\t// string                 smaller     block      differ    cmp\n\t\t\t// fixed string           smaller     block      small-cmp cmp-fix\n\n\t\t\t// when isEqual = false:\n\t\t\t// range         version: EOA/object  undefined  number    string\n\t\t\t// EOA                    nequal      block      next-ver  next-ver\n\t\t\t// undefined              nequal      block      next-ver  next-ver\n\t\t\t// number                 nequal      block      next      next\n\t\t\t// fixed number           nequal      block      next      next   (this never happens)\n\t\t\t// string                 nequal      block      next      next\n\t\t\t// fixed string           nequal      block      next      next   (this never happens)\n\n\t\t\t// EOA end of array\n\t\t\t// equal (version is equal range):\n\t\t\t//   when !negated: return true,\n\t\t\t//   when negated: return false\n\t\t\t// bigger (version is bigger as range):\n\t\t\t//   when fixed: return false,\n\t\t\t//   when !negated: return true,\n\t\t\t//   when negated: return false,\n\t\t\t// smaller (version is smaller as range):\n\t\t\t//   when !negated: return false,\n\t\t\t//   when negated: return true\n\t\t\t// nequal (version is not equal range (> resp <)): return true\n\t\t\t// block (version is in different prerelease area): return false\n\t\t\t// differ (version is different from fixed range (string vs. number)): return false\n\t\t\t// next: continues to the next items\n\t\t\t// next-ver: when fixed: return false, continues to the next item only for the version, sets isEqual=false\n\t\t\t// big-ver: when fixed || negated: return false, continues to the next item only for the version, sets isEqual=false\n\t\t\t// next-nequ: continues to the next items, sets isEqual=false\n\t\t\t// cmp (negated === false): version < range => return false, version > range => next-nequ, else => next\n\t\t\t// cmp (negated === true): version > range => return false, version < range => next-nequ, else => next\n\t\t\t// cmp-fix: version == range => next, else => return false\n\t\t\t// big-cmp: when negated => return false, else => next-nequ\n\t\t\t// small-cmp: when negated => next-nequ, else => return false\n\n\t\t\tvar rangeType = j < range.length ? (typeof range[j])[0] : \"\";\n\n\t\t\tvar versionValue;\n\t\t\tvar versionType;\n\n\t\t\t// Handles first column in both tables (end of version or object)\n\t\t\tif (\n\t\t\t\ti >= version.length ||\n\t\t\t\t((versionValue = version[i]),\n\t\t\t\t(versionType = (typeof versionValue)[0]) == \"o\")\n\t\t\t) {\n\t\t\t\t// Handles nequal\n\t\t\t\tif (!isEqual) return true;\n\t\t\t\t// Handles bigger\n\t\t\t\tif (rangeType == \"u\") return j > fixCount && !negated;\n\t\t\t\t// Handles equal and smaller: (range === EOA) XOR negated\n\t\t\t\treturn (rangeType == \"\") != negated; // equal + smaller\n\t\t\t}\n\n\t\t\t// Handles second column in both tables (version = undefined)\n\t\t\tif (versionType == \"u\") {\n\t\t\t\tif (!isEqual || rangeType != \"u\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// switch between first and second table\n\t\t\telse if (isEqual) {\n\t\t\t\t// Handle diagonal\n\t\t\t\tif (rangeType == versionType) {\n\t\t\t\t\tif (j <= fixCount) {\n\t\t\t\t\t\t// Handles \"cmp-fix\" cases\n\t\t\t\t\t\tif (versionValue != range[j]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Handles \"cmp\" cases\n\t\t\t\t\t\tif (negated ? versionValue > range[j] : versionValue < range[j]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (versionValue != range[j]) isEqual = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Handle big-ver\n\t\t\t\telse if (rangeType != \"s\" && rangeType != \"n\") {\n\t\t\t\t\tif (negated || j <= fixCount) return false;\n\t\t\t\t\tisEqual = false;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\n\t\t\t\t// Handle differ, big-cmp and small-cmp\n\t\t\t\telse if (j <= fixCount || versionType < rangeType != negated) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tisEqual = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handles all \"next-ver\" cases in the second table\n\t\t\t\tif (rangeType != \"s\" && rangeType != \"n\") {\n\t\t\t\t\tisEqual = false;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\n\t\t\t\t// next is applied by default\n\t\t\t}\n\t\t}\n\t}\n\t/** @type {(boolean | number)[]} */\n\tvar stack = [];\n\tvar p = stack.pop.bind(stack);\n\t// eslint-disable-next-line no-redeclare\n\tfor (var i = 1; i < range.length; i++) {\n\t\tvar item = /** @type {SemVerRange | 0 | 1 | 2} */ (range[i]);\n\t\tstack.push(\n\t\t\titem == 1\n\t\t\t\t? p() | p()\n\t\t\t\t: item == 2\n\t\t\t\t? p() & p()\n\t\t\t\t: item\n\t\t\t\t? satisfy(item, version)\n\t\t\t\t: !p()\n\t\t);\n\t}\n\treturn !!p();\n};\n/* eslint-enable eqeqeq */\nexports.satisfy = satisfy;\n\nexports.stringifyHoley = json => {\n\tswitch (typeof json) {\n\t\tcase \"undefined\":\n\t\t\treturn \"\";\n\t\tcase \"object\":\n\t\t\tif (Array.isArray(json)) {\n\t\t\t\tlet str = \"[\";\n\t\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\t\tif (i !== 0) str += \",\";\n\t\t\t\t\tstr += this.stringifyHoley(json[i]);\n\t\t\t\t}\n\t\t\t\tstr += \"]\";\n\t\t\t\treturn str;\n\t\t\t} else {\n\t\t\t\treturn JSON.stringify(json);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn JSON.stringify(json);\n\t}\n};\n\n//#region runtime code: parseVersion\nexports.parseVersionRuntimeCode = runtimeTemplate =>\n\t`var parseVersion = ${runtimeTemplate.basicFunction(\"str\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t`var p=${\n\t\t\truntimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"\n\t\t}{return p.split(\".\").map((${\n\t\t\truntimeTemplate.supportsArrowFunction() ? \"p=>\" : \"function(p)\"\n\t\t}{return+p==p?+p:p}))},n=/^([^-+]+)?(?:-([^+]+))?(?:\\\\+(.+))?$/.exec(str),r=n[1]?p(n[1]):[];return n[2]&&(r.length++,r.push.apply(r,p(n[2]))),n[3]&&(r.push([]),r.push.apply(r,p(n[3]))),r;`\n\t])}`;\n//#endregion\n\n//#region runtime code: versionLt\nexports.versionLtRuntimeCode = runtimeTemplate =>\n\t`var versionLt = ${runtimeTemplate.basicFunction(\"a, b\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t'a=parseVersion(a),b=parseVersion(b);for(var r=0;;){if(r>=a.length)return r<b.length&&\"u\"!=(typeof b[r])[0];var e=a[r],n=(typeof e)[0];if(r>=b.length)return\"u\"==n;var t=b[r],f=(typeof t)[0];if(n!=f)return\"o\"==n&&\"n\"==f||(\"s\"==f||\"u\"==n);if(\"o\"!=n&&\"u\"!=n&&e!=t)return e<t;r++}'\n\t])}`;\n//#endregion\n\n//#region runtime code: rangeToString\nexports.rangeToStringRuntimeCode = runtimeTemplate =>\n\t`var rangeToString = ${runtimeTemplate.basicFunction(\"range\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t'var r=range[0],n=\"\";if(1===range.length)return\"*\";if(r+.5){n+=0==r?\">=\":-1==r?\"<\":1==r?\"^\":2==r?\"~\":r>0?\"=\":\"!=\";for(var e=1,a=1;a<range.length;a++){e--,n+=\"u\"==(typeof(t=range[a]))[0]?\"-\":(e>0?\".\":\"\")+(e=2,t)}return n}var g=[];for(a=1;a<range.length;a++){var t=range[a];g.push(0===t?\"not(\"+o()+\")\":1===t?\"(\"+o()+\" || \"+o()+\")\":2===t?g.pop()+\" \"+g.pop():rangeToString(t))}return o();function o(){return g.pop().replace(/^\\\\((.+)\\\\)$/,\"$1\")}'\n\t])}`;\n//#endregion\n\n//#region runtime code: satisfy\nexports.satisfyRuntimeCode = runtimeTemplate =>\n\t`var satisfy = ${runtimeTemplate.basicFunction(\"range, version\", [\n\t\t\"// see webpack/lib/util/semver.js for original code\",\n\t\t'if(0 in range){version=parseVersion(version);var e=range[0],r=e<0;r&&(e=-e-1);for(var n=0,i=1,a=!0;;i++,n++){var f,s,g=i<range.length?(typeof range[i])[0]:\"\";if(n>=version.length||\"o\"==(s=(typeof(f=version[n]))[0]))return!a||(\"u\"==g?i>e&&!r:\"\"==g!=r);if(\"u\"==s){if(!a||\"u\"!=g)return!1}else if(a)if(g==s)if(i<=e){if(f!=range[i])return!1}else{if(r?f>range[i]:f<range[i])return!1;f!=range[i]&&(a=!1)}else if(\"s\"!=g&&\"n\"!=g){if(r||i<=e)return!1;a=!1,i--}else{if(i<=e||s<g!=r)return!1;a=!1}else\"s\"!=g&&\"n\"!=g&&(a=!1,i--)}}var t=[],o=t.pop.bind(t);for(n=1;n<range.length;n++){var u=range[n];t.push(1==u?o()|o():2==u?o()&o():u?satisfy(u,version):!o())}return!!o();'\n\t])}`;\n//#endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}