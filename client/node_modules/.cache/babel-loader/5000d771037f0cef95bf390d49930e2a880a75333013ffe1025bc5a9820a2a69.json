{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\nconst {\n  numberToIdentifier,\n  NUMBER_OF_IDENTIFIER_START_CHARS,\n  NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n} = require(\"../Template\");\nconst {\n  assignDeterministicIds\n} = require(\"../ids/IdHelpers\");\nconst {\n  compareSelect,\n  compareStringsNumeric\n} = require(\"../util/comparators\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n\n/**\n * @param {ExportsInfo} exportsInfo exports info\n * @returns {boolean} mangle is possible\n */\nconst canMangle = exportsInfo => {\n  if (exportsInfo.otherExportsInfo.getUsed(undefined) !== UsageState.Unused) return false;\n  let hasSomethingToMangle = false;\n  for (const exportInfo of exportsInfo.exports) {\n    if (exportInfo.canMangle === true) {\n      hasSomethingToMangle = true;\n    }\n  }\n  return hasSomethingToMangle;\n};\n\n// Sort by name\nconst comparator = compareSelect(e => e.name, compareStringsNumeric);\n/**\n * @param {boolean} deterministic use deterministic names\n * @param {ExportsInfo} exportsInfo exports info\n * @param {boolean} isNamespace is namespace object\n * @returns {void}\n */\nconst mangleExportsInfo = (deterministic, exportsInfo, isNamespace) => {\n  if (!canMangle(exportsInfo)) return;\n  const usedNames = new Set();\n  /** @type {ExportInfo[]} */\n  const mangleableExports = [];\n\n  // Avoid to renamed exports that are not provided when\n  // 1. it's not a namespace export: non-provided exports can be found in prototype chain\n  // 2. there are other provided exports and deterministic mode is chosen:\n  //    non-provided exports would break the determinism\n  let avoidMangleNonProvided = !isNamespace;\n  if (!avoidMangleNonProvided && deterministic) {\n    for (const exportInfo of exportsInfo.ownedExports) {\n      if (exportInfo.provided !== false) {\n        avoidMangleNonProvided = true;\n        break;\n      }\n    }\n  }\n  for (const exportInfo of exportsInfo.ownedExports) {\n    const name = exportInfo.name;\n    if (!exportInfo.hasUsedName()) {\n      if (\n      // Can the export be mangled?\n      exportInfo.canMangle !== true ||\n      // Never rename 1 char exports\n      name.length === 1 && /^[a-zA-Z0-9_$]/.test(name) ||\n      // Don't rename 2 char exports in deterministic mode\n      deterministic && name.length === 2 && /^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name) ||\n      // Don't rename exports that are not provided\n      avoidMangleNonProvided && exportInfo.provided !== true) {\n        exportInfo.setUsedName(name);\n        usedNames.add(name);\n      } else {\n        mangleableExports.push(exportInfo);\n      }\n    }\n    if (exportInfo.exportsInfoOwned) {\n      const used = exportInfo.getUsed(undefined);\n      if (used === UsageState.OnlyPropertiesUsed || used === UsageState.Unused) {\n        mangleExportsInfo(deterministic, exportInfo.exportsInfo, false);\n      }\n    }\n  }\n  if (deterministic) {\n    assignDeterministicIds(mangleableExports, e => e.name, comparator, (e, id) => {\n      const name = numberToIdentifier(id);\n      const size = usedNames.size;\n      usedNames.add(name);\n      if (size === usedNames.size) return false;\n      e.setUsedName(name);\n      return true;\n    }, [NUMBER_OF_IDENTIFIER_START_CHARS, NUMBER_OF_IDENTIFIER_START_CHARS * NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS], NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS, usedNames.size);\n  } else {\n    const usedExports = [];\n    const unusedExports = [];\n    for (const exportInfo of mangleableExports) {\n      if (exportInfo.getUsed(undefined) === UsageState.Unused) {\n        unusedExports.push(exportInfo);\n      } else {\n        usedExports.push(exportInfo);\n      }\n    }\n    usedExports.sort(comparator);\n    unusedExports.sort(comparator);\n    let i = 0;\n    for (const list of [usedExports, unusedExports]) {\n      for (const exportInfo of list) {\n        let name;\n        do {\n          name = numberToIdentifier(i++);\n        } while (usedNames.has(name));\n        exportInfo.setUsedName(name);\n      }\n    }\n  }\n};\nclass MangleExportsPlugin {\n  /**\n   * @param {boolean} deterministic use deterministic names\n   */\n  constructor(deterministic) {\n    this._deterministic = deterministic;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const {\n      _deterministic: deterministic\n    } = this;\n    compiler.hooks.compilation.tap(\"MangleExportsPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.optimizeCodeGeneration.tap(\"MangleExportsPlugin\", modules => {\n        if (compilation.moduleMemCaches) {\n          throw new Error(\"optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect\");\n        }\n        for (const module of modules) {\n          const isNamespace = module.buildMeta && module.buildMeta.exportsType === \"namespace\";\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          mangleExportsInfo(deterministic, exportsInfo, isNamespace);\n        }\n      });\n    });\n  }\n}\nmodule.exports = MangleExportsPlugin;","map":{"version":3,"names":["UsageState","require","numberToIdentifier","NUMBER_OF_IDENTIFIER_START_CHARS","NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS","assignDeterministicIds","compareSelect","compareStringsNumeric","canMangle","exportsInfo","otherExportsInfo","getUsed","undefined","Unused","hasSomethingToMangle","exportInfo","exports","comparator","e","name","mangleExportsInfo","deterministic","isNamespace","usedNames","Set","mangleableExports","avoidMangleNonProvided","ownedExports","provided","hasUsedName","length","test","setUsedName","add","push","exportsInfoOwned","used","OnlyPropertiesUsed","id","size","usedExports","unusedExports","sort","i","list","has","MangleExportsPlugin","constructor","_deterministic","apply","compiler","hooks","compilation","tap","moduleGraph","optimizeCodeGeneration","modules","moduleMemCaches","Error","module","buildMeta","exportsType","getExportsInfo"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/MangleExportsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\nconst {\n\tnumberToIdentifier,\n\tNUMBER_OF_IDENTIFIER_START_CHARS,\n\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n} = require(\"../Template\");\nconst { assignDeterministicIds } = require(\"../ids/IdHelpers\");\nconst { compareSelect, compareStringsNumeric } = require(\"../util/comparators\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n\n/**\n * @param {ExportsInfo} exportsInfo exports info\n * @returns {boolean} mangle is possible\n */\nconst canMangle = exportsInfo => {\n\tif (exportsInfo.otherExportsInfo.getUsed(undefined) !== UsageState.Unused)\n\t\treturn false;\n\tlet hasSomethingToMangle = false;\n\tfor (const exportInfo of exportsInfo.exports) {\n\t\tif (exportInfo.canMangle === true) {\n\t\t\thasSomethingToMangle = true;\n\t\t}\n\t}\n\treturn hasSomethingToMangle;\n};\n\n// Sort by name\nconst comparator = compareSelect(e => e.name, compareStringsNumeric);\n/**\n * @param {boolean} deterministic use deterministic names\n * @param {ExportsInfo} exportsInfo exports info\n * @param {boolean} isNamespace is namespace object\n * @returns {void}\n */\nconst mangleExportsInfo = (deterministic, exportsInfo, isNamespace) => {\n\tif (!canMangle(exportsInfo)) return;\n\tconst usedNames = new Set();\n\t/** @type {ExportInfo[]} */\n\tconst mangleableExports = [];\n\n\t// Avoid to renamed exports that are not provided when\n\t// 1. it's not a namespace export: non-provided exports can be found in prototype chain\n\t// 2. there are other provided exports and deterministic mode is chosen:\n\t//    non-provided exports would break the determinism\n\tlet avoidMangleNonProvided = !isNamespace;\n\tif (!avoidMangleNonProvided && deterministic) {\n\t\tfor (const exportInfo of exportsInfo.ownedExports) {\n\t\t\tif (exportInfo.provided !== false) {\n\t\t\t\tavoidMangleNonProvided = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const exportInfo of exportsInfo.ownedExports) {\n\t\tconst name = exportInfo.name;\n\t\tif (!exportInfo.hasUsedName()) {\n\t\t\tif (\n\t\t\t\t// Can the export be mangled?\n\t\t\t\texportInfo.canMangle !== true ||\n\t\t\t\t// Never rename 1 char exports\n\t\t\t\t(name.length === 1 && /^[a-zA-Z0-9_$]/.test(name)) ||\n\t\t\t\t// Don't rename 2 char exports in deterministic mode\n\t\t\t\t(deterministic &&\n\t\t\t\t\tname.length === 2 &&\n\t\t\t\t\t/^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name)) ||\n\t\t\t\t// Don't rename exports that are not provided\n\t\t\t\t(avoidMangleNonProvided && exportInfo.provided !== true)\n\t\t\t) {\n\t\t\t\texportInfo.setUsedName(name);\n\t\t\t\tusedNames.add(name);\n\t\t\t} else {\n\t\t\t\tmangleableExports.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tif (exportInfo.exportsInfoOwned) {\n\t\t\tconst used = exportInfo.getUsed(undefined);\n\t\t\tif (\n\t\t\t\tused === UsageState.OnlyPropertiesUsed ||\n\t\t\t\tused === UsageState.Unused\n\t\t\t) {\n\t\t\t\tmangleExportsInfo(deterministic, exportInfo.exportsInfo, false);\n\t\t\t}\n\t\t}\n\t}\n\tif (deterministic) {\n\t\tassignDeterministicIds(\n\t\t\tmangleableExports,\n\t\t\te => e.name,\n\t\t\tcomparator,\n\t\t\t(e, id) => {\n\t\t\t\tconst name = numberToIdentifier(id);\n\t\t\t\tconst size = usedNames.size;\n\t\t\t\tusedNames.add(name);\n\t\t\t\tif (size === usedNames.size) return false;\n\t\t\t\te.setUsedName(name);\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\t[\n\t\t\t\tNUMBER_OF_IDENTIFIER_START_CHARS,\n\t\t\t\tNUMBER_OF_IDENTIFIER_START_CHARS *\n\t\t\t\t\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n\t\t\t],\n\t\t\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS,\n\t\t\tusedNames.size\n\t\t);\n\t} else {\n\t\tconst usedExports = [];\n\t\tconst unusedExports = [];\n\t\tfor (const exportInfo of mangleableExports) {\n\t\t\tif (exportInfo.getUsed(undefined) === UsageState.Unused) {\n\t\t\t\tunusedExports.push(exportInfo);\n\t\t\t} else {\n\t\t\t\tusedExports.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tusedExports.sort(comparator);\n\t\tunusedExports.sort(comparator);\n\t\tlet i = 0;\n\t\tfor (const list of [usedExports, unusedExports]) {\n\t\t\tfor (const exportInfo of list) {\n\t\t\t\tlet name;\n\t\t\t\tdo {\n\t\t\t\t\tname = numberToIdentifier(i++);\n\t\t\t\t} while (usedNames.has(name));\n\t\t\t\texportInfo.setUsedName(name);\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass MangleExportsPlugin {\n\t/**\n\t * @param {boolean} deterministic use deterministic names\n\t */\n\tconstructor(deterministic) {\n\t\tthis._deterministic = deterministic;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _deterministic: deterministic } = this;\n\t\tcompiler.hooks.compilation.tap(\"MangleExportsPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.optimizeCodeGeneration.tap(\n\t\t\t\t\"MangleExportsPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst isNamespace =\n\t\t\t\t\t\t\tmodule.buildMeta && module.buildMeta.exportsType === \"namespace\";\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tmangleExportsInfo(deterministic, exportsInfo, isNamespace);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = MangleExportsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}