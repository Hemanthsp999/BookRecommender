{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\nfunction getState(parserState) {\n  return parserStateMap.get(parserState);\n}\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.bailout = parserState => {\n  parserStateMap.set(parserState, false);\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.enable = parserState => {\n  const state = parserStateMap.get(parserState);\n  if (state === false) {\n    return;\n  }\n  parserStateMap.set(parserState, {\n    innerGraph: new Map(),\n    currentTopLevelSymbol: undefined,\n    usageCallbackMap: new Map()\n  });\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\nexports.isEnabled = parserState => {\n  const state = parserStateMap.get(parserState);\n  return !!state;\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addUsage = (state, symbol, usage) => {\n  const innerGraphState = getState(state);\n  if (innerGraphState) {\n    const {\n      innerGraph\n    } = innerGraphState;\n    const info = innerGraph.get(symbol);\n    if (usage === true) {\n      innerGraph.set(symbol, true);\n    } else if (info === undefined) {\n      innerGraph.set(symbol, new Set([usage]));\n    } else if (info !== true) {\n      info.add(usage);\n    }\n  }\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addVariableUsage = (parser, name, usage) => {\n  const symbol = /** @type {TopLevelSymbol} */parser.getTagData(name, topLevelSymbolTag) || exports.tagTopLevelSymbol(parser, name);\n  if (symbol) {\n    exports.addUsage(parser.state, symbol, usage);\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\nexports.inferDependencyUsage = state => {\n  const innerGraphState = getState(state);\n  if (!innerGraphState) {\n    return;\n  }\n  const {\n    innerGraph,\n    usageCallbackMap\n  } = innerGraphState;\n  const processed = new Map();\n  // flatten graph to terminal nodes (string, undefined or true)\n  const nonTerminal = new Set(innerGraph.keys());\n  while (nonTerminal.size > 0) {\n    for (const key of nonTerminal) {\n      /** @type {Set<string|TopLevelSymbol> | true} */\n      let newSet = new Set();\n      let isTerminal = true;\n      const value = innerGraph.get(key);\n      let alreadyProcessed = processed.get(key);\n      if (alreadyProcessed === undefined) {\n        alreadyProcessed = new Set();\n        processed.set(key, alreadyProcessed);\n      }\n      if (value !== true && value !== undefined) {\n        for (const item of value) {\n          alreadyProcessed.add(item);\n        }\n        for (const item of value) {\n          if (typeof item === \"string\") {\n            newSet.add(item);\n          } else {\n            const itemValue = innerGraph.get(item);\n            if (itemValue === true) {\n              newSet = true;\n              break;\n            }\n            if (itemValue !== undefined) {\n              for (const i of itemValue) {\n                if (i === key) continue;\n                if (alreadyProcessed.has(i)) continue;\n                newSet.add(i);\n                if (typeof i !== \"string\") {\n                  isTerminal = false;\n                }\n              }\n            }\n          }\n        }\n        if (newSet === true) {\n          innerGraph.set(key, true);\n        } else if (newSet.size === 0) {\n          innerGraph.set(key, undefined);\n        } else {\n          innerGraph.set(key, newSet);\n        }\n      }\n      if (isTerminal) {\n        nonTerminal.delete(key);\n\n        // For the global key, merge with all other keys\n        if (key === null) {\n          const globalValue = innerGraph.get(null);\n          if (globalValue) {\n            for (const [key, value] of innerGraph) {\n              if (key !== null && value !== true) {\n                if (globalValue === true) {\n                  innerGraph.set(key, true);\n                } else {\n                  const newSet = new Set(value);\n                  for (const item of globalValue) {\n                    newSet.add(item);\n                  }\n                  innerGraph.set(key, newSet);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** @type {Map<Dependency, true | Set<string>>} */\n  for (const [symbol, callbacks] of usageCallbackMap) {\n    const usage = /** @type {true | Set<string> | undefined} */\n    innerGraph.get(symbol);\n    for (const callback of callbacks) {\n      callback(usage === undefined ? false : usage);\n    }\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\nexports.onUsage = (state, onUsageCallback) => {\n  const innerGraphState = getState(state);\n  if (innerGraphState) {\n    const {\n      usageCallbackMap,\n      currentTopLevelSymbol\n    } = innerGraphState;\n    if (currentTopLevelSymbol) {\n      let callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n      if (callbacks === undefined) {\n        callbacks = new Set();\n        usageCallbackMap.set(currentTopLevelSymbol, callbacks);\n      }\n      callbacks.add(onUsageCallback);\n    } else {\n      onUsageCallback(true);\n    }\n  } else {\n    onUsageCallback(undefined);\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\nexports.setTopLevelSymbol = (state, symbol) => {\n  const innerGraphState = getState(state);\n  if (innerGraphState) {\n    innerGraphState.currentTopLevelSymbol = symbol;\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\nexports.getTopLevelSymbol = state => {\n  const innerGraphState = getState(state);\n  if (innerGraphState) {\n    return innerGraphState.currentTopLevelSymbol;\n  }\n};\n\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\nexports.tagTopLevelSymbol = (parser, name) => {\n  const innerGraphState = getState(parser.state);\n  if (!innerGraphState) return;\n  parser.defineVariable(name);\n  const existingTag = /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag);\n  if (existingTag) {\n    return existingTag;\n  }\n  const fn = new TopLevelSymbol(name);\n  parser.tagVariable(name, topLevelSymbolTag, fn);\n  return fn;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\nexports.isDependencyUsedByExports = (dependency, usedByExports, moduleGraph, runtime) => {\n  if (usedByExports === false) return false;\n  if (usedByExports !== true && usedByExports !== undefined) {\n    const selfModule = moduleGraph.getParentModule(dependency);\n    const exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    let used = false;\n    for (const exportName of usedByExports) {\n      if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) used = true;\n    }\n    if (!used) return false;\n  }\n  return true;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\nexports.getDependencyUsedByExportsCondition = (dependency, usedByExports, moduleGraph) => {\n  if (usedByExports === false) return false;\n  if (usedByExports !== true && usedByExports !== undefined) {\n    const selfModule = moduleGraph.getParentModule(dependency);\n    const exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    return (connections, runtime) => {\n      for (const exportName of usedByExports) {\n        if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) return true;\n      }\n      return false;\n    };\n  }\n  return null;\n};\nclass TopLevelSymbol {\n  /**\n   * @param {string} name name of the variable\n   */\n  constructor(name) {\n    this.name = name;\n  }\n}\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;","map":{"version":3,"names":["UsageState","require","parserStateMap","WeakMap","topLevelSymbolTag","Symbol","getState","parserState","get","exports","bailout","set","enable","state","innerGraph","Map","currentTopLevelSymbol","undefined","usageCallbackMap","isEnabled","addUsage","symbol","usage","innerGraphState","info","Set","add","addVariableUsage","parser","name","getTagData","tagTopLevelSymbol","inferDependencyUsage","processed","nonTerminal","keys","size","key","newSet","isTerminal","value","alreadyProcessed","item","itemValue","i","has","delete","globalValue","callbacks","callback","onUsage","onUsageCallback","setTopLevelSymbol","getTopLevelSymbol","defineVariable","existingTag","fn","TopLevelSymbol","tagVariable","isDependencyUsedByExports","dependency","usedByExports","moduleGraph","runtime","selfModule","getParentModule","exportsInfo","getExportsInfo","used","exportName","getUsed","Unused","getDependencyUsedByExportsCondition","connections","constructor"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/InnerGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\nfunction getState(parserState) {\n\treturn parserStateMap.get(parserState);\n}\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.bailout = parserState => {\n\tparserStateMap.set(parserState, false);\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.enable = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\tif (state === false) {\n\t\treturn;\n\t}\n\tparserStateMap.set(parserState, {\n\t\tinnerGraph: new Map(),\n\t\tcurrentTopLevelSymbol: undefined,\n\t\tusageCallbackMap: new Map()\n\t});\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\nexports.isEnabled = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\treturn !!state;\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addUsage = (state, symbol, usage) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { innerGraph } = innerGraphState;\n\t\tconst info = innerGraph.get(symbol);\n\t\tif (usage === true) {\n\t\t\tinnerGraph.set(symbol, true);\n\t\t} else if (info === undefined) {\n\t\t\tinnerGraph.set(symbol, new Set([usage]));\n\t\t} else if (info !== true) {\n\t\t\tinfo.add(usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addVariableUsage = (parser, name, usage) => {\n\tconst symbol =\n\t\t/** @type {TopLevelSymbol} */ (\n\t\t\tparser.getTagData(name, topLevelSymbolTag)\n\t\t) || exports.tagTopLevelSymbol(parser, name);\n\tif (symbol) {\n\t\texports.addUsage(parser.state, symbol, usage);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\nexports.inferDependencyUsage = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (!innerGraphState) {\n\t\treturn;\n\t}\n\n\tconst { innerGraph, usageCallbackMap } = innerGraphState;\n\tconst processed = new Map();\n\t// flatten graph to terminal nodes (string, undefined or true)\n\tconst nonTerminal = new Set(innerGraph.keys());\n\twhile (nonTerminal.size > 0) {\n\t\tfor (const key of nonTerminal) {\n\t\t\t/** @type {Set<string|TopLevelSymbol> | true} */\n\t\t\tlet newSet = new Set();\n\t\t\tlet isTerminal = true;\n\t\t\tconst value = innerGraph.get(key);\n\t\t\tlet alreadyProcessed = processed.get(key);\n\t\t\tif (alreadyProcessed === undefined) {\n\t\t\t\talreadyProcessed = new Set();\n\t\t\t\tprocessed.set(key, alreadyProcessed);\n\t\t\t}\n\t\t\tif (value !== true && value !== undefined) {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\talreadyProcessed.add(item);\n\t\t\t\t}\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst itemValue = innerGraph.get(item);\n\t\t\t\t\t\tif (itemValue === true) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (itemValue !== undefined) {\n\t\t\t\t\t\t\tfor (const i of itemValue) {\n\t\t\t\t\t\t\t\tif (i === key) continue;\n\t\t\t\t\t\t\t\tif (alreadyProcessed.has(i)) continue;\n\t\t\t\t\t\t\t\tnewSet.add(i);\n\t\t\t\t\t\t\t\tif (typeof i !== \"string\") {\n\t\t\t\t\t\t\t\t\tisTerminal = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newSet === true) {\n\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t} else if (newSet.size === 0) {\n\t\t\t\t\tinnerGraph.set(key, undefined);\n\t\t\t\t} else {\n\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isTerminal) {\n\t\t\t\tnonTerminal.delete(key);\n\n\t\t\t\t// For the global key, merge with all other keys\n\t\t\t\tif (key === null) {\n\t\t\t\t\tconst globalValue = innerGraph.get(null);\n\t\t\t\t\tif (globalValue) {\n\t\t\t\t\t\tfor (const [key, value] of innerGraph) {\n\t\t\t\t\t\t\tif (key !== null && value !== true) {\n\t\t\t\t\t\t\t\tif (globalValue === true) {\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst newSet = new Set(value);\n\t\t\t\t\t\t\t\t\tfor (const item of globalValue) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {Map<Dependency, true | Set<string>>} */\n\tfor (const [symbol, callbacks] of usageCallbackMap) {\n\t\tconst usage = /** @type {true | Set<string> | undefined} */ (\n\t\t\tinnerGraph.get(symbol)\n\t\t);\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(usage === undefined ? false : usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\nexports.onUsage = (state, onUsageCallback) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { usageCallbackMap, currentTopLevelSymbol } = innerGraphState;\n\t\tif (currentTopLevelSymbol) {\n\t\t\tlet callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n\t\t\tif (callbacks === undefined) {\n\t\t\t\tcallbacks = new Set();\n\t\t\t\tusageCallbackMap.set(currentTopLevelSymbol, callbacks);\n\t\t\t}\n\n\t\t\tcallbacks.add(onUsageCallback);\n\t\t} else {\n\t\t\tonUsageCallback(true);\n\t\t}\n\t} else {\n\t\tonUsageCallback(undefined);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\nexports.setTopLevelSymbol = (state, symbol) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tinnerGraphState.currentTopLevelSymbol = symbol;\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\nexports.getTopLevelSymbol = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\treturn innerGraphState.currentTopLevelSymbol;\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\nexports.tagTopLevelSymbol = (parser, name) => {\n\tconst innerGraphState = getState(parser.state);\n\tif (!innerGraphState) return;\n\n\tparser.defineVariable(name);\n\n\tconst existingTag = /** @type {TopLevelSymbol} */ (\n\t\tparser.getTagData(name, topLevelSymbolTag)\n\t);\n\tif (existingTag) {\n\t\treturn existingTag;\n\t}\n\n\tconst fn = new TopLevelSymbol(name);\n\tparser.tagVariable(name, topLevelSymbolTag, fn);\n\treturn fn;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\nexports.isDependencyUsedByExports = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph,\n\truntime\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\tlet used = false;\n\t\tfor (const exportName of usedByExports) {\n\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\tused = true;\n\t\t}\n\t\tif (!used) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\nexports.getDependencyUsedByExportsCondition = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\treturn (connections, runtime) => {\n\t\t\tfor (const exportName of usedByExports) {\n\t\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn null;\n};\n\nclass TopLevelSymbol {\n\t/**\n\t * @param {string} name name of the variable\n\t */\n\tconstructor(name) {\n\t\tthis.name = name;\n\t}\n}\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}