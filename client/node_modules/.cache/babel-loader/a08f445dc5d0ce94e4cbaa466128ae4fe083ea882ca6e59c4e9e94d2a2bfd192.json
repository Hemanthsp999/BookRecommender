{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst ArraySerializer = require(\"./ArraySerializer\");\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\n/**\n * @template T\n * @param {Set<T>} set set\n * @param {number} size count of items to keep\n */\nconst setSetSize = (set, size) => {\n  let i = 0;\n  for (const item of set) {\n    if (i++ >= size) {\n      set.delete(item);\n    }\n  }\n};\n\n/**\n * @template K, X\n * @param {Map<K, X>} map map\n * @param {number} size count of items to keep\n */\nconst setMapSize = (map, size) => {\n  let i = 0;\n  for (const item of map.keys()) {\n    if (i++ >= size) {\n      map.delete(item);\n    }\n  }\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst toHash = (buffer, hashFunction) => {\n  const hash = createHash(hashFunction);\n  hash.update(buffer);\n  return (/** @type {string} */hash.digest(\"latin1\")\n  );\n};\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\nconst CURRENT_VERSION = 2;\n\n/** @type {Map<Constructor, { request?: string, name?: string | number , serializer?: ObjectSerializer }>} */\nconst serializers = new Map();\n/** @type {Map<string | number, ObjectSerializer>} */\nconst serializerInversed = new Map();\n\n/** @type {Set<string>} */\nconst loadedRequests = new Set();\nconst NOT_SERIALIZABLE = {};\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n  const Obj = /** @type {typeof Object} */exports.constructor;\n  const Fn = /** @type {typeof Function} */Obj.constructor;\n  for (const [type, config] of Array.from(jsTypes)) {\n    if (type) {\n      const Type = new Fn(`return ${type.name};`)();\n      jsTypes.set(Type, config);\n    }\n  }\n}\n{\n  let i = 1;\n  for (const [type, serializer] of jsTypes) {\n    serializers.set(type, {\n      request: \"\",\n      name: i++,\n      serializer\n    });\n  }\n}\nfor (const {\n  request,\n  name,\n  serializer\n} of serializers.values()) {\n  serializerInversed.set(`${request}/${name}`, serializer);\n}\n\n/** @type {Map<RegExp, (request: string) => boolean>} */\nconst loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass ObjectMiddleware extends SerializerMiddleware {\n  /**\n   * @param {function(any): void} extendContext context extensions\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  constructor(extendContext) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    super();\n    this.extendContext = extendContext;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {RegExp} regExp RegExp for which the request is tested\n   * @param {function(string): boolean} loader loader to load the request, returns true when successful\n   * @returns {void}\n   */\n  static registerLoader(regExp, loader) {\n    loaders.set(regExp, loader);\n  }\n\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @param {string} request the request which will be required when deserializing\n   * @param {string} name the name to make multiple serializer unique when sharing a request\n   * @param {ObjectSerializer} serializer the serializer\n   * @returns {void}\n   */\n  static register(Constructor, request, name, serializer) {\n    const key = request + \"/\" + name;\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`);\n    }\n    if (serializerInversed.has(key)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${key} is already registered`);\n    }\n    serializers.set(Constructor, {\n      request,\n      name,\n      serializer\n    });\n    serializerInversed.set(key, serializer);\n  }\n\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @returns {void}\n   */\n  static registerNotSerializable(Constructor) {\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`);\n    }\n    serializers.set(Constructor, NOT_SERIALIZABLE);\n  }\n  static getSerializerFor(object) {\n    const proto = Object.getPrototypeOf(object);\n    let c;\n    if (proto === null) {\n      // Object created with Object.create(null)\n      c = null;\n    } else {\n      c = proto.constructor;\n      if (!c) {\n        throw new Error(\"Serialization of objects with prototype without valid constructor property not possible\");\n      }\n    }\n    const config = serializers.get(c);\n    if (!config) throw new Error(`No serializer registered for ${c.name}`);\n    if (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n    return config;\n  }\n\n  /**\n   * @param {string} request request\n   * @param {TODO} name name\n   * @returns {ObjectSerializer} serializer\n   */\n  static getDeserializerFor(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n    if (serializer === undefined) {\n      throw new Error(`No deserializer registered for ${key}`);\n    }\n    return serializer;\n  }\n\n  /**\n   * @param {string} request request\n   * @param {TODO} name name\n   * @returns {ObjectSerializer} serializer\n   */\n  static _getDeserializerForWithoutError(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n    return serializer;\n  }\n\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n  serialize(data, context) {\n    /** @type {any[]} */\n    let result = [CURRENT_VERSION];\n    let currentPos = 0;\n    let referenceable = new Map();\n    const addReferenceable = item => {\n      referenceable.set(item, currentPos++);\n    };\n    let bufferDedupeMap = new Map();\n    const dedupeBuffer = buf => {\n      const len = buf.length;\n      const entry = bufferDedupeMap.get(len);\n      if (entry === undefined) {\n        bufferDedupeMap.set(len, buf);\n        return buf;\n      }\n      if (Buffer.isBuffer(entry)) {\n        if (len < 32) {\n          if (buf.equals(entry)) {\n            return entry;\n          }\n          bufferDedupeMap.set(len, [entry, buf]);\n          return buf;\n        } else {\n          const hash = toHash(entry, this._hashFunction);\n          const newMap = new Map();\n          newMap.set(hash, entry);\n          bufferDedupeMap.set(len, newMap);\n          const hashBuf = toHash(buf, this._hashFunction);\n          if (hash === hashBuf) {\n            return entry;\n          }\n          return buf;\n        }\n      } else if (Array.isArray(entry)) {\n        if (entry.length < 16) {\n          for (const item of entry) {\n            if (buf.equals(item)) {\n              return item;\n            }\n          }\n          entry.push(buf);\n          return buf;\n        } else {\n          const newMap = new Map();\n          const hash = toHash(buf, this._hashFunction);\n          let found;\n          for (const item of entry) {\n            const itemHash = toHash(item, this._hashFunction);\n            newMap.set(itemHash, item);\n            if (found === undefined && itemHash === hash) found = item;\n          }\n          bufferDedupeMap.set(len, newMap);\n          if (found === undefined) {\n            newMap.set(hash, buf);\n            return buf;\n          } else {\n            return found;\n          }\n        }\n      } else {\n        const hash = toHash(buf, this._hashFunction);\n        const item = entry.get(hash);\n        if (item !== undefined) {\n          return item;\n        }\n        entry.set(hash, buf);\n        return buf;\n      }\n    };\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = new Map();\n    const cycleStack = new Set();\n    const stackToString = item => {\n      const arr = Array.from(cycleStack);\n      arr.push(item);\n      return arr.map(item => {\n        if (typeof item === \"string\") {\n          if (item.length > 100) {\n            return `String ${JSON.stringify(item.slice(0, 100)).slice(0, -1)}...\"`;\n          }\n          return `String ${JSON.stringify(item)}`;\n        }\n        try {\n          const {\n            request,\n            name\n          } = ObjectMiddleware.getSerializerFor(item);\n          if (request) {\n            return `${request}${name ? `.${name}` : \"\"}`;\n          }\n        } catch (e) {\n          // ignore -> fallback\n        }\n        if (typeof item === \"object\" && item !== null) {\n          if (item.constructor) {\n            if (item.constructor === Object) return `Object { ${Object.keys(item).join(\", \")} }`;\n            if (item.constructor === Map) return `Map { ${item.size} items }`;\n            if (item.constructor === Array) return `Array { ${item.length} items }`;\n            if (item.constructor === Set) return `Set { ${item.size} items }`;\n            if (item.constructor === RegExp) return item.toString();\n            return `${item.constructor.name}`;\n          }\n          return `Object [null prototype] { ${Object.keys(item).join(\", \")} }`;\n        }\n        try {\n          return `${item}`;\n        } catch (e) {\n          return `(${e.message})`;\n        }\n      }).join(\" -> \");\n    };\n    let hasDebugInfoAttached;\n    let ctx = {\n      write(value, key) {\n        try {\n          process(value);\n        } catch (e) {\n          if (e !== NOT_SERIALIZABLE) {\n            if (hasDebugInfoAttached === undefined) hasDebugInfoAttached = new WeakSet();\n            if (!hasDebugInfoAttached.has(e)) {\n              e.message += `\\nwhile serializing ${stackToString(value)}`;\n              hasDebugInfoAttached.add(e);\n            }\n          }\n          throw e;\n        }\n      },\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n      snapshot() {\n        return {\n          length: result.length,\n          cycleStackSize: cycleStack.size,\n          referenceableSize: referenceable.size,\n          currentPos,\n          objectTypeLookupSize: objectTypeLookup.size,\n          currentPosTypeLookup\n        };\n      },\n      rollback(snapshot) {\n        result.length = snapshot.length;\n        setSetSize(cycleStack, snapshot.cycleStackSize);\n        setMapSize(referenceable, snapshot.referenceableSize);\n        currentPos = snapshot.currentPos;\n        setMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n        currentPosTypeLookup = snapshot.currentPosTypeLookup;\n      },\n      ...context\n    };\n    this.extendContext(ctx);\n    const process = item => {\n      if (Buffer.isBuffer(item)) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n        const alreadyUsedBuffer = dedupeBuffer(item);\n        if (alreadyUsedBuffer !== item) {\n          const ref = referenceable.get(alreadyUsedBuffer);\n          if (ref !== undefined) {\n            referenceable.set(item, ref);\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n          item = alreadyUsedBuffer;\n        }\n        addReferenceable(item);\n        result.push(item);\n      } else if (item === ESCAPE) {\n        result.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n      } else if (typeof item === \"object\"\n      // We don't have to check for null as ESCAPE is null and this has been checked before\n      ) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n        if (cycleStack.has(item)) {\n          throw new Error(`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`);\n        }\n        const {\n          request,\n          name,\n          serializer\n        } = ObjectMiddleware.getSerializerFor(item);\n        const key = `${request}/${name}`;\n        const lastIndex = objectTypeLookup.get(key);\n        if (lastIndex === undefined) {\n          objectTypeLookup.set(key, currentPosTypeLookup++);\n          result.push(ESCAPE, request, name);\n        } else {\n          result.push(ESCAPE, currentPosTypeLookup - lastIndex);\n        }\n        cycleStack.add(item);\n        try {\n          serializer.serialize(item, ctx);\n        } finally {\n          cycleStack.delete(item);\n        }\n        result.push(ESCAPE, ESCAPE_END_OBJECT);\n        addReferenceable(item);\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          // short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n          // check if we can emit a reference\n          const ref = referenceable.get(item);\n          if (ref !== undefined) {\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n          addReferenceable(item);\n        }\n        if (item.length > 102400 && context.logger) {\n          context.logger.warn(`Serializing big strings (${Math.round(item.length / 1024)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`);\n        }\n        result.push(item);\n      } else if (typeof item === \"function\") {\n        if (!SerializerMiddleware.isLazy(item)) throw new Error(\"Unexpected function \" + item);\n        /** @type {SerializedType} */\n        const serializedData = SerializerMiddleware.getLazySerializedValue(item);\n        if (serializedData !== undefined) {\n          if (typeof serializedData === \"function\") {\n            result.push(serializedData);\n          } else {\n            throw new Error(\"Not implemented\");\n          }\n        } else if (SerializerMiddleware.isLazy(item, this)) {\n          throw new Error(\"Not implemented\");\n        } else {\n          const data = SerializerMiddleware.serializeLazy(item, data => this.serialize([data], context));\n          SerializerMiddleware.setLazySerializedValue(item, data);\n          result.push(data);\n        }\n      } else if (item === undefined) {\n        result.push(ESCAPE, ESCAPE_UNDEFINED);\n      } else {\n        result.push(item);\n      }\n    };\n    try {\n      for (const item of data) {\n        process(item);\n      }\n      return result;\n    } catch (e) {\n      if (e === NOT_SERIALIZABLE) return null;\n      throw e;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.write\" method so it will reference\n      // it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n      data = result = referenceable = bufferDedupeMap = objectTypeLookup = ctx = undefined;\n    }\n  }\n\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n  deserialize(data, context) {\n    let currentDataPos = 0;\n    const read = () => {\n      if (currentDataPos >= data.length) throw new Error(\"Unexpected end of stream\");\n      return data[currentDataPos++];\n    };\n    if (read() !== CURRENT_VERSION) throw new Error(\"Version mismatch, serializer changed\");\n    let currentPos = 0;\n    let referenceable = [];\n    const addReferenceable = item => {\n      referenceable.push(item);\n      currentPos++;\n    };\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = [];\n    let result = [];\n    let ctx = {\n      read() {\n        return decodeValue();\n      },\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n      ...context\n    };\n    this.extendContext(ctx);\n    const decodeValue = () => {\n      const item = read();\n      if (item === ESCAPE) {\n        const nextItem = read();\n        if (nextItem === ESCAPE_ESCAPE_VALUE) {\n          return ESCAPE;\n        } else if (nextItem === ESCAPE_UNDEFINED) {\n          return undefined;\n        } else if (nextItem === ESCAPE_END_OBJECT) {\n          throw new Error(`Unexpected end of object at position ${currentDataPos - 1}`);\n        } else {\n          const request = nextItem;\n          let serializer;\n          if (typeof request === \"number\") {\n            if (request < 0) {\n              // relative reference\n              return referenceable[currentPos + request];\n            }\n            serializer = objectTypeLookup[currentPosTypeLookup - request];\n          } else {\n            if (typeof request !== \"string\") {\n              throw new Error(`Unexpected type (${typeof request}) of request ` + `at position ${currentDataPos - 1}`);\n            }\n            const name = read();\n            serializer = ObjectMiddleware._getDeserializerForWithoutError(request, name);\n            if (serializer === undefined) {\n              if (request && !loadedRequests.has(request)) {\n                let loaded = false;\n                for (const [regExp, loader] of loaders) {\n                  if (regExp.test(request)) {\n                    if (loader(request)) {\n                      loaded = true;\n                      break;\n                    }\n                  }\n                }\n                if (!loaded) {\n                  require(request);\n                }\n                loadedRequests.add(request);\n              }\n              serializer = ObjectMiddleware.getDeserializerFor(request, name);\n            }\n            objectTypeLookup.push(serializer);\n            currentPosTypeLookup++;\n          }\n          try {\n            const item = serializer.deserialize(ctx);\n            const end1 = read();\n            if (end1 !== ESCAPE) {\n              throw new Error(\"Expected end of object\");\n            }\n            const end2 = read();\n            if (end2 !== ESCAPE_END_OBJECT) {\n              throw new Error(\"Expected end of object\");\n            }\n            addReferenceable(item);\n            return item;\n          } catch (err) {\n            // As this is only for error handling, we omit creating a Map for\n            // faster access to this information, as this would affect performance\n            // in the good case\n            let serializerEntry;\n            for (const entry of serializers) {\n              if (entry[1].serializer === serializer) {\n                serializerEntry = entry;\n                break;\n              }\n            }\n            const name = !serializerEntry ? \"unknown\" : !serializerEntry[1].request ? serializerEntry[0].name : serializerEntry[1].name ? `${serializerEntry[1].request} ${serializerEntry[1].name}` : serializerEntry[1].request;\n            err.message += `\\n(during deserialization of ${name})`;\n            throw err;\n          }\n        }\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          addReferenceable(item);\n        }\n        return item;\n      } else if (Buffer.isBuffer(item)) {\n        addReferenceable(item);\n        return item;\n      } else if (typeof item === \"function\") {\n        return SerializerMiddleware.deserializeLazy(item, data => this.deserialize(data, context)[0]);\n      } else {\n        return item;\n      }\n    };\n    try {\n      while (currentDataPos < data.length) {\n        result.push(decodeValue());\n      }\n      return result;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.read\" method so it will reference\n      // it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n      result = referenceable = data = objectTypeLookup = ctx = undefined;\n    }\n  }\n}\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;","map":{"version":3,"names":["createHash","require","ArraySerializer","DateObjectSerializer","ErrorObjectSerializer","MapObjectSerializer","NullPrototypeObjectSerializer","PlainObjectSerializer","RegExpObjectSerializer","SerializerMiddleware","SetObjectSerializer","setSetSize","set","size","i","item","delete","setMapSize","map","keys","toHash","buffer","hashFunction","hash","update","digest","ESCAPE","ESCAPE_ESCAPE_VALUE","ESCAPE_END_OBJECT","ESCAPE_UNDEFINED","CURRENT_VERSION","serializers","Map","serializerInversed","loadedRequests","Set","NOT_SERIALIZABLE","jsTypes","Object","Array","Date","RegExp","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","exports","constructor","Obj","Fn","type","config","from","Type","name","serializer","request","values","loaders","ObjectMiddleware","extendContext","arguments","length","undefined","_hashFunction","registerLoader","regExp","loader","register","Constructor","key","has","registerNotSerializable","getSerializerFor","object","proto","getPrototypeOf","c","get","getDeserializerFor","_getDeserializerForWithoutError","serialize","data","context","result","currentPos","referenceable","addReferenceable","bufferDedupeMap","dedupeBuffer","buf","len","entry","Buffer","isBuffer","equals","newMap","hashBuf","isArray","push","found","itemHash","currentPosTypeLookup","objectTypeLookup","cycleStack","stackToString","arr","JSON","stringify","slice","e","join","toString","message","hasDebugInfoAttached","ctx","write","value","process","WeakSet","add","setCircularReference","ref","snapshot","cycleStackSize","referenceableSize","objectTypeLookupSize","rollback","alreadyUsedBuffer","lastIndex","logger","warn","Math","round","isLazy","serializedData","getLazySerializedValue","serializeLazy","setLazySerializedValue","deserialize","currentDataPos","read","decodeValue","nextItem","loaded","test","end1","end2","err","serializerEntry","deserializeLazy","module"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/serialization/ObjectMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst ArraySerializer = require(\"./ArraySerializer\");\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n * @property {function(any): void} setCircularReference\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\n/**\n * @template T\n * @param {Set<T>} set set\n * @param {number} size count of items to keep\n */\nconst setSetSize = (set, size) => {\n\tlet i = 0;\n\tfor (const item of set) {\n\t\tif (i++ >= size) {\n\t\t\tset.delete(item);\n\t\t}\n\t}\n};\n\n/**\n * @template K, X\n * @param {Map<K, X>} map map\n * @param {number} size count of items to keep\n */\nconst setMapSize = (map, size) => {\n\tlet i = 0;\n\tfor (const item of map.keys()) {\n\t\tif (i++ >= size) {\n\t\t\tmap.delete(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst toHash = (buffer, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(buffer);\n\treturn /** @type {string} */ (hash.digest(\"latin1\"));\n};\n\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\n\nconst CURRENT_VERSION = 2;\n\n/** @type {Map<Constructor, { request?: string, name?: string | number , serializer?: ObjectSerializer }>} */\nconst serializers = new Map();\n/** @type {Map<string | number, ObjectSerializer>} */\nconst serializerInversed = new Map();\n\n/** @type {Set<string>} */\nconst loadedRequests = new Set();\n\nconst NOT_SERIALIZABLE = {};\n\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n\tconst Obj = /** @type {typeof Object} */ (exports.constructor);\n\tconst Fn = /** @type {typeof Function} */ (Obj.constructor);\n\tfor (const [type, config] of Array.from(jsTypes)) {\n\t\tif (type) {\n\t\t\tconst Type = new Fn(`return ${type.name};`)();\n\t\t\tjsTypes.set(Type, config);\n\t\t}\n\t}\n}\n\n{\n\tlet i = 1;\n\tfor (const [type, serializer] of jsTypes) {\n\t\tserializers.set(type, {\n\t\t\trequest: \"\",\n\t\t\tname: i++,\n\t\t\tserializer\n\t\t});\n\t}\n}\n\nfor (const { request, name, serializer } of serializers.values()) {\n\tserializerInversed.set(`${request}/${name}`, serializer);\n}\n\n/** @type {Map<RegExp, (request: string) => boolean>} */\nconst loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass ObjectMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {function(any): void} extendContext context extensions\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(extendContext, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.extendContext = extendContext;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {RegExp} regExp RegExp for which the request is tested\n\t * @param {function(string): boolean} loader loader to load the request, returns true when successful\n\t * @returns {void}\n\t */\n\tstatic registerLoader(regExp, loader) {\n\t\tloaders.set(regExp, loader);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @param {string} request the request which will be required when deserializing\n\t * @param {string} name the name to make multiple serializer unique when sharing a request\n\t * @param {ObjectSerializer} serializer the serializer\n\t * @returns {void}\n\t */\n\tstatic register(Constructor, request, name, serializer) {\n\t\tconst key = request + \"/\" + name;\n\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tif (serializerInversed.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${key} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, {\n\t\t\trequest,\n\t\t\tname,\n\t\t\tserializer\n\t\t});\n\n\t\tserializerInversed.set(key, serializer);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @returns {void}\n\t */\n\tstatic registerNotSerializable(Constructor) {\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, NOT_SERIALIZABLE);\n\t}\n\n\tstatic getSerializerFor(object) {\n\t\tconst proto = Object.getPrototypeOf(object);\n\t\tlet c;\n\t\tif (proto === null) {\n\t\t\t// Object created with Object.create(null)\n\t\t\tc = null;\n\t\t} else {\n\t\t\tc = proto.constructor;\n\t\t\tif (!c) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Serialization of objects with prototype without valid constructor property not possible\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst config = serializers.get(c);\n\n\t\tif (!config) throw new Error(`No serializer registered for ${c.name}`);\n\t\tif (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n\n\t\treturn config;\n\t}\n\n\t/**\n\t * @param {string} request request\n\t * @param {TODO} name name\n\t * @returns {ObjectSerializer} serializer\n\t */\n\tstatic getDeserializerFor(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\n\t\tif (serializer === undefined) {\n\t\t\tthrow new Error(`No deserializer registered for ${key}`);\n\t\t}\n\n\t\treturn serializer;\n\t}\n\n\t/**\n\t * @param {string} request request\n\t * @param {TODO} name name\n\t * @returns {ObjectSerializer} serializer\n\t */\n\tstatic _getDeserializerForWithoutError(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\t\treturn serializer;\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\t/** @type {any[]} */\n\t\tlet result = [CURRENT_VERSION];\n\t\tlet currentPos = 0;\n\t\tlet referenceable = new Map();\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.set(item, currentPos++);\n\t\t};\n\t\tlet bufferDedupeMap = new Map();\n\t\tconst dedupeBuffer = buf => {\n\t\t\tconst len = buf.length;\n\t\t\tconst entry = bufferDedupeMap.get(len);\n\t\t\tif (entry === undefined) {\n\t\t\t\tbufferDedupeMap.set(len, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t\tif (Buffer.isBuffer(entry)) {\n\t\t\t\tif (len < 32) {\n\t\t\t\t\tif (buf.equals(entry)) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, [entry, buf]);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst hash = toHash(entry, this._hashFunction);\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tnewMap.set(hash, entry);\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tconst hashBuf = toHash(buf, this._hashFunction);\n\t\t\t\t\tif (hash === hashBuf) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf;\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(entry)) {\n\t\t\t\tif (entry.length < 16) {\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tif (buf.equals(item)) {\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentry.push(buf);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\t\tlet found;\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tconst itemHash = toHash(item, this._hashFunction);\n\t\t\t\t\t\tnewMap.set(itemHash, item);\n\t\t\t\t\t\tif (found === undefined && itemHash === hash) found = item;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tif (found === undefined) {\n\t\t\t\t\t\tnewMap.set(hash, buf);\n\t\t\t\t\t\treturn buf;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\tconst item = entry.get(hash);\n\t\t\t\tif (item !== undefined) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t\tentry.set(hash, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = new Map();\n\t\tconst cycleStack = new Set();\n\t\tconst stackToString = item => {\n\t\t\tconst arr = Array.from(cycleStack);\n\t\t\tarr.push(item);\n\t\t\treturn arr\n\t\t\t\t.map(item => {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tif (item.length > 100) {\n\t\t\t\t\t\t\treturn `String ${JSON.stringify(item.slice(0, 100)).slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t)}...\"`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `String ${JSON.stringify(item)}`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { request, name } = ObjectMiddleware.getSerializerFor(item);\n\t\t\t\t\t\tif (request) {\n\t\t\t\t\t\t\treturn `${request}${name ? `.${name}` : \"\"}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// ignore -> fallback\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof item === \"object\" && item !== null) {\n\t\t\t\t\t\tif (item.constructor) {\n\t\t\t\t\t\t\tif (item.constructor === Object)\n\t\t\t\t\t\t\t\treturn `Object { ${Object.keys(item).join(\", \")} }`;\n\t\t\t\t\t\t\tif (item.constructor === Map) return `Map { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Array)\n\t\t\t\t\t\t\t\treturn `Array { ${item.length} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Set) return `Set { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === RegExp) return item.toString();\n\t\t\t\t\t\t\treturn `${item.constructor.name}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `Object [null prototype] { ${Object.keys(item).join(\n\t\t\t\t\t\t\t\", \"\n\t\t\t\t\t\t)} }`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn `${item}`;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn `(${e.message})`;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.join(\" -> \");\n\t\t};\n\t\tlet hasDebugInfoAttached;\n\t\tlet ctx = {\n\t\t\twrite(value, key) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e !== NOT_SERIALIZABLE) {\n\t\t\t\t\t\tif (hasDebugInfoAttached === undefined)\n\t\t\t\t\t\t\thasDebugInfoAttached = new WeakSet();\n\t\t\t\t\t\tif (!hasDebugInfoAttached.has(e)) {\n\t\t\t\t\t\t\te.message += `\\nwhile serializing ${stackToString(value)}`;\n\t\t\t\t\t\t\thasDebugInfoAttached.add(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\tsnapshot() {\n\t\t\t\treturn {\n\t\t\t\t\tlength: result.length,\n\t\t\t\t\tcycleStackSize: cycleStack.size,\n\t\t\t\t\treferenceableSize: referenceable.size,\n\t\t\t\t\tcurrentPos,\n\t\t\t\t\tobjectTypeLookupSize: objectTypeLookup.size,\n\t\t\t\t\tcurrentPosTypeLookup\n\t\t\t\t};\n\t\t\t},\n\t\t\trollback(snapshot) {\n\t\t\t\tresult.length = snapshot.length;\n\t\t\t\tsetSetSize(cycleStack, snapshot.cycleStackSize);\n\t\t\t\tsetMapSize(referenceable, snapshot.referenceableSize);\n\t\t\t\tcurrentPos = snapshot.currentPos;\n\t\t\t\tsetMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n\t\t\t\tcurrentPosTypeLookup = snapshot.currentPosTypeLookup;\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst process = item => {\n\t\t\tif (Buffer.isBuffer(item)) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst alreadyUsedBuffer = dedupeBuffer(item);\n\t\t\t\tif (alreadyUsedBuffer !== item) {\n\t\t\t\t\tconst ref = referenceable.get(alreadyUsedBuffer);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\treferenceable.set(item, ref);\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\titem = alreadyUsedBuffer;\n\t\t\t\t}\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (item === ESCAPE) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n\t\t\t} else if (\n\t\t\t\ttypeof item === \"object\"\n\t\t\t\t// We don't have to check for null as ESCAPE is null and this has been checked before\n\t\t\t) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (cycleStack.has(item)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst { request, name, serializer } =\n\t\t\t\t\tObjectMiddleware.getSerializerFor(item);\n\t\t\t\tconst key = `${request}/${name}`;\n\t\t\t\tconst lastIndex = objectTypeLookup.get(key);\n\n\t\t\t\tif (lastIndex === undefined) {\n\t\t\t\t\tobjectTypeLookup.set(key, currentPosTypeLookup++);\n\n\t\t\t\t\tresult.push(ESCAPE, request, name);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(ESCAPE, currentPosTypeLookup - lastIndex);\n\t\t\t\t}\n\n\t\t\t\tcycleStack.add(item);\n\n\t\t\t\ttry {\n\t\t\t\t\tserializer.serialize(item, ctx);\n\t\t\t\t} finally {\n\t\t\t\t\tcycleStack.delete(item);\n\t\t\t\t}\n\n\t\t\t\tresult.push(ESCAPE, ESCAPE_END_OBJECT);\n\n\t\t\t\taddReferenceable(item);\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\t// short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n\t\t\t\t\t// check if we can emit a reference\n\t\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\tif (item.length > 102400 && context.logger) {\n\t\t\t\t\tcontext.logger.warn(\n\t\t\t\t\t\t`Serializing big strings (${Math.round(\n\t\t\t\t\t\t\titem.length / 1024\n\t\t\t\t\t\t)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\t\tthrow new Error(\"Unexpected function \" + item);\n\t\t\t\t/** @type {SerializedType} */\n\t\t\t\tconst serializedData =\n\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(item);\n\t\t\t\tif (serializedData !== undefined) {\n\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\tresult.push(serializedData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t\t}\n\t\t\t\t} else if (SerializerMiddleware.isLazy(item, this)) {\n\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t} else {\n\t\t\t\t\tconst data = SerializerMiddleware.serializeLazy(item, data =>\n\t\t\t\t\t\tthis.serialize([data], context)\n\t\t\t\t\t);\n\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(item, data);\n\t\t\t\t\tresult.push(data);\n\t\t\t\t}\n\t\t\t} else if (item === undefined) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_UNDEFINED);\n\t\t\t} else {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tfor (const item of data) {\n\t\t\t\tprocess(item);\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (e === NOT_SERIALIZABLE) return null;\n\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.write\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n\t\t\tdata =\n\t\t\t\tresult =\n\t\t\t\treferenceable =\n\t\t\t\tbufferDedupeMap =\n\t\t\t\tobjectTypeLookup =\n\t\t\t\tctx =\n\t\t\t\t\tundefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tlet currentDataPos = 0;\n\t\tconst read = () => {\n\t\t\tif (currentDataPos >= data.length)\n\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\n\t\t\treturn data[currentDataPos++];\n\t\t};\n\n\t\tif (read() !== CURRENT_VERSION)\n\t\t\tthrow new Error(\"Version mismatch, serializer changed\");\n\n\t\tlet currentPos = 0;\n\t\tlet referenceable = [];\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.push(item);\n\t\t\tcurrentPos++;\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = [];\n\t\tlet result = [];\n\t\tlet ctx = {\n\t\t\tread() {\n\t\t\t\treturn decodeValue();\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst decodeValue = () => {\n\t\t\tconst item = read();\n\n\t\t\tif (item === ESCAPE) {\n\t\t\t\tconst nextItem = read();\n\n\t\t\t\tif (nextItem === ESCAPE_ESCAPE_VALUE) {\n\t\t\t\t\treturn ESCAPE;\n\t\t\t\t} else if (nextItem === ESCAPE_UNDEFINED) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else if (nextItem === ESCAPE_END_OBJECT) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unexpected end of object at position ${currentDataPos - 1}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst request = nextItem;\n\t\t\t\t\tlet serializer;\n\n\t\t\t\t\tif (typeof request === \"number\") {\n\t\t\t\t\t\tif (request < 0) {\n\t\t\t\t\t\t\t// relative reference\n\t\t\t\t\t\t\treturn referenceable[currentPos + request];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tserializer = objectTypeLookup[currentPosTypeLookup - request];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof request !== \"string\") {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected type (${typeof request}) of request ` +\n\t\t\t\t\t\t\t\t\t`at position ${currentDataPos - 1}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = read();\n\n\t\t\t\t\t\tserializer = ObjectMiddleware._getDeserializerForWithoutError(\n\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (serializer === undefined) {\n\t\t\t\t\t\t\tif (request && !loadedRequests.has(request)) {\n\t\t\t\t\t\t\t\tlet loaded = false;\n\t\t\t\t\t\t\t\tfor (const [regExp, loader] of loaders) {\n\t\t\t\t\t\t\t\t\tif (regExp.test(request)) {\n\t\t\t\t\t\t\t\t\t\tif (loader(request)) {\n\t\t\t\t\t\t\t\t\t\t\tloaded = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!loaded) {\n\t\t\t\t\t\t\t\t\trequire(request);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tloadedRequests.add(request);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tserializer = ObjectMiddleware.getDeserializerFor(request, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectTypeLookup.push(serializer);\n\t\t\t\t\t\tcurrentPosTypeLookup++;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst item = serializer.deserialize(ctx);\n\t\t\t\t\t\tconst end1 = read();\n\n\t\t\t\t\t\tif (end1 !== ESCAPE) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst end2 = read();\n\n\t\t\t\t\t\tif (end2 !== ESCAPE_END_OBJECT) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taddReferenceable(item);\n\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t// As this is only for error handling, we omit creating a Map for\n\t\t\t\t\t\t// faster access to this information, as this would affect performance\n\t\t\t\t\t\t// in the good case\n\t\t\t\t\t\tlet serializerEntry;\n\t\t\t\t\t\tfor (const entry of serializers) {\n\t\t\t\t\t\t\tif (entry[1].serializer === serializer) {\n\t\t\t\t\t\t\t\tserializerEntry = entry;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = !serializerEntry\n\t\t\t\t\t\t\t? \"unknown\"\n\t\t\t\t\t\t\t: !serializerEntry[1].request\n\t\t\t\t\t\t\t? serializerEntry[0].name\n\t\t\t\t\t\t\t: serializerEntry[1].name\n\t\t\t\t\t\t\t? `${serializerEntry[1].request} ${serializerEntry[1].name}`\n\t\t\t\t\t\t\t: serializerEntry[1].request;\n\t\t\t\t\t\terr.message += `\\n(during deserialization of ${name})`;\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\treturn item;\n\t\t\t} else if (Buffer.isBuffer(item)) {\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\treturn item;\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\treturn SerializerMiddleware.deserializeLazy(\n\t\t\t\t\titem,\n\t\t\t\t\tdata => this.deserialize(data, context)[0]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\twhile (currentDataPos < data.length) {\n\t\t\t\tresult.push(decodeValue());\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.read\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n\t\t\tresult = referenceable = data = objectTypeLookup = ctx = undefined;\n\t\t}\n\t}\n}\n\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;\n"],"mappings":"AAAA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAChD,MAAMC,eAAe,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AACpD,MAAME,oBAAoB,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AAC9D,MAAMG,qBAAqB,GAAGH,OAAO,CAAC,yBAAyB,CAAC;AAChE,MAAMI,mBAAmB,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AAC5D,MAAMK,6BAA6B,GAAGL,OAAO,CAAC,iCAAiC,CAAC;AAChF,MAAMM,qBAAqB,GAAGN,OAAO,CAAC,yBAAyB,CAAC;AAChE,MAAMO,sBAAsB,GAAGP,OAAO,CAAC,0BAA0B,CAAC;AAClE,MAAMQ,oBAAoB,GAAGR,OAAO,CAAC,wBAAwB,CAAC;AAC9D,MAAMS,mBAAmB,GAAGT,OAAO,CAAC,uBAAuB,CAAC;;AAE5D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMU,UAAU,GAAGA,CAACC,GAAG,EAAEC,IAAI,KAAK;EACjC,IAAIC,CAAC,GAAG,CAAC;EACT,KAAK,MAAMC,IAAI,IAAIH,GAAG,EAAE;IACvB,IAAIE,CAAC,EAAE,IAAID,IAAI,EAAE;MAChBD,GAAG,CAACI,MAAM,CAACD,IAAI,CAAC;IACjB;EACD;AACD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAME,UAAU,GAAGA,CAACC,GAAG,EAAEL,IAAI,KAAK;EACjC,IAAIC,CAAC,GAAG,CAAC;EACT,KAAK,MAAMC,IAAI,IAAIG,GAAG,CAACC,IAAI,CAAC,CAAC,EAAE;IAC9B,IAAIL,CAAC,EAAE,IAAID,IAAI,EAAE;MAChBK,GAAG,CAACF,MAAM,CAACD,IAAI,CAAC;IACjB;EACD;AACD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMK,MAAM,GAAGA,CAACC,MAAM,EAAEC,YAAY,KAAK;EACxC,MAAMC,IAAI,GAAGvB,UAAU,CAACsB,YAAY,CAAC;EACrCC,IAAI,CAACC,MAAM,CAACH,MAAM,CAAC;EACnB,OAAO,sBAAuBE,IAAI,CAACE,MAAM,CAAC,QAAQ;EAAC;AACpD,CAAC;AAED,MAAMC,MAAM,GAAG,IAAI;AACnB,MAAMC,mBAAmB,GAAG,IAAI;AAChC,MAAMC,iBAAiB,GAAG,IAAI;AAC9B,MAAMC,gBAAgB,GAAG,KAAK;AAE9B,MAAMC,eAAe,GAAG,CAAC;;AAEzB;AACA,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;AAC7B;AACA,MAAMC,kBAAkB,GAAG,IAAID,GAAG,CAAC,CAAC;;AAEpC;AACA,MAAME,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;AAEhC,MAAMC,gBAAgB,GAAG,CAAC,CAAC;AAE3B,MAAMC,OAAO,GAAG,IAAIL,GAAG,CAAC,CAAC;AACzBK,OAAO,CAACzB,GAAG,CAAC0B,MAAM,EAAE,IAAI/B,qBAAqB,CAAC,CAAC,CAAC;AAChD8B,OAAO,CAACzB,GAAG,CAAC2B,KAAK,EAAE,IAAIrC,eAAe,CAAC,CAAC,CAAC;AACzCmC,OAAO,CAACzB,GAAG,CAAC,IAAI,EAAE,IAAIN,6BAA6B,CAAC,CAAC,CAAC;AACtD+B,OAAO,CAACzB,GAAG,CAACoB,GAAG,EAAE,IAAI3B,mBAAmB,CAAC,CAAC,CAAC;AAC3CgC,OAAO,CAACzB,GAAG,CAACuB,GAAG,EAAE,IAAIzB,mBAAmB,CAAC,CAAC,CAAC;AAC3C2B,OAAO,CAACzB,GAAG,CAAC4B,IAAI,EAAE,IAAIrC,oBAAoB,CAAC,CAAC,CAAC;AAC7CkC,OAAO,CAACzB,GAAG,CAAC6B,MAAM,EAAE,IAAIjC,sBAAsB,CAAC,CAAC,CAAC;AACjD6B,OAAO,CAACzB,GAAG,CAAC8B,KAAK,EAAE,IAAItC,qBAAqB,CAACsC,KAAK,CAAC,CAAC;AACpDL,OAAO,CAACzB,GAAG,CAAC+B,SAAS,EAAE,IAAIvC,qBAAqB,CAACuC,SAAS,CAAC,CAAC;AAC5DN,OAAO,CAACzB,GAAG,CAACgC,UAAU,EAAE,IAAIxC,qBAAqB,CAACwC,UAAU,CAAC,CAAC;AAC9DP,OAAO,CAACzB,GAAG,CAACiC,cAAc,EAAE,IAAIzC,qBAAqB,CAACyC,cAAc,CAAC,CAAC;AACtER,OAAO,CAACzB,GAAG,CAACkC,WAAW,EAAE,IAAI1C,qBAAqB,CAAC0C,WAAW,CAAC,CAAC;AAChET,OAAO,CAACzB,GAAG,CAACmC,SAAS,EAAE,IAAI3C,qBAAqB,CAAC2C,SAAS,CAAC,CAAC;;AAE5D;AACA;AACA;AACA,IAAIC,OAAO,CAACC,WAAW,KAAKX,MAAM,EAAE;EACnC,MAAMY,GAAG,GAAG,4BAA8BF,OAAO,CAACC,WAAY;EAC9D,MAAME,EAAE,GAAG,8BAAgCD,GAAG,CAACD,WAAY;EAC3D,KAAK,MAAM,CAACG,IAAI,EAAEC,MAAM,CAAC,IAAId,KAAK,CAACe,IAAI,CAACjB,OAAO,CAAC,EAAE;IACjD,IAAIe,IAAI,EAAE;MACT,MAAMG,IAAI,GAAG,IAAIJ,EAAE,CAAE,UAASC,IAAI,CAACI,IAAK,GAAE,CAAC,CAAC,CAAC;MAC7CnB,OAAO,CAACzB,GAAG,CAAC2C,IAAI,EAAEF,MAAM,CAAC;IAC1B;EACD;AACD;AAEA;EACC,IAAIvC,CAAC,GAAG,CAAC;EACT,KAAK,MAAM,CAACsC,IAAI,EAAEK,UAAU,CAAC,IAAIpB,OAAO,EAAE;IACzCN,WAAW,CAACnB,GAAG,CAACwC,IAAI,EAAE;MACrBM,OAAO,EAAE,EAAE;MACXF,IAAI,EAAE1C,CAAC,EAAE;MACT2C;IACD,CAAC,CAAC;EACH;AACD;AAEA,KAAK,MAAM;EAAEC,OAAO;EAAEF,IAAI;EAAEC;AAAW,CAAC,IAAI1B,WAAW,CAAC4B,MAAM,CAAC,CAAC,EAAE;EACjE1B,kBAAkB,CAACrB,GAAG,CAAE,GAAE8C,OAAQ,IAAGF,IAAK,EAAC,EAAEC,UAAU,CAAC;AACzD;;AAEA;AACA,MAAMG,OAAO,GAAG,IAAI5B,GAAG,CAAC,CAAC;;AAEzB;AACA;AACA;AACA;AACA;AACA,MAAM6B,gBAAgB,SAASpD,oBAAoB,CAAC;EACnD;AACD;AACA;AACA;EACCwC,WAAWA,CAACa,aAAa,EAAwB;IAAA,IAAtBxC,YAAY,GAAAyC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;IAC9C,KAAK,CAAC,CAAC;IACP,IAAI,CAACD,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACI,aAAa,GAAG5C,YAAY;EAClC;EACA;AACD;AACA;AACA;AACA;EACC,OAAO6C,cAAcA,CAACC,MAAM,EAAEC,MAAM,EAAE;IACrCT,OAAO,CAAChD,GAAG,CAACwD,MAAM,EAAEC,MAAM,CAAC;EAC5B;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;EACC,OAAOC,QAAQA,CAACC,WAAW,EAAEb,OAAO,EAAEF,IAAI,EAAEC,UAAU,EAAE;IACvD,MAAMe,GAAG,GAAGd,OAAO,GAAG,GAAG,GAAGF,IAAI;IAEhC,IAAIzB,WAAW,CAAC0C,GAAG,CAACF,WAAW,CAAC,EAAE;MACjC,MAAM,IAAI7B,KAAK,CACb,6CAA4C6B,WAAW,CAACf,IAAK,wBAC/D,CAAC;IACF;IAEA,IAAIvB,kBAAkB,CAACwC,GAAG,CAACD,GAAG,CAAC,EAAE;MAChC,MAAM,IAAI9B,KAAK,CACb,6CAA4C8B,GAAI,wBAClD,CAAC;IACF;IAEAzC,WAAW,CAACnB,GAAG,CAAC2D,WAAW,EAAE;MAC5Bb,OAAO;MACPF,IAAI;MACJC;IACD,CAAC,CAAC;IAEFxB,kBAAkB,CAACrB,GAAG,CAAC4D,GAAG,EAAEf,UAAU,CAAC;EACxC;;EAEA;AACD;AACA;AACA;EACC,OAAOiB,uBAAuBA,CAACH,WAAW,EAAE;IAC3C,IAAIxC,WAAW,CAAC0C,GAAG,CAACF,WAAW,CAAC,EAAE;MACjC,MAAM,IAAI7B,KAAK,CACb,4DAA2D6B,WAAW,CAACf,IAAK,wBAC9E,CAAC;IACF;IAEAzB,WAAW,CAACnB,GAAG,CAAC2D,WAAW,EAAEnC,gBAAgB,CAAC;EAC/C;EAEA,OAAOuC,gBAAgBA,CAACC,MAAM,EAAE;IAC/B,MAAMC,KAAK,GAAGvC,MAAM,CAACwC,cAAc,CAACF,MAAM,CAAC;IAC3C,IAAIG,CAAC;IACL,IAAIF,KAAK,KAAK,IAAI,EAAE;MACnB;MACAE,CAAC,GAAG,IAAI;IACT,CAAC,MAAM;MACNA,CAAC,GAAGF,KAAK,CAAC5B,WAAW;MACrB,IAAI,CAAC8B,CAAC,EAAE;QACP,MAAM,IAAIrC,KAAK,CACd,yFACD,CAAC;MACF;IACD;IACA,MAAMW,MAAM,GAAGtB,WAAW,CAACiD,GAAG,CAACD,CAAC,CAAC;IAEjC,IAAI,CAAC1B,MAAM,EAAE,MAAM,IAAIX,KAAK,CAAE,gCAA+BqC,CAAC,CAACvB,IAAK,EAAC,CAAC;IACtE,IAAIH,MAAM,KAAKjB,gBAAgB,EAAE,MAAMA,gBAAgB;IAEvD,OAAOiB,MAAM;EACd;;EAEA;AACD;AACA;AACA;AACA;EACC,OAAO4B,kBAAkBA,CAACvB,OAAO,EAAEF,IAAI,EAAE;IACxC,MAAMgB,GAAG,GAAGd,OAAO,GAAG,GAAG,GAAGF,IAAI;IAChC,MAAMC,UAAU,GAAGxB,kBAAkB,CAAC+C,GAAG,CAACR,GAAG,CAAC;IAE9C,IAAIf,UAAU,KAAKQ,SAAS,EAAE;MAC7B,MAAM,IAAIvB,KAAK,CAAE,kCAAiC8B,GAAI,EAAC,CAAC;IACzD;IAEA,OAAOf,UAAU;EAClB;;EAEA;AACD;AACA;AACA;AACA;EACC,OAAOyB,+BAA+BA,CAACxB,OAAO,EAAEF,IAAI,EAAE;IACrD,MAAMgB,GAAG,GAAGd,OAAO,GAAG,GAAG,GAAGF,IAAI;IAChC,MAAMC,UAAU,GAAGxB,kBAAkB,CAAC+C,GAAG,CAACR,GAAG,CAAC;IAC9C,OAAOf,UAAU;EAClB;;EAEA;AACD;AACA;AACA;AACA;EACC0B,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAE;IACxB;IACA,IAAIC,MAAM,GAAG,CAACxD,eAAe,CAAC;IAC9B,IAAIyD,UAAU,GAAG,CAAC;IAClB,IAAIC,aAAa,GAAG,IAAIxD,GAAG,CAAC,CAAC;IAC7B,MAAMyD,gBAAgB,GAAG1E,IAAI,IAAI;MAChCyE,aAAa,CAAC5E,GAAG,CAACG,IAAI,EAAEwE,UAAU,EAAE,CAAC;IACtC,CAAC;IACD,IAAIG,eAAe,GAAG,IAAI1D,GAAG,CAAC,CAAC;IAC/B,MAAM2D,YAAY,GAAGC,GAAG,IAAI;MAC3B,MAAMC,GAAG,GAAGD,GAAG,CAAC5B,MAAM;MACtB,MAAM8B,KAAK,GAAGJ,eAAe,CAACV,GAAG,CAACa,GAAG,CAAC;MACtC,IAAIC,KAAK,KAAK7B,SAAS,EAAE;QACxByB,eAAe,CAAC9E,GAAG,CAACiF,GAAG,EAAED,GAAG,CAAC;QAC7B,OAAOA,GAAG;MACX;MACA,IAAIG,MAAM,CAACC,QAAQ,CAACF,KAAK,CAAC,EAAE;QAC3B,IAAID,GAAG,GAAG,EAAE,EAAE;UACb,IAAID,GAAG,CAACK,MAAM,CAACH,KAAK,CAAC,EAAE;YACtB,OAAOA,KAAK;UACb;UACAJ,eAAe,CAAC9E,GAAG,CAACiF,GAAG,EAAE,CAACC,KAAK,EAAEF,GAAG,CAAC,CAAC;UACtC,OAAOA,GAAG;QACX,CAAC,MAAM;UACN,MAAMrE,IAAI,GAAGH,MAAM,CAAC0E,KAAK,EAAE,IAAI,CAAC5B,aAAa,CAAC;UAC9C,MAAMgC,MAAM,GAAG,IAAIlE,GAAG,CAAC,CAAC;UACxBkE,MAAM,CAACtF,GAAG,CAACW,IAAI,EAAEuE,KAAK,CAAC;UACvBJ,eAAe,CAAC9E,GAAG,CAACiF,GAAG,EAAEK,MAAM,CAAC;UAChC,MAAMC,OAAO,GAAG/E,MAAM,CAACwE,GAAG,EAAE,IAAI,CAAC1B,aAAa,CAAC;UAC/C,IAAI3C,IAAI,KAAK4E,OAAO,EAAE;YACrB,OAAOL,KAAK;UACb;UACA,OAAOF,GAAG;QACX;MACD,CAAC,MAAM,IAAIrD,KAAK,CAAC6D,OAAO,CAACN,KAAK,CAAC,EAAE;QAChC,IAAIA,KAAK,CAAC9B,MAAM,GAAG,EAAE,EAAE;UACtB,KAAK,MAAMjD,IAAI,IAAI+E,KAAK,EAAE;YACzB,IAAIF,GAAG,CAACK,MAAM,CAAClF,IAAI,CAAC,EAAE;cACrB,OAAOA,IAAI;YACZ;UACD;UACA+E,KAAK,CAACO,IAAI,CAACT,GAAG,CAAC;UACf,OAAOA,GAAG;QACX,CAAC,MAAM;UACN,MAAMM,MAAM,GAAG,IAAIlE,GAAG,CAAC,CAAC;UACxB,MAAMT,IAAI,GAAGH,MAAM,CAACwE,GAAG,EAAE,IAAI,CAAC1B,aAAa,CAAC;UAC5C,IAAIoC,KAAK;UACT,KAAK,MAAMvF,IAAI,IAAI+E,KAAK,EAAE;YACzB,MAAMS,QAAQ,GAAGnF,MAAM,CAACL,IAAI,EAAE,IAAI,CAACmD,aAAa,CAAC;YACjDgC,MAAM,CAACtF,GAAG,CAAC2F,QAAQ,EAAExF,IAAI,CAAC;YAC1B,IAAIuF,KAAK,KAAKrC,SAAS,IAAIsC,QAAQ,KAAKhF,IAAI,EAAE+E,KAAK,GAAGvF,IAAI;UAC3D;UACA2E,eAAe,CAAC9E,GAAG,CAACiF,GAAG,EAAEK,MAAM,CAAC;UAChC,IAAII,KAAK,KAAKrC,SAAS,EAAE;YACxBiC,MAAM,CAACtF,GAAG,CAACW,IAAI,EAAEqE,GAAG,CAAC;YACrB,OAAOA,GAAG;UACX,CAAC,MAAM;YACN,OAAOU,KAAK;UACb;QACD;MACD,CAAC,MAAM;QACN,MAAM/E,IAAI,GAAGH,MAAM,CAACwE,GAAG,EAAE,IAAI,CAAC1B,aAAa,CAAC;QAC5C,MAAMnD,IAAI,GAAG+E,KAAK,CAACd,GAAG,CAACzD,IAAI,CAAC;QAC5B,IAAIR,IAAI,KAAKkD,SAAS,EAAE;UACvB,OAAOlD,IAAI;QACZ;QACA+E,KAAK,CAAClF,GAAG,CAACW,IAAI,EAAEqE,GAAG,CAAC;QACpB,OAAOA,GAAG;MACX;IACD,CAAC;IACD,IAAIY,oBAAoB,GAAG,CAAC;IAC5B,IAAIC,gBAAgB,GAAG,IAAIzE,GAAG,CAAC,CAAC;IAChC,MAAM0E,UAAU,GAAG,IAAIvE,GAAG,CAAC,CAAC;IAC5B,MAAMwE,aAAa,GAAG5F,IAAI,IAAI;MAC7B,MAAM6F,GAAG,GAAGrE,KAAK,CAACe,IAAI,CAACoD,UAAU,CAAC;MAClCE,GAAG,CAACP,IAAI,CAACtF,IAAI,CAAC;MACd,OAAO6F,GAAG,CACR1F,GAAG,CAACH,IAAI,IAAI;QACZ,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;UAC7B,IAAIA,IAAI,CAACiD,MAAM,GAAG,GAAG,EAAE;YACtB,OAAQ,UAAS6C,IAAI,CAACC,SAAS,CAAC/F,IAAI,CAACgG,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACA,KAAK,CACxD,CAAC,EACD,CAAC,CACF,CAAE,MAAK;UACR;UACA,OAAQ,UAASF,IAAI,CAACC,SAAS,CAAC/F,IAAI,CAAE,EAAC;QACxC;QACA,IAAI;UACH,MAAM;YAAE2C,OAAO;YAAEF;UAAK,CAAC,GAAGK,gBAAgB,CAACc,gBAAgB,CAAC5D,IAAI,CAAC;UACjE,IAAI2C,OAAO,EAAE;YACZ,OAAQ,GAAEA,OAAQ,GAAEF,IAAI,GAAI,IAAGA,IAAK,EAAC,GAAG,EAAG,EAAC;UAC7C;QACD,CAAC,CAAC,OAAOwD,CAAC,EAAE;UACX;QAAA;QAED,IAAI,OAAOjG,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;UAC9C,IAAIA,IAAI,CAACkC,WAAW,EAAE;YACrB,IAAIlC,IAAI,CAACkC,WAAW,KAAKX,MAAM,EAC9B,OAAQ,YAAWA,MAAM,CAACnB,IAAI,CAACJ,IAAI,CAAC,CAACkG,IAAI,CAAC,IAAI,CAAE,IAAG;YACpD,IAAIlG,IAAI,CAACkC,WAAW,KAAKjB,GAAG,EAAE,OAAQ,SAAQjB,IAAI,CAACF,IAAK,UAAS;YACjE,IAAIE,IAAI,CAACkC,WAAW,KAAKV,KAAK,EAC7B,OAAQ,WAAUxB,IAAI,CAACiD,MAAO,UAAS;YACxC,IAAIjD,IAAI,CAACkC,WAAW,KAAKd,GAAG,EAAE,OAAQ,SAAQpB,IAAI,CAACF,IAAK,UAAS;YACjE,IAAIE,IAAI,CAACkC,WAAW,KAAKR,MAAM,EAAE,OAAO1B,IAAI,CAACmG,QAAQ,CAAC,CAAC;YACvD,OAAQ,GAAEnG,IAAI,CAACkC,WAAW,CAACO,IAAK,EAAC;UAClC;UACA,OAAQ,6BAA4BlB,MAAM,CAACnB,IAAI,CAACJ,IAAI,CAAC,CAACkG,IAAI,CACzD,IACD,CAAE,IAAG;QACN;QACA,IAAI;UACH,OAAQ,GAAElG,IAAK,EAAC;QACjB,CAAC,CAAC,OAAOiG,CAAC,EAAE;UACX,OAAQ,IAAGA,CAAC,CAACG,OAAQ,GAAE;QACxB;MACD,CAAC,CAAC,CACDF,IAAI,CAAC,MAAM,CAAC;IACf,CAAC;IACD,IAAIG,oBAAoB;IACxB,IAAIC,GAAG,GAAG;MACTC,KAAKA,CAACC,KAAK,EAAE/C,GAAG,EAAE;QACjB,IAAI;UACHgD,OAAO,CAACD,KAAK,CAAC;QACf,CAAC,CAAC,OAAOP,CAAC,EAAE;UACX,IAAIA,CAAC,KAAK5E,gBAAgB,EAAE;YAC3B,IAAIgF,oBAAoB,KAAKnD,SAAS,EACrCmD,oBAAoB,GAAG,IAAIK,OAAO,CAAC,CAAC;YACrC,IAAI,CAACL,oBAAoB,CAAC3C,GAAG,CAACuC,CAAC,CAAC,EAAE;cACjCA,CAAC,CAACG,OAAO,IAAK,uBAAsBR,aAAa,CAACY,KAAK,CAAE,EAAC;cAC1DH,oBAAoB,CAACM,GAAG,CAACV,CAAC,CAAC;YAC5B;UACD;UACA,MAAMA,CAAC;QACR;MACD,CAAC;MACDW,oBAAoBA,CAACC,GAAG,EAAE;QACzBnC,gBAAgB,CAACmC,GAAG,CAAC;MACtB,CAAC;MACDC,QAAQA,CAAA,EAAG;QACV,OAAO;UACN7D,MAAM,EAAEsB,MAAM,CAACtB,MAAM;UACrB8D,cAAc,EAAEpB,UAAU,CAAC7F,IAAI;UAC/BkH,iBAAiB,EAAEvC,aAAa,CAAC3E,IAAI;UACrC0E,UAAU;UACVyC,oBAAoB,EAAEvB,gBAAgB,CAAC5F,IAAI;UAC3C2F;QACD,CAAC;MACF,CAAC;MACDyB,QAAQA,CAACJ,QAAQ,EAAE;QAClBvC,MAAM,CAACtB,MAAM,GAAG6D,QAAQ,CAAC7D,MAAM;QAC/BrD,UAAU,CAAC+F,UAAU,EAAEmB,QAAQ,CAACC,cAAc,CAAC;QAC/C7G,UAAU,CAACuE,aAAa,EAAEqC,QAAQ,CAACE,iBAAiB,CAAC;QACrDxC,UAAU,GAAGsC,QAAQ,CAACtC,UAAU;QAChCtE,UAAU,CAACwF,gBAAgB,EAAEoB,QAAQ,CAACG,oBAAoB,CAAC;QAC3DxB,oBAAoB,GAAGqB,QAAQ,CAACrB,oBAAoB;MACrD,CAAC;MACD,GAAGnB;IACJ,CAAC;IACD,IAAI,CAACvB,aAAa,CAACuD,GAAG,CAAC;IACvB,MAAMG,OAAO,GAAGzG,IAAI,IAAI;MACvB,IAAIgF,MAAM,CAACC,QAAQ,CAACjF,IAAI,CAAC,EAAE;QAC1B;QACA,MAAM6G,GAAG,GAAGpC,aAAa,CAACR,GAAG,CAACjE,IAAI,CAAC;QACnC,IAAI6G,GAAG,KAAK3D,SAAS,EAAE;UACtBqB,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEkG,GAAG,GAAGrC,UAAU,CAAC;UACrC;QACD;QACA,MAAM2C,iBAAiB,GAAGvC,YAAY,CAAC5E,IAAI,CAAC;QAC5C,IAAImH,iBAAiB,KAAKnH,IAAI,EAAE;UAC/B,MAAM6G,GAAG,GAAGpC,aAAa,CAACR,GAAG,CAACkD,iBAAiB,CAAC;UAChD,IAAIN,GAAG,KAAK3D,SAAS,EAAE;YACtBuB,aAAa,CAAC5E,GAAG,CAACG,IAAI,EAAE6G,GAAG,CAAC;YAC5BtC,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEkG,GAAG,GAAGrC,UAAU,CAAC;YACrC;UACD;UACAxE,IAAI,GAAGmH,iBAAiB;QACzB;QACAzC,gBAAgB,CAAC1E,IAAI,CAAC;QAEtBuE,MAAM,CAACe,IAAI,CAACtF,IAAI,CAAC;MAClB,CAAC,MAAM,IAAIA,IAAI,KAAKW,MAAM,EAAE;QAC3B4D,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEC,mBAAmB,CAAC;MACzC,CAAC,MAAM,IACN,OAAOZ,IAAI,KAAK;MAChB;MAAA,EACC;QACD;QACA,MAAM6G,GAAG,GAAGpC,aAAa,CAACR,GAAG,CAACjE,IAAI,CAAC;QACnC,IAAI6G,GAAG,KAAK3D,SAAS,EAAE;UACtBqB,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEkG,GAAG,GAAGrC,UAAU,CAAC;UACrC;QACD;QAEA,IAAImB,UAAU,CAACjC,GAAG,CAAC1D,IAAI,CAAC,EAAE;UACzB,MAAM,IAAI2B,KAAK,CACb,sJACF,CAAC;QACF;QAEA,MAAM;UAAEgB,OAAO;UAAEF,IAAI;UAAEC;QAAW,CAAC,GAClCI,gBAAgB,CAACc,gBAAgB,CAAC5D,IAAI,CAAC;QACxC,MAAMyD,GAAG,GAAI,GAAEd,OAAQ,IAAGF,IAAK,EAAC;QAChC,MAAM2E,SAAS,GAAG1B,gBAAgB,CAACzB,GAAG,CAACR,GAAG,CAAC;QAE3C,IAAI2D,SAAS,KAAKlE,SAAS,EAAE;UAC5BwC,gBAAgB,CAAC7F,GAAG,CAAC4D,GAAG,EAAEgC,oBAAoB,EAAE,CAAC;UAEjDlB,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEgC,OAAO,EAAEF,IAAI,CAAC;QACnC,CAAC,MAAM;UACN8B,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAE8E,oBAAoB,GAAG2B,SAAS,CAAC;QACtD;QAEAzB,UAAU,CAACgB,GAAG,CAAC3G,IAAI,CAAC;QAEpB,IAAI;UACH0C,UAAU,CAAC0B,SAAS,CAACpE,IAAI,EAAEsG,GAAG,CAAC;QAChC,CAAC,SAAS;UACTX,UAAU,CAAC1F,MAAM,CAACD,IAAI,CAAC;QACxB;QAEAuE,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEE,iBAAiB,CAAC;QAEtC6D,gBAAgB,CAAC1E,IAAI,CAAC;MACvB,CAAC,MAAM,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QACpC,IAAIA,IAAI,CAACiD,MAAM,GAAG,CAAC,EAAE;UACpB;UACA;UACA,MAAM4D,GAAG,GAAGpC,aAAa,CAACR,GAAG,CAACjE,IAAI,CAAC;UACnC,IAAI6G,GAAG,KAAK3D,SAAS,EAAE;YACtBqB,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEkG,GAAG,GAAGrC,UAAU,CAAC;YACrC;UACD;UACAE,gBAAgB,CAAC1E,IAAI,CAAC;QACvB;QAEA,IAAIA,IAAI,CAACiD,MAAM,GAAG,MAAM,IAAIqB,OAAO,CAAC+C,MAAM,EAAE;UAC3C/C,OAAO,CAAC+C,MAAM,CAACC,IAAI,CACjB,4BAA2BC,IAAI,CAACC,KAAK,CACrCxH,IAAI,CAACiD,MAAM,GAAG,IACf,CAAE,iGACH,CAAC;QACF;QAEAsB,MAAM,CAACe,IAAI,CAACtF,IAAI,CAAC;MAClB,CAAC,MAAM,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;QACtC,IAAI,CAACN,oBAAoB,CAAC+H,MAAM,CAACzH,IAAI,CAAC,EACrC,MAAM,IAAI2B,KAAK,CAAC,sBAAsB,GAAG3B,IAAI,CAAC;QAC/C;QACA,MAAM0H,cAAc,GACnBhI,oBAAoB,CAACiI,sBAAsB,CAAC3H,IAAI,CAAC;QAClD,IAAI0H,cAAc,KAAKxE,SAAS,EAAE;UACjC,IAAI,OAAOwE,cAAc,KAAK,UAAU,EAAE;YACzCnD,MAAM,CAACe,IAAI,CAACoC,cAAc,CAAC;UAC5B,CAAC,MAAM;YACN,MAAM,IAAI/F,KAAK,CAAC,iBAAiB,CAAC;UACnC;QACD,CAAC,MAAM,IAAIjC,oBAAoB,CAAC+H,MAAM,CAACzH,IAAI,EAAE,IAAI,CAAC,EAAE;UACnD,MAAM,IAAI2B,KAAK,CAAC,iBAAiB,CAAC;QACnC,CAAC,MAAM;UACN,MAAM0C,IAAI,GAAG3E,oBAAoB,CAACkI,aAAa,CAAC5H,IAAI,EAAEqE,IAAI,IACzD,IAAI,CAACD,SAAS,CAAC,CAACC,IAAI,CAAC,EAAEC,OAAO,CAC/B,CAAC;UACD5E,oBAAoB,CAACmI,sBAAsB,CAAC7H,IAAI,EAAEqE,IAAI,CAAC;UACvDE,MAAM,CAACe,IAAI,CAACjB,IAAI,CAAC;QAClB;MACD,CAAC,MAAM,IAAIrE,IAAI,KAAKkD,SAAS,EAAE;QAC9BqB,MAAM,CAACe,IAAI,CAAC3E,MAAM,EAAEG,gBAAgB,CAAC;MACtC,CAAC,MAAM;QACNyD,MAAM,CAACe,IAAI,CAACtF,IAAI,CAAC;MAClB;IACD,CAAC;IAED,IAAI;MACH,KAAK,MAAMA,IAAI,IAAIqE,IAAI,EAAE;QACxBoC,OAAO,CAACzG,IAAI,CAAC;MACd;MACA,OAAOuE,MAAM;IACd,CAAC,CAAC,OAAO0B,CAAC,EAAE;MACX,IAAIA,CAAC,KAAK5E,gBAAgB,EAAE,OAAO,IAAI;MAEvC,MAAM4E,CAAC;IACR,CAAC,SAAS;MACT;MACA;MACA;MACA;MACA5B,IAAI,GACHE,MAAM,GACNE,aAAa,GACbE,eAAe,GACfe,gBAAgB,GAChBY,GAAG,GACFpD,SAAS;IACZ;EACD;;EAEA;AACD;AACA;AACA;AACA;EACC4E,WAAWA,CAACzD,IAAI,EAAEC,OAAO,EAAE;IAC1B,IAAIyD,cAAc,GAAG,CAAC;IACtB,MAAMC,IAAI,GAAGA,CAAA,KAAM;MAClB,IAAID,cAAc,IAAI1D,IAAI,CAACpB,MAAM,EAChC,MAAM,IAAItB,KAAK,CAAC,0BAA0B,CAAC;MAE5C,OAAO0C,IAAI,CAAC0D,cAAc,EAAE,CAAC;IAC9B,CAAC;IAED,IAAIC,IAAI,CAAC,CAAC,KAAKjH,eAAe,EAC7B,MAAM,IAAIY,KAAK,CAAC,sCAAsC,CAAC;IAExD,IAAI6C,UAAU,GAAG,CAAC;IAClB,IAAIC,aAAa,GAAG,EAAE;IACtB,MAAMC,gBAAgB,GAAG1E,IAAI,IAAI;MAChCyE,aAAa,CAACa,IAAI,CAACtF,IAAI,CAAC;MACxBwE,UAAU,EAAE;IACb,CAAC;IACD,IAAIiB,oBAAoB,GAAG,CAAC;IAC5B,IAAIC,gBAAgB,GAAG,EAAE;IACzB,IAAInB,MAAM,GAAG,EAAE;IACf,IAAI+B,GAAG,GAAG;MACT0B,IAAIA,CAAA,EAAG;QACN,OAAOC,WAAW,CAAC,CAAC;MACrB,CAAC;MACDrB,oBAAoBA,CAACC,GAAG,EAAE;QACzBnC,gBAAgB,CAACmC,GAAG,CAAC;MACtB,CAAC;MACD,GAAGvC;IACJ,CAAC;IACD,IAAI,CAACvB,aAAa,CAACuD,GAAG,CAAC;IACvB,MAAM2B,WAAW,GAAGA,CAAA,KAAM;MACzB,MAAMjI,IAAI,GAAGgI,IAAI,CAAC,CAAC;MAEnB,IAAIhI,IAAI,KAAKW,MAAM,EAAE;QACpB,MAAMuH,QAAQ,GAAGF,IAAI,CAAC,CAAC;QAEvB,IAAIE,QAAQ,KAAKtH,mBAAmB,EAAE;UACrC,OAAOD,MAAM;QACd,CAAC,MAAM,IAAIuH,QAAQ,KAAKpH,gBAAgB,EAAE;UACzC,OAAOoC,SAAS;QACjB,CAAC,MAAM,IAAIgF,QAAQ,KAAKrH,iBAAiB,EAAE;UAC1C,MAAM,IAAIc,KAAK,CACb,wCAAuCoG,cAAc,GAAG,CAAE,EAC5D,CAAC;QACF,CAAC,MAAM;UACN,MAAMpF,OAAO,GAAGuF,QAAQ;UACxB,IAAIxF,UAAU;UAEd,IAAI,OAAOC,OAAO,KAAK,QAAQ,EAAE;YAChC,IAAIA,OAAO,GAAG,CAAC,EAAE;cAChB;cACA,OAAO8B,aAAa,CAACD,UAAU,GAAG7B,OAAO,CAAC;YAC3C;YACAD,UAAU,GAAGgD,gBAAgB,CAACD,oBAAoB,GAAG9C,OAAO,CAAC;UAC9D,CAAC,MAAM;YACN,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;cAChC,MAAM,IAAIhB,KAAK,CACb,oBAAmB,OAAOgB,OAAQ,eAAc,GAC/C,eAAcoF,cAAc,GAAG,CAAE,EACpC,CAAC;YACF;YACA,MAAMtF,IAAI,GAAGuF,IAAI,CAAC,CAAC;YAEnBtF,UAAU,GAAGI,gBAAgB,CAACqB,+BAA+B,CAC5DxB,OAAO,EACPF,IACD,CAAC;YAED,IAAIC,UAAU,KAAKQ,SAAS,EAAE;cAC7B,IAAIP,OAAO,IAAI,CAACxB,cAAc,CAACuC,GAAG,CAACf,OAAO,CAAC,EAAE;gBAC5C,IAAIwF,MAAM,GAAG,KAAK;gBAClB,KAAK,MAAM,CAAC9E,MAAM,EAAEC,MAAM,CAAC,IAAIT,OAAO,EAAE;kBACvC,IAAIQ,MAAM,CAAC+E,IAAI,CAACzF,OAAO,CAAC,EAAE;oBACzB,IAAIW,MAAM,CAACX,OAAO,CAAC,EAAE;sBACpBwF,MAAM,GAAG,IAAI;sBACb;oBACD;kBACD;gBACD;gBACA,IAAI,CAACA,MAAM,EAAE;kBACZjJ,OAAO,CAACyD,OAAO,CAAC;gBACjB;gBAEAxB,cAAc,CAACwF,GAAG,CAAChE,OAAO,CAAC;cAC5B;cAEAD,UAAU,GAAGI,gBAAgB,CAACoB,kBAAkB,CAACvB,OAAO,EAAEF,IAAI,CAAC;YAChE;YAEAiD,gBAAgB,CAACJ,IAAI,CAAC5C,UAAU,CAAC;YACjC+C,oBAAoB,EAAE;UACvB;UACA,IAAI;YACH,MAAMzF,IAAI,GAAG0C,UAAU,CAACoF,WAAW,CAACxB,GAAG,CAAC;YACxC,MAAM+B,IAAI,GAAGL,IAAI,CAAC,CAAC;YAEnB,IAAIK,IAAI,KAAK1H,MAAM,EAAE;cACpB,MAAM,IAAIgB,KAAK,CAAC,wBAAwB,CAAC;YAC1C;YAEA,MAAM2G,IAAI,GAAGN,IAAI,CAAC,CAAC;YAEnB,IAAIM,IAAI,KAAKzH,iBAAiB,EAAE;cAC/B,MAAM,IAAIc,KAAK,CAAC,wBAAwB,CAAC;YAC1C;YAEA+C,gBAAgB,CAAC1E,IAAI,CAAC;YAEtB,OAAOA,IAAI;UACZ,CAAC,CAAC,OAAOuI,GAAG,EAAE;YACb;YACA;YACA;YACA,IAAIC,eAAe;YACnB,KAAK,MAAMzD,KAAK,IAAI/D,WAAW,EAAE;cAChC,IAAI+D,KAAK,CAAC,CAAC,CAAC,CAACrC,UAAU,KAAKA,UAAU,EAAE;gBACvC8F,eAAe,GAAGzD,KAAK;gBACvB;cACD;YACD;YACA,MAAMtC,IAAI,GAAG,CAAC+F,eAAe,GAC1B,SAAS,GACT,CAACA,eAAe,CAAC,CAAC,CAAC,CAAC7F,OAAO,GAC3B6F,eAAe,CAAC,CAAC,CAAC,CAAC/F,IAAI,GACvB+F,eAAe,CAAC,CAAC,CAAC,CAAC/F,IAAI,GACtB,GAAE+F,eAAe,CAAC,CAAC,CAAC,CAAC7F,OAAQ,IAAG6F,eAAe,CAAC,CAAC,CAAC,CAAC/F,IAAK,EAAC,GAC1D+F,eAAe,CAAC,CAAC,CAAC,CAAC7F,OAAO;YAC7B4F,GAAG,CAACnC,OAAO,IAAK,gCAA+B3D,IAAK,GAAE;YACtD,MAAM8F,GAAG;UACV;QACD;MACD,CAAC,MAAM,IAAI,OAAOvI,IAAI,KAAK,QAAQ,EAAE;QACpC,IAAIA,IAAI,CAACiD,MAAM,GAAG,CAAC,EAAE;UACpByB,gBAAgB,CAAC1E,IAAI,CAAC;QACvB;QAEA,OAAOA,IAAI;MACZ,CAAC,MAAM,IAAIgF,MAAM,CAACC,QAAQ,CAACjF,IAAI,CAAC,EAAE;QACjC0E,gBAAgB,CAAC1E,IAAI,CAAC;QAEtB,OAAOA,IAAI;MACZ,CAAC,MAAM,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;QACtC,OAAON,oBAAoB,CAAC+I,eAAe,CAC1CzI,IAAI,EACJqE,IAAI,IAAI,IAAI,CAACyD,WAAW,CAACzD,IAAI,EAAEC,OAAO,CAAC,CAAC,CAAC,CAC1C,CAAC;MACF,CAAC,MAAM;QACN,OAAOtE,IAAI;MACZ;IACD,CAAC;IAED,IAAI;MACH,OAAO+H,cAAc,GAAG1D,IAAI,CAACpB,MAAM,EAAE;QACpCsB,MAAM,CAACe,IAAI,CAAC2C,WAAW,CAAC,CAAC,CAAC;MAC3B;MACA,OAAO1D,MAAM;IACd,CAAC,SAAS;MACT;MACA;MACA;MACA;MACAA,MAAM,GAAGE,aAAa,GAAGJ,IAAI,GAAGqB,gBAAgB,GAAGY,GAAG,GAAGpD,SAAS;IACnE;EACD;AACD;AAEAwF,MAAM,CAACzG,OAAO,GAAGa,gBAAgB;AACjC4F,MAAM,CAACzG,OAAO,CAACZ,gBAAgB,GAAGA,gBAAgB"},"metadata":{},"sourceType":"script","externalDependencies":[]}