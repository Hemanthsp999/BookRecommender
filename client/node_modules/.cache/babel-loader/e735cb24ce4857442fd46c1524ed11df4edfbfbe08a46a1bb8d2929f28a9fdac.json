{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst {\n  topLevelSymbolTag\n} = InnerGraph;\nconst PLUGIN_NAME = \"InnerGraphPlugin\";\nclass InnerGraphPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      const logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n      compilation.dependencyTemplates.set(PureExpressionDependency, new PureExpressionDependency.Template());\n\n      /**\n       * @param {JavascriptParser} parser the parser\n       * @param {Object} parserOptions options\n       * @returns {void}\n       */\n      const handler = (parser, parserOptions) => {\n        const onUsageSuper = sup => {\n          InnerGraph.onUsage(parser.state, usedByExports => {\n            switch (usedByExports) {\n              case undefined:\n              case true:\n                return;\n              default:\n                {\n                  const dep = new PureExpressionDependency(sup.range);\n                  dep.loc = sup.loc;\n                  dep.usedByExports = usedByExports;\n                  parser.state.module.addDependency(dep);\n                  break;\n                }\n            }\n          });\n        };\n        parser.hooks.program.tap(PLUGIN_NAME, () => {\n          InnerGraph.enable(parser.state);\n        });\n        parser.hooks.finish.tap(PLUGIN_NAME, () => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          logger.time(\"infer dependency usage\");\n          InnerGraph.inferDependencyUsage(parser.state);\n          logger.timeAggregate(\"infer dependency usage\");\n        });\n\n        // During prewalking the following datastructures are filled with\n        // nodes that have a TopLevelSymbol assigned and\n        // variables are tagged with the assigned TopLevelSymbol\n\n        // We differ 3 types of nodes:\n        // 1. full statements (export default, function declaration)\n        // 2. classes (class declaration, class expression)\n        // 3. variable declarators (const x = ...)\n\n        /** @type {WeakMap<Node, TopLevelSymbol>} */\n        const statementWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakMap<Node, Node>} */\n        const statementPurePart = new WeakMap();\n\n        /** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n        const classWithTopLevelSymbol = new WeakMap();\n\n        /** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n        const declWithTopLevelSymbol = new WeakMap();\n        /** @type {WeakSet<VariableDeclaratorNode>} */\n        const pureDeclarators = new WeakSet();\n\n        // The following hooks are used during prewalking:\n\n        parser.hooks.preStatement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"FunctionDeclaration\") {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              statementWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n          }\n        });\n        parser.hooks.blockPreStatement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            if (statement.type === \"ClassDeclaration\" && parser.isPure(statement, statement.range[0])) {\n              const name = statement.id ? statement.id.name : \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(statement, fn);\n              return true;\n            }\n            if (statement.type === \"ExportDefaultDeclaration\") {\n              const name = \"*default*\";\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              const decl = statement.declaration;\n              if ((decl.type === \"ClassExpression\" || decl.type === \"ClassDeclaration\") && parser.isPure(decl, decl.range[0])) {\n                classWithTopLevelSymbol.set(decl, fn);\n              } else if (parser.isPure(decl, statement.range[0])) {\n                statementWithTopLevelSymbol.set(statement, fn);\n                if (!decl.type.endsWith(\"FunctionExpression\") && !decl.type.endsWith(\"Declaration\") && decl.type !== \"Literal\") {\n                  statementPurePart.set(statement, decl);\n                }\n              }\n            }\n          }\n        });\n        parser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true && decl.init && decl.id.type === \"Identifier\") {\n            const name = decl.id.name;\n            if (decl.init.type === \"ClassExpression\" && parser.isPure(decl.init, decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              classWithTopLevelSymbol.set(decl.init, fn);\n            } else if (parser.isPure(decl.init, decl.id.range[1])) {\n              const fn = InnerGraph.tagTopLevelSymbol(parser, name);\n              declWithTopLevelSymbol.set(decl, fn);\n              if (!decl.init.type.endsWith(\"FunctionExpression\") && decl.init.type !== \"Literal\") {\n                pureDeclarators.add(decl);\n              }\n              return true;\n            }\n          }\n        });\n\n        // During real walking we set the TopLevelSymbol state to the assigned\n        // TopLevelSymbol by using the fill datastructures.\n\n        // In addition to tracking TopLevelSymbols, we sometimes need to\n        // add a PureExpressionDependency. This is needed to skip execution\n        // of pure expressions, even when they are not dropped due to\n        // minimizing. Otherwise symbols used there might not exist anymore\n        // as they are removed as unused by this optimization\n\n        // When we find a reference to a TopLevelSymbol, we register a\n        // TopLevelSymbol dependency from TopLevelSymbol in state to the\n        // referenced TopLevelSymbol. This way we get a graph of all\n        // TopLevelSymbols.\n\n        // The following hooks are called during walking:\n\n        parser.hooks.statement.tap(PLUGIN_NAME, statement => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            const fn = statementWithTopLevelSymbol.get(statement);\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              const purePart = statementPurePart.get(statement);\n              if (purePart) {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(purePart.range);\n                        dep.loc = statement.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n          }\n        });\n        parser.hooks.classExtendsExpression.tap(PLUGIN_NAME, (expr, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(statement);\n            if (fn && parser.isPure(expr, statement.id ? statement.id.range[1] : statement.range[0])) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              onUsageSuper(expr);\n            }\n          }\n        });\n        parser.hooks.classBodyElement.tap(PLUGIN_NAME, (element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            }\n          }\n        });\n        parser.hooks.classBodyValue.tap(PLUGIN_NAME, (expression, element, classDefinition) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (parser.scope.topLevelScope === true) {\n            const fn = classWithTopLevelSymbol.get(classDefinition);\n            if (fn) {\n              if (!element.static || parser.isPure(expression, element.key ? element.key.range[1] : element.range[0])) {\n                InnerGraph.setTopLevelSymbol(parser.state, fn);\n                if (element.type !== \"MethodDefinition\" && element.static) {\n                  InnerGraph.onUsage(parser.state, usedByExports => {\n                    switch (usedByExports) {\n                      case undefined:\n                      case true:\n                        return;\n                      default:\n                        {\n                          const dep = new PureExpressionDependency(expression.range);\n                          dep.loc = expression.loc;\n                          dep.usedByExports = usedByExports;\n                          parser.state.module.addDependency(dep);\n                          break;\n                        }\n                    }\n                  });\n                }\n              } else {\n                InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              }\n            }\n          }\n        });\n        parser.hooks.declarator.tap(PLUGIN_NAME, (decl, statement) => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          const fn = declWithTopLevelSymbol.get(decl);\n          if (fn) {\n            InnerGraph.setTopLevelSymbol(parser.state, fn);\n            if (pureDeclarators.has(decl)) {\n              if (decl.init.type === \"ClassExpression\") {\n                if (decl.init.superClass) {\n                  onUsageSuper(decl.init.superClass);\n                }\n              } else {\n                InnerGraph.onUsage(parser.state, usedByExports => {\n                  switch (usedByExports) {\n                    case undefined:\n                    case true:\n                      return;\n                    default:\n                      {\n                        const dep = new PureExpressionDependency(decl.init.range);\n                        dep.loc = decl.loc;\n                        dep.usedByExports = usedByExports;\n                        parser.state.module.addDependency(dep);\n                        break;\n                      }\n                  }\n                });\n              }\n            }\n            parser.walkExpression(decl.init);\n            InnerGraph.setTopLevelSymbol(parser.state, undefined);\n            return true;\n          }\n        });\n        parser.hooks.expression.for(topLevelSymbolTag).tap(PLUGIN_NAME, () => {\n          const topLevelSymbol = /** @type {TopLevelSymbol} */\n          parser.currentTagData;\n          const currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(parser.state);\n          InnerGraph.addUsage(parser.state, topLevelSymbol, currentTopLevelSymbol || true);\n        });\n        parser.hooks.assign.for(topLevelSymbolTag).tap(PLUGIN_NAME, expr => {\n          if (!InnerGraph.isEnabled(parser.state)) return;\n          if (expr.operator === \"=\") return true;\n        });\n      };\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, handler);\n      compilation.hooks.finishModules.tap(PLUGIN_NAME, () => {\n        logger.timeAggregateEnd(\"infer dependency usage\");\n      });\n    });\n  }\n}\nmodule.exports = InnerGraphPlugin;","map":{"version":3,"names":["JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","require","PureExpressionDependency","InnerGraph","topLevelSymbolTag","PLUGIN_NAME","InnerGraphPlugin","apply","compiler","hooks","compilation","tap","_ref","normalModuleFactory","logger","getLogger","dependencyTemplates","set","Template","handler","parser","parserOptions","onUsageSuper","sup","onUsage","state","usedByExports","undefined","dep","range","loc","module","addDependency","program","enable","finish","isEnabled","time","inferDependencyUsage","timeAggregate","statementWithTopLevelSymbol","WeakMap","statementPurePart","classWithTopLevelSymbol","declWithTopLevelSymbol","pureDeclarators","WeakSet","preStatement","statement","scope","topLevelScope","type","name","id","fn","tagTopLevelSymbol","blockPreStatement","isPure","decl","declaration","endsWith","preDeclarator","init","add","setTopLevelSymbol","get","purePart","classExtendsExpression","expr","classBodyElement","element","classDefinition","classBodyValue","expression","static","key","declarator","has","superClass","walkExpression","for","topLevelSymbol","currentTagData","currentTopLevelSymbol","getTopLevelSymbol","addUsage","assign","operator","finishModules","timeAggregateEnd","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/InnerGraphPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM\n} = require(\"../ModuleTypeConstants\");\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst { topLevelSymbolTag } = InnerGraph;\n\nconst PLUGIN_NAME = \"InnerGraphPlugin\";\n\nclass InnerGraphPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tPureExpressionDependency,\n\t\t\t\t\tnew PureExpressionDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {Object} parserOptions options\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tconst onUsageSuper = sup => {\n\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(sup.range);\n\t\t\t\t\t\t\t\t\tdep.loc = sup.loc;\n\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tparser.hooks.program.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tInnerGraph.enable(parser.state);\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.finish.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tlogger.time(\"infer dependency usage\");\n\t\t\t\t\t\tInnerGraph.inferDependencyUsage(parser.state);\n\t\t\t\t\t\tlogger.timeAggregate(\"infer dependency usage\");\n\t\t\t\t\t});\n\n\t\t\t\t\t// During prewalking the following datastructures are filled with\n\t\t\t\t\t// nodes that have a TopLevelSymbol assigned and\n\t\t\t\t\t// variables are tagged with the assigned TopLevelSymbol\n\n\t\t\t\t\t// We differ 3 types of nodes:\n\t\t\t\t\t// 1. full statements (export default, function declaration)\n\t\t\t\t\t// 2. classes (class declaration, class expression)\n\t\t\t\t\t// 3. variable declarators (const x = ...)\n\n\t\t\t\t\t/** @type {WeakMap<Node, TopLevelSymbol>} */\n\t\t\t\t\tconst statementWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakMap<Node, Node>} */\n\t\t\t\t\tconst statementPurePart = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n\t\t\t\t\tconst classWithTopLevelSymbol = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n\t\t\t\t\tconst declWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakSet<VariableDeclaratorNode>} */\n\t\t\t\t\tconst pureDeclarators = new WeakSet();\n\n\t\t\t\t\t// The following hooks are used during prewalking:\n\n\t\t\t\t\tparser.hooks.preStatement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (statement.type === \"FunctionDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.blockPreStatement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tstatement.type === \"ClassDeclaration\" &&\n\t\t\t\t\t\t\t\tparser.isPure(statement, statement.range[0])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (statement.type === \"ExportDefaultDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tconst decl = statement.declaration;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t(decl.type === \"ClassExpression\" ||\n\t\t\t\t\t\t\t\t\t\tdecl.type === \"ClassDeclaration\") &&\n\t\t\t\t\t\t\t\t\tparser.isPure(decl, decl.range[0])\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl, statement.range[0])) {\n\t\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"Declaration\") &&\n\t\t\t\t\t\t\t\t\t\tdecl.type !== \"Literal\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tstatementPurePart.set(statement, decl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.preDeclarator.tap(PLUGIN_NAME, (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tparser.scope.topLevelScope === true &&\n\t\t\t\t\t\t\tdecl.init &&\n\t\t\t\t\t\t\tdecl.id.type === \"Identifier\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst name = decl.id.name;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdecl.init.type === \"ClassExpression\" &&\n\t\t\t\t\t\t\t\tparser.isPure(decl.init, decl.id.range[1])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl.init, fn);\n\t\t\t\t\t\t\t} else if (parser.isPure(decl.init, decl.id.range[1])) {\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tdeclWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!decl.init.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\tdecl.init.type !== \"Literal\"\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tpureDeclarators.add(decl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// During real walking we set the TopLevelSymbol state to the assigned\n\t\t\t\t\t// TopLevelSymbol by using the fill datastructures.\n\n\t\t\t\t\t// In addition to tracking TopLevelSymbols, we sometimes need to\n\t\t\t\t\t// add a PureExpressionDependency. This is needed to skip execution\n\t\t\t\t\t// of pure expressions, even when they are not dropped due to\n\t\t\t\t\t// minimizing. Otherwise symbols used there might not exist anymore\n\t\t\t\t\t// as they are removed as unused by this optimization\n\n\t\t\t\t\t// When we find a reference to a TopLevelSymbol, we register a\n\t\t\t\t\t// TopLevelSymbol dependency from TopLevelSymbol in state to the\n\t\t\t\t\t// referenced TopLevelSymbol. This way we get a graph of all\n\t\t\t\t\t// TopLevelSymbols.\n\n\t\t\t\t\t// The following hooks are called during walking:\n\n\t\t\t\t\tparser.hooks.statement.tap(PLUGIN_NAME, statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\n\t\t\t\t\t\t\tconst fn = statementWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\tconst purePart = statementPurePart.get(statement);\n\t\t\t\t\t\t\t\tif (purePart) {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tpurePart.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = statement.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.classExtendsExpression.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(expr, statement) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tfn &&\n\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tstatement.id ? statement.id.range[1] : statement.range[0]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\tonUsageSuper(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyElement.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyValue.tap(\n\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t(expression, element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!element.static ||\n\t\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\t\t\t\telement.key ? element.key.range[1] : element.range[0]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\t\tif (element.type !== \"MethodDefinition\" && element.static) {\n\t\t\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpression.range\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.declarator.tap(PLUGIN_NAME, (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tconst fn = declWithTopLevelSymbol.get(decl);\n\n\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\tif (pureDeclarators.has(decl)) {\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\n\t\t\t\t\t\t\t\t\tif (decl.init.superClass) {\n\t\t\t\t\t\t\t\t\t\tonUsageSuper(decl.init.superClass);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tdecl.init.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = decl.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.walkExpression(decl.init);\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(topLevelSymbolTag)\n\t\t\t\t\t\t.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\tconst topLevelSymbol = /** @type {TopLevelSymbol} */ (\n\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(\n\t\t\t\t\t\t\t\tparser.state\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tInnerGraph.addUsage(\n\t\t\t\t\t\t\t\tparser.state,\n\t\t\t\t\t\t\t\ttopLevelSymbol,\n\t\t\t\t\t\t\t\tcurrentTopLevelSymbol || true\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.assign.for(topLevelSymbolTag).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (expr.operator === \"=\") return true;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\n\t\t\t\tcompilation.hooks.finishModules.tap(PLUGIN_NAME, () => {\n\t\t\t\t\tlogger.timeAggregateEnd(\"infer dependency usage\");\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = InnerGraphPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}