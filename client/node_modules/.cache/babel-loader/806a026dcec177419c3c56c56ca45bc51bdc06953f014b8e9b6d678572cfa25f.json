{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  STAGE_BASIC\n} = require(\"../OptimizationStages\");\nconst {\n  runtimeEqual\n} = require(\"../util/runtime\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass MergeDuplicateChunksPlugin {\n  /**\n   * @param {Compiler} compiler the compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"MergeDuplicateChunksPlugin\", compilation => {\n      compilation.hooks.optimizeChunks.tap({\n        name: \"MergeDuplicateChunksPlugin\",\n        stage: STAGE_BASIC\n      }, chunks => {\n        const {\n          chunkGraph,\n          moduleGraph\n        } = compilation;\n\n        // remember already tested chunks for performance\n        const notDuplicates = new Set();\n\n        // for each chunk\n        for (const chunk of chunks) {\n          // track a Set of all chunk that could be duplicates\n          let possibleDuplicates;\n          for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n            if (possibleDuplicates === undefined) {\n              // when possibleDuplicates is not yet set,\n              // create a new Set from chunks of the current module\n              // including only chunks with the same number of modules\n              for (const dup of chunkGraph.getModuleChunksIterable(module)) {\n                if (dup !== chunk && chunkGraph.getNumberOfChunkModules(chunk) === chunkGraph.getNumberOfChunkModules(dup) && !notDuplicates.has(dup)) {\n                  // delay allocating the new Set until here, reduce memory pressure\n                  if (possibleDuplicates === undefined) {\n                    possibleDuplicates = new Set();\n                  }\n                  possibleDuplicates.add(dup);\n                }\n              }\n              // when no chunk is possible we can break here\n              if (possibleDuplicates === undefined) break;\n            } else {\n              // validate existing possible duplicates\n              for (const dup of possibleDuplicates) {\n                // remove possible duplicate when module is not contained\n                if (!chunkGraph.isModuleInChunk(module, dup)) {\n                  possibleDuplicates.delete(dup);\n                }\n              }\n              // when all chunks has been removed we can break here\n              if (possibleDuplicates.size === 0) break;\n            }\n          }\n\n          // when we found duplicates\n          if (possibleDuplicates !== undefined && possibleDuplicates.size > 0) {\n            outer: for (const otherChunk of possibleDuplicates) {\n              if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;\n              if (chunkGraph.getNumberOfEntryModules(chunk) > 0) continue;\n              if (chunkGraph.getNumberOfEntryModules(otherChunk) > 0) continue;\n              if (!runtimeEqual(chunk.runtime, otherChunk.runtime)) {\n                for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n                  const exportsInfo = moduleGraph.getExportsInfo(module);\n                  if (!exportsInfo.isEquallyUsed(chunk.runtime, otherChunk.runtime)) {\n                    continue outer;\n                  }\n                }\n              }\n              // merge them\n              if (chunkGraph.canChunksBeIntegrated(chunk, otherChunk)) {\n                chunkGraph.integrateChunks(chunk, otherChunk);\n                compilation.chunks.delete(otherChunk);\n              }\n            }\n          }\n\n          // don't check already processed chunks twice\n          notDuplicates.add(chunk);\n        }\n      });\n    });\n  }\n}\nmodule.exports = MergeDuplicateChunksPlugin;","map":{"version":3,"names":["STAGE_BASIC","require","runtimeEqual","MergeDuplicateChunksPlugin","apply","compiler","hooks","compilation","tap","optimizeChunks","name","stage","chunks","chunkGraph","moduleGraph","notDuplicates","Set","chunk","possibleDuplicates","module","getChunkModulesIterable","undefined","dup","getModuleChunksIterable","getNumberOfChunkModules","has","add","isModuleInChunk","delete","size","outer","otherChunk","hasRuntime","getNumberOfEntryModules","runtime","exportsInfo","getExportsInfo","isEquallyUsed","canChunksBeIntegrated","integrateChunks","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/MergeDuplicateChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_BASIC } = require(\"../OptimizationStages\");\nconst { runtimeEqual } = require(\"../util/runtime\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass MergeDuplicateChunksPlugin {\n\t/**\n\t * @param {Compiler} compiler the compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"MergeDuplicateChunksPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"MergeDuplicateChunksPlugin\",\n\t\t\t\t\t\tstage: STAGE_BASIC\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\n\t\t\t\t\t\t// remember already tested chunks for performance\n\t\t\t\t\t\tconst notDuplicates = new Set();\n\n\t\t\t\t\t\t// for each chunk\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t// track a Set of all chunk that could be duplicates\n\t\t\t\t\t\t\tlet possibleDuplicates;\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) {\n\t\t\t\t\t\t\t\t\t// when possibleDuplicates is not yet set,\n\t\t\t\t\t\t\t\t\t// create a new Set from chunks of the current module\n\t\t\t\t\t\t\t\t\t// including only chunks with the same number of modules\n\t\t\t\t\t\t\t\t\tfor (const dup of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tdup !== chunk &&\n\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) ===\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(dup) &&\n\t\t\t\t\t\t\t\t\t\t\t!notDuplicates.has(dup)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t// delay allocating the new Set until here, reduce memory pressure\n\t\t\t\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates = new Set();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates.add(dup);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// when no chunk is possible we can break here\n\t\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) break;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// validate existing possible duplicates\n\t\t\t\t\t\t\t\t\tfor (const dup of possibleDuplicates) {\n\t\t\t\t\t\t\t\t\t\t// remove possible duplicate when module is not contained\n\t\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, dup)) {\n\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates.delete(dup);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// when all chunks has been removed we can break here\n\t\t\t\t\t\t\t\t\tif (possibleDuplicates.size === 0) break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// when we found duplicates\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tpossibleDuplicates !== undefined &&\n\t\t\t\t\t\t\t\tpossibleDuplicates.size > 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\touter: for (const otherChunk of possibleDuplicates) {\n\t\t\t\t\t\t\t\t\tif (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;\n\t\t\t\t\t\t\t\t\tif (chunkGraph.getNumberOfEntryModules(chunk) > 0) continue;\n\t\t\t\t\t\t\t\t\tif (chunkGraph.getNumberOfEntryModules(otherChunk) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif (!runtimeEqual(chunk.runtime, otherChunk.runtime)) {\n\t\t\t\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(\n\t\t\t\t\t\t\t\t\t\t\tchunk\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t!exportsInfo.isEquallyUsed(\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunk.runtime,\n\t\t\t\t\t\t\t\t\t\t\t\t\totherChunk.runtime\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// merge them\n\t\t\t\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(chunk, otherChunk)) {\n\t\t\t\t\t\t\t\t\t\tchunkGraph.integrateChunks(chunk, otherChunk);\n\t\t\t\t\t\t\t\t\t\tcompilation.chunks.delete(otherChunk);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// don't check already processed chunks twice\n\t\t\t\t\t\t\tnotDuplicates.add(chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MergeDuplicateChunksPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}