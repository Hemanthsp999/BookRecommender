{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ConditionalInitFragment = require(\"../ConditionalInitFragment\");\nconst Dependency = require(\"../Dependency\");\nconst HarmonyLinkingError = require(\"../HarmonyLinkingError\");\nconst InitFragment = require(\"../InitFragment\");\nconst Template = require(\"../Template\");\nconst AwaitDependenciesInitFragment = require(\"../async-modules/AwaitDependenciesInitFragment\");\nconst {\n  filterRuntime,\n  mergeRuntime\n} = require(\"../util/runtime\");\nconst ModuleDependency = require(\"./ModuleDependency\");\n\n/** @typedef {import(\"webpack-sources\").ReplaceSource} ReplaceSource */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../javascript/JavascriptParser\").Assertions} Assertions */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ExportPresenceModes = {\n  NONE: /** @type {0} */0,\n  WARN: /** @type {1} */1,\n  AUTO: /** @type {2} */2,\n  ERROR: /** @type {3} */3,\n  fromUserOption(str) {\n    switch (str) {\n      case \"error\":\n        return ExportPresenceModes.ERROR;\n      case \"warn\":\n        return ExportPresenceModes.WARN;\n      case \"auto\":\n        return ExportPresenceModes.AUTO;\n      case false:\n        return ExportPresenceModes.NONE;\n      default:\n        throw new Error(`Invalid export presence value ${str}`);\n    }\n  }\n};\nclass HarmonyImportDependency extends ModuleDependency {\n  /**\n   *\n   * @param {string} request request string\n   * @param {number} sourceOrder source order\n   * @param {Assertions=} assertions import assertions\n   */\n  constructor(request, sourceOrder, assertions) {\n    super(request);\n    this.sourceOrder = sourceOrder;\n    this.assertions = assertions;\n  }\n  get category() {\n    return \"esm\";\n  }\n\n  /**\n   * Returns list of exports referenced by this dependency\n   * @param {ModuleGraph} moduleGraph module graph\n   * @param {RuntimeSpec} runtime the runtime for which the module is analysed\n   * @returns {(string[] | ReferencedExport)[]} referenced exports\n   */\n  getReferencedExports(moduleGraph, runtime) {\n    return Dependency.NO_EXPORTS_REFERENCED;\n  }\n\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {string} name of the variable for the import\n   */\n  getImportVar(moduleGraph) {\n    const module = moduleGraph.getParentModule(this);\n    const meta = moduleGraph.getMeta(module);\n    let importVarMap = meta.importVarMap;\n    if (!importVarMap) meta.importVarMap = importVarMap = new Map();\n    let importVar = importVarMap.get(moduleGraph.getModule(this));\n    if (importVar) return importVar;\n    importVar = `${Template.toIdentifier(`${this.userRequest}`)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`;\n    importVarMap.set(moduleGraph.getModule(this), importVar);\n    return importVar;\n  }\n\n  /**\n   * @param {boolean} update create new variables or update existing one\n   * @param {DependencyTemplateContext} templateContext the template context\n   * @returns {[string, string]} the import statement and the compat statement\n   */\n  getImportStatement(update, _ref) {\n    let {\n      runtimeTemplate,\n      module,\n      moduleGraph,\n      chunkGraph,\n      runtimeRequirements\n    } = _ref;\n    return runtimeTemplate.importStatement({\n      update,\n      module: moduleGraph.getModule(this),\n      chunkGraph,\n      importVar: this.getImportVar(moduleGraph),\n      request: this.request,\n      originModule: module,\n      runtimeRequirements\n    });\n  }\n\n  /**\n   * @param {ModuleGraph} moduleGraph module graph\n   * @param {string[]} ids imported ids\n   * @param {string} additionalMessage extra info included in the error message\n   * @returns {WebpackError[] | undefined} errors\n   */\n  getLinkingErrors(moduleGraph, ids, additionalMessage) {\n    const importedModule = moduleGraph.getModule(this);\n    // ignore errors for missing or failed modules\n    if (!importedModule || importedModule.getNumberOfErrors() > 0) {\n      return;\n    }\n    const parentModule = moduleGraph.getParentModule(this);\n    const exportsType = importedModule.getExportsType(moduleGraph, parentModule.buildMeta.strictHarmonyModule);\n    if (exportsType === \"namespace\" || exportsType === \"default-with-named\") {\n      if (ids.length === 0) {\n        return;\n      }\n      if ((exportsType !== \"default-with-named\" || ids[0] !== \"default\") && moduleGraph.isExportProvided(importedModule, ids) === false) {\n        // We are sure that it's not provided\n\n        // Try to provide detailed info in the error message\n        let pos = 0;\n        let exportsInfo = moduleGraph.getExportsInfo(importedModule);\n        while (pos < ids.length && exportsInfo) {\n          const id = ids[pos++];\n          const exportInfo = exportsInfo.getReadOnlyExportInfo(id);\n          if (exportInfo.provided === false) {\n            // We are sure that it's not provided\n            const providedExports = exportsInfo.getProvidedExports();\n            const moreInfo = !Array.isArray(providedExports) ? \" (possible exports unknown)\" : providedExports.length === 0 ? \" (module has no exports)\" : ` (possible exports: ${providedExports.join(\", \")})`;\n            return [new HarmonyLinkingError(`export ${ids.slice(0, pos).map(id => `'${id}'`).join(\".\")} ${additionalMessage} was not found in '${this.userRequest}'${moreInfo}`)];\n          }\n          exportsInfo = exportInfo.getNestedExportsInfo();\n        }\n\n        // General error message\n        return [new HarmonyLinkingError(`export ${ids.map(id => `'${id}'`).join(\".\")} ${additionalMessage} was not found in '${this.userRequest}'`)];\n      }\n    }\n    switch (exportsType) {\n      case \"default-only\":\n        // It's has only a default export\n        if (ids.length > 0 && ids[0] !== \"default\") {\n          // In strict harmony modules we only support the default export\n          return [new HarmonyLinkingError(`Can't import the named export ${ids.map(id => `'${id}'`).join(\".\")} ${additionalMessage} from default-exporting module (only default export is available)`)];\n        }\n        break;\n      case \"default-with-named\":\n        // It has a default export and named properties redirect\n        // In some cases we still want to warn here\n        if (ids.length > 0 && ids[0] !== \"default\" && importedModule.buildMeta.defaultObject === \"redirect-warn\") {\n          // For these modules only the default export is supported\n          return [new HarmonyLinkingError(`Should not import the named export ${ids.map(id => `'${id}'`).join(\".\")} ${additionalMessage} from default-exporting module (only default export is available soon)`)];\n        }\n        break;\n    }\n  }\n\n  /**\n   * @param {ObjectSerializerContext} context context\n   */\n  serialize(context) {\n    const {\n      write\n    } = context;\n    write(this.sourceOrder);\n    write(this.assertions);\n    super.serialize(context);\n  }\n\n  /**\n   * @param {ObjectDeserializerContext} context context\n   */\n  deserialize(context) {\n    const {\n      read\n    } = context;\n    this.sourceOrder = read();\n    this.assertions = read();\n    super.deserialize(context);\n  }\n}\nmodule.exports = HarmonyImportDependency;\n\n/** @type {WeakMap<Module, WeakMap<Module, RuntimeSpec | boolean>>} */\nconst importEmittedMap = new WeakMap();\nHarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends ModuleDependency.Template {\n  /**\n   * @param {Dependency} dependency the dependency for which the template should be applied\n   * @param {ReplaceSource} source the current replace source which can be modified\n   * @param {DependencyTemplateContext} templateContext the context object\n   * @returns {void}\n   */\n  apply(dependency, source, templateContext) {\n    const dep = /** @type {HarmonyImportDependency} */dependency;\n    const {\n      module,\n      chunkGraph,\n      moduleGraph,\n      runtime\n    } = templateContext;\n    const connection = moduleGraph.getConnection(dep);\n    if (connection && !connection.isTargetActive(runtime)) return;\n    const referencedModule = connection && connection.module;\n    if (connection && connection.weak && referencedModule && chunkGraph.getModuleId(referencedModule) === null) {\n      // in weak references, module might not be in any chunk\n      // but that's ok, we don't need that logic in this case\n      return;\n    }\n    const moduleKey = referencedModule ? referencedModule.identifier() : dep.request;\n    const key = `harmony import ${moduleKey}`;\n    const runtimeCondition = dep.weak ? false : connection ? filterRuntime(runtime, r => connection.isTargetActive(r)) : true;\n    if (module && referencedModule) {\n      let emittedModules = importEmittedMap.get(module);\n      if (emittedModules === undefined) {\n        emittedModules = new WeakMap();\n        importEmittedMap.set(module, emittedModules);\n      }\n      let mergedRuntimeCondition = runtimeCondition;\n      const oldRuntimeCondition = emittedModules.get(referencedModule) || false;\n      if (oldRuntimeCondition !== false && mergedRuntimeCondition !== true) {\n        if (mergedRuntimeCondition === false || oldRuntimeCondition === true) {\n          mergedRuntimeCondition = oldRuntimeCondition;\n        } else {\n          mergedRuntimeCondition = mergeRuntime(oldRuntimeCondition, mergedRuntimeCondition);\n        }\n      }\n      emittedModules.set(referencedModule, mergedRuntimeCondition);\n    }\n    const importStatement = dep.getImportStatement(false, templateContext);\n    if (referencedModule && templateContext.moduleGraph.isAsync(referencedModule)) {\n      templateContext.initFragments.push(new ConditionalInitFragment(importStatement[0], InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder, key, runtimeCondition));\n      templateContext.initFragments.push(new AwaitDependenciesInitFragment(new Set([dep.getImportVar(templateContext.moduleGraph)])));\n      templateContext.initFragments.push(new ConditionalInitFragment(importStatement[1], InitFragment.STAGE_ASYNC_HARMONY_IMPORTS, dep.sourceOrder, key + \" compat\", runtimeCondition));\n    } else {\n      templateContext.initFragments.push(new ConditionalInitFragment(importStatement[0] + importStatement[1], InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder, key, runtimeCondition));\n    }\n  }\n\n  /**\n   *\n   * @param {Module} module the module\n   * @param {Module} referencedModule the referenced module\n   * @returns {RuntimeSpec | boolean} runtimeCondition in which this import has been emitted\n   */\n  static getImportEmittedRuntime(module, referencedModule) {\n    const emittedModules = importEmittedMap.get(module);\n    if (emittedModules === undefined) return false;\n    return emittedModules.get(referencedModule) || false;\n  }\n};\nmodule.exports.ExportPresenceModes = ExportPresenceModes;","map":{"version":3,"names":["ConditionalInitFragment","require","Dependency","HarmonyLinkingError","InitFragment","Template","AwaitDependenciesInitFragment","filterRuntime","mergeRuntime","ModuleDependency","ExportPresenceModes","NONE","WARN","AUTO","ERROR","fromUserOption","str","Error","HarmonyImportDependency","constructor","request","sourceOrder","assertions","category","getReferencedExports","moduleGraph","runtime","NO_EXPORTS_REFERENCED","getImportVar","module","getParentModule","meta","getMeta","importVarMap","Map","importVar","get","getModule","toIdentifier","userRequest","size","set","getImportStatement","update","_ref","runtimeTemplate","chunkGraph","runtimeRequirements","importStatement","originModule","getLinkingErrors","ids","additionalMessage","importedModule","getNumberOfErrors","parentModule","exportsType","getExportsType","buildMeta","strictHarmonyModule","length","isExportProvided","pos","exportsInfo","getExportsInfo","id","exportInfo","getReadOnlyExportInfo","provided","providedExports","getProvidedExports","moreInfo","Array","isArray","join","slice","map","getNestedExportsInfo","defaultObject","serialize","context","write","deserialize","read","exports","importEmittedMap","WeakMap","HarmonyImportDependencyTemplate","apply","dependency","source","templateContext","dep","connection","getConnection","isTargetActive","referencedModule","weak","getModuleId","moduleKey","identifier","key","runtimeCondition","r","emittedModules","undefined","mergedRuntimeCondition","oldRuntimeCondition","isAsync","initFragments","push","STAGE_HARMONY_IMPORTS","Set","STAGE_ASYNC_HARMONY_IMPORTS","getImportEmittedRuntime"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/dependencies/HarmonyImportDependency.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ConditionalInitFragment = require(\"../ConditionalInitFragment\");\nconst Dependency = require(\"../Dependency\");\nconst HarmonyLinkingError = require(\"../HarmonyLinkingError\");\nconst InitFragment = require(\"../InitFragment\");\nconst Template = require(\"../Template\");\nconst AwaitDependenciesInitFragment = require(\"../async-modules/AwaitDependenciesInitFragment\");\nconst { filterRuntime, mergeRuntime } = require(\"../util/runtime\");\nconst ModuleDependency = require(\"./ModuleDependency\");\n\n/** @typedef {import(\"webpack-sources\").ReplaceSource} ReplaceSource */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"../Dependency\").UpdateHashContext} UpdateHashContext */\n/** @typedef {import(\"../DependencyTemplate\").DependencyTemplateContext} DependencyTemplateContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../javascript/JavascriptParser\").Assertions} Assertions */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"../serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ExportPresenceModes = {\n\tNONE: /** @type {0} */ (0),\n\tWARN: /** @type {1} */ (1),\n\tAUTO: /** @type {2} */ (2),\n\tERROR: /** @type {3} */ (3),\n\tfromUserOption(str) {\n\t\tswitch (str) {\n\t\t\tcase \"error\":\n\t\t\t\treturn ExportPresenceModes.ERROR;\n\t\t\tcase \"warn\":\n\t\t\t\treturn ExportPresenceModes.WARN;\n\t\t\tcase \"auto\":\n\t\t\t\treturn ExportPresenceModes.AUTO;\n\t\t\tcase false:\n\t\t\t\treturn ExportPresenceModes.NONE;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid export presence value ${str}`);\n\t\t}\n\t}\n};\n\nclass HarmonyImportDependency extends ModuleDependency {\n\t/**\n\t *\n\t * @param {string} request request string\n\t * @param {number} sourceOrder source order\n\t * @param {Assertions=} assertions import assertions\n\t */\n\tconstructor(request, sourceOrder, assertions) {\n\t\tsuper(request);\n\t\tthis.sourceOrder = sourceOrder;\n\t\tthis.assertions = assertions;\n\t}\n\n\tget category() {\n\t\treturn \"esm\";\n\t}\n\n\t/**\n\t * Returns list of exports referenced by this dependency\n\t * @param {ModuleGraph} moduleGraph module graph\n\t * @param {RuntimeSpec} runtime the runtime for which the module is analysed\n\t * @returns {(string[] | ReferencedExport)[]} referenced exports\n\t */\n\tgetReferencedExports(moduleGraph, runtime) {\n\t\treturn Dependency.NO_EXPORTS_REFERENCED;\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {string} name of the variable for the import\n\t */\n\tgetImportVar(moduleGraph) {\n\t\tconst module = moduleGraph.getParentModule(this);\n\t\tconst meta = moduleGraph.getMeta(module);\n\t\tlet importVarMap = meta.importVarMap;\n\t\tif (!importVarMap) meta.importVarMap = importVarMap = new Map();\n\t\tlet importVar = importVarMap.get(moduleGraph.getModule(this));\n\t\tif (importVar) return importVar;\n\t\timportVar = `${Template.toIdentifier(\n\t\t\t`${this.userRequest}`\n\t\t)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`;\n\t\timportVarMap.set(moduleGraph.getModule(this), importVar);\n\t\treturn importVar;\n\t}\n\n\t/**\n\t * @param {boolean} update create new variables or update existing one\n\t * @param {DependencyTemplateContext} templateContext the template context\n\t * @returns {[string, string]} the import statement and the compat statement\n\t */\n\tgetImportStatement(\n\t\tupdate,\n\t\t{ runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements }\n\t) {\n\t\treturn runtimeTemplate.importStatement({\n\t\t\tupdate,\n\t\t\tmodule: moduleGraph.getModule(this),\n\t\t\tchunkGraph,\n\t\t\timportVar: this.getImportVar(moduleGraph),\n\t\t\trequest: this.request,\n\t\t\toriginModule: module,\n\t\t\truntimeRequirements\n\t\t});\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph module graph\n\t * @param {string[]} ids imported ids\n\t * @param {string} additionalMessage extra info included in the error message\n\t * @returns {WebpackError[] | undefined} errors\n\t */\n\tgetLinkingErrors(moduleGraph, ids, additionalMessage) {\n\t\tconst importedModule = moduleGraph.getModule(this);\n\t\t// ignore errors for missing or failed modules\n\t\tif (!importedModule || importedModule.getNumberOfErrors() > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst parentModule = moduleGraph.getParentModule(this);\n\t\tconst exportsType = importedModule.getExportsType(\n\t\t\tmoduleGraph,\n\t\t\tparentModule.buildMeta.strictHarmonyModule\n\t\t);\n\t\tif (exportsType === \"namespace\" || exportsType === \"default-with-named\") {\n\t\t\tif (ids.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(exportsType !== \"default-with-named\" || ids[0] !== \"default\") &&\n\t\t\t\tmoduleGraph.isExportProvided(importedModule, ids) === false\n\t\t\t) {\n\t\t\t\t// We are sure that it's not provided\n\n\t\t\t\t// Try to provide detailed info in the error message\n\t\t\t\tlet pos = 0;\n\t\t\t\tlet exportsInfo = moduleGraph.getExportsInfo(importedModule);\n\t\t\t\twhile (pos < ids.length && exportsInfo) {\n\t\t\t\t\tconst id = ids[pos++];\n\t\t\t\t\tconst exportInfo = exportsInfo.getReadOnlyExportInfo(id);\n\t\t\t\t\tif (exportInfo.provided === false) {\n\t\t\t\t\t\t// We are sure that it's not provided\n\t\t\t\t\t\tconst providedExports = exportsInfo.getProvidedExports();\n\t\t\t\t\t\tconst moreInfo = !Array.isArray(providedExports)\n\t\t\t\t\t\t\t? \" (possible exports unknown)\"\n\t\t\t\t\t\t\t: providedExports.length === 0\n\t\t\t\t\t\t\t? \" (module has no exports)\"\n\t\t\t\t\t\t\t: ` (possible exports: ${providedExports.join(\", \")})`;\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t\t\t`export ${ids\n\t\t\t\t\t\t\t\t\t.slice(0, pos)\n\t\t\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t\t\t.join(\".\")} ${additionalMessage} was not found in '${\n\t\t\t\t\t\t\t\t\tthis.userRequest\n\t\t\t\t\t\t\t\t}'${moreInfo}`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\texportsInfo = exportInfo.getNestedExportsInfo();\n\t\t\t\t}\n\n\t\t\t\t// General error message\n\t\t\t\treturn [\n\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t`export ${ids\n\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t.join(\".\")} ${additionalMessage} was not found in '${\n\t\t\t\t\t\t\tthis.userRequest\n\t\t\t\t\t\t}'`\n\t\t\t\t\t)\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t\tswitch (exportsType) {\n\t\t\tcase \"default-only\":\n\t\t\t\t// It's has only a default export\n\t\t\t\tif (ids.length > 0 && ids[0] !== \"default\") {\n\t\t\t\t\t// In strict harmony modules we only support the default export\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t\t`Can't import the named export ${ids\n\t\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t\t.join(\n\t\t\t\t\t\t\t\t\t\".\"\n\t\t\t\t\t\t\t\t)} ${additionalMessage} from default-exporting module (only default export is available)`\n\t\t\t\t\t\t)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"default-with-named\":\n\t\t\t\t// It has a default export and named properties redirect\n\t\t\t\t// In some cases we still want to warn here\n\t\t\t\tif (\n\t\t\t\t\tids.length > 0 &&\n\t\t\t\t\tids[0] !== \"default\" &&\n\t\t\t\t\timportedModule.buildMeta.defaultObject === \"redirect-warn\"\n\t\t\t\t) {\n\t\t\t\t\t// For these modules only the default export is supported\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew HarmonyLinkingError(\n\t\t\t\t\t\t\t`Should not import the named export ${ids\n\t\t\t\t\t\t\t\t.map(id => `'${id}'`)\n\t\t\t\t\t\t\t\t.join(\n\t\t\t\t\t\t\t\t\t\".\"\n\t\t\t\t\t\t\t\t)} ${additionalMessage} from default-exporting module (only default export is available soon)`\n\t\t\t\t\t\t)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ObjectSerializerContext} context context\n\t */\n\tserialize(context) {\n\t\tconst { write } = context;\n\t\twrite(this.sourceOrder);\n\t\twrite(this.assertions);\n\t\tsuper.serialize(context);\n\t}\n\n\t/**\n\t * @param {ObjectDeserializerContext} context context\n\t */\n\tdeserialize(context) {\n\t\tconst { read } = context;\n\t\tthis.sourceOrder = read();\n\t\tthis.assertions = read();\n\t\tsuper.deserialize(context);\n\t}\n}\n\nmodule.exports = HarmonyImportDependency;\n\n/** @type {WeakMap<Module, WeakMap<Module, RuntimeSpec | boolean>>} */\nconst importEmittedMap = new WeakMap();\n\nHarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends (\n\tModuleDependency.Template\n) {\n\t/**\n\t * @param {Dependency} dependency the dependency for which the template should be applied\n\t * @param {ReplaceSource} source the current replace source which can be modified\n\t * @param {DependencyTemplateContext} templateContext the context object\n\t * @returns {void}\n\t */\n\tapply(dependency, source, templateContext) {\n\t\tconst dep = /** @type {HarmonyImportDependency} */ (dependency);\n\t\tconst { module, chunkGraph, moduleGraph, runtime } = templateContext;\n\n\t\tconst connection = moduleGraph.getConnection(dep);\n\t\tif (connection && !connection.isTargetActive(runtime)) return;\n\n\t\tconst referencedModule = connection && connection.module;\n\n\t\tif (\n\t\t\tconnection &&\n\t\t\tconnection.weak &&\n\t\t\treferencedModule &&\n\t\t\tchunkGraph.getModuleId(referencedModule) === null\n\t\t) {\n\t\t\t// in weak references, module might not be in any chunk\n\t\t\t// but that's ok, we don't need that logic in this case\n\t\t\treturn;\n\t\t}\n\n\t\tconst moduleKey = referencedModule\n\t\t\t? referencedModule.identifier()\n\t\t\t: dep.request;\n\t\tconst key = `harmony import ${moduleKey}`;\n\n\t\tconst runtimeCondition = dep.weak\n\t\t\t? false\n\t\t\t: connection\n\t\t\t? filterRuntime(runtime, r => connection.isTargetActive(r))\n\t\t\t: true;\n\n\t\tif (module && referencedModule) {\n\t\t\tlet emittedModules = importEmittedMap.get(module);\n\t\t\tif (emittedModules === undefined) {\n\t\t\t\temittedModules = new WeakMap();\n\t\t\t\timportEmittedMap.set(module, emittedModules);\n\t\t\t}\n\t\t\tlet mergedRuntimeCondition = runtimeCondition;\n\t\t\tconst oldRuntimeCondition = emittedModules.get(referencedModule) || false;\n\t\t\tif (oldRuntimeCondition !== false && mergedRuntimeCondition !== true) {\n\t\t\t\tif (mergedRuntimeCondition === false || oldRuntimeCondition === true) {\n\t\t\t\t\tmergedRuntimeCondition = oldRuntimeCondition;\n\t\t\t\t} else {\n\t\t\t\t\tmergedRuntimeCondition = mergeRuntime(\n\t\t\t\t\t\toldRuntimeCondition,\n\t\t\t\t\t\tmergedRuntimeCondition\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\temittedModules.set(referencedModule, mergedRuntimeCondition);\n\t\t}\n\n\t\tconst importStatement = dep.getImportStatement(false, templateContext);\n\t\tif (\n\t\t\treferencedModule &&\n\t\t\ttemplateContext.moduleGraph.isAsync(referencedModule)\n\t\t) {\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew ConditionalInitFragment(\n\t\t\t\t\timportStatement[0],\n\t\t\t\t\tInitFragment.STAGE_HARMONY_IMPORTS,\n\t\t\t\t\tdep.sourceOrder,\n\t\t\t\t\tkey,\n\t\t\t\t\truntimeCondition\n\t\t\t\t)\n\t\t\t);\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew AwaitDependenciesInitFragment(\n\t\t\t\t\tnew Set([dep.getImportVar(templateContext.moduleGraph)])\n\t\t\t\t)\n\t\t\t);\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew ConditionalInitFragment(\n\t\t\t\t\timportStatement[1],\n\t\t\t\t\tInitFragment.STAGE_ASYNC_HARMONY_IMPORTS,\n\t\t\t\t\tdep.sourceOrder,\n\t\t\t\t\tkey + \" compat\",\n\t\t\t\t\truntimeCondition\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\ttemplateContext.initFragments.push(\n\t\t\t\tnew ConditionalInitFragment(\n\t\t\t\t\timportStatement[0] + importStatement[1],\n\t\t\t\t\tInitFragment.STAGE_HARMONY_IMPORTS,\n\t\t\t\t\tdep.sourceOrder,\n\t\t\t\t\tkey,\n\t\t\t\t\truntimeCondition\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module the module\n\t * @param {Module} referencedModule the referenced module\n\t * @returns {RuntimeSpec | boolean} runtimeCondition in which this import has been emitted\n\t */\n\tstatic getImportEmittedRuntime(module, referencedModule) {\n\t\tconst emittedModules = importEmittedMap.get(module);\n\t\tif (emittedModules === undefined) return false;\n\t\treturn emittedModules.get(referencedModule) || false;\n\t}\n};\n\nmodule.exports.ExportPresenceModes = ExportPresenceModes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}