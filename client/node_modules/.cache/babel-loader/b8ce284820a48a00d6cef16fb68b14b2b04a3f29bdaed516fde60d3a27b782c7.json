{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Module\")} Module */\nconst MODULE_REFERENCE_REGEXP = /^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\nconst DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\nconst NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\n\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {number} index\n * @property {Module} module\n */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {number} index\n * @property {Module} module\n * @property {Map<string, string>} exportMap mapping from export name to symbol\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\n * @property {string=} namespaceExportSymbol\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\n\n/**\n * @typedef {Object} ModuleReferenceOptions\n * @property {string[]} ids the properties/exports of the module\n * @property {boolean} call true, when this referenced export is called\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\n */\n\nclass ConcatenationScope {\n  /**\n   * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\n   * @param {ConcatenatedModuleInfo} currentModule the current module info\n   */\n  constructor(modulesMap, currentModule) {\n    this._currentModule = currentModule;\n    if (Array.isArray(modulesMap)) {\n      const map = new Map();\n      for (const info of modulesMap) {\n        map.set(info.module, info);\n      }\n      modulesMap = map;\n    }\n    this._modulesMap = modulesMap;\n  }\n\n  /**\n   * @param {Module} module the referenced module\n   * @returns {boolean} true, when it's in the scope\n   */\n  isModuleInScope(module) {\n    return this._modulesMap.has(module);\n  }\n\n  /**\n   *\n   * @param {string} exportName name of the export\n   * @param {string} symbol identifier of the export in source code\n   */\n  registerExport(exportName, symbol) {\n    if (!this._currentModule.exportMap) {\n      this._currentModule.exportMap = new Map();\n    }\n    if (!this._currentModule.exportMap.has(exportName)) {\n      this._currentModule.exportMap.set(exportName, symbol);\n    }\n  }\n\n  /**\n   *\n   * @param {string} exportName name of the export\n   * @param {string} expression expression to be used\n   */\n  registerRawExport(exportName, expression) {\n    if (!this._currentModule.rawExportMap) {\n      this._currentModule.rawExportMap = new Map();\n    }\n    if (!this._currentModule.rawExportMap.has(exportName)) {\n      this._currentModule.rawExportMap.set(exportName, expression);\n    }\n  }\n\n  /**\n   * @param {string} symbol identifier of the export in source code\n   */\n  registerNamespaceExport(symbol) {\n    this._currentModule.namespaceExportSymbol = symbol;\n  }\n\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {Partial<ModuleReferenceOptions>} options options\n   * @returns {string} the reference as identifier\n   */\n  createModuleReference(module, _ref) {\n    let {\n      ids = undefined,\n      call = false,\n      directImport = false,\n      asiSafe = false\n    } = _ref;\n    const info = this._modulesMap.get(module);\n    const callFlag = call ? \"_call\" : \"\";\n    const directImportFlag = directImport ? \"_directImport\" : \"\";\n    const asiSafeFlag = asiSafe ? \"_asiSafe1\" : asiSafe === false ? \"_asiSafe0\" : \"\";\n    const exportData = ids ? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\") : \"ns\";\n    // a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\n    return `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;\n  }\n\n  /**\n   * @param {string} name the identifier\n   * @returns {boolean} true, when it's an module reference\n   */\n  static isModuleReference(name) {\n    return MODULE_REFERENCE_REGEXP.test(name);\n  }\n\n  /**\n   * @param {string} name the identifier\n   * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\n   */\n  static matchModuleReference(name) {\n    const match = MODULE_REFERENCE_REGEXP.exec(name);\n    if (!match) return null;\n    const index = +match[1];\n    const asiSafe = match[5];\n    return {\n      index,\n      ids: match[2] === \"ns\" ? [] : JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\n      call: !!match[3],\n      directImport: !!match[4],\n      asiSafe: asiSafe ? asiSafe === \"1\" : undefined\n    };\n  }\n}\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\nmodule.exports = ConcatenationScope;","map":{"version":3,"names":["MODULE_REFERENCE_REGEXP","DEFAULT_EXPORT","NAMESPACE_OBJECT_EXPORT","ConcatenationScope","constructor","modulesMap","currentModule","_currentModule","Array","isArray","map","Map","info","set","module","_modulesMap","isModuleInScope","has","registerExport","exportName","symbol","exportMap","registerRawExport","expression","rawExportMap","registerNamespaceExport","namespaceExportSymbol","createModuleReference","_ref","ids","undefined","call","directImport","asiSafe","get","callFlag","directImportFlag","asiSafeFlag","exportData","Buffer","from","JSON","stringify","toString","index","isModuleReference","name","test","matchModuleReference","match","exec","parse","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/ConcatenationScope.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Module\")} Module */\n\nconst MODULE_REFERENCE_REGEXP =\n\t/^__WEBPACK_MODULE_REFERENCE__(\\d+)_([\\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\\d))?__$/;\n\nconst DEFAULT_EXPORT = \"__WEBPACK_DEFAULT_EXPORT__\";\nconst NAMESPACE_OBJECT_EXPORT = \"__WEBPACK_NAMESPACE_OBJECT__\";\n\n/**\n * @typedef {Object} ExternalModuleInfo\n * @property {number} index\n * @property {Module} module\n */\n\n/**\n * @typedef {Object} ConcatenatedModuleInfo\n * @property {number} index\n * @property {Module} module\n * @property {Map<string, string>} exportMap mapping from export name to symbol\n * @property {Map<string, string>} rawExportMap mapping from export name to symbol\n * @property {string=} namespaceExportSymbol\n */\n\n/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo} ModuleInfo */\n\n/**\n * @typedef {Object} ModuleReferenceOptions\n * @property {string[]} ids the properties/exports of the module\n * @property {boolean} call true, when this referenced export is called\n * @property {boolean} directImport true, when this referenced export is directly imported (not via property access)\n * @property {boolean | undefined} asiSafe if the position is ASI safe or unknown\n */\n\nclass ConcatenationScope {\n\t/**\n\t * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module\n\t * @param {ConcatenatedModuleInfo} currentModule the current module info\n\t */\n\tconstructor(modulesMap, currentModule) {\n\t\tthis._currentModule = currentModule;\n\t\tif (Array.isArray(modulesMap)) {\n\t\t\tconst map = new Map();\n\t\t\tfor (const info of modulesMap) {\n\t\t\t\tmap.set(info.module, info);\n\t\t\t}\n\t\t\tmodulesMap = map;\n\t\t}\n\t\tthis._modulesMap = modulesMap;\n\t}\n\n\t/**\n\t * @param {Module} module the referenced module\n\t * @returns {boolean} true, when it's in the scope\n\t */\n\tisModuleInScope(module) {\n\t\treturn this._modulesMap.has(module);\n\t}\n\n\t/**\n\t *\n\t * @param {string} exportName name of the export\n\t * @param {string} symbol identifier of the export in source code\n\t */\n\tregisterExport(exportName, symbol) {\n\t\tif (!this._currentModule.exportMap) {\n\t\t\tthis._currentModule.exportMap = new Map();\n\t\t}\n\t\tif (!this._currentModule.exportMap.has(exportName)) {\n\t\t\tthis._currentModule.exportMap.set(exportName, symbol);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {string} exportName name of the export\n\t * @param {string} expression expression to be used\n\t */\n\tregisterRawExport(exportName, expression) {\n\t\tif (!this._currentModule.rawExportMap) {\n\t\t\tthis._currentModule.rawExportMap = new Map();\n\t\t}\n\t\tif (!this._currentModule.rawExportMap.has(exportName)) {\n\t\t\tthis._currentModule.rawExportMap.set(exportName, expression);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} symbol identifier of the export in source code\n\t */\n\tregisterNamespaceExport(symbol) {\n\t\tthis._currentModule.namespaceExportSymbol = symbol;\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module the referenced module\n\t * @param {Partial<ModuleReferenceOptions>} options options\n\t * @returns {string} the reference as identifier\n\t */\n\tcreateModuleReference(\n\t\tmodule,\n\t\t{ ids = undefined, call = false, directImport = false, asiSafe = false }\n\t) {\n\t\tconst info = this._modulesMap.get(module);\n\t\tconst callFlag = call ? \"_call\" : \"\";\n\t\tconst directImportFlag = directImport ? \"_directImport\" : \"\";\n\t\tconst asiSafeFlag = asiSafe\n\t\t\t? \"_asiSafe1\"\n\t\t\t: asiSafe === false\n\t\t\t? \"_asiSafe0\"\n\t\t\t: \"\";\n\t\tconst exportData = ids\n\t\t\t? Buffer.from(JSON.stringify(ids), \"utf-8\").toString(\"hex\")\n\t\t\t: \"ns\";\n\t\t// a \"._\" is appended to allow \"delete ...\", which would cause a SyntaxError in strict mode\n\t\treturn `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;\n\t}\n\n\t/**\n\t * @param {string} name the identifier\n\t * @returns {boolean} true, when it's an module reference\n\t */\n\tstatic isModuleReference(name) {\n\t\treturn MODULE_REFERENCE_REGEXP.test(name);\n\t}\n\n\t/**\n\t * @param {string} name the identifier\n\t * @returns {ModuleReferenceOptions & { index: number }} parsed options and index\n\t */\n\tstatic matchModuleReference(name) {\n\t\tconst match = MODULE_REFERENCE_REGEXP.exec(name);\n\t\tif (!match) return null;\n\t\tconst index = +match[1];\n\t\tconst asiSafe = match[5];\n\t\treturn {\n\t\t\tindex,\n\t\t\tids:\n\t\t\t\tmatch[2] === \"ns\"\n\t\t\t\t\t? []\n\t\t\t\t\t: JSON.parse(Buffer.from(match[2], \"hex\").toString(\"utf-8\")),\n\t\t\tcall: !!match[3],\n\t\t\tdirectImport: !!match[4],\n\t\t\tasiSafe: asiSafe ? asiSafe === \"1\" : undefined\n\t\t};\n\t}\n}\n\nConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;\nConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;\n\nmodule.exports = ConcatenationScope;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}