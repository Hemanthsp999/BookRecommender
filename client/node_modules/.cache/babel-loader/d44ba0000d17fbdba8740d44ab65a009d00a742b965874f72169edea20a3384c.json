{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\nconst extractPair = pair => {\n  const key = pair[0];\n  const val = pair[1];\n  if (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n    return [key, undefined];\n  } else {\n    return (/** @type {[K, Cell<V>]} */pair\n    );\n  }\n};\n\n/**\n * @template K\n * @template V\n */\nclass StackedMap {\n  /**\n   * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n   */\n  constructor(parentStack) {\n    /** @type {Map<K, InternalCell<V>>} */\n    this.map = new Map();\n    /** @type {Map<K, InternalCell<V>>[]} */\n    this.stack = parentStack === undefined ? [] : parentStack.slice();\n    this.stack.push(this.map);\n  }\n\n  /**\n   * @param {K} item the key of the element to add\n   * @param {V} value the value of the element to add\n   * @returns {void}\n   */\n  set(item, value) {\n    this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n  }\n\n  /**\n   * @param {K} item the item to delete\n   * @returns {void}\n   */\n  delete(item) {\n    if (this.stack.length > 1) {\n      this.map.set(item, TOMBSTONE);\n    } else {\n      this.map.delete(item);\n    }\n  }\n\n  /**\n   * @param {K} item the item to test\n   * @returns {boolean} true if the item exists in this set\n   */\n  has(item) {\n    const topValue = this.map.get(item);\n    if (topValue !== undefined) {\n      return topValue !== TOMBSTONE;\n    }\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value !== TOMBSTONE;\n        }\n      }\n      this.map.set(item, TOMBSTONE);\n    }\n    return false;\n  }\n\n  /**\n   * @param {K} item the key of the element to return\n   * @returns {Cell<V>} the value of the element\n   */\n  get(item) {\n    const topValue = this.map.get(item);\n    if (topValue !== undefined) {\n      return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? undefined : topValue;\n    }\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value === TOMBSTONE || value === UNDEFINED_MARKER ? undefined : value;\n        }\n      }\n      this.map.set(item, TOMBSTONE);\n    }\n    return undefined;\n  }\n  _compress() {\n    if (this.stack.length === 1) return;\n    this.map = new Map();\n    for (const data of this.stack) {\n      for (const pair of data) {\n        if (pair[1] === TOMBSTONE) {\n          this.map.delete(pair[0]);\n        } else {\n          this.map.set(pair[0], pair[1]);\n        }\n      }\n    }\n    this.stack = [this.map];\n  }\n  asArray() {\n    this._compress();\n    return Array.from(this.map.keys());\n  }\n  asSet() {\n    this._compress();\n    return new Set(this.map.keys());\n  }\n  asPairArray() {\n    this._compress();\n    return Array.from(this.map.entries(), extractPair);\n  }\n  asMap() {\n    return new Map(this.asPairArray());\n  }\n  get size() {\n    this._compress();\n    return this.map.size;\n  }\n  createChild() {\n    return new StackedMap(this.stack);\n  }\n}\nmodule.exports = StackedMap;","map":{"version":3,"names":["TOMBSTONE","Symbol","UNDEFINED_MARKER","extractPair","pair","key","val","undefined","StackedMap","constructor","parentStack","map","Map","stack","slice","push","set","item","value","delete","length","has","topValue","get","i","_compress","data","asArray","Array","from","keys","asSet","Set","asPairArray","entries","asMap","size","createChild","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/StackedMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\nconst extractPair = pair => {\n\tconst key = pair[0];\n\tconst val = pair[1];\n\tif (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n\t\treturn [key, undefined];\n\t} else {\n\t\treturn /** @type {[K, Cell<V>]} */ (pair);\n\t}\n};\n\n/**\n * @template K\n * @template V\n */\nclass StackedMap {\n\t/**\n\t * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n\t */\n\tconstructor(parentStack) {\n\t\t/** @type {Map<K, InternalCell<V>>} */\n\t\tthis.map = new Map();\n\t\t/** @type {Map<K, InternalCell<V>>[]} */\n\t\tthis.stack = parentStack === undefined ? [] : parentStack.slice();\n\t\tthis.stack.push(this.map);\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to add\n\t * @param {V} value the value of the element to add\n\t * @returns {void}\n\t */\n\tset(item, value) {\n\t\tthis.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n\t}\n\n\t/**\n\t * @param {K} item the item to delete\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tif (this.stack.length > 1) {\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t} else {\n\t\t\tthis.map.delete(item);\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} item the item to test\n\t * @returns {boolean} true if the item exists in this set\n\t */\n\thas(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue !== TOMBSTONE;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value !== TOMBSTONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to return\n\t * @returns {Cell<V>} the value of the element\n\t */\n\tget(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue === TOMBSTONE || topValue === UNDEFINED_MARKER\n\t\t\t\t? undefined\n\t\t\t\t: topValue;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value === TOMBSTONE || value === UNDEFINED_MARKER\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t_compress() {\n\t\tif (this.stack.length === 1) return;\n\t\tthis.map = new Map();\n\t\tfor (const data of this.stack) {\n\t\t\tfor (const pair of data) {\n\t\t\t\tif (pair[1] === TOMBSTONE) {\n\t\t\t\t\tthis.map.delete(pair[0]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.map.set(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.stack = [this.map];\n\t}\n\n\tasArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.keys());\n\t}\n\n\tasSet() {\n\t\tthis._compress();\n\t\treturn new Set(this.map.keys());\n\t}\n\n\tasPairArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.entries(), extractPair);\n\t}\n\n\tasMap() {\n\t\treturn new Map(this.asPairArray());\n\t}\n\n\tget size() {\n\t\tthis._compress();\n\t\treturn this.map.size;\n\t}\n\n\tcreateChild() {\n\t\treturn new StackedMap(this.stack);\n\t}\n}\n\nmodule.exports = StackedMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}