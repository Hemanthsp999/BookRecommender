{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @template T @typedef {(string | Record<string, string | string[] | T>)[] | Record<string, string | string[] | T>} ContainerOptionsFormat */\n\n/**\n * @template T\n * @template N\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : N} normalizeSimple normalize a simple item\n * @param {function(T, string) : N} normalizeOptions normalize a complex item\n * @param {function(string, N): void} fn processing function\n * @returns {void}\n */\nconst process = (options, normalizeSimple, normalizeOptions, fn) => {\n  const array = items => {\n    for (const item of items) {\n      if (typeof item === \"string\") {\n        fn(item, normalizeSimple(item, item));\n      } else if (item && typeof item === \"object\") {\n        object(item);\n      } else {\n        throw new Error(\"Unexpected options format\");\n      }\n    }\n  };\n  const object = obj => {\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === \"string\" || Array.isArray(value)) {\n        fn(key, normalizeSimple(value, key));\n      } else {\n        fn(key, normalizeOptions(value, key));\n      }\n    }\n  };\n  if (!options) {\n    return;\n  } else if (Array.isArray(options)) {\n    array(options);\n  } else if (typeof options === \"object\") {\n    object(options);\n  } else {\n    throw new Error(\"Unexpected options format\");\n  }\n};\n\n/**\n * @template T\n * @template R\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : R} normalizeSimple normalize a simple item\n * @param {function(T, string) : R} normalizeOptions normalize a complex item\n * @returns {[string, R][]} parsed options\n */\nconst parseOptions = (options, normalizeSimple, normalizeOptions) => {\n  /** @type {[string, R][]} */\n  const items = [];\n  process(options, normalizeSimple, normalizeOptions, (key, value) => {\n    items.push([key, value]);\n  });\n  return items;\n};\n\n/**\n * @template T\n * @param {string} scope scope name\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @returns {Record<string, string | string[] | T>} options to spread or pass\n */\nconst scope = (scope, options) => {\n  /** @type {Record<string, string | string[] | T>} */\n  const obj = {};\n  process(options, item => /** @type {string | string[] | T} */item, item => /** @type {string | string[] | T} */item, (key, value) => {\n    obj[key.startsWith(\"./\") ? `${scope}${key.slice(1)}` : `${scope}/${key}`] = value;\n  });\n  return obj;\n};\nexports.parseOptions = parseOptions;\nexports.scope = scope;","map":{"version":3,"names":["process","options","normalizeSimple","normalizeOptions","fn","array","items","item","object","Error","obj","key","value","Object","entries","Array","isArray","parseOptions","push","scope","startsWith","slice","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/container/options.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @template T @typedef {(string | Record<string, string | string[] | T>)[] | Record<string, string | string[] | T>} ContainerOptionsFormat */\n\n/**\n * @template T\n * @template N\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : N} normalizeSimple normalize a simple item\n * @param {function(T, string) : N} normalizeOptions normalize a complex item\n * @param {function(string, N): void} fn processing function\n * @returns {void}\n */\nconst process = (options, normalizeSimple, normalizeOptions, fn) => {\n\tconst array = items => {\n\t\tfor (const item of items) {\n\t\t\tif (typeof item === \"string\") {\n\t\t\t\tfn(item, normalizeSimple(item, item));\n\t\t\t} else if (item && typeof item === \"object\") {\n\t\t\t\tobject(item);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected options format\");\n\t\t\t}\n\t\t}\n\t};\n\tconst object = obj => {\n\t\tfor (const [key, value] of Object.entries(obj)) {\n\t\t\tif (typeof value === \"string\" || Array.isArray(value)) {\n\t\t\t\tfn(key, normalizeSimple(value, key));\n\t\t\t} else {\n\t\t\t\tfn(key, normalizeOptions(value, key));\n\t\t\t}\n\t\t}\n\t};\n\tif (!options) {\n\t\treturn;\n\t} else if (Array.isArray(options)) {\n\t\tarray(options);\n\t} else if (typeof options === \"object\") {\n\t\tobject(options);\n\t} else {\n\t\tthrow new Error(\"Unexpected options format\");\n\t}\n};\n\n/**\n * @template T\n * @template R\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @param {function(string | string[], string) : R} normalizeSimple normalize a simple item\n * @param {function(T, string) : R} normalizeOptions normalize a complex item\n * @returns {[string, R][]} parsed options\n */\nconst parseOptions = (options, normalizeSimple, normalizeOptions) => {\n\t/** @type {[string, R][]} */\n\tconst items = [];\n\tprocess(options, normalizeSimple, normalizeOptions, (key, value) => {\n\t\titems.push([key, value]);\n\t});\n\treturn items;\n};\n\n/**\n * @template T\n * @param {string} scope scope name\n * @param {ContainerOptionsFormat<T>} options options passed by the user\n * @returns {Record<string, string | string[] | T>} options to spread or pass\n */\nconst scope = (scope, options) => {\n\t/** @type {Record<string, string | string[] | T>} */\n\tconst obj = {};\n\tprocess(\n\t\toptions,\n\t\titem => /** @type {string | string[] | T} */ (item),\n\t\titem => /** @type {string | string[] | T} */ (item),\n\t\t(key, value) => {\n\t\t\tobj[\n\t\t\t\tkey.startsWith(\"./\") ? `${scope}${key.slice(1)}` : `${scope}/${key}`\n\t\t\t] = value;\n\t\t}\n\t);\n\treturn obj;\n};\n\nexports.parseOptions = parseOptions;\nexports.scope = scope;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,OAAO,GAAGA,CAACC,OAAO,EAAEC,eAAe,EAAEC,gBAAgB,EAAEC,EAAE,KAAK;EACnE,MAAMC,KAAK,GAAGC,KAAK,IAAI;IACtB,KAAK,MAAMC,IAAI,IAAID,KAAK,EAAE;MACzB,IAAI,OAAOC,IAAI,KAAK,QAAQ,EAAE;QAC7BH,EAAE,CAACG,IAAI,EAAEL,eAAe,CAACK,IAAI,EAAEA,IAAI,CAAC,CAAC;MACtC,CAAC,MAAM,IAAIA,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QAC5CC,MAAM,CAACD,IAAI,CAAC;MACb,CAAC,MAAM;QACN,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;MAC7C;IACD;EACD,CAAC;EACD,MAAMD,MAAM,GAAGE,GAAG,IAAI;IACrB,KAAK,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACJ,GAAG,CAAC,EAAE;MAC/C,IAAI,OAAOE,KAAK,KAAK,QAAQ,IAAIG,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,EAAE;QACtDR,EAAE,CAACO,GAAG,EAAET,eAAe,CAACU,KAAK,EAAED,GAAG,CAAC,CAAC;MACrC,CAAC,MAAM;QACNP,EAAE,CAACO,GAAG,EAAER,gBAAgB,CAACS,KAAK,EAAED,GAAG,CAAC,CAAC;MACtC;IACD;EACD,CAAC;EACD,IAAI,CAACV,OAAO,EAAE;IACb;EACD,CAAC,MAAM,IAAIc,KAAK,CAACC,OAAO,CAACf,OAAO,CAAC,EAAE;IAClCI,KAAK,CAACJ,OAAO,CAAC;EACf,CAAC,MAAM,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IACvCO,MAAM,CAACP,OAAO,CAAC;EAChB,CAAC,MAAM;IACN,MAAM,IAAIQ,KAAK,CAAC,2BAA2B,CAAC;EAC7C;AACD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMQ,YAAY,GAAGA,CAAChB,OAAO,EAAEC,eAAe,EAAEC,gBAAgB,KAAK;EACpE;EACA,MAAMG,KAAK,GAAG,EAAE;EAChBN,OAAO,CAACC,OAAO,EAAEC,eAAe,EAAEC,gBAAgB,EAAE,CAACQ,GAAG,EAAEC,KAAK,KAAK;IACnEN,KAAK,CAACY,IAAI,CAAC,CAACP,GAAG,EAAEC,KAAK,CAAC,CAAC;EACzB,CAAC,CAAC;EACF,OAAON,KAAK;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMa,KAAK,GAAGA,CAACA,KAAK,EAAElB,OAAO,KAAK;EACjC;EACA,MAAMS,GAAG,GAAG,CAAC,CAAC;EACdV,OAAO,CACNC,OAAO,EACPM,IAAI,IAAI,oCAAsCA,IAAK,EACnDA,IAAI,IAAI,oCAAsCA,IAAK,EACnD,CAACI,GAAG,EAAEC,KAAK,KAAK;IACfF,GAAG,CACFC,GAAG,CAACS,UAAU,CAAC,IAAI,CAAC,GAAI,GAAED,KAAM,GAAER,GAAG,CAACU,KAAK,CAAC,CAAC,CAAE,EAAC,GAAI,GAAEF,KAAM,IAAGR,GAAI,EAAC,CACpE,GAAGC,KAAK;EACV,CACD,CAAC;EACD,OAAOF,GAAG;AACX,CAAC;AAEDY,OAAO,CAACL,YAAY,GAAGA,YAAY;AACnCK,OAAO,CAACH,KAAK,GAAGA,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}