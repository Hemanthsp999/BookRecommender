{"ast":null,"code":"'use strict';\n\nconst os = require('os');\nconst onExit = require('signal-exit');\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nconst spawnedKill = function (kill) {\n  let signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const killResult = kill(signal);\n  setKillTimeout(kill, signal, options, killResult);\n  return killResult;\n};\nconst setKillTimeout = (kill, signal, options, killResult) => {\n  if (!shouldForceKill(signal, options, killResult)) {\n    return;\n  }\n  const timeout = getForceKillAfterTimeout(options);\n  const t = setTimeout(() => {\n    kill('SIGKILL');\n  }, timeout);\n\n  // Guarded because there's no `.unref()` when `execa` is used in the renderer\n  // process in Electron. This cannot be tested since we don't run tests in\n  // Electron.\n  // istanbul ignore else\n  if (t.unref) {\n    t.unref();\n  }\n};\nconst shouldForceKill = (signal, _ref, killResult) => {\n  let {\n    forceKillAfterTimeout\n  } = _ref;\n  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\nconst isSigterm = signal => {\n  return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';\n};\nconst getForceKillAfterTimeout = _ref2 => {\n  let {\n    forceKillAfterTimeout = true\n  } = _ref2;\n  if (forceKillAfterTimeout === true) {\n    return DEFAULT_FORCE_KILL_TIMEOUT;\n  }\n  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n    throw new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n  }\n  return forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nconst spawnedCancel = (spawned, context) => {\n  const killResult = spawned.kill();\n  if (killResult) {\n    context.isCanceled = true;\n  }\n};\nconst timeoutKill = (spawned, signal, reject) => {\n  spawned.kill(signal);\n  reject(Object.assign(new Error('Timed out'), {\n    timedOut: true,\n    signal\n  }));\n};\n\n// `timeout` option handling\nconst setupTimeout = (spawned, _ref3, spawnedPromise) => {\n  let {\n    timeout,\n    killSignal = 'SIGTERM'\n  } = _ref3;\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise;\n  }\n  let timeoutId;\n  const timeoutPromise = new Promise((resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      timeoutKill(spawned, killSignal, reject);\n    }, timeout);\n  });\n  const safeSpawnedPromise = spawnedPromise.finally(() => {\n    clearTimeout(timeoutId);\n  });\n  return Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\nconst validateTimeout = _ref4 => {\n  let {\n    timeout\n  } = _ref4;\n  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n    throw new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n  }\n};\n\n// `cleanup` option handling\nconst setExitHandler = async (spawned, _ref5, timedPromise) => {\n  let {\n    cleanup,\n    detached\n  } = _ref5;\n  if (!cleanup || detached) {\n    return timedPromise;\n  }\n  const removeExitHandler = onExit(() => {\n    spawned.kill();\n  });\n  return timedPromise.finally(() => {\n    removeExitHandler();\n  });\n};\nmodule.exports = {\n  spawnedKill,\n  spawnedCancel,\n  setupTimeout,\n  validateTimeout,\n  setExitHandler\n};","map":{"version":3,"names":["os","require","onExit","DEFAULT_FORCE_KILL_TIMEOUT","spawnedKill","kill","signal","arguments","length","undefined","options","killResult","setKillTimeout","shouldForceKill","timeout","getForceKillAfterTimeout","t","setTimeout","unref","_ref","forceKillAfterTimeout","isSigterm","constants","signals","SIGTERM","toUpperCase","_ref2","Number","isFinite","TypeError","spawnedCancel","spawned","context","isCanceled","timeoutKill","reject","Object","assign","Error","timedOut","setupTimeout","_ref3","spawnedPromise","killSignal","timeoutId","timeoutPromise","Promise","resolve","safeSpawnedPromise","finally","clearTimeout","race","validateTimeout","_ref4","setExitHandler","_ref5","timedPromise","cleanup","detached","removeExitHandler","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/execa/lib/kill.js"],"sourcesContent":["'use strict';\nconst os = require('os');\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nconst spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {\n\treturn isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n\treturn signal === os.constants.signals.SIGTERM ||\n\t\t(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n};\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nconst spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nconst setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nconst validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nconst setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n\nmodule.exports = {\n\tspawnedKill,\n\tspawnedCancel,\n\tsetupTimeout,\n\tvalidateTimeout,\n\tsetExitHandler\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}