{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let dist = 0;\n  for (let i = 0; i < l; i++) {\n    const ca = a.charCodeAt(i);\n    const cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n  return dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b, usedNames) => {\n  const l = Math.min(a.length, b.length);\n  let i = 0;\n  while (i < l) {\n    if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n      i++;\n      break;\n    }\n    i++;\n  }\n  while (i < l) {\n    const name = a.slice(0, i);\n    const lowerName = name.toLowerCase();\n    if (!usedNames.has(lowerName)) {\n      usedNames.add(lowerName);\n      return name;\n    }\n    i++;\n  }\n  // names always contain a hash, so this is always unique\n  // we don't need to check usedNames nor add it\n  return a;\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst addSizeTo = (total, size) => {\n  for (const key of Object.keys(size)) {\n    total[key] = (total[key] || 0) + size[key];\n  }\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst subtractSizeFrom = (total, size) => {\n  for (const key of Object.keys(size)) {\n    total[key] -= size[key];\n  }\n};\n\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\nconst sumSize = nodes => {\n  const sum = Object.create(null);\n  for (const node of nodes) {\n    addSizeTo(sum, node.size);\n  }\n  return sum;\n};\nconst isTooBig = (size, maxSize) => {\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const maxSizeValue = maxSize[key];\n    if (typeof maxSizeValue === \"number\") {\n      if (s > maxSizeValue) return true;\n    }\n  }\n  return false;\n};\nconst isTooSmall = (size, minSize) => {\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const minSizeValue = minSize[key];\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) return true;\n    }\n  }\n  return false;\n};\nconst getTooSmallTypes = (size, minSize) => {\n  const types = new Set();\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const minSizeValue = minSize[key];\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) types.add(key);\n    }\n  }\n  return types;\n};\nconst getNumberOfMatchingSizeTypes = (size, types) => {\n  let i = 0;\n  for (const key of Object.keys(size)) {\n    if (size[key] !== 0 && types.has(key)) i++;\n  }\n  return i;\n};\nconst selectiveSizeSum = (size, types) => {\n  let sum = 0;\n  for (const key of Object.keys(size)) {\n    if (size[key] !== 0 && types.has(key)) sum += size[key];\n  }\n  return sum;\n};\n\n/**\n * @template T\n */\nclass Node {\n  /**\n   * @param {T} item item\n   * @param {string} key key\n   * @param {Record<string, number>} size size\n   */\n  constructor(item, key, size) {\n    this.item = item;\n    this.key = key;\n    this.size = size;\n  }\n}\n\n/**\n * @template T\n */\nclass Group {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   * @param {Record<string, number>=} size size of the group\n   */\n  constructor(nodes, similarities, size) {\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = size || sumSize(nodes);\n    /** @type {string} */\n    this.key = undefined;\n  }\n\n  /**\n   * @param {function(Node): boolean} filter filter function\n   * @returns {Node[]} removed nodes\n   */\n  popNodes(filter) {\n    const newNodes = [];\n    const newSimilarities = [];\n    const resultNodes = [];\n    let lastNode;\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i];\n      if (filter(node)) {\n        resultNodes.push(node);\n      } else {\n        if (newNodes.length > 0) {\n          newSimilarities.push(lastNode === this.nodes[i - 1] ? this.similarities[i - 1] : similarity(lastNode.key, node.key));\n        }\n        newNodes.push(node);\n        lastNode = node;\n      }\n    }\n    if (resultNodes.length === this.nodes.length) return undefined;\n    this.nodes = newNodes;\n    this.similarities = newSimilarities;\n    this.size = sumSize(newNodes);\n    return resultNodes;\n  }\n}\n\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\nconst getSimilarities = nodes => {\n  // calculate similarities between lexically adjacent nodes\n  /** @type {number[]} */\n  const similarities = [];\n  let last = undefined;\n  for (const node of nodes) {\n    if (last !== undefined) {\n      similarities.push(similarity(last.key, node.key));\n    }\n    last = node;\n  }\n  return similarities;\n};\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = _ref => {\n  let {\n    maxSize,\n    minSize,\n    items,\n    getSize,\n    getKey\n  } = _ref;\n  /** @type {Group<T>[]} */\n  const result = [];\n  const nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item)));\n\n  /** @type {Node<T>[]} */\n  const initialNodes = [];\n\n  // lexically ordering of keys\n  nodes.sort((a, b) => {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  });\n\n  // return nodes bigger than maxSize directly as group\n  // But make sure that minSize is not violated\n  for (const node of nodes) {\n    if (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n  if (initialNodes.length > 0) {\n    const initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n    const removeProblematicNodes = function (group) {\n      let consideredSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : group.size;\n      const problemTypes = getTooSmallTypes(consideredSize, minSize);\n      if (problemTypes.size > 0) {\n        // We hit an edge case where the working set is already smaller than minSize\n        // We merge problematic nodes with the smallest result node to keep minSize intact\n        const problemNodes = group.popNodes(n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0);\n        if (problemNodes === undefined) return false;\n        // Only merge it with result nodes that have the problematic size type\n        const possibleResultGroups = result.filter(n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0);\n        if (possibleResultGroups.length > 0) {\n          const bestGroup = possibleResultGroups.reduce((min, group) => {\n            const minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n            const groupMatches = getNumberOfMatchingSizeTypes(group, problemTypes);\n            if (minMatches !== groupMatches) return minMatches < groupMatches ? group : min;\n            if (selectiveSizeSum(min.size, problemTypes) > selectiveSizeSum(group.size, problemTypes)) return group;\n            return min;\n          });\n          for (const node of problemNodes) bestGroup.nodes.push(node);\n          bestGroup.nodes.sort((a, b) => {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n        } else {\n          // There are no other nodes with the same size types\n          // We create a new group and have to accept that it's smaller than minSize\n          result.push(new Group(problemNodes, null));\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    if (initialGroup.nodes.length > 0) {\n      const queue = [initialGroup];\n      while (queue.length) {\n        const group = queue.pop();\n        // only groups bigger than maxSize need to be splitted\n        if (!isTooBig(group.size, maxSize)) {\n          result.push(group);\n          continue;\n        }\n        // If the group is already too small\n        // we try to work only with the unproblematic nodes\n        if (removeProblematicNodes(group)) {\n          // This changed something, so we try this group again\n          queue.push(group);\n          continue;\n        }\n\n        // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n        let left = 1;\n        let leftSize = Object.create(null);\n        addSizeTo(leftSize, group.nodes[0].size);\n        while (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n          addSizeTo(leftSize, group.nodes[left].size);\n          left++;\n        }\n        let right = group.nodes.length - 2;\n        let rightSize = Object.create(null);\n        addSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n        while (right >= 0 && isTooSmall(rightSize, minSize)) {\n          addSizeTo(rightSize, group.nodes[right].size);\n          right--;\n        }\n\n        //      left v   v right\n        // [ O O O ] O O O [ O O O ]\n        // ^^^^^^^^^ leftSize\n        //       rightSize ^^^^^^^^^\n        // leftSize > minSize\n        // rightSize > minSize\n\n        // Perfect split: [ O O O ] [ O O O ]\n        //                right === left - 1\n\n        if (left - 1 > right) {\n          // We try to remove some problematic nodes to \"fix\" that\n          let prevSize;\n          if (right < group.nodes.length - left) {\n            subtractSizeFrom(rightSize, group.nodes[right + 1].size);\n            prevSize = rightSize;\n          } else {\n            subtractSizeFrom(leftSize, group.nodes[left - 1].size);\n            prevSize = leftSize;\n          }\n          if (removeProblematicNodes(group, prevSize)) {\n            // This changed something, so we try this group again\n            queue.push(group);\n            continue;\n          }\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the problematic nodes as result here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          // But we also need to make sure to not create too small groups\n          let best = -1;\n          let bestSimilarity = Infinity;\n          let pos = left;\n          let rightSize = sumSize(group.nodes.slice(pos));\n\n          //       pos v   v right\n          // [ O O O ] O O O [ O O O ]\n          // ^^^^^^^^^ leftSize\n          // rightSize ^^^^^^^^^^^^^^^\n\n          while (pos <= right + 1) {\n            const similarity = group.similarities[pos - 1];\n            if (similarity < bestSimilarity && !isTooSmall(leftSize, minSize) && !isTooSmall(rightSize, minSize)) {\n              best = pos;\n              bestSimilarity = similarity;\n            }\n            addSizeTo(leftSize, group.nodes[pos].size);\n            subtractSizeFrom(rightSize, group.nodes[pos].size);\n            pos++;\n          }\n          if (best < 0) {\n            // This can't happen\n            // but if that assumption is wrong\n            // fallback to a big group\n            result.push(group);\n            continue;\n          }\n          left = best;\n          right = best - 1;\n        }\n\n        // create two new groups for left and right area\n        // and queue them up\n        const rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n        const rightSimilarities = [];\n        for (let i = right + 2; i < group.nodes.length; i++) {\n          rightSimilarities.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n        queue.push(new Group(rightNodes, rightSimilarities));\n        const leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n        const leftSimilarities = [];\n        for (let i = 1; i < left; i++) {\n          leftSimilarities.push(group.similarities[i - 1]);\n          leftNodes.push(group.nodes[i]);\n        }\n        queue.push(new Group(leftNodes, leftSimilarities));\n      }\n    }\n  }\n\n  // lexically ordering\n  result.sort((a, b) => {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  });\n\n  // give every group a name\n  const usedNames = new Set();\n  for (let i = 0; i < result.length; i++) {\n    const group = result[i];\n    if (group.nodes.length === 1) {\n      group.key = group.nodes[0].key;\n    } else {\n      const first = group.nodes[0];\n      const last = group.nodes[group.nodes.length - 1];\n      const name = getName(first.key, last.key, usedNames);\n      group.key = name;\n    }\n  }\n\n  // return the results\n  return result.map(group => {\n    /** @type {GroupedItems<T>} */\n    return {\n      key: group.key,\n      items: group.nodes.map(node => node.item),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","usedNames","name","slice","lowerName","toLowerCase","has","add","addSizeTo","total","size","key","Object","keys","subtractSizeFrom","sumSize","nodes","sum","create","node","isTooBig","maxSize","s","maxSizeValue","isTooSmall","minSize","minSizeValue","getTooSmallTypes","types","Set","getNumberOfMatchingSizeTypes","selectiveSizeSum","Node","constructor","item","Group","similarities","undefined","popNodes","filter","newNodes","newSimilarities","resultNodes","lastNode","push","getSimilarities","last","module","exports","_ref","items","getSize","getKey","result","Array","from","initialNodes","sort","initialGroup","removeProblematicNodes","group","consideredSize","arguments","problemTypes","problemNodes","n","possibleResultGroups","bestGroup","reduce","minMatches","groupMatches","queue","pop","left","leftSize","right","rightSize","prevSize","best","bestSimilarity","Infinity","pos","rightNodes","rightSimilarities","leftNodes","leftSimilarities","first","map"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/deterministicGrouping.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b, usedNames) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet i = 0;\n\twhile (i < l) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l) {\n\t\tconst name = a.slice(0, i);\n\t\tconst lowerName = name.toLowerCase();\n\t\tif (!usedNames.has(lowerName)) {\n\t\t\tusedNames.add(lowerName);\n\t\t\treturn name;\n\t\t}\n\t\ti++;\n\t}\n\t// names always contain a hash, so this is always unique\n\t// we don't need to check usedNames nor add it\n\treturn a;\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst addSizeTo = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] = (total[key] || 0) + size[key];\n\t}\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst subtractSizeFrom = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] -= size[key];\n\t}\n};\n\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\nconst sumSize = nodes => {\n\tconst sum = Object.create(null);\n\tfor (const node of nodes) {\n\t\taddSizeTo(sum, node.size);\n\t}\n\treturn sum;\n};\n\nconst isTooBig = (size, maxSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst maxSizeValue = maxSize[key];\n\t\tif (typeof maxSizeValue === \"number\") {\n\t\t\tif (s > maxSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst isTooSmall = (size, minSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst getTooSmallTypes = (size, minSize) => {\n\tconst types = new Set();\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) types.add(key);\n\t\t}\n\t}\n\treturn types;\n};\n\nconst getNumberOfMatchingSizeTypes = (size, types) => {\n\tlet i = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) i++;\n\t}\n\treturn i;\n};\n\nconst selectiveSizeSum = (size, types) => {\n\tlet sum = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) sum += size[key];\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {Record<string, number>} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t * @param {Record<string, number>=} size size of the group\n\t */\n\tconstructor(nodes, similarities, size) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = size || sumSize(nodes);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n\n\t/**\n\t * @param {function(Node): boolean} filter filter function\n\t * @returns {Node[]} removed nodes\n\t */\n\tpopNodes(filter) {\n\t\tconst newNodes = [];\n\t\tconst newSimilarities = [];\n\t\tconst resultNodes = [];\n\t\tlet lastNode;\n\t\tfor (let i = 0; i < this.nodes.length; i++) {\n\t\t\tconst node = this.nodes[i];\n\t\t\tif (filter(node)) {\n\t\t\t\tresultNodes.push(node);\n\t\t\t} else {\n\t\t\t\tif (newNodes.length > 0) {\n\t\t\t\t\tnewSimilarities.push(\n\t\t\t\t\t\tlastNode === this.nodes[i - 1]\n\t\t\t\t\t\t\t? this.similarities[i - 1]\n\t\t\t\t\t\t\t: similarity(lastNode.key, node.key)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tnewNodes.push(node);\n\t\t\t\tlastNode = node;\n\t\t\t}\n\t\t}\n\t\tif (resultNodes.length === this.nodes.length) return undefined;\n\t\tthis.nodes = newNodes;\n\t\tthis.similarities = newSimilarities;\n\t\tthis.size = sumSize(newNodes);\n\t\treturn resultNodes;\n\t}\n}\n\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\nconst getSimilarities = nodes => {\n\t// calculate similarities between lexically adjacent nodes\n\t/** @type {number[]} */\n\tconst similarities = [];\n\tlet last = undefined;\n\tfor (const node of nodes) {\n\t\tif (last !== undefined) {\n\t\t\tsimilarities.push(similarity(last.key, node.key));\n\t\t}\n\t\tlast = node;\n\t}\n\treturn similarities;\n};\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\t// But make sure that minSize is not violated\n\tfor (const node of nodes) {\n\t\tif (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\tconst initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n\n\t\tconst removeProblematicNodes = (group, consideredSize = group.size) => {\n\t\t\tconst problemTypes = getTooSmallTypes(consideredSize, minSize);\n\t\t\tif (problemTypes.size > 0) {\n\t\t\t\t// We hit an edge case where the working set is already smaller than minSize\n\t\t\t\t// We merge problematic nodes with the smallest result node to keep minSize intact\n\t\t\t\tconst problemNodes = group.popNodes(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (problemNodes === undefined) return false;\n\t\t\t\t// Only merge it with result nodes that have the problematic size type\n\t\t\t\tconst possibleResultGroups = result.filter(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (possibleResultGroups.length > 0) {\n\t\t\t\t\tconst bestGroup = possibleResultGroups.reduce((min, group) => {\n\t\t\t\t\t\tconst minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n\t\t\t\t\t\tconst groupMatches = getNumberOfMatchingSizeTypes(\n\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\tproblemTypes\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (minMatches !== groupMatches)\n\t\t\t\t\t\t\treturn minMatches < groupMatches ? group : min;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tselectiveSizeSum(min.size, problemTypes) >\n\t\t\t\t\t\t\tselectiveSizeSum(group.size, problemTypes)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\treturn group;\n\t\t\t\t\t\treturn min;\n\t\t\t\t\t});\n\t\t\t\t\tfor (const node of problemNodes) bestGroup.nodes.push(node);\n\t\t\t\t\tbestGroup.nodes.sort((a, b) => {\n\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// There are no other nodes with the same size types\n\t\t\t\t\t// We create a new group and have to accept that it's smaller than minSize\n\t\t\t\t\tresult.push(new Group(problemNodes, null));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\tif (initialGroup.nodes.length > 0) {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (!isTooBig(group.size, maxSize)) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// If the group is already too small\n\t\t\t\t// we try to work only with the unproblematic nodes\n\t\t\t\tif (removeProblematicNodes(group)) {\n\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\tqueue.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 1;\n\t\t\t\tlet leftSize = Object.create(null);\n\t\t\t\taddSizeTo(leftSize, group.nodes[0].size);\n\t\t\t\twhile (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n\t\t\t\t\taddSizeTo(leftSize, group.nodes[left].size);\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 2;\n\t\t\t\tlet rightSize = Object.create(null);\n\t\t\t\taddSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n\t\t\t\twhile (right >= 0 && isTooSmall(rightSize, minSize)) {\n\t\t\t\t\taddSizeTo(rightSize, group.nodes[right].size);\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\t//      left v   v right\n\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t//       rightSize ^^^^^^^^^\n\t\t\t\t// leftSize > minSize\n\t\t\t\t// rightSize > minSize\n\n\t\t\t\t// Perfect split: [ O O O ] [ O O O ]\n\t\t\t\t//                right === left - 1\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// We try to remove some problematic nodes to \"fix\" that\n\t\t\t\t\tlet prevSize;\n\t\t\t\t\tif (right < group.nodes.length - left) {\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[right + 1].size);\n\t\t\t\t\t\tprevSize = rightSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubtractSizeFrom(leftSize, group.nodes[left - 1].size);\n\t\t\t\t\t\tprevSize = leftSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (removeProblematicNodes(group, prevSize)) {\n\t\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\t\tqueue.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the problematic nodes as result here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\t// But we also need to make sure to not create too small groups\n\t\t\t\t\tlet best = -1;\n\t\t\t\t\tlet bestSimilarity = Infinity;\n\t\t\t\t\tlet pos = left;\n\t\t\t\t\tlet rightSize = sumSize(group.nodes.slice(pos));\n\n\t\t\t\t\t//       pos v   v right\n\t\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t\t// rightSize ^^^^^^^^^^^^^^^\n\n\t\t\t\t\twhile (pos <= right + 1) {\n\t\t\t\t\t\tconst similarity = group.similarities[pos - 1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsimilarity < bestSimilarity &&\n\t\t\t\t\t\t\t!isTooSmall(leftSize, minSize) &&\n\t\t\t\t\t\t\t!isTooSmall(rightSize, minSize)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbest = pos;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddSizeTo(leftSize, group.nodes[pos].size);\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[pos].size);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0) {\n\t\t\t\t\t\t// This can't happen\n\t\t\t\t\t\t// but if that assumption is wrong\n\t\t\t\t\t\t// fallback to a big group\n\t\t\t\t\t\tresult.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tleft = best;\n\t\t\t\t\tright = best - 1;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilarities = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilarities));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilarities = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilarities));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tconst usedNames = new Set();\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tif (group.nodes.length === 1) {\n\t\t\tgroup.key = group.nodes[0].key;\n\t\t} else {\n\t\t\tconst first = group.nodes[0];\n\t\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\t\tconst name = getName(first.key, last.key, usedNames);\n\t\t\tgroup.key = name;\n\t\t}\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems<T>} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}