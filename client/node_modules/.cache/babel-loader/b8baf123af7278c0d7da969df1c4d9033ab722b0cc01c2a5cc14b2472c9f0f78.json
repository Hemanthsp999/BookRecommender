{"ast":null,"code":"'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + ['\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n  TOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\nfunction matchAll(s, r) {\n  var origIndex = r.lastIndex;\n  var matches = [];\n  var matchObj;\n  while (matchObj = r.exec(s)) {\n    matches.push(matchObj);\n    if (r.lastIndex === matchObj.index) {\n      r.lastIndex += 1;\n    }\n  }\n  r.lastIndex = origIndex;\n  return matches;\n}\nfunction getVar(env, pre, key) {\n  var r = typeof env === 'function' ? env(key) : env[key];\n  if (typeof r === 'undefined' && key != '') {\n    r = '';\n  } else if (typeof r === 'undefined') {\n    r = '$';\n  }\n  if (typeof r === 'object') {\n    return pre + TOKEN + JSON.stringify(r) + TOKEN;\n  }\n  return pre + r;\n}\nfunction parseInternal(string, env, opts) {\n  if (!opts) {\n    opts = {};\n  }\n  var BS = opts.escape || '\\\\';\n  var BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n  var chunker = new RegExp(['(' + CONTROL + ')',\n  // control chars\n  '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'].join('|'), 'g');\n  var matches = matchAll(string, chunker);\n  if (matches.length === 0) {\n    return [];\n  }\n  if (!env) {\n    env = {};\n  }\n  var commented = false;\n  return matches.map(function (match) {\n    var s = match[0];\n    if (!s || commented) {\n      return void undefined;\n    }\n    if (controlRE.test(s)) {\n      return {\n        op: s\n      };\n    }\n\n    // Hand-written scanner/parser for Bash quoting rules:\n    //\n    // 1. inside single quotes, all characters are printed literally.\n    // 2. inside double quotes, all characters are printed literally\n    //    except variables prefixed by '$' and backslashes followed by\n    //    either a double quote or another backslash.\n    // 3. outside of any quotes, backslashes are treated as escape\n    //    characters and not printed (unless they are themselves escaped)\n    // 4. quote context can switch mid-token if there is no whitespace\n    //     between the two quote contexts (e.g. all'one'\"token\" parses as\n    //     \"allonetoken\")\n    var quote = false;\n    var esc = false;\n    var out = '';\n    var isGlob = false;\n    var i;\n    function parseEnvVar() {\n      i += 1;\n      var varend;\n      var varname;\n      var char = s.charAt(i);\n      if (char === '{') {\n        i += 1;\n        if (s.charAt(i) === '}') {\n          throw new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n        }\n        varend = s.indexOf('}', i);\n        if (varend < 0) {\n          throw new Error('Bad substitution: ' + s.slice(i));\n        }\n        varname = s.slice(i, varend);\n        i = varend;\n      } else if (/[*@#?$!_-]/.test(char)) {\n        varname = char;\n        i += 1;\n      } else {\n        var slicedFromI = s.slice(i);\n        varend = slicedFromI.match(/[^\\w\\d_]/);\n        if (!varend) {\n          varname = slicedFromI;\n          i = s.length;\n        } else {\n          varname = slicedFromI.slice(0, varend.index);\n          i += varend.index - 1;\n        }\n      }\n      return getVar(env, '', varname);\n    }\n    for (i = 0; i < s.length; i++) {\n      var c = s.charAt(i);\n      isGlob = isGlob || !quote && (c === '*' || c === '?');\n      if (esc) {\n        out += c;\n        esc = false;\n      } else if (quote) {\n        if (c === quote) {\n          quote = false;\n        } else if (quote == SQ) {\n          out += c;\n        } else {\n          // Double quote\n          if (c === BS) {\n            i += 1;\n            c = s.charAt(i);\n            if (c === DQ || c === BS || c === DS) {\n              out += c;\n            } else {\n              out += BS + c;\n            }\n          } else if (c === DS) {\n            out += parseEnvVar();\n          } else {\n            out += c;\n          }\n        }\n      } else if (c === DQ || c === SQ) {\n        quote = c;\n      } else if (controlRE.test(c)) {\n        return {\n          op: s\n        };\n      } else if (hash.test(c)) {\n        commented = true;\n        var commentObj = {\n          comment: string.slice(match.index + i + 1)\n        };\n        if (out.length) {\n          return [out, commentObj];\n        }\n        return [commentObj];\n      } else if (c === BS) {\n        esc = true;\n      } else if (c === DS) {\n        out += parseEnvVar();\n      } else {\n        out += c;\n      }\n    }\n    if (isGlob) {\n      return {\n        op: 'glob',\n        pattern: out\n      };\n    }\n    return out;\n  }).reduce(function (prev, arg) {\n    // finalize parsed arguments\n    // TODO: replace this whole reduce with a concat\n    return typeof arg === 'undefined' ? prev : prev.concat(arg);\n  }, []);\n}\nmodule.exports = function parse(s, env, opts) {\n  var mapped = parseInternal(s, env, opts);\n  if (typeof env !== 'function') {\n    return mapped;\n  }\n  return mapped.reduce(function (acc, s) {\n    if (typeof s === 'object') {\n      return acc.concat(s);\n    }\n    var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n    if (xs.length === 1) {\n      return acc.concat(xs[0]);\n    }\n    return acc.concat(xs.filter(Boolean).map(function (x) {\n      if (startsWithToken.test(x)) {\n        return JSON.parse(x.split(TOKEN)[1]);\n      }\n      return x;\n    }));\n  }, []);\n};","map":{"version":3,"names":["CONTROL","join","controlRE","RegExp","META","SINGLE_QUOTE","DOUBLE_QUOTE","hash","SQ","DQ","DS","TOKEN","mult","i","Math","random","toString","startsWithToken","matchAll","s","r","origIndex","lastIndex","matches","matchObj","exec","push","index","getVar","env","pre","key","JSON","stringify","parseInternal","string","opts","BS","escape","BAREWORD","chunker","length","commented","map","match","undefined","test","op","quote","esc","out","isGlob","parseEnvVar","varend","varname","char","charAt","Error","slice","indexOf","slicedFromI","c","commentObj","comment","pattern","reduce","prev","arg","concat","module","exports","parse","mapped","acc","xs","split","filter","Boolean","x"],"sources":["/home/hemanth/react-project/client/node_modules/shell-quote/parse.js"],"sourcesContent":["'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}