{"ast":null,"code":"var LoaderLoadingError = require(\"./LoaderLoadingError\");\nvar url;\nmodule.exports = function loadLoader(loader, callback) {\n  if (loader.type === \"module\") {\n    try {\n      if (url === undefined) url = require(\"url\");\n      var loaderUrl = url.pathToFileURL(loader.path);\n      var modulePromise = eval(\"import(\" + JSON.stringify(loaderUrl.toString()) + \")\");\n      modulePromise.then(function (module) {\n        handleResult(loader, module, callback);\n      }, callback);\n      return;\n    } catch (e) {\n      callback(e);\n    }\n  } else {\n    try {\n      var module = require(loader.path);\n    } catch (e) {\n      // it is possible for node to choke on a require if the FD descriptor\n      // limit has been reached. give it a chance to recover.\n      if (e instanceof Error && e.code === \"EMFILE\") {\n        var retry = loadLoader.bind(null, loader, callback);\n        if (typeof setImmediate === \"function\") {\n          // node >= 0.9.0\n          return setImmediate(retry);\n        } else {\n          // node < 0.9.0\n          return process.nextTick(retry);\n        }\n      }\n      return callback(e);\n    }\n    return handleResult(loader, module, callback);\n  }\n};\nfunction handleResult(loader, module, callback) {\n  if (typeof module !== \"function\" && typeof module !== \"object\") {\n    return callback(new LoaderLoadingError(\"Module '\" + loader.path + \"' is not a loader (export function or es6 module)\"));\n  }\n  loader.normal = typeof module === \"function\" ? module : module.default;\n  loader.pitch = module.pitch;\n  loader.raw = module.raw;\n  if (typeof loader.normal !== \"function\" && typeof loader.pitch !== \"function\") {\n    return callback(new LoaderLoadingError(\"Module '\" + loader.path + \"' is not a loader (must have normal or pitch function)\"));\n  }\n  callback();\n}","map":{"version":3,"names":["LoaderLoadingError","require","url","module","exports","loadLoader","loader","callback","type","undefined","loaderUrl","pathToFileURL","path","modulePromise","eval","JSON","stringify","toString","then","handleResult","e","Error","code","retry","bind","setImmediate","process","nextTick","normal","default","pitch","raw"],"sources":["/home/hemanth/react-project/client/node_modules/loader-runner/lib/loadLoader.js"],"sourcesContent":["var LoaderLoadingError = require(\"./LoaderLoadingError\");\nvar url;\n\nmodule.exports = function loadLoader(loader, callback) {\n\tif(loader.type === \"module\") {\n\t\ttry {\n\t\t\tif(url === undefined) url = require(\"url\");\n\t\t\tvar loaderUrl = url.pathToFileURL(loader.path);\n\t\t\tvar modulePromise = eval(\"import(\" + JSON.stringify(loaderUrl.toString()) + \")\");\n\t\t\tmodulePromise.then(function(module) {\n\t\t\t\thandleResult(loader, module, callback);\n\t\t\t}, callback);\n\t\t\treturn;\n\t\t} catch(e) {\n\t\t\tcallback(e);\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tvar module = require(loader.path);\n\t\t} catch(e) {\n\t\t\t// it is possible for node to choke on a require if the FD descriptor\n\t\t\t// limit has been reached. give it a chance to recover.\n\t\t\tif(e instanceof Error && e.code === \"EMFILE\") {\n\t\t\t\tvar retry = loadLoader.bind(null, loader, callback);\n\t\t\t\tif(typeof setImmediate === \"function\") {\n\t\t\t\t\t// node >= 0.9.0\n\t\t\t\t\treturn setImmediate(retry);\n\t\t\t\t} else {\n\t\t\t\t\t// node < 0.9.0\n\t\t\t\t\treturn process.nextTick(retry);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn callback(e);\n\t\t}\n\t\treturn handleResult(loader, module, callback);\n\t}\n};\n\nfunction handleResult(loader, module, callback) {\n\tif(typeof module !== \"function\" && typeof module !== \"object\") {\n\t\treturn callback(new LoaderLoadingError(\n\t\t\t\"Module '\" + loader.path + \"' is not a loader (export function or es6 module)\"\n\t\t));\n\t}\n\tloader.normal = typeof module === \"function\" ? module : module.default;\n\tloader.pitch = module.pitch;\n\tloader.raw = module.raw;\n\tif(typeof loader.normal !== \"function\" && typeof loader.pitch !== \"function\") {\n\t\treturn callback(new LoaderLoadingError(\n\t\t\t\"Module '\" + loader.path + \"' is not a loader (must have normal or pitch function)\"\n\t\t));\n\t}\n\tcallback();\n}\n"],"mappings":"AAAA,IAAIA,kBAAkB,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AACxD,IAAIC,GAAG;AAEPC,MAAM,CAACC,OAAO,GAAG,SAASC,UAAUA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EACtD,IAAGD,MAAM,CAACE,IAAI,KAAK,QAAQ,EAAE;IAC5B,IAAI;MACH,IAAGN,GAAG,KAAKO,SAAS,EAAEP,GAAG,GAAGD,OAAO,CAAC,KAAK,CAAC;MAC1C,IAAIS,SAAS,GAAGR,GAAG,CAACS,aAAa,CAACL,MAAM,CAACM,IAAI,CAAC;MAC9C,IAAIC,aAAa,GAAGC,IAAI,CAAC,SAAS,GAAGC,IAAI,CAACC,SAAS,CAACN,SAAS,CAACO,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;MAChFJ,aAAa,CAACK,IAAI,CAAC,UAASf,MAAM,EAAE;QACnCgB,YAAY,CAACb,MAAM,EAAEH,MAAM,EAAEI,QAAQ,CAAC;MACvC,CAAC,EAAEA,QAAQ,CAAC;MACZ;IACD,CAAC,CAAC,OAAMa,CAAC,EAAE;MACVb,QAAQ,CAACa,CAAC,CAAC;IACZ;EACD,CAAC,MAAM;IACN,IAAI;MACH,IAAIjB,MAAM,GAAGF,OAAO,CAACK,MAAM,CAACM,IAAI,CAAC;IAClC,CAAC,CAAC,OAAMQ,CAAC,EAAE;MACV;MACA;MACA,IAAGA,CAAC,YAAYC,KAAK,IAAID,CAAC,CAACE,IAAI,KAAK,QAAQ,EAAE;QAC7C,IAAIC,KAAK,GAAGlB,UAAU,CAACmB,IAAI,CAAC,IAAI,EAAElB,MAAM,EAAEC,QAAQ,CAAC;QACnD,IAAG,OAAOkB,YAAY,KAAK,UAAU,EAAE;UACtC;UACA,OAAOA,YAAY,CAACF,KAAK,CAAC;QAC3B,CAAC,MAAM;UACN;UACA,OAAOG,OAAO,CAACC,QAAQ,CAACJ,KAAK,CAAC;QAC/B;MACD;MACA,OAAOhB,QAAQ,CAACa,CAAC,CAAC;IACnB;IACA,OAAOD,YAAY,CAACb,MAAM,EAAEH,MAAM,EAAEI,QAAQ,CAAC;EAC9C;AACD,CAAC;AAED,SAASY,YAAYA,CAACb,MAAM,EAAEH,MAAM,EAAEI,QAAQ,EAAE;EAC/C,IAAG,OAAOJ,MAAM,KAAK,UAAU,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9D,OAAOI,QAAQ,CAAC,IAAIP,kBAAkB,CACrC,UAAU,GAAGM,MAAM,CAACM,IAAI,GAAG,mDAC5B,CAAC,CAAC;EACH;EACAN,MAAM,CAACsB,MAAM,GAAG,OAAOzB,MAAM,KAAK,UAAU,GAAGA,MAAM,GAAGA,MAAM,CAAC0B,OAAO;EACtEvB,MAAM,CAACwB,KAAK,GAAG3B,MAAM,CAAC2B,KAAK;EAC3BxB,MAAM,CAACyB,GAAG,GAAG5B,MAAM,CAAC4B,GAAG;EACvB,IAAG,OAAOzB,MAAM,CAACsB,MAAM,KAAK,UAAU,IAAI,OAAOtB,MAAM,CAACwB,KAAK,KAAK,UAAU,EAAE;IAC7E,OAAOvB,QAAQ,CAAC,IAAIP,kBAAkB,CACrC,UAAU,GAAGM,MAAM,CAACM,IAAI,GAAG,wDAC5B,CAAC,CAAC;EACH;EACAL,QAAQ,CAAC,CAAC;AACX"},"metadata":{},"sourceType":"script","externalDependencies":[]}