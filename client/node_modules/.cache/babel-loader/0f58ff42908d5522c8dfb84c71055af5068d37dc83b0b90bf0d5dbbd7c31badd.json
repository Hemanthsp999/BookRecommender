{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst Queue = require(\"./util/Queue\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n\nconst PLUGIN_NAME = \"FlagDependencyExportsPlugin\";\nconst PLUGIN_LOGGER_NAME = `webpack.${PLUGIN_NAME}`;\nclass FlagDependencyExportsPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      const cache = compilation.getCache(PLUGIN_NAME);\n      compilation.hooks.finishModules.tapAsync(PLUGIN_NAME, (modules, callback) => {\n        const logger = compilation.getLogger(PLUGIN_LOGGER_NAME);\n        let statRestoredFromMemCache = 0;\n        let statRestoredFromCache = 0;\n        let statNoExports = 0;\n        let statFlaggedUncached = 0;\n        let statNotCached = 0;\n        let statQueueItemsProcessed = 0;\n        const {\n          moduleMemCaches\n        } = compilation;\n\n        /** @type {Queue<Module>} */\n        const queue = new Queue();\n\n        // Step 1: Try to restore cached provided export info from cache\n        logger.time(\"restore cached provided exports\");\n        asyncLib.each(modules, (module, callback) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          // If the module doesn't have an exportsType, it's a module\n          // without declared exports.\n          if (!module.buildMeta || !module.buildMeta.exportsType) {\n            if (exportsInfo.otherExportsInfo.provided !== null) {\n              // It's a module without declared exports\n              statNoExports++;\n              exportsInfo.setHasProvideInfo();\n              exportsInfo.setUnknownExportsProvided();\n              return callback();\n            }\n          }\n          // If the module has no hash, it's uncacheable\n          if (typeof module.buildInfo.hash !== \"string\") {\n            statFlaggedUncached++;\n            // Enqueue uncacheable module for determining the exports\n            queue.enqueue(module);\n            exportsInfo.setHasProvideInfo();\n            return callback();\n          }\n          const memCache = moduleMemCaches && moduleMemCaches.get(module);\n          const memCacheValue = memCache && memCache.get(this);\n          if (memCacheValue !== undefined) {\n            statRestoredFromMemCache++;\n            exportsInfo.restoreProvided(memCacheValue);\n            return callback();\n          }\n          cache.get(module.identifier(), module.buildInfo.hash, (err, result) => {\n            if (err) return callback(err);\n            if (result !== undefined) {\n              statRestoredFromCache++;\n              exportsInfo.restoreProvided(result);\n            } else {\n              statNotCached++;\n              // Without cached info enqueue module for determining the exports\n              queue.enqueue(module);\n              exportsInfo.setHasProvideInfo();\n            }\n            callback();\n          });\n        }, err => {\n          logger.timeEnd(\"restore cached provided exports\");\n          if (err) return callback(err);\n\n          /** @type {Set<Module>} */\n          const modulesToStore = new Set();\n\n          /** @type {Map<Module, Set<Module>>} */\n          const dependencies = new Map();\n\n          /** @type {Module} */\n          let module;\n\n          /** @type {ExportsInfo} */\n          let exportsInfo;\n\n          /** @type {Map<Dependency, ExportsSpec>} */\n          const exportsSpecsFromDependencies = new Map();\n          let cacheable = true;\n          let changed = false;\n\n          /**\n           * @param {DependenciesBlock} depBlock the dependencies block\n           * @returns {void}\n           */\n          const processDependenciesBlock = depBlock => {\n            for (const dep of depBlock.dependencies) {\n              processDependency(dep);\n            }\n            for (const block of depBlock.blocks) {\n              processDependenciesBlock(block);\n            }\n          };\n\n          /**\n           * @param {Dependency} dep the dependency\n           * @returns {void}\n           */\n          const processDependency = dep => {\n            const exportDesc = dep.getExports(moduleGraph);\n            if (!exportDesc) return;\n            exportsSpecsFromDependencies.set(dep, exportDesc);\n          };\n\n          /**\n           * @param {Dependency} dep dependency\n           * @param {ExportsSpec} exportDesc info\n           * @returns {void}\n           */\n          const processExportsSpec = (dep, exportDesc) => {\n            const exports = exportDesc.exports;\n            const globalCanMangle = exportDesc.canMangle;\n            const globalFrom = exportDesc.from;\n            const globalPriority = exportDesc.priority;\n            const globalTerminalBinding = exportDesc.terminalBinding || false;\n            const exportDeps = exportDesc.dependencies;\n            if (exportDesc.hideExports) {\n              for (const name of exportDesc.hideExports) {\n                const exportInfo = exportsInfo.getExportInfo(name);\n                exportInfo.unsetTarget(dep);\n              }\n            }\n            if (exports === true) {\n              // unknown exports\n              if (exportsInfo.setUnknownExportsProvided(globalCanMangle, exportDesc.excludeExports, globalFrom && dep, globalFrom, globalPriority)) {\n                changed = true;\n              }\n            } else if (Array.isArray(exports)) {\n              /**\n               * merge in new exports\n               * @param {ExportsInfo} exportsInfo own exports info\n               * @param {(ExportSpec | string)[]} exports list of exports\n               */\n              const mergeExports = (exportsInfo, exports) => {\n                for (const exportNameOrSpec of exports) {\n                  let name;\n                  let canMangle = globalCanMangle;\n                  let terminalBinding = globalTerminalBinding;\n                  let exports = undefined;\n                  let from = globalFrom;\n                  let fromExport = undefined;\n                  let priority = globalPriority;\n                  let hidden = false;\n                  if (typeof exportNameOrSpec === \"string\") {\n                    name = exportNameOrSpec;\n                  } else {\n                    name = exportNameOrSpec.name;\n                    if (exportNameOrSpec.canMangle !== undefined) canMangle = exportNameOrSpec.canMangle;\n                    if (exportNameOrSpec.export !== undefined) fromExport = exportNameOrSpec.export;\n                    if (exportNameOrSpec.exports !== undefined) exports = exportNameOrSpec.exports;\n                    if (exportNameOrSpec.from !== undefined) from = exportNameOrSpec.from;\n                    if (exportNameOrSpec.priority !== undefined) priority = exportNameOrSpec.priority;\n                    if (exportNameOrSpec.terminalBinding !== undefined) terminalBinding = exportNameOrSpec.terminalBinding;\n                    if (exportNameOrSpec.hidden !== undefined) hidden = exportNameOrSpec.hidden;\n                  }\n                  const exportInfo = exportsInfo.getExportInfo(name);\n                  if (exportInfo.provided === false || exportInfo.provided === null) {\n                    exportInfo.provided = true;\n                    changed = true;\n                  }\n                  if (exportInfo.canMangleProvide !== false && canMangle === false) {\n                    exportInfo.canMangleProvide = false;\n                    changed = true;\n                  }\n                  if (terminalBinding && !exportInfo.terminalBinding) {\n                    exportInfo.terminalBinding = true;\n                    changed = true;\n                  }\n                  if (exports) {\n                    const nestedExportsInfo = exportInfo.createNestedExportsInfo();\n                    mergeExports(nestedExportsInfo, exports);\n                  }\n                  if (from && (hidden ? exportInfo.unsetTarget(dep) : exportInfo.setTarget(dep, from, fromExport === undefined ? [name] : fromExport, priority))) {\n                    changed = true;\n                  }\n\n                  // Recalculate target exportsInfo\n                  const target = exportInfo.getTarget(moduleGraph);\n                  let targetExportsInfo = undefined;\n                  if (target) {\n                    const targetModuleExportsInfo = moduleGraph.getExportsInfo(target.module);\n                    targetExportsInfo = targetModuleExportsInfo.getNestedExportsInfo(target.export);\n                    // add dependency for this module\n                    const set = dependencies.get(target.module);\n                    if (set === undefined) {\n                      dependencies.set(target.module, new Set([module]));\n                    } else {\n                      set.add(module);\n                    }\n                  }\n                  if (exportInfo.exportsInfoOwned) {\n                    if (exportInfo.exportsInfo.setRedirectNamedTo(targetExportsInfo)) {\n                      changed = true;\n                    }\n                  } else if (exportInfo.exportsInfo !== targetExportsInfo) {\n                    exportInfo.exportsInfo = targetExportsInfo;\n                    changed = true;\n                  }\n                }\n              };\n              mergeExports(exportsInfo, exports);\n            }\n            // store dependencies\n            if (exportDeps) {\n              cacheable = false;\n              for (const exportDependency of exportDeps) {\n                // add dependency for this module\n                const set = dependencies.get(exportDependency);\n                if (set === undefined) {\n                  dependencies.set(exportDependency, new Set([module]));\n                } else {\n                  set.add(module);\n                }\n              }\n            }\n          };\n          const notifyDependencies = () => {\n            const deps = dependencies.get(module);\n            if (deps !== undefined) {\n              for (const dep of deps) {\n                queue.enqueue(dep);\n              }\n            }\n          };\n          logger.time(\"figure out provided exports\");\n          while (queue.length > 0) {\n            module = queue.dequeue();\n            statQueueItemsProcessed++;\n            exportsInfo = moduleGraph.getExportsInfo(module);\n            cacheable = true;\n            changed = false;\n            exportsSpecsFromDependencies.clear();\n            moduleGraph.freeze();\n            processDependenciesBlock(module);\n            moduleGraph.unfreeze();\n            for (const [dep, exportsSpec] of exportsSpecsFromDependencies) {\n              processExportsSpec(dep, exportsSpec);\n            }\n            if (cacheable) {\n              modulesToStore.add(module);\n            }\n            if (changed) {\n              notifyDependencies();\n            }\n          }\n          logger.timeEnd(\"figure out provided exports\");\n          logger.log(`${Math.round(100 * (statFlaggedUncached + statNotCached) / (statRestoredFromMemCache + statRestoredFromCache + statNotCached + statFlaggedUncached + statNoExports))}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${statQueueItemsProcessed - statNotCached - statFlaggedUncached} additional calculations due to dependencies)`);\n          logger.time(\"store provided exports into cache\");\n          asyncLib.each(modulesToStore, (module, callback) => {\n            if (typeof module.buildInfo.hash !== \"string\") {\n              // not cacheable\n              return callback();\n            }\n            const cachedData = moduleGraph.getExportsInfo(module).getRestoreProvidedData();\n            const memCache = moduleMemCaches && moduleMemCaches.get(module);\n            if (memCache) {\n              memCache.set(this, cachedData);\n            }\n            cache.store(module.identifier(), module.buildInfo.hash, cachedData, callback);\n          }, err => {\n            logger.timeEnd(\"store provided exports into cache\");\n            callback(err);\n          });\n        });\n      });\n\n      /** @type {WeakMap<Module, any>} */\n      const providedExportsCache = new WeakMap();\n      compilation.hooks.rebuildModule.tap(PLUGIN_NAME, module => {\n        providedExportsCache.set(module, moduleGraph.getExportsInfo(module).getRestoreProvidedData());\n      });\n      compilation.hooks.finishRebuildingModule.tap(PLUGIN_NAME, module => {\n        moduleGraph.getExportsInfo(module).restoreProvided(providedExportsCache.get(module));\n      });\n    });\n  }\n}\nmodule.exports = FlagDependencyExportsPlugin;","map":{"version":3,"names":["asyncLib","require","Queue","PLUGIN_NAME","PLUGIN_LOGGER_NAME","FlagDependencyExportsPlugin","apply","compiler","hooks","compilation","tap","moduleGraph","cache","getCache","finishModules","tapAsync","modules","callback","logger","getLogger","statRestoredFromMemCache","statRestoredFromCache","statNoExports","statFlaggedUncached","statNotCached","statQueueItemsProcessed","moduleMemCaches","queue","time","each","module","exportsInfo","getExportsInfo","buildMeta","exportsType","otherExportsInfo","provided","setHasProvideInfo","setUnknownExportsProvided","buildInfo","hash","enqueue","memCache","get","memCacheValue","undefined","restoreProvided","identifier","err","result","timeEnd","modulesToStore","Set","dependencies","Map","exportsSpecsFromDependencies","cacheable","changed","processDependenciesBlock","depBlock","dep","processDependency","block","blocks","exportDesc","getExports","set","processExportsSpec","exports","globalCanMangle","canMangle","globalFrom","from","globalPriority","priority","globalTerminalBinding","terminalBinding","exportDeps","hideExports","name","exportInfo","getExportInfo","unsetTarget","excludeExports","Array","isArray","mergeExports","exportNameOrSpec","fromExport","hidden","export","canMangleProvide","nestedExportsInfo","createNestedExportsInfo","setTarget","target","getTarget","targetExportsInfo","targetModuleExportsInfo","getNestedExportsInfo","add","exportsInfoOwned","setRedirectNamedTo","exportDependency","notifyDependencies","deps","length","dequeue","clear","freeze","unfreeze","exportsSpec","log","Math","round","cachedData","getRestoreProvidedData","store","providedExportsCache","WeakMap","rebuildModule","finishRebuildingModule"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/FlagDependencyExportsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst Queue = require(\"./util/Queue\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n\nconst PLUGIN_NAME = \"FlagDependencyExportsPlugin\";\nconst PLUGIN_LOGGER_NAME = `webpack.${PLUGIN_NAME}`;\n\nclass FlagDependencyExportsPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tconst cache = compilation.getCache(PLUGIN_NAME);\n\t\t\tcompilation.hooks.finishModules.tapAsync(\n\t\t\t\tPLUGIN_NAME,\n\t\t\t\t(modules, callback) => {\n\t\t\t\t\tconst logger = compilation.getLogger(PLUGIN_LOGGER_NAME);\n\t\t\t\t\tlet statRestoredFromMemCache = 0;\n\t\t\t\t\tlet statRestoredFromCache = 0;\n\t\t\t\t\tlet statNoExports = 0;\n\t\t\t\t\tlet statFlaggedUncached = 0;\n\t\t\t\t\tlet statNotCached = 0;\n\t\t\t\t\tlet statQueueItemsProcessed = 0;\n\n\t\t\t\t\tconst { moduleMemCaches } = compilation;\n\n\t\t\t\t\t/** @type {Queue<Module>} */\n\t\t\t\t\tconst queue = new Queue();\n\n\t\t\t\t\t// Step 1: Try to restore cached provided export info from cache\n\t\t\t\t\tlogger.time(\"restore cached provided exports\");\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t// If the module doesn't have an exportsType, it's a module\n\t\t\t\t\t\t\t// without declared exports.\n\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\tif (exportsInfo.otherExportsInfo.provided !== null) {\n\t\t\t\t\t\t\t\t\t// It's a module without declared exports\n\t\t\t\t\t\t\t\t\tstatNoExports++;\n\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided();\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// If the module has no hash, it's uncacheable\n\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\tstatFlaggedUncached++;\n\t\t\t\t\t\t\t\t// Enqueue uncacheable module for determining the exports\n\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\tconst memCacheValue = memCache && memCache.get(this);\n\t\t\t\t\t\t\tif (memCacheValue !== undefined) {\n\t\t\t\t\t\t\t\tstatRestoredFromMemCache++;\n\t\t\t\t\t\t\t\texportsInfo.restoreProvided(memCacheValue);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcache.get(\n\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache++;\n\t\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(result);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tstatNotCached++;\n\t\t\t\t\t\t\t\t\t\t// Without cached info enqueue module for determining the exports\n\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"restore cached provided exports\");\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\tconst modulesToStore = new Set();\n\n\t\t\t\t\t\t\t/** @type {Map<Module, Set<Module>>} */\n\t\t\t\t\t\t\tconst dependencies = new Map();\n\n\t\t\t\t\t\t\t/** @type {Module} */\n\t\t\t\t\t\t\tlet module;\n\n\t\t\t\t\t\t\t/** @type {ExportsInfo} */\n\t\t\t\t\t\t\tlet exportsInfo;\n\n\t\t\t\t\t\t\t/** @type {Map<Dependency, ExportsSpec>} */\n\t\t\t\t\t\t\tconst exportsSpecsFromDependencies = new Map();\n\n\t\t\t\t\t\t\tlet cacheable = true;\n\t\t\t\t\t\t\tlet changed = false;\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {DependenciesBlock} depBlock the dependencies block\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst processDependenciesBlock = depBlock => {\n\t\t\t\t\t\t\t\tfor (const dep of depBlock.dependencies) {\n\t\t\t\t\t\t\t\t\tprocessDependency(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const block of depBlock.blocks) {\n\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(block);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Dependency} dep the dependency\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst processDependency = dep => {\n\t\t\t\t\t\t\t\tconst exportDesc = dep.getExports(moduleGraph);\n\t\t\t\t\t\t\t\tif (!exportDesc) return;\n\t\t\t\t\t\t\t\texportsSpecsFromDependencies.set(dep, exportDesc);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t\t\t * @param {ExportsSpec} exportDesc info\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst processExportsSpec = (dep, exportDesc) => {\n\t\t\t\t\t\t\t\tconst exports = exportDesc.exports;\n\t\t\t\t\t\t\t\tconst globalCanMangle = exportDesc.canMangle;\n\t\t\t\t\t\t\t\tconst globalFrom = exportDesc.from;\n\t\t\t\t\t\t\t\tconst globalPriority = exportDesc.priority;\n\t\t\t\t\t\t\t\tconst globalTerminalBinding =\n\t\t\t\t\t\t\t\t\texportDesc.terminalBinding || false;\n\t\t\t\t\t\t\t\tconst exportDeps = exportDesc.dependencies;\n\t\t\t\t\t\t\t\tif (exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\tfor (const name of exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\t\t\t\t\t\t\t\t\t\texportInfo.unsetTarget(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (exports === true) {\n\t\t\t\t\t\t\t\t\t// unknown exports\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided(\n\t\t\t\t\t\t\t\t\t\t\tglobalCanMangle,\n\t\t\t\t\t\t\t\t\t\t\texportDesc.excludeExports,\n\t\t\t\t\t\t\t\t\t\t\tglobalFrom && dep,\n\t\t\t\t\t\t\t\t\t\t\tglobalFrom,\n\t\t\t\t\t\t\t\t\t\t\tglobalPriority\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (Array.isArray(exports)) {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * merge in new exports\n\t\t\t\t\t\t\t\t\t * @param {ExportsInfo} exportsInfo own exports info\n\t\t\t\t\t\t\t\t\t * @param {(ExportSpec | string)[]} exports list of exports\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tconst mergeExports = (exportsInfo, exports) => {\n\t\t\t\t\t\t\t\t\t\tfor (const exportNameOrSpec of exports) {\n\t\t\t\t\t\t\t\t\t\t\tlet name;\n\t\t\t\t\t\t\t\t\t\t\tlet canMangle = globalCanMangle;\n\t\t\t\t\t\t\t\t\t\t\tlet terminalBinding = globalTerminalBinding;\n\t\t\t\t\t\t\t\t\t\t\tlet exports = undefined;\n\t\t\t\t\t\t\t\t\t\t\tlet from = globalFrom;\n\t\t\t\t\t\t\t\t\t\t\tlet fromExport = undefined;\n\t\t\t\t\t\t\t\t\t\t\tlet priority = globalPriority;\n\t\t\t\t\t\t\t\t\t\t\tlet hidden = false;\n\t\t\t\t\t\t\t\t\t\t\tif (typeof exportNameOrSpec === \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec.name;\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.canMangle !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle = exportNameOrSpec.canMangle;\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.export !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport = exportNameOrSpec.export;\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.exports !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\texports = exportNameOrSpec.exports;\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.from !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\tfrom = exportNameOrSpec.from;\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.priority !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\tpriority = exportNameOrSpec.priority;\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.terminalBinding !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\tterminalBinding = exportNameOrSpec.terminalBinding;\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.hidden !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\thidden = exportNameOrSpec.hidden;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === false ||\n\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === null\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided = true;\n\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide !== false &&\n\t\t\t\t\t\t\t\t\t\t\t\tcanMangle === false\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide = false;\n\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (terminalBinding && !exportInfo.terminalBinding) {\n\t\t\t\t\t\t\t\t\t\t\t\texportInfo.terminalBinding = true;\n\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (exports) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst nestedExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.createNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\t\tmergeExports(nestedExportsInfo, exports);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\tfrom &&\n\t\t\t\t\t\t\t\t\t\t\t\t(hidden\n\t\t\t\t\t\t\t\t\t\t\t\t\t? exportInfo.unsetTarget(dep)\n\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfo.setTarget(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport === undefined ? [name] : fromExport,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ))\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Recalculate target exportsInfo\n\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(moduleGraph);\n\t\t\t\t\t\t\t\t\t\t\tlet targetExportsInfo = undefined;\n\t\t\t\t\t\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst targetModuleExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModuleExportsInfo.getNestedExportsInfo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(target.module, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (exportInfo.exportsInfoOwned) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo.setRedirectNamedTo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else if (exportInfo.exportsInfo !== targetExportsInfo) {\n\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo = targetExportsInfo;\n\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tmergeExports(exportsInfo, exports);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// store dependencies\n\t\t\t\t\t\t\t\tif (exportDeps) {\n\t\t\t\t\t\t\t\t\tcacheable = false;\n\t\t\t\t\t\t\t\t\tfor (const exportDependency of exportDeps) {\n\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(exportDependency);\n\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\tdependencies.set(exportDependency, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst notifyDependencies = () => {\n\t\t\t\t\t\t\t\tconst deps = dependencies.get(module);\n\t\t\t\t\t\t\t\tif (deps !== undefined) {\n\t\t\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\t\t\tqueue.enqueue(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tlogger.time(\"figure out provided exports\");\n\t\t\t\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\t\t\t\tmodule = queue.dequeue();\n\n\t\t\t\t\t\t\t\tstatQueueItemsProcessed++;\n\n\t\t\t\t\t\t\t\texportsInfo = moduleGraph.getExportsInfo(module);\n\n\t\t\t\t\t\t\t\tcacheable = true;\n\t\t\t\t\t\t\t\tchanged = false;\n\n\t\t\t\t\t\t\t\texportsSpecsFromDependencies.clear();\n\t\t\t\t\t\t\t\tmoduleGraph.freeze();\n\t\t\t\t\t\t\t\tprocessDependenciesBlock(module);\n\t\t\t\t\t\t\t\tmoduleGraph.unfreeze();\n\t\t\t\t\t\t\t\tfor (const [dep, exportsSpec] of exportsSpecsFromDependencies) {\n\t\t\t\t\t\t\t\t\tprocessExportsSpec(dep, exportsSpec);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (cacheable) {\n\t\t\t\t\t\t\t\t\tmodulesToStore.add(module);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\t\t\tnotifyDependencies();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlogger.timeEnd(\"figure out provided exports\");\n\n\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t\t\t(100 * (statFlaggedUncached + statNotCached)) /\n\t\t\t\t\t\t\t\t\t\t(statRestoredFromMemCache +\n\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache +\n\t\t\t\t\t\t\t\t\t\t\tstatNotCached +\n\t\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached +\n\t\t\t\t\t\t\t\t\t\t\tstatNoExports)\n\t\t\t\t\t\t\t\t)}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${\n\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed - statNotCached - statFlaggedUncached\n\t\t\t\t\t\t\t\t} additional calculations due to dependencies)`\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tlogger.time(\"store provided exports into cache\");\n\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\tmodulesToStore,\n\t\t\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\t\t\t// not cacheable\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst cachedData = moduleGraph\n\t\t\t\t\t\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t\t\t\t\t\t.getRestoreProvidedData();\n\t\t\t\t\t\t\t\t\tconst memCache =\n\t\t\t\t\t\t\t\t\t\tmoduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\t\t\tif (memCache) {\n\t\t\t\t\t\t\t\t\t\tmemCache.set(this, cachedData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcache.store(\n\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t\t\tcachedData,\n\t\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"store provided exports into cache\");\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/** @type {WeakMap<Module, any>} */\n\t\t\tconst providedExportsCache = new WeakMap();\n\t\t\tcompilation.hooks.rebuildModule.tap(PLUGIN_NAME, module => {\n\t\t\t\tprovidedExportsCache.set(\n\t\t\t\t\tmodule,\n\t\t\t\t\tmoduleGraph.getExportsInfo(module).getRestoreProvidedData()\n\t\t\t\t);\n\t\t\t});\n\t\t\tcompilation.hooks.finishRebuildingModule.tap(PLUGIN_NAME, module => {\n\t\t\t\tmoduleGraph\n\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t.restoreProvided(providedExportsCache.get(module));\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = FlagDependencyExportsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}