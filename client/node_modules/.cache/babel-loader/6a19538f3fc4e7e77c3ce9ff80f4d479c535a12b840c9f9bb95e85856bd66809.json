{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst {\n  first\n} = require(\"../util/SetHelpers\");\nconst {\n  propertyName\n} = require(\"../util/propertyName\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\nconst joinIterableWithComma = iterable => {\n  // This is more performant than Array.from().join(\", \")\n  // as it doesn't create an array\n  let str = \"\";\n  let first = true;\n  for (const item of iterable) {\n    if (first) {\n      first = false;\n    } else {\n      str += \", \";\n    }\n    str += item;\n  }\n  return str;\n};\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n\n/**\n * @typedef {GenerateContext} Context\n */\nclass HarmonyExportInitFragment extends InitFragment {\n  /**\n   * @param {string} exportsArgument the exports identifier\n   * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n   * @param {Set<string>} unusedExports list of unused export names\n   */\n  constructor(exportsArgument) {\n    let exportMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_MAP;\n    let unusedExports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_SET;\n    super(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n    this.exportsArgument = exportsArgument;\n    this.exportMap = exportMap;\n    this.unusedExports = unusedExports;\n  }\n\n  /**\n   * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n   * @returns {HarmonyExportInitFragment} merged fragment\n   */\n  mergeAll(fragments) {\n    let exportMap;\n    let exportMapOwned = false;\n    let unusedExports;\n    let unusedExportsOwned = false;\n    for (const fragment of fragments) {\n      if (fragment.exportMap.size !== 0) {\n        if (exportMap === undefined) {\n          exportMap = fragment.exportMap;\n          exportMapOwned = false;\n        } else {\n          if (!exportMapOwned) {\n            exportMap = new Map(exportMap);\n            exportMapOwned = true;\n          }\n          for (const [key, value] of fragment.exportMap) {\n            if (!exportMap.has(key)) exportMap.set(key, value);\n          }\n        }\n      }\n      if (fragment.unusedExports.size !== 0) {\n        if (unusedExports === undefined) {\n          unusedExports = fragment.unusedExports;\n          unusedExportsOwned = false;\n        } else {\n          if (!unusedExportsOwned) {\n            unusedExports = new Set(unusedExports);\n            unusedExportsOwned = true;\n          }\n          for (const value of fragment.unusedExports) {\n            unusedExports.add(value);\n          }\n        }\n      }\n    }\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n  merge(other) {\n    let exportMap;\n    if (this.exportMap.size === 0) {\n      exportMap = other.exportMap;\n    } else if (other.exportMap.size === 0) {\n      exportMap = this.exportMap;\n    } else {\n      exportMap = new Map(other.exportMap);\n      for (const [key, value] of this.exportMap) {\n        if (!exportMap.has(key)) exportMap.set(key, value);\n      }\n    }\n    let unusedExports;\n    if (this.unusedExports.size === 0) {\n      unusedExports = other.unusedExports;\n    } else if (other.unusedExports.size === 0) {\n      unusedExports = this.unusedExports;\n    } else {\n      unusedExports = new Set(other.unusedExports);\n      for (const value of this.unusedExports) {\n        unusedExports.add(value);\n      }\n    }\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n\n  /**\n   * @param {Context} context context\n   * @returns {string|Source} the source code that will be included as initialization code\n   */\n  getContent(_ref) {\n    let {\n      runtimeTemplate,\n      runtimeRequirements\n    } = _ref;\n    runtimeRequirements.add(RuntimeGlobals.exports);\n    runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n    const unusedPart = this.unusedExports.size > 1 ? `/* unused harmony exports ${joinIterableWithComma(this.unusedExports)} */\\n` : this.unusedExports.size > 0 ? `/* unused harmony export ${first(this.unusedExports)} */\\n` : \"\";\n    const definitions = [];\n    const orderedExportMap = Array.from(this.exportMap).sort((_ref2, _ref3) => {\n      let [a] = _ref2;\n      let [b] = _ref3;\n      return a < b ? -1 : 1;\n    });\n    for (const [key, value] of orderedExportMap) {\n      definitions.push(`\\n/* harmony export */   ${propertyName(key)}: ${runtimeTemplate.returningFunction(value)}`);\n    }\n    const definePart = this.exportMap.size > 0 ? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(\",\")}\\n/* harmony export */ });\\n` : \"\";\n    return `${definePart}${unusedPart}`;\n  }\n}\nmodule.exports = HarmonyExportInitFragment;","map":{"version":3,"names":["InitFragment","require","RuntimeGlobals","first","propertyName","joinIterableWithComma","iterable","str","item","EMPTY_MAP","Map","EMPTY_SET","Set","HarmonyExportInitFragment","constructor","exportsArgument","exportMap","arguments","length","undefined","unusedExports","STAGE_HARMONY_EXPORTS","mergeAll","fragments","exportMapOwned","unusedExportsOwned","fragment","size","key","value","has","set","add","merge","other","getContent","_ref","runtimeTemplate","runtimeRequirements","exports","definePropertyGetters","unusedPart","definitions","orderedExportMap","Array","from","sort","_ref2","_ref3","a","b","push","returningFunction","definePart","join","module"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/dependencies/HarmonyExportInitFragment.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst { first } = require(\"../util/SetHelpers\");\nconst { propertyName } = require(\"../util/propertyName\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\nconst joinIterableWithComma = iterable => {\n\t// This is more performant than Array.from().join(\", \")\n\t// as it doesn't create an array\n\tlet str = \"\";\n\tlet first = true;\n\tfor (const item of iterable) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tstr += \", \";\n\t\t}\n\t\tstr += item;\n\t}\n\treturn str;\n};\n\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n\n/**\n * @typedef {GenerateContext} Context\n */\nclass HarmonyExportInitFragment extends InitFragment {\n\t/**\n\t * @param {string} exportsArgument the exports identifier\n\t * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n\t * @param {Set<string>} unusedExports list of unused export names\n\t */\n\tconstructor(\n\t\texportsArgument,\n\t\texportMap = EMPTY_MAP,\n\t\tunusedExports = EMPTY_SET\n\t) {\n\t\tsuper(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n\t\tthis.exportsArgument = exportsArgument;\n\t\tthis.exportMap = exportMap;\n\t\tthis.unusedExports = unusedExports;\n\t}\n\n\t/**\n\t * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n\t * @returns {HarmonyExportInitFragment} merged fragment\n\t */\n\tmergeAll(fragments) {\n\t\tlet exportMap;\n\t\tlet exportMapOwned = false;\n\t\tlet unusedExports;\n\t\tlet unusedExportsOwned = false;\n\n\t\tfor (const fragment of fragments) {\n\t\t\tif (fragment.exportMap.size !== 0) {\n\t\t\t\tif (exportMap === undefined) {\n\t\t\t\t\texportMap = fragment.exportMap;\n\t\t\t\t\texportMapOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!exportMapOwned) {\n\t\t\t\t\t\texportMap = new Map(exportMap);\n\t\t\t\t\t\texportMapOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [key, value] of fragment.exportMap) {\n\t\t\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fragment.unusedExports.size !== 0) {\n\t\t\t\tif (unusedExports === undefined) {\n\t\t\t\t\tunusedExports = fragment.unusedExports;\n\t\t\t\t\tunusedExportsOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!unusedExportsOwned) {\n\t\t\t\t\t\tunusedExports = new Set(unusedExports);\n\t\t\t\t\t\tunusedExportsOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const value of fragment.unusedExports) {\n\t\t\t\t\t\tunusedExports.add(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\tmerge(other) {\n\t\tlet exportMap;\n\t\tif (this.exportMap.size === 0) {\n\t\t\texportMap = other.exportMap;\n\t\t} else if (other.exportMap.size === 0) {\n\t\t\texportMap = this.exportMap;\n\t\t} else {\n\t\t\texportMap = new Map(other.exportMap);\n\t\t\tfor (const [key, value] of this.exportMap) {\n\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t}\n\t\t}\n\t\tlet unusedExports;\n\t\tif (this.unusedExports.size === 0) {\n\t\t\tunusedExports = other.unusedExports;\n\t\t} else if (other.unusedExports.size === 0) {\n\t\t\tunusedExports = this.unusedExports;\n\t\t} else {\n\t\t\tunusedExports = new Set(other.unusedExports);\n\t\t\tfor (const value of this.unusedExports) {\n\t\t\t\tunusedExports.add(value);\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\t/**\n\t * @param {Context} context context\n\t * @returns {string|Source} the source code that will be included as initialization code\n\t */\n\tgetContent({ runtimeTemplate, runtimeRequirements }) {\n\t\truntimeRequirements.add(RuntimeGlobals.exports);\n\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\n\t\tconst unusedPart =\n\t\t\tthis.unusedExports.size > 1\n\t\t\t\t? `/* unused harmony exports ${joinIterableWithComma(\n\t\t\t\t\t\tthis.unusedExports\n\t\t\t\t  )} */\\n`\n\t\t\t\t: this.unusedExports.size > 0\n\t\t\t\t? `/* unused harmony export ${first(this.unusedExports)} */\\n`\n\t\t\t\t: \"\";\n\t\tconst definitions = [];\n\t\tconst orderedExportMap = Array.from(this.exportMap).sort(([a], [b]) =>\n\t\t\ta < b ? -1 : 1\n\t\t);\n\t\tfor (const [key, value] of orderedExportMap) {\n\t\t\tdefinitions.push(\n\t\t\t\t`\\n/* harmony export */   ${propertyName(\n\t\t\t\t\tkey\n\t\t\t\t)}: ${runtimeTemplate.returningFunction(value)}`\n\t\t\t);\n\t\t}\n\t\tconst definePart =\n\t\t\tthis.exportMap.size > 0\n\t\t\t\t? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${\n\t\t\t\t\t\tthis.exportsArgument\n\t\t\t\t  }, {${definitions.join(\",\")}\\n/* harmony export */ });\\n`\n\t\t\t\t: \"\";\n\t\treturn `${definePart}${unusedPart}`;\n\t}\n}\n\nmodule.exports = HarmonyExportInitFragment;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,YAAY,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC/C,MAAMC,cAAc,GAAGD,OAAO,CAAC,mBAAmB,CAAC;AACnD,MAAM;EAAEE;AAAM,CAAC,GAAGF,OAAO,CAAC,oBAAoB,CAAC;AAC/C,MAAM;EAAEG;AAAa,CAAC,GAAGH,OAAO,CAAC,sBAAsB,CAAC;;AAExD;AACA;;AAEA,MAAMI,qBAAqB,GAAGC,QAAQ,IAAI;EACzC;EACA;EACA,IAAIC,GAAG,GAAG,EAAE;EACZ,IAAIJ,KAAK,GAAG,IAAI;EAChB,KAAK,MAAMK,IAAI,IAAIF,QAAQ,EAAE;IAC5B,IAAIH,KAAK,EAAE;MACVA,KAAK,GAAG,KAAK;IACd,CAAC,MAAM;MACNI,GAAG,IAAI,IAAI;IACZ;IACAA,GAAG,IAAIC,IAAI;EACZ;EACA,OAAOD,GAAG;AACX,CAAC;AAED,MAAME,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;AAC3B,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAE3B;AACA;AACA;AACA,MAAMC,yBAAyB,SAASb,YAAY,CAAC;EACpD;AACD;AACA;AACA;AACA;EACCc,WAAWA,CACVC,eAAe,EAGd;IAAA,IAFDC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGR,SAAS;IAAA,IACrBW,aAAa,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGN,SAAS;IAEzB,KAAK,CAACQ,SAAS,EAAEnB,YAAY,CAACqB,qBAAqB,EAAE,CAAC,EAAE,iBAAiB,CAAC;IAC1E,IAAI,CAACN,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACI,aAAa,GAAGA,aAAa;EACnC;;EAEA;AACD;AACA;AACA;EACCE,QAAQA,CAACC,SAAS,EAAE;IACnB,IAAIP,SAAS;IACb,IAAIQ,cAAc,GAAG,KAAK;IAC1B,IAAIJ,aAAa;IACjB,IAAIK,kBAAkB,GAAG,KAAK;IAE9B,KAAK,MAAMC,QAAQ,IAAIH,SAAS,EAAE;MACjC,IAAIG,QAAQ,CAACV,SAAS,CAACW,IAAI,KAAK,CAAC,EAAE;QAClC,IAAIX,SAAS,KAAKG,SAAS,EAAE;UAC5BH,SAAS,GAAGU,QAAQ,CAACV,SAAS;UAC9BQ,cAAc,GAAG,KAAK;QACvB,CAAC,MAAM;UACN,IAAI,CAACA,cAAc,EAAE;YACpBR,SAAS,GAAG,IAAIN,GAAG,CAACM,SAAS,CAAC;YAC9BQ,cAAc,GAAG,IAAI;UACtB;UACA,KAAK,MAAM,CAACI,GAAG,EAAEC,KAAK,CAAC,IAAIH,QAAQ,CAACV,SAAS,EAAE;YAC9C,IAAI,CAACA,SAAS,CAACc,GAAG,CAACF,GAAG,CAAC,EAAEZ,SAAS,CAACe,GAAG,CAACH,GAAG,EAAEC,KAAK,CAAC;UACnD;QACD;MACD;MACA,IAAIH,QAAQ,CAACN,aAAa,CAACO,IAAI,KAAK,CAAC,EAAE;QACtC,IAAIP,aAAa,KAAKD,SAAS,EAAE;UAChCC,aAAa,GAAGM,QAAQ,CAACN,aAAa;UACtCK,kBAAkB,GAAG,KAAK;QAC3B,CAAC,MAAM;UACN,IAAI,CAACA,kBAAkB,EAAE;YACxBL,aAAa,GAAG,IAAIR,GAAG,CAACQ,aAAa,CAAC;YACtCK,kBAAkB,GAAG,IAAI;UAC1B;UACA,KAAK,MAAMI,KAAK,IAAIH,QAAQ,CAACN,aAAa,EAAE;YAC3CA,aAAa,CAACY,GAAG,CAACH,KAAK,CAAC;UACzB;QACD;MACD;IACD;IACA,OAAO,IAAIhB,yBAAyB,CACnC,IAAI,CAACE,eAAe,EACpBC,SAAS,EACTI,aACD,CAAC;EACF;EAEAa,KAAKA,CAACC,KAAK,EAAE;IACZ,IAAIlB,SAAS;IACb,IAAI,IAAI,CAACA,SAAS,CAACW,IAAI,KAAK,CAAC,EAAE;MAC9BX,SAAS,GAAGkB,KAAK,CAAClB,SAAS;IAC5B,CAAC,MAAM,IAAIkB,KAAK,CAAClB,SAAS,CAACW,IAAI,KAAK,CAAC,EAAE;MACtCX,SAAS,GAAG,IAAI,CAACA,SAAS;IAC3B,CAAC,MAAM;MACNA,SAAS,GAAG,IAAIN,GAAG,CAACwB,KAAK,CAAClB,SAAS,CAAC;MACpC,KAAK,MAAM,CAACY,GAAG,EAAEC,KAAK,CAAC,IAAI,IAAI,CAACb,SAAS,EAAE;QAC1C,IAAI,CAACA,SAAS,CAACc,GAAG,CAACF,GAAG,CAAC,EAAEZ,SAAS,CAACe,GAAG,CAACH,GAAG,EAAEC,KAAK,CAAC;MACnD;IACD;IACA,IAAIT,aAAa;IACjB,IAAI,IAAI,CAACA,aAAa,CAACO,IAAI,KAAK,CAAC,EAAE;MAClCP,aAAa,GAAGc,KAAK,CAACd,aAAa;IACpC,CAAC,MAAM,IAAIc,KAAK,CAACd,aAAa,CAACO,IAAI,KAAK,CAAC,EAAE;MAC1CP,aAAa,GAAG,IAAI,CAACA,aAAa;IACnC,CAAC,MAAM;MACNA,aAAa,GAAG,IAAIR,GAAG,CAACsB,KAAK,CAACd,aAAa,CAAC;MAC5C,KAAK,MAAMS,KAAK,IAAI,IAAI,CAACT,aAAa,EAAE;QACvCA,aAAa,CAACY,GAAG,CAACH,KAAK,CAAC;MACzB;IACD;IACA,OAAO,IAAIhB,yBAAyB,CACnC,IAAI,CAACE,eAAe,EACpBC,SAAS,EACTI,aACD,CAAC;EACF;;EAEA;AACD;AACA;AACA;EACCe,UAAUA,CAAAC,IAAA,EAA2C;IAAA,IAA1C;MAAEC,eAAe;MAAEC;IAAoB,CAAC,GAAAF,IAAA;IAClDE,mBAAmB,CAACN,GAAG,CAAC9B,cAAc,CAACqC,OAAO,CAAC;IAC/CD,mBAAmB,CAACN,GAAG,CAAC9B,cAAc,CAACsC,qBAAqB,CAAC;IAE7D,MAAMC,UAAU,GACf,IAAI,CAACrB,aAAa,CAACO,IAAI,GAAG,CAAC,GACvB,6BAA4BtB,qBAAqB,CAClD,IAAI,CAACe,aACL,CAAE,OAAM,GACR,IAAI,CAACA,aAAa,CAACO,IAAI,GAAG,CAAC,GAC1B,4BAA2BxB,KAAK,CAAC,IAAI,CAACiB,aAAa,CAAE,OAAM,GAC5D,EAAE;IACN,MAAMsB,WAAW,GAAG,EAAE;IACtB,MAAMC,gBAAgB,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC7B,SAAS,CAAC,CAAC8B,IAAI,CAAC,CAAAC,KAAA,EAAAC,KAAA;MAAA,IAAC,CAACC,CAAC,CAAC,GAAAF,KAAA;MAAA,IAAE,CAACG,CAAC,CAAC,GAAAF,KAAA;MAAA,OACjEC,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IAAA,CACf,CAAC;IACD,KAAK,MAAM,CAACtB,GAAG,EAAEC,KAAK,CAAC,IAAIc,gBAAgB,EAAE;MAC5CD,WAAW,CAACS,IAAI,CACd,4BAA2B/C,YAAY,CACvCwB,GACD,CAAE,KAAIS,eAAe,CAACe,iBAAiB,CAACvB,KAAK,CAAE,EAChD,CAAC;IACF;IACA,MAAMwB,UAAU,GACf,IAAI,CAACrC,SAAS,CAACW,IAAI,GAAG,CAAC,GACnB,wBAAuBzB,cAAc,CAACsC,qBAAsB,IAC7D,IAAI,CAACzB,eACJ,MAAK2B,WAAW,CAACY,IAAI,CAAC,GAAG,CAAE,8BAA6B,GACzD,EAAE;IACN,OAAQ,GAAED,UAAW,GAAEZ,UAAW,EAAC;EACpC;AACD;AAEAc,MAAM,CAAChB,OAAO,GAAG1B,yBAAyB"},"metadata":{},"sourceType":"script","externalDependencies":[]}