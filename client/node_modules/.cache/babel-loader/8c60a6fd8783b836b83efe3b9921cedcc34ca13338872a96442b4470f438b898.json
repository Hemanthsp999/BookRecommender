{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\nconst {\n  compareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"), () => require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\"), {\n  name: \"Limit Chunk Count Plugin\",\n  baseDataPath: \"options\"\n});\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n  const set = map.get(key);\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\nclass LimitChunkCountPlugin {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  constructor(options) {\n    validate(options);\n    this.options = options;\n  }\n\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n      compilation.hooks.optimizeChunks.tap({\n        name: \"LimitChunkCountPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        const chunkGraph = compilation.chunkGraph;\n        const maxChunks = options.maxChunks;\n        if (!maxChunks) return;\n        if (maxChunks < 1) return;\n        if (compilation.chunks.size <= maxChunks) return;\n        let remainingChunksToMerge = compilation.chunks.size - maxChunks;\n\n        // order chunks in a deterministic way\n        const compareChunksWithGraph = compareChunks(chunkGraph);\n        const orderedChunks = Array.from(chunks).sort(compareChunksWithGraph);\n\n        // create a lazy sorted data structure to keep all combinations\n        // this is large. Size = chunks * (chunks - 1) / 2\n        // It uses a multi layer bucket sort plus normal sort in the last layer\n        // It's also lazy so only accessed buckets are sorted\n        const combinations = new LazyBucketSortedSet(\n        // Layer 1: ordered by largest size benefit\n        c => c.sizeDiff, (a, b) => b - a,\n        // Layer 2: ordered by smallest combined size\n        c => c.integratedSize, (a, b) => a - b,\n        // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n        c => c.bIdx - c.aIdx, (a, b) => a - b,\n        // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n        (a, b) => a.bIdx - b.bIdx);\n\n        // we keep a mapping from chunk to all combinations\n        // but this mapping is not kept up-to-date with deletions\n        // so `deleted` flag need to be considered when iterating this\n        /** @type {Map<Chunk, Set<ChunkCombination>>} */\n        const combinationsByChunk = new Map();\n        orderedChunks.forEach((b, bIdx) => {\n          // create combination pairs with size and integrated size\n          for (let aIdx = 0; aIdx < bIdx; aIdx++) {\n            const a = orderedChunks[aIdx];\n            // filter pairs that can not be integrated!\n            if (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n            const integratedSize = chunkGraph.getIntegratedChunksSize(a, b, options);\n            const aSize = chunkGraph.getChunkSize(a, options);\n            const bSize = chunkGraph.getChunkSize(b, options);\n            const c = {\n              deleted: false,\n              sizeDiff: aSize + bSize - integratedSize,\n              integratedSize,\n              a,\n              b,\n              aIdx,\n              bIdx,\n              aSize,\n              bSize\n            };\n            combinations.add(c);\n            addToSetMap(combinationsByChunk, a, c);\n            addToSetMap(combinationsByChunk, b, c);\n          }\n          return combinations;\n        });\n\n        // list of modified chunks during this run\n        // combinations affected by this change are skipped to allow\n        // further optimizations\n        /** @type {Set<Chunk>} */\n        const modifiedChunks = new Set();\n        let changed = false;\n        // eslint-disable-next-line no-constant-condition\n        loop: while (true) {\n          const combination = combinations.popFirst();\n          if (combination === undefined) break;\n          combination.deleted = true;\n          const {\n            a,\n            b,\n            integratedSize\n          } = combination;\n\n          // skip over pair when\n          // one of the already merged chunks is a parent of one of the chunks\n          if (modifiedChunks.size > 0) {\n            const queue = new Set(a.groupsIterable);\n            for (const group of b.groupsIterable) {\n              queue.add(group);\n            }\n            for (const group of queue) {\n              for (const mChunk of modifiedChunks) {\n                if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n                  // This is a potential pair which needs recalculation\n                  // We can't do that now, but it merge before following pairs\n                  // so we leave space for it, and consider chunks as modified\n                  // just for the worse case\n                  remainingChunksToMerge--;\n                  if (remainingChunksToMerge <= 0) break loop;\n                  modifiedChunks.add(a);\n                  modifiedChunks.add(b);\n                  continue loop;\n                }\n              }\n              for (const parent of group.parentsIterable) {\n                queue.add(parent);\n              }\n            }\n          }\n\n          // merge the chunks\n          if (chunkGraph.canChunksBeIntegrated(a, b)) {\n            chunkGraph.integrateChunks(a, b);\n            compilation.chunks.delete(b);\n\n            // flag chunk a as modified as further optimization are possible for all children here\n            modifiedChunks.add(a);\n            changed = true;\n            remainingChunksToMerge--;\n            if (remainingChunksToMerge <= 0) break;\n\n            // Update all affected combinations\n            // delete all combination with the removed chunk\n            // we will use combinations with the kept chunk instead\n            for (const combination of combinationsByChunk.get(a)) {\n              if (combination.deleted) continue;\n              combination.deleted = true;\n              combinations.delete(combination);\n            }\n\n            // Update combinations with the kept chunk with new sizes\n            for (const combination of combinationsByChunk.get(b)) {\n              if (combination.deleted) continue;\n              if (combination.a === b) {\n                if (!chunkGraph.canChunksBeIntegrated(a, combination.b)) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n                // Update size\n                const newIntegratedSize = chunkGraph.getIntegratedChunksSize(a, combination.b, options);\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.a = a;\n                combination.integratedSize = newIntegratedSize;\n                combination.aSize = integratedSize;\n                combination.sizeDiff = combination.bSize + integratedSize - newIntegratedSize;\n                finishUpdate();\n              } else if (combination.b === b) {\n                if (!chunkGraph.canChunksBeIntegrated(combination.a, a)) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n                // Update size\n                const newIntegratedSize = chunkGraph.getIntegratedChunksSize(combination.a, a, options);\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.b = a;\n                combination.integratedSize = newIntegratedSize;\n                combination.bSize = integratedSize;\n                combination.sizeDiff = integratedSize + combination.aSize - newIntegratedSize;\n                finishUpdate();\n              }\n            }\n            combinationsByChunk.set(a, combinationsByChunk.get(b));\n            combinationsByChunk.delete(b);\n          }\n        }\n        if (changed) return true;\n      });\n    });\n  }\n}\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"names":["STAGE_ADVANCED","require","LazyBucketSortedSet","compareChunks","createSchemaValidation","validate","name","baseDataPath","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","constructor","options","apply","compiler","hooks","compilation","tap","optimizeChunks","stage","chunks","chunkGraph","maxChunks","size","remainingChunksToMerge","compareChunksWithGraph","orderedChunks","Array","from","sort","combinations","c","sizeDiff","a","b","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","canChunksBeIntegrated","getIntegratedChunksSize","aSize","getChunkSize","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parent","parentsIterable","integrateChunks","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\nconst { compareChunks } = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\"),\n\t{\n\t\tname: \"Limit Chunk Count Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"LimitChunkCountPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (compilation.chunks.size <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = compilation.chunks.size - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst compareChunksWithGraph = compareChunks(chunkGraph);\n\t\t\t\t\tconst orderedChunks = Array.from(chunks).sort(compareChunksWithGraph);\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mapping from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\t// filter pairs that can not be integrated!\n\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n\n\t\t\t\t\t\t\tconst integratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst aSize = chunkGraph.getChunkSize(a, options);\n\t\t\t\t\t\t\tconst bSize = chunkGraph.getChunkSize(b, options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// further optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(a, b)) {\n\t\t\t\t\t\t\tchunkGraph.integrateChunks(a, b);\n\t\t\t\t\t\t\tcompilation.chunks.delete(b);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, combination.b)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.a = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(combination.a, a)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\tcombination.a,\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.b = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsByChunk.set(a, combinationsByChunk.get(b));\n\t\t\t\t\t\t\tcombinationsByChunk.delete(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}