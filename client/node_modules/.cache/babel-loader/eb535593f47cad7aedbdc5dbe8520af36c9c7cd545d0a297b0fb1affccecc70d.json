{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst {\n  processExportsField\n} = require(\"./util/entrypoints\");\nconst {\n  parseIdentifier\n} = require(\"./util/identifier\");\nconst {\n  checkImportsExportsFieldTarget\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\nmodule.exports = class ExportsFieldPlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} target target\n   */\n  constructor(source, conditionNames, fieldNamePath, target) {\n    this.source = source;\n    this.target = target;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<JsonObject, FieldProcessor>} */\n    this.fieldProcessorCache = new WeakMap();\n  }\n\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n  apply(resolver) {\n    const target = resolver.ensureHook(this.target);\n    resolver.getHook(this.source).tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\n      // When there is no description file, abort\n      if (!request.descriptionFilePath) return callback();\n      if (\n      // When the description file is inherited from parent, abort\n      // (There is no description file inside of this package)\n      request.relativePath !== \".\" || request.request === undefined) return callback();\n      const remainingRequest = request.query || request.fragment ? (request.request === \".\" ? \"./\" : request.request) + request.query + request.fragment : request.request;\n      const exportsField = /** @type {ExportsField|null|undefined} */\n\n      DescriptionFileUtils.getField( /** @type {JsonObject} */request.descriptionFileData, this.fieldName);\n      if (!exportsField) return callback();\n      if (request.directory) {\n        return callback(new Error(`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`));\n      }\n\n      /** @type {string[]} */\n      let paths;\n      try {\n        // We attach the cache to the description file instead of the exportsField value\n        // because we use a WeakMap and the exportsField could be a string too.\n        // Description file is always an object when exports field can be accessed.\n        let fieldProcessor = this.fieldProcessorCache.get( /** @type {JsonObject} */request.descriptionFileData);\n        if (fieldProcessor === undefined) {\n          fieldProcessor = processExportsField(exportsField);\n          this.fieldProcessorCache.set( /** @type {JsonObject} */request.descriptionFileData, fieldProcessor);\n        }\n        paths = fieldProcessor(remainingRequest, this.conditionNames);\n      } catch ( /** @type {unknown} */err) {\n        if (resolveContext.log) {\n          resolveContext.log(`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`);\n        }\n        return callback( /** @type {Error} */err);\n      }\n      if (paths.length === 0) {\n        return callback(new Error(`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`));\n      }\n      forEachBail(paths,\n      /**\n       * @param {string} p path\n       * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n       * @returns {void}\n       */\n      (p, callback) => {\n        const parsedIdentifier = parseIdentifier(p);\n        if (!parsedIdentifier) return callback();\n        const [relativePath, query, fragment] = parsedIdentifier;\n        const error = checkImportsExportsFieldTarget(relativePath);\n        if (error) {\n          return callback(error);\n        }\n\n        /** @type {ResolveRequest} */\n        const obj = {\n          ...request,\n          request: undefined,\n          path: path.join( /** @type {string} */request.descriptionFileRoot, relativePath),\n          relativePath,\n          query,\n          fragment\n        };\n        resolver.doResolve(target, obj, \"using exports field: \" + p, resolveContext, callback);\n      },\n      /**\n       * @param {null|Error} [err] error\n       * @param {null|ResolveRequest} [result] result\n       * @returns {void}\n       */\n      (err, result) => callback(err, result || null));\n    });\n  }\n};","map":{"version":3,"names":["path","require","DescriptionFileUtils","forEachBail","processExportsField","parseIdentifier","checkImportsExportsFieldTarget","module","exports","ExportsFieldPlugin","constructor","source","conditionNames","fieldNamePath","target","fieldName","fieldProcessorCache","WeakMap","apply","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","relativePath","undefined","remainingRequest","query","fragment","exportsField","getField","descriptionFileData","directory","Error","paths","fieldProcessor","get","set","err","log","length","descriptionFileRoot","p","parsedIdentifier","error","obj","join","doResolve","result"],"sources":["/home/hemanth/react-project/client/node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processExportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst { checkImportsExportsFieldTarget } = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").JsonObject} JsonObject */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\nmodule.exports = class ExportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, conditionNames, fieldNamePath, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<JsonObject, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath) return callback();\n\t\t\t\tif (\n\t\t\t\t\t// When the description file is inherited from parent, abort\n\t\t\t\t\t// (There is no description file inside of this package)\n\t\t\t\t\trequest.relativePath !== \".\" ||\n\t\t\t\t\trequest.request === undefined\n\t\t\t\t)\n\t\t\t\t\treturn callback();\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.query || request.fragment\n\t\t\t\t\t\t? (request.request === \".\" ? \"./\" : request.request) +\n\t\t\t\t\t\t  request.query +\n\t\t\t\t\t\t  request.fragment\n\t\t\t\t\t\t: request.request;\n\t\t\t\tconst exportsField =\n\t\t\t\t\t/** @type {ExportsField|null|undefined} */\n\t\t\t\t\t(\n\t\t\t\t\t\tDescriptionFileUtils.getField(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tthis.fieldName\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\tif (!exportsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tlet paths;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the exportsField value\n\t\t\t\t\t// because we use a WeakMap and the exportsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData)\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processExportsField(exportsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\t/** @type {JsonObject} */ (request.descriptionFileData),\n\t\t\t\t\t\t\tfieldProcessor\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpaths = fieldProcessor(remainingRequest, this.conditionNames);\n\t\t\t\t} catch (/** @type {unknown} */ err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(/** @type {Error} */ (err));\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} p path\n\t\t\t\t\t * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(p, callback) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(p);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [relativePath, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tconst error = checkImportsExportsFieldTarget(relativePath);\n\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn callback(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\tpath: path.join(\n\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\trelativePath\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\"using exports field: \" + p,\n\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {null|Error} [err] error\n\t\t\t\t\t * @param {null|ResolveRequest} [result] result\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(err, result) => callback(err, result || null)\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}