{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\nconst {\n  compareModulesByIdentifier,\n  compareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"), () => require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"), {\n  name: \"Aggressive Splitting Plugin\",\n  baseDataPath: \"options\"\n});\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n  return module => {\n    chunkGraph.disconnectChunkAndModule(oldChunk, module);\n    chunkGraph.connectChunkAndModule(newChunk, module);\n  };\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n  return module => {\n    return !chunkGraph.isEntryModuleInChunk(module, chunk);\n  };\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.options = options;\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk to test\n   * @returns {boolean} true if the chunk was recorded\n   */\n  static wasChunkRecorded(chunk) {\n    return recordedChunks.has(chunk);\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      let fromAggressiveSplittingSet;\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"AggressiveSplittingPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        const chunkGraph = compilation.chunkGraph;\n        // Precompute stuff\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n        const makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n        for (const m of compilation.modules) {\n          const name = makePathsRelative(m.identifier());\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        }\n\n        // Check used chunk ids\n        const usedIds = new Set();\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = this.options.minSize;\n        const maxSize = this.options.maxSize;\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          }\n\n          // Get module objects from names\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name));\n\n          // Does the modules exist at all?\n          if (!selectedModules.every(Boolean)) return false;\n\n          // Check if size matches (faster than waiting for hash)\n          let size = 0;\n          for (const m of selectedModules) size += m.size();\n          if (size !== splitData.size) return false;\n\n          // get chunks with all modules\n          const selectedChunks = intersect(selectedModules.map(m => new Set(chunkGraph.getModuleChunksIterable(m))));\n\n          // No relevant chunks found\n          if (selectedChunks.size === 0) return false;\n\n          // The found chunk is already the split or similar\n          if (selectedChunks.size === 1 && chunkGraph.getNumberOfChunkModules(Array.from(selectedChunks)[0]) === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          }\n\n          // split the chunk into two parts\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunkGraph, chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n            newChunk.ids = [splitData.id];\n          }\n          return true;\n        };\n\n        // try to restore to recorded splitting\n        let changed = false;\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        }\n\n        // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n        const cmpFn = compareChunks(chunkGraph);\n        const sortedChunks = Array.from(chunks).sort((a, b) => {\n          const diff1 = chunkGraph.getChunkModulesSize(b) - chunkGraph.getChunkModulesSize(a);\n          if (diff1) return diff1;\n          const diff2 = chunkGraph.getNumberOfChunkModules(a) - chunkGraph.getNumberOfChunkModules(b);\n          if (diff2) return diff2;\n          return cmpFn(a, b);\n        });\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunkGraph.getChunkModulesSize(chunk);\n          if (size > maxSize && chunkGraph.getNumberOfChunkModules(chunk) > 1) {\n            const modules = chunkGraph.getOrderedChunkModules(chunk, compareModulesByIdentifier).filter(isNotAEntryModule(chunkGraph, chunk));\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set();\n\n        // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData);\n              // set flag for stats\n              recordedChunks.add(chunk);\n            }\n          }\n\n          // Also add all unused historical splits (after the used ones)\n          // They can still be used in some future compilation\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          }\n\n          // record all splits\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n}\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"names":["STAGE_ADVANCED","require","intersect","compareModulesByIdentifier","compareChunks","createSchemaValidation","identifierUtils","validate","name","baseDataPath","moveModuleBetween","chunkGraph","oldChunk","newChunk","module","disconnectChunkAndModule","connectChunkAndModule","isNotAEntryModule","chunk","isEntryModuleInChunk","recordedChunks","WeakSet","AggressiveSplittingPlugin","constructor","options","arguments","length","undefined","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","wasChunkRecorded","has","apply","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunks","stage","chunks","nameToModuleMap","moduleToNameMap","makePathsRelative","bindContextCache","context","root","m","modules","identifier","set","usedIds","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","selectedModules","map","get","every","Boolean","size","selectedChunks","getModuleChunksIterable","getNumberOfChunkModules","Array","from","addChunk","chunkReason","forEach","split","ids","changed","j","cmpFn","sortedChunks","sort","a","b","diff1","getChunkModulesSize","diff2","getOrderedChunkModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"),\n\t() =>\n\t\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"),\n\t{\n\t\tname: \"Aggressive Splitting Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n\treturn module => {\n\t\tchunkGraph.disconnectChunkAndModule(oldChunk, module);\n\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t};\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n\treturn module => {\n\t\treturn !chunkGraph.isEntryModuleInChunk(module, chunk);\n\t};\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to test\n\t * @returns {boolean} true if the chunk was recorded\n\t */\n\tstatic wasChunkRecorded(chunk) {\n\t\treturn recordedChunks.has(chunk);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"AggressiveSplittingPlugin\",\n\t\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tconst makePathsRelative =\n\t\t\t\t\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tcompiler.root\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = makePathsRelative(m.identifier());\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tlet size = 0;\n\t\t\t\t\t\t\tfor (const m of selectedModules) size += m.size();\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(\n\t\t\t\t\t\t\t\t\tm => new Set(chunkGraph.getModuleChunksIterable(m))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(\n\t\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0]\n\t\t\t\t\t\t\t\t) === selectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(\n\t\t\t\t\t\t\t\t\tmoveModuleBetween(chunkGraph, chunk, newChunk)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t\tnewChunk.ids = [splitData.id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst cmpFn = compareChunks(chunkGraph);\n\t\t\t\t\t\tconst sortedChunks = Array.from(chunks).sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 =\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(b) -\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(a);\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 =\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(a) -\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(b);\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\treturn cmpFn(a, b);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunkGraph.getChunkModulesSize(chunk);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tsize > maxSize &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) > 1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst modules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getOrderedChunkModules(chunk, compareModulesByIdentifier)\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunkGraph, chunk));\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\trecordedChunks.add(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historical splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}