{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\nconst fs = require(\"graceful-fs\");\nconst path = require(\"path\");\nconst watchEventSource = require(\"./watchEventSource\");\nconst EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});\nlet FS_ACCURACY = 2000;\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst WATCHPACK_POLLING = process.env.WATCHPACK_POLLING;\nconst FORCE_POLLING = `${+WATCHPACK_POLLING}` === WATCHPACK_POLLING ? +WATCHPACK_POLLING : !!WATCHPACK_POLLING && WATCHPACK_POLLING !== \"false\";\nfunction withoutCase(str) {\n  return str.toLowerCase();\n}\nfunction needCalls(times, callback) {\n  return function () {\n    if (--times === 0) {\n      return callback();\n    }\n  };\n}\nclass Watcher extends EventEmitter {\n  constructor(directoryWatcher, filePath, startTime) {\n    super();\n    this.directoryWatcher = directoryWatcher;\n    this.path = filePath;\n    this.startTime = startTime && +startTime;\n  }\n  checkStartTime(mtime, initial) {\n    const startTime = this.startTime;\n    if (typeof startTime !== \"number\") return !initial;\n    return startTime <= mtime;\n  }\n  close() {\n    this.emit(\"closed\");\n  }\n}\nclass DirectoryWatcher extends EventEmitter {\n  constructor(watcherManager, directoryPath, options) {\n    super();\n    if (FORCE_POLLING) {\n      options.poll = FORCE_POLLING;\n    }\n    this.watcherManager = watcherManager;\n    this.options = options;\n    this.path = directoryPath;\n    // safeTime is the point in time after which reading is safe to be unchanged\n    // timestamp is a value that should be compared with another timestamp (mtime)\n    /** @type {Map<string, { safeTime: number, timestamp: number }} */\n    this.files = new Map();\n    /** @type {Map<string, number>} */\n    this.filesWithoutCase = new Map();\n    this.directories = new Map();\n    this.lastWatchEvent = 0;\n    this.initialScan = true;\n    this.ignored = options.ignored || (() => false);\n    this.nestedWatching = false;\n    this.polledWatching = typeof options.poll === \"number\" ? options.poll : options.poll ? 5007 : false;\n    this.timeout = undefined;\n    this.initialScanRemoved = new Set();\n    this.initialScanFinished = undefined;\n    /** @type {Map<string, Set<Watcher>>} */\n    this.watchers = new Map();\n    this.parentWatcher = null;\n    this.refs = 0;\n    this._activeEvents = new Map();\n    this.closed = false;\n    this.scanning = false;\n    this.scanAgain = false;\n    this.scanAgainInitial = false;\n    this.createWatcher();\n    this.doScan(true);\n  }\n  createWatcher() {\n    try {\n      if (this.polledWatching) {\n        this.watcher = {\n          close: () => {\n            if (this.timeout) {\n              clearTimeout(this.timeout);\n              this.timeout = undefined;\n            }\n          }\n        };\n      } else {\n        if (IS_OSX) {\n          this.watchInParentDirectory();\n        }\n        this.watcher = watchEventSource.watch(this.path);\n        this.watcher.on(\"change\", this.onWatchEvent.bind(this));\n        this.watcher.on(\"error\", this.onWatcherError.bind(this));\n      }\n    } catch (err) {\n      this.onWatcherError(err);\n    }\n  }\n  forEachWatcher(path, fn) {\n    const watchers = this.watchers.get(withoutCase(path));\n    if (watchers !== undefined) {\n      for (const w of watchers) {\n        fn(w);\n      }\n    }\n  }\n  setMissing(itemPath, initial, type) {\n    if (this.initialScan) {\n      this.initialScanRemoved.add(itemPath);\n    }\n    const oldDirectory = this.directories.get(itemPath);\n    if (oldDirectory) {\n      if (this.nestedWatching) oldDirectory.close();\n      this.directories.delete(itemPath);\n      this.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", itemPath, null, type, initial));\n      }\n    }\n    const oldFile = this.files.get(itemPath);\n    if (oldFile) {\n      this.files.delete(itemPath);\n      const key = withoutCase(itemPath);\n      const count = this.filesWithoutCase.get(key) - 1;\n      if (count <= 0) {\n        this.filesWithoutCase.delete(key);\n        this.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n      } else {\n        this.filesWithoutCase.set(key, count);\n      }\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", itemPath, null, type, initial));\n      }\n    }\n  }\n  setFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {\n    const now = Date.now();\n    if (this.ignored(filePath)) return;\n    const old = this.files.get(filePath);\n    let safeTime, accuracy;\n    if (initial) {\n      safeTime = Math.min(now, mtime) + FS_ACCURACY;\n      accuracy = FS_ACCURACY;\n    } else {\n      safeTime = now;\n      accuracy = 0;\n      if (old && old.timestamp === mtime && mtime + FS_ACCURACY < now) {\n        // We are sure that mtime is untouched\n        // This can be caused by some file attribute change\n        // e. g. when access time has been changed\n        // but the file content is untouched\n        return;\n      }\n    }\n    if (ignoreWhenEqual && old && old.timestamp === mtime) return;\n    this.files.set(filePath, {\n      safeTime,\n      accuracy,\n      timestamp: mtime\n    });\n    if (!old) {\n      const key = withoutCase(filePath);\n      const count = this.filesWithoutCase.get(key);\n      this.filesWithoutCase.set(key, (count || 0) + 1);\n      if (count !== undefined) {\n        // There is already a file with case-insensitive-equal name\n        // On a case-insensitive filesystem we may miss the renaming\n        // when only casing is changed.\n        // To be sure that our information is correct\n        // we trigger a rescan here\n        this.doScan(false);\n      }\n      this.forEachWatcher(filePath, w => {\n        if (!initial || w.checkStartTime(safeTime, initial)) {\n          w.emit(\"change\", mtime, type);\n        }\n      });\n    } else if (!initial) {\n      this.forEachWatcher(filePath, w => w.emit(\"change\", mtime, type));\n    }\n    this.forEachWatcher(this.path, w => {\n      if (!initial || w.checkStartTime(safeTime, initial)) {\n        w.emit(\"change\", filePath, safeTime, type, initial);\n      }\n    });\n  }\n  setDirectory(directoryPath, birthtime, initial, type) {\n    if (this.ignored(directoryPath)) return;\n    if (directoryPath === this.path) {\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", directoryPath, birthtime, type, initial));\n      }\n    } else {\n      const old = this.directories.get(directoryPath);\n      if (!old) {\n        const now = Date.now();\n        if (this.nestedWatching) {\n          this.createNestedWatcher(directoryPath);\n        } else {\n          this.directories.set(directoryPath, true);\n        }\n        let safeTime;\n        if (initial) {\n          safeTime = Math.min(now, birthtime) + FS_ACCURACY;\n        } else {\n          safeTime = now;\n        }\n        this.forEachWatcher(directoryPath, w => {\n          if (!initial || w.checkStartTime(safeTime, false)) {\n            w.emit(\"change\", birthtime, type);\n          }\n        });\n        this.forEachWatcher(this.path, w => {\n          if (!initial || w.checkStartTime(safeTime, initial)) {\n            w.emit(\"change\", directoryPath, safeTime, type, initial);\n          }\n        });\n      }\n    }\n  }\n  createNestedWatcher(directoryPath) {\n    const watcher = this.watcherManager.watchDirectory(directoryPath, 1);\n    watcher.on(\"change\", (filePath, mtime, type, initial) => {\n      this.forEachWatcher(this.path, w => {\n        if (!initial || w.checkStartTime(mtime, initial)) {\n          w.emit(\"change\", filePath, mtime, type, initial);\n        }\n      });\n    });\n    this.directories.set(directoryPath, watcher);\n  }\n  setNestedWatching(flag) {\n    if (this.nestedWatching !== !!flag) {\n      this.nestedWatching = !!flag;\n      if (this.nestedWatching) {\n        for (const directory of this.directories.keys()) {\n          this.createNestedWatcher(directory);\n        }\n      } else {\n        for (const [directory, watcher] of this.directories) {\n          watcher.close();\n          this.directories.set(directory, true);\n        }\n      }\n    }\n  }\n  watch(filePath, startTime) {\n    const key = withoutCase(filePath);\n    let watchers = this.watchers.get(key);\n    if (watchers === undefined) {\n      watchers = new Set();\n      this.watchers.set(key, watchers);\n    }\n    this.refs++;\n    const watcher = new Watcher(this, filePath, startTime);\n    watcher.on(\"closed\", () => {\n      if (--this.refs <= 0) {\n        this.close();\n        return;\n      }\n      watchers.delete(watcher);\n      if (watchers.size === 0) {\n        this.watchers.delete(key);\n        if (this.path === filePath) this.setNestedWatching(false);\n      }\n    });\n    watchers.add(watcher);\n    let safeTime;\n    if (filePath === this.path) {\n      this.setNestedWatching(true);\n      safeTime = this.lastWatchEvent;\n      for (const entry of this.files.values()) {\n        fixupEntryAccuracy(entry);\n        safeTime = Math.max(safeTime, entry.safeTime);\n      }\n    } else {\n      const entry = this.files.get(filePath);\n      if (entry) {\n        fixupEntryAccuracy(entry);\n        safeTime = entry.safeTime;\n      } else {\n        safeTime = 0;\n      }\n    }\n    if (safeTime) {\n      if (safeTime >= startTime) {\n        process.nextTick(() => {\n          if (this.closed) return;\n          if (filePath === this.path) {\n            watcher.emit(\"change\", filePath, safeTime, \"watch (outdated on attach)\", true);\n          } else {\n            watcher.emit(\"change\", safeTime, \"watch (outdated on attach)\", true);\n          }\n        });\n      }\n    } else if (this.initialScan) {\n      if (this.initialScanRemoved.has(filePath)) {\n        process.nextTick(() => {\n          if (this.closed) return;\n          watcher.emit(\"remove\");\n        });\n      }\n    } else if (!this.directories.has(filePath) && watcher.checkStartTime(this.initialScanFinished, false)) {\n      process.nextTick(() => {\n        if (this.closed) return;\n        watcher.emit(\"initial-missing\", \"watch (missing on attach)\");\n      });\n    }\n    return watcher;\n  }\n  onWatchEvent(eventType, filename) {\n    if (this.closed) return;\n    if (!filename) {\n      // In some cases no filename is provided\n      // This seem to happen on windows\n      // So some event happened but we don't know which file is affected\n      // We have to do a full scan of the directory\n      this.doScan(false);\n      return;\n    }\n    const filePath = path.join(this.path, filename);\n    if (this.ignored(filePath)) return;\n    if (this._activeEvents.get(filename) === undefined) {\n      this._activeEvents.set(filename, false);\n      const checkStats = () => {\n        if (this.closed) return;\n        this._activeEvents.set(filename, false);\n        fs.lstat(filePath, (err, stats) => {\n          if (this.closed) return;\n          if (this._activeEvents.get(filename) === true) {\n            process.nextTick(checkStats);\n            return;\n          }\n          this._activeEvents.delete(filename);\n          // ENOENT happens when the file/directory doesn't exist\n          // EPERM happens when the containing directory doesn't exist\n          if (err) {\n            if (err.code !== \"ENOENT\" && err.code !== \"EPERM\" && err.code !== \"EBUSY\") {\n              this.onStatsError(err);\n            } else {\n              if (filename === path.basename(this.path)) {\n                // This may indicate that the directory itself was removed\n                if (!fs.existsSync(this.path)) {\n                  this.onDirectoryRemoved(\"stat failed\");\n                }\n              }\n            }\n          }\n          this.lastWatchEvent = Date.now();\n          if (!stats) {\n            this.setMissing(filePath, false, eventType);\n          } else if (stats.isDirectory()) {\n            this.setDirectory(filePath, +stats.birthtime || 1, false, eventType);\n          } else if (stats.isFile() || stats.isSymbolicLink()) {\n            if (stats.mtime) {\n              ensureFsAccuracy(stats.mtime);\n            }\n            this.setFileTime(filePath, +stats.mtime || +stats.ctime || 1, false, false, eventType);\n          }\n        });\n      };\n      process.nextTick(checkStats);\n    } else {\n      this._activeEvents.set(filename, true);\n    }\n  }\n  onWatcherError(err) {\n    if (this.closed) return;\n    if (err) {\n      if (err.code !== \"EPERM\" && err.code !== \"ENOENT\") {\n        console.error(\"Watchpack Error (watcher): \" + err);\n      }\n      this.onDirectoryRemoved(\"watch error\");\n    }\n  }\n  onStatsError(err) {\n    if (err) {\n      console.error(\"Watchpack Error (stats): \" + err);\n    }\n  }\n  onScanError(err) {\n    if (err) {\n      console.error(\"Watchpack Error (initial scan): \" + err);\n    }\n    this.onScanFinished();\n  }\n  onScanFinished() {\n    if (this.polledWatching) {\n      this.timeout = setTimeout(() => {\n        if (this.closed) return;\n        this.doScan(false);\n      }, this.polledWatching);\n    }\n  }\n  onDirectoryRemoved(reason) {\n    if (this.watcher) {\n      this.watcher.close();\n      this.watcher = null;\n    }\n    this.watchInParentDirectory();\n    const type = `directory-removed (${reason})`;\n    for (const directory of this.directories.keys()) {\n      this.setMissing(directory, null, type);\n    }\n    for (const file of this.files.keys()) {\n      this.setMissing(file, null, type);\n    }\n  }\n  watchInParentDirectory() {\n    if (!this.parentWatcher) {\n      const parentDir = path.dirname(this.path);\n      // avoid watching in the root directory\n      // removing directories in the root directory is not supported\n      if (path.dirname(parentDir) === parentDir) return;\n      this.parentWatcher = this.watcherManager.watchFile(this.path, 1);\n      this.parentWatcher.on(\"change\", (mtime, type) => {\n        if (this.closed) return;\n\n        // On non-osx platforms we don't need this watcher to detect\n        // directory removal, as an EPERM error indicates that\n        if ((!IS_OSX || this.polledWatching) && this.parentWatcher) {\n          this.parentWatcher.close();\n          this.parentWatcher = null;\n        }\n        // Try to create the watcher when parent directory is found\n        if (!this.watcher) {\n          this.createWatcher();\n          this.doScan(false);\n\n          // directory was created so we emit an event\n          this.forEachWatcher(this.path, w => w.emit(\"change\", this.path, mtime, type, false));\n        }\n      });\n      this.parentWatcher.on(\"remove\", () => {\n        this.onDirectoryRemoved(\"parent directory removed\");\n      });\n    }\n  }\n  doScan(initial) {\n    if (this.scanning) {\n      if (this.scanAgain) {\n        if (!initial) this.scanAgainInitial = false;\n      } else {\n        this.scanAgain = true;\n        this.scanAgainInitial = initial;\n      }\n      return;\n    }\n    this.scanning = true;\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = undefined;\n    }\n    process.nextTick(() => {\n      if (this.closed) return;\n      fs.readdir(this.path, (err, items) => {\n        if (this.closed) return;\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"EPERM\") {\n            this.onDirectoryRemoved(\"scan readdir failed\");\n          } else {\n            this.onScanError(err);\n          }\n          this.initialScan = false;\n          this.initialScanFinished = Date.now();\n          if (initial) {\n            for (const watchers of this.watchers.values()) {\n              for (const watcher of watchers) {\n                if (watcher.checkStartTime(this.initialScanFinished, false)) {\n                  watcher.emit(\"initial-missing\", \"scan (parent directory missing in initial scan)\");\n                }\n              }\n            }\n          }\n          if (this.scanAgain) {\n            this.scanAgain = false;\n            this.doScan(this.scanAgainInitial);\n          } else {\n            this.scanning = false;\n          }\n          return;\n        }\n        const itemPaths = new Set(items.map(item => path.join(this.path, item.normalize(\"NFC\"))));\n        for (const file of this.files.keys()) {\n          if (!itemPaths.has(file)) {\n            this.setMissing(file, initial, \"scan (missing)\");\n          }\n        }\n        for (const directory of this.directories.keys()) {\n          if (!itemPaths.has(directory)) {\n            this.setMissing(directory, initial, \"scan (missing)\");\n          }\n        }\n        if (this.scanAgain) {\n          // Early repeat of scan\n          this.scanAgain = false;\n          this.doScan(initial);\n          return;\n        }\n        const itemFinished = needCalls(itemPaths.size + 1, () => {\n          if (this.closed) return;\n          this.initialScan = false;\n          this.initialScanRemoved = null;\n          this.initialScanFinished = Date.now();\n          if (initial) {\n            const missingWatchers = new Map(this.watchers);\n            missingWatchers.delete(withoutCase(this.path));\n            for (const item of itemPaths) {\n              missingWatchers.delete(withoutCase(item));\n            }\n            for (const watchers of missingWatchers.values()) {\n              for (const watcher of watchers) {\n                if (watcher.checkStartTime(this.initialScanFinished, false)) {\n                  watcher.emit(\"initial-missing\", \"scan (missing in initial scan)\");\n                }\n              }\n            }\n          }\n          if (this.scanAgain) {\n            this.scanAgain = false;\n            this.doScan(this.scanAgainInitial);\n          } else {\n            this.scanning = false;\n            this.onScanFinished();\n          }\n        });\n        for (const itemPath of itemPaths) {\n          fs.lstat(itemPath, (err2, stats) => {\n            if (this.closed) return;\n            if (err2) {\n              if (err2.code === \"ENOENT\" || err2.code === \"EPERM\" || err2.code === \"EACCES\" || err2.code === \"EBUSY\") {\n                this.setMissing(itemPath, initial, \"scan (\" + err2.code + \")\");\n              } else {\n                this.onScanError(err2);\n              }\n              itemFinished();\n              return;\n            }\n            if (stats.isFile() || stats.isSymbolicLink()) {\n              if (stats.mtime) {\n                ensureFsAccuracy(stats.mtime);\n              }\n              this.setFileTime(itemPath, +stats.mtime || +stats.ctime || 1, initial, true, \"scan (file)\");\n            } else if (stats.isDirectory()) {\n              if (!initial || !this.directories.has(itemPath)) this.setDirectory(itemPath, +stats.birthtime || 1, initial, \"scan (dir)\");\n            }\n            itemFinished();\n          });\n        }\n        itemFinished();\n      });\n    });\n  }\n  getTimes() {\n    const obj = Object.create(null);\n    let safeTime = this.lastWatchEvent;\n    for (const [file, entry] of this.files) {\n      fixupEntryAccuracy(entry);\n      safeTime = Math.max(safeTime, entry.safeTime);\n      obj[file] = Math.max(entry.safeTime, entry.timestamp);\n    }\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        const times = w.directoryWatcher.getTimes();\n        for (const file of Object.keys(times)) {\n          const time = times[file];\n          safeTime = Math.max(safeTime, time);\n          obj[file] = time;\n        }\n      }\n      obj[this.path] = safeTime;\n    }\n    if (!this.initialScan) {\n      for (const watchers of this.watchers.values()) {\n        for (const watcher of watchers) {\n          const path = watcher.path;\n          if (!Object.prototype.hasOwnProperty.call(obj, path)) {\n            obj[path] = null;\n          }\n        }\n      }\n    }\n    return obj;\n  }\n  collectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n    let safeTime = this.lastWatchEvent;\n    for (const [file, entry] of this.files) {\n      fixupEntryAccuracy(entry);\n      safeTime = Math.max(safeTime, entry.safeTime);\n      fileTimestamps.set(file, entry);\n    }\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        safeTime = Math.max(safeTime, w.directoryWatcher.collectTimeInfoEntries(fileTimestamps, directoryTimestamps));\n      }\n      fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n      directoryTimestamps.set(this.path, {\n        safeTime\n      });\n    } else {\n      for (const dir of this.directories.keys()) {\n        // No additional info about this directory\n        // but maybe another DirectoryWatcher has info\n        fileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n        if (!directoryTimestamps.has(dir)) directoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n      }\n      fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n      directoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n    }\n    if (!this.initialScan) {\n      for (const watchers of this.watchers.values()) {\n        for (const watcher of watchers) {\n          const path = watcher.path;\n          if (!fileTimestamps.has(path)) {\n            fileTimestamps.set(path, null);\n          }\n        }\n      }\n    }\n    return safeTime;\n  }\n  close() {\n    this.closed = true;\n    this.initialScan = false;\n    if (this.watcher) {\n      this.watcher.close();\n      this.watcher = null;\n    }\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        w.close();\n      }\n      this.directories.clear();\n    }\n    if (this.parentWatcher) {\n      this.parentWatcher.close();\n      this.parentWatcher = null;\n    }\n    this.emit(\"closed\");\n  }\n}\nmodule.exports = DirectoryWatcher;\nmodule.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;\nfunction fixupEntryAccuracy(entry) {\n  if (entry.accuracy > FS_ACCURACY) {\n    entry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY;\n    entry.accuracy = FS_ACCURACY;\n  }\n}\nfunction ensureFsAccuracy(mtime) {\n  if (!mtime) return;\n  if (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;else if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;else if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;else if (FS_ACCURACY > 1000 && mtime % 1000 !== 0) FS_ACCURACY = 1000;\n}","map":{"version":3,"names":["EventEmitter","require","fs","path","watchEventSource","EXISTANCE_ONLY_TIME_ENTRY","Object","freeze","FS_ACCURACY","IS_OSX","platform","WATCHPACK_POLLING","process","env","FORCE_POLLING","withoutCase","str","toLowerCase","needCalls","times","callback","Watcher","constructor","directoryWatcher","filePath","startTime","checkStartTime","mtime","initial","close","emit","DirectoryWatcher","watcherManager","directoryPath","options","poll","files","Map","filesWithoutCase","directories","lastWatchEvent","initialScan","ignored","nestedWatching","polledWatching","timeout","undefined","initialScanRemoved","Set","initialScanFinished","watchers","parentWatcher","refs","_activeEvents","closed","scanning","scanAgain","scanAgainInitial","createWatcher","doScan","watcher","clearTimeout","watchInParentDirectory","watch","on","onWatchEvent","bind","onWatcherError","err","forEachWatcher","fn","get","w","setMissing","itemPath","type","add","oldDirectory","delete","oldFile","key","count","set","setFileTime","ignoreWhenEqual","now","Date","old","safeTime","accuracy","Math","min","timestamp","setDirectory","birthtime","createNestedWatcher","watchDirectory","setNestedWatching","flag","directory","keys","size","entry","values","fixupEntryAccuracy","max","nextTick","has","eventType","filename","join","checkStats","lstat","stats","code","onStatsError","basename","existsSync","onDirectoryRemoved","isDirectory","isFile","isSymbolicLink","ensureFsAccuracy","ctime","console","error","onScanError","onScanFinished","setTimeout","reason","file","parentDir","dirname","watchFile","readdir","items","itemPaths","map","item","normalize","itemFinished","missingWatchers","err2","getTimes","obj","create","time","prototype","hasOwnProperty","call","collectTimeInfoEntries","fileTimestamps","directoryTimestamps","dir","clear","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/watchpack/lib/DirectoryWatcher.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\nconst fs = require(\"graceful-fs\");\nconst path = require(\"path\");\n\nconst watchEventSource = require(\"./watchEventSource\");\n\nconst EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});\n\nlet FS_ACCURACY = 2000;\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst WATCHPACK_POLLING = process.env.WATCHPACK_POLLING;\nconst FORCE_POLLING =\n\t`${+WATCHPACK_POLLING}` === WATCHPACK_POLLING\n\t\t? +WATCHPACK_POLLING\n\t\t: !!WATCHPACK_POLLING && WATCHPACK_POLLING !== \"false\";\n\nfunction withoutCase(str) {\n\treturn str.toLowerCase();\n}\n\nfunction needCalls(times, callback) {\n\treturn function() {\n\t\tif (--times === 0) {\n\t\t\treturn callback();\n\t\t}\n\t};\n}\n\nclass Watcher extends EventEmitter {\n\tconstructor(directoryWatcher, filePath, startTime) {\n\t\tsuper();\n\t\tthis.directoryWatcher = directoryWatcher;\n\t\tthis.path = filePath;\n\t\tthis.startTime = startTime && +startTime;\n\t}\n\n\tcheckStartTime(mtime, initial) {\n\t\tconst startTime = this.startTime;\n\t\tif (typeof startTime !== \"number\") return !initial;\n\t\treturn startTime <= mtime;\n\t}\n\n\tclose() {\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nclass DirectoryWatcher extends EventEmitter {\n\tconstructor(watcherManager, directoryPath, options) {\n\t\tsuper();\n\t\tif (FORCE_POLLING) {\n\t\t\toptions.poll = FORCE_POLLING;\n\t\t}\n\t\tthis.watcherManager = watcherManager;\n\t\tthis.options = options;\n\t\tthis.path = directoryPath;\n\t\t// safeTime is the point in time after which reading is safe to be unchanged\n\t\t// timestamp is a value that should be compared with another timestamp (mtime)\n\t\t/** @type {Map<string, { safeTime: number, timestamp: number }} */\n\t\tthis.files = new Map();\n\t\t/** @type {Map<string, number>} */\n\t\tthis.filesWithoutCase = new Map();\n\t\tthis.directories = new Map();\n\t\tthis.lastWatchEvent = 0;\n\t\tthis.initialScan = true;\n\t\tthis.ignored = options.ignored || (() => false);\n\t\tthis.nestedWatching = false;\n\t\tthis.polledWatching =\n\t\t\ttypeof options.poll === \"number\"\n\t\t\t\t? options.poll\n\t\t\t\t: options.poll\n\t\t\t\t? 5007\n\t\t\t\t: false;\n\t\tthis.timeout = undefined;\n\t\tthis.initialScanRemoved = new Set();\n\t\tthis.initialScanFinished = undefined;\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.watchers = new Map();\n\t\tthis.parentWatcher = null;\n\t\tthis.refs = 0;\n\t\tthis._activeEvents = new Map();\n\t\tthis.closed = false;\n\t\tthis.scanning = false;\n\t\tthis.scanAgain = false;\n\t\tthis.scanAgainInitial = false;\n\n\t\tthis.createWatcher();\n\t\tthis.doScan(true);\n\t}\n\n\tcreateWatcher() {\n\t\ttry {\n\t\t\tif (this.polledWatching) {\n\t\t\t\tthis.watcher = {\n\t\t\t\t\tclose: () => {\n\t\t\t\t\t\tif (this.timeout) {\n\t\t\t\t\t\t\tclearTimeout(this.timeout);\n\t\t\t\t\t\t\tthis.timeout = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (IS_OSX) {\n\t\t\t\t\tthis.watchInParentDirectory();\n\t\t\t\t}\n\t\t\t\tthis.watcher = watchEventSource.watch(this.path);\n\t\t\t\tthis.watcher.on(\"change\", this.onWatchEvent.bind(this));\n\t\t\t\tthis.watcher.on(\"error\", this.onWatcherError.bind(this));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.onWatcherError(err);\n\t\t}\n\t}\n\n\tforEachWatcher(path, fn) {\n\t\tconst watchers = this.watchers.get(withoutCase(path));\n\t\tif (watchers !== undefined) {\n\t\t\tfor (const w of watchers) {\n\t\t\t\tfn(w);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetMissing(itemPath, initial, type) {\n\t\tif (this.initialScan) {\n\t\t\tthis.initialScanRemoved.add(itemPath);\n\t\t}\n\n\t\tconst oldDirectory = this.directories.get(itemPath);\n\t\tif (oldDirectory) {\n\t\t\tif (this.nestedWatching) oldDirectory.close();\n\t\t\tthis.directories.delete(itemPath);\n\n\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst oldFile = this.files.get(itemPath);\n\t\tif (oldFile) {\n\t\t\tthis.files.delete(itemPath);\n\t\t\tconst key = withoutCase(itemPath);\n\t\t\tconst count = this.filesWithoutCase.get(key) - 1;\n\t\t\tif (count <= 0) {\n\t\t\t\tthis.filesWithoutCase.delete(key);\n\t\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\t} else {\n\t\t\t\tthis.filesWithoutCase.set(key, count);\n\t\t\t}\n\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {\n\t\tconst now = Date.now();\n\n\t\tif (this.ignored(filePath)) return;\n\n\t\tconst old = this.files.get(filePath);\n\n\t\tlet safeTime, accuracy;\n\t\tif (initial) {\n\t\t\tsafeTime = Math.min(now, mtime) + FS_ACCURACY;\n\t\t\taccuracy = FS_ACCURACY;\n\t\t} else {\n\t\t\tsafeTime = now;\n\t\t\taccuracy = 0;\n\n\t\t\tif (old && old.timestamp === mtime && mtime + FS_ACCURACY < now) {\n\t\t\t\t// We are sure that mtime is untouched\n\t\t\t\t// This can be caused by some file attribute change\n\t\t\t\t// e. g. when access time has been changed\n\t\t\t\t// but the file content is untouched\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreWhenEqual && old && old.timestamp === mtime) return;\n\n\t\tthis.files.set(filePath, {\n\t\t\tsafeTime,\n\t\t\taccuracy,\n\t\t\ttimestamp: mtime\n\t\t});\n\n\t\tif (!old) {\n\t\t\tconst key = withoutCase(filePath);\n\t\t\tconst count = this.filesWithoutCase.get(key);\n\t\t\tthis.filesWithoutCase.set(key, (count || 0) + 1);\n\t\t\tif (count !== undefined) {\n\t\t\t\t// There is already a file with case-insensitive-equal name\n\t\t\t\t// On a case-insensitive filesystem we may miss the renaming\n\t\t\t\t// when only casing is changed.\n\t\t\t\t// To be sure that our information is correct\n\t\t\t\t// we trigger a rescan here\n\t\t\t\tthis.doScan(false);\n\t\t\t}\n\n\t\t\tthis.forEachWatcher(filePath, w => {\n\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\tw.emit(\"change\", mtime, type);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!initial) {\n\t\t\tthis.forEachWatcher(filePath, w => w.emit(\"change\", mtime, type));\n\t\t}\n\t\tthis.forEachWatcher(this.path, w => {\n\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\tw.emit(\"change\", filePath, safeTime, type, initial);\n\t\t\t}\n\t\t});\n\t}\n\n\tsetDirectory(directoryPath, birthtime, initial, type) {\n\t\tif (this.ignored(directoryPath)) return;\n\t\tif (directoryPath === this.path) {\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", directoryPath, birthtime, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst old = this.directories.get(directoryPath);\n\t\t\tif (!old) {\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tif (this.nestedWatching) {\n\t\t\t\t\tthis.createNestedWatcher(directoryPath);\n\t\t\t\t} else {\n\t\t\t\t\tthis.directories.set(directoryPath, true);\n\t\t\t\t}\n\n\t\t\t\tlet safeTime;\n\t\t\t\tif (initial) {\n\t\t\t\t\tsafeTime = Math.min(now, birthtime) + FS_ACCURACY;\n\t\t\t\t} else {\n\t\t\t\t\tsafeTime = now;\n\t\t\t\t}\n\n\t\t\t\tthis.forEachWatcher(directoryPath, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, false)) {\n\t\t\t\t\t\tw.emit(\"change\", birthtime, type);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\t\tw.emit(\"change\", directoryPath, safeTime, type, initial);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateNestedWatcher(directoryPath) {\n\t\tconst watcher = this.watcherManager.watchDirectory(directoryPath, 1);\n\t\twatcher.on(\"change\", (filePath, mtime, type, initial) => {\n\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\tif (!initial || w.checkStartTime(mtime, initial)) {\n\t\t\t\t\tw.emit(\"change\", filePath, mtime, type, initial);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tthis.directories.set(directoryPath, watcher);\n\t}\n\n\tsetNestedWatching(flag) {\n\t\tif (this.nestedWatching !== !!flag) {\n\t\t\tthis.nestedWatching = !!flag;\n\t\t\tif (this.nestedWatching) {\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tthis.createNestedWatcher(directory);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const [directory, watcher] of this.directories) {\n\t\t\t\t\twatcher.close();\n\t\t\t\t\tthis.directories.set(directory, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twatch(filePath, startTime) {\n\t\tconst key = withoutCase(filePath);\n\t\tlet watchers = this.watchers.get(key);\n\t\tif (watchers === undefined) {\n\t\t\twatchers = new Set();\n\t\t\tthis.watchers.set(key, watchers);\n\t\t}\n\t\tthis.refs++;\n\t\tconst watcher = new Watcher(this, filePath, startTime);\n\t\twatcher.on(\"closed\", () => {\n\t\t\tif (--this.refs <= 0) {\n\t\t\t\tthis.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twatchers.delete(watcher);\n\t\t\tif (watchers.size === 0) {\n\t\t\t\tthis.watchers.delete(key);\n\t\t\t\tif (this.path === filePath) this.setNestedWatching(false);\n\t\t\t}\n\t\t});\n\t\twatchers.add(watcher);\n\t\tlet safeTime;\n\t\tif (filePath === this.path) {\n\t\t\tthis.setNestedWatching(true);\n\t\t\tsafeTime = this.lastWatchEvent;\n\t\t\tfor (const entry of this.files.values()) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t}\n\t\t} else {\n\t\t\tconst entry = this.files.get(filePath);\n\t\t\tif (entry) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = entry.safeTime;\n\t\t\t} else {\n\t\t\t\tsafeTime = 0;\n\t\t\t}\n\t\t}\n\t\tif (safeTime) {\n\t\t\tif (safeTime >= startTime) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (filePath === this.path) {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (this.initialScan) {\n\t\t\tif (this.initialScanRemoved.has(filePath)) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\twatcher.emit(\"remove\");\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\t!this.directories.has(filePath) &&\n\t\t\twatcher.checkStartTime(this.initialScanFinished, false)\n\t\t) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\twatcher.emit(\"initial-missing\", \"watch (missing on attach)\");\n\t\t\t});\n\t\t}\n\t\treturn watcher;\n\t}\n\n\tonWatchEvent(eventType, filename) {\n\t\tif (this.closed) return;\n\t\tif (!filename) {\n\t\t\t// In some cases no filename is provided\n\t\t\t// This seem to happen on windows\n\t\t\t// So some event happened but we don't know which file is affected\n\t\t\t// We have to do a full scan of the directory\n\t\t\tthis.doScan(false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst filePath = path.join(this.path, filename);\n\t\tif (this.ignored(filePath)) return;\n\n\t\tif (this._activeEvents.get(filename) === undefined) {\n\t\t\tthis._activeEvents.set(filename, false);\n\t\t\tconst checkStats = () => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis._activeEvents.set(filename, false);\n\t\t\t\tfs.lstat(filePath, (err, stats) => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (this._activeEvents.get(filename) === true) {\n\t\t\t\t\t\tprocess.nextTick(checkStats);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._activeEvents.delete(filename);\n\t\t\t\t\t// ENOENT happens when the file/directory doesn't exist\n\t\t\t\t\t// EPERM happens when the containing directory doesn't exist\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terr.code !== \"ENOENT\" &&\n\t\t\t\t\t\t\terr.code !== \"EPERM\" &&\n\t\t\t\t\t\t\terr.code !== \"EBUSY\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.onStatsError(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (filename === path.basename(this.path)) {\n\t\t\t\t\t\t\t\t// This may indicate that the directory itself was removed\n\t\t\t\t\t\t\t\tif (!fs.existsSync(this.path)) {\n\t\t\t\t\t\t\t\t\tthis.onDirectoryRemoved(\"stat failed\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastWatchEvent = Date.now();\n\t\t\t\t\tif (!stats) {\n\t\t\t\t\t\tthis.setMissing(filePath, false, eventType);\n\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tprocess.nextTick(checkStats);\n\t\t} else {\n\t\t\tthis._activeEvents.set(filename, true);\n\t\t}\n\t}\n\n\tonWatcherError(err) {\n\t\tif (this.closed) return;\n\t\tif (err) {\n\t\t\tif (err.code !== \"EPERM\" && err.code !== \"ENOENT\") {\n\t\t\t\tconsole.error(\"Watchpack Error (watcher): \" + err);\n\t\t\t}\n\t\t\tthis.onDirectoryRemoved(\"watch error\");\n\t\t}\n\t}\n\n\tonStatsError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (stats): \" + err);\n\t\t}\n\t}\n\n\tonScanError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (initial scan): \" + err);\n\t\t}\n\t\tthis.onScanFinished();\n\t}\n\n\tonScanFinished() {\n\t\tif (this.polledWatching) {\n\t\t\tthis.timeout = setTimeout(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis.doScan(false);\n\t\t\t}, this.polledWatching);\n\t\t}\n\t}\n\n\tonDirectoryRemoved(reason) {\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tthis.watchInParentDirectory();\n\t\tconst type = `directory-removed (${reason})`;\n\t\tfor (const directory of this.directories.keys()) {\n\t\t\tthis.setMissing(directory, null, type);\n\t\t}\n\t\tfor (const file of this.files.keys()) {\n\t\t\tthis.setMissing(file, null, type);\n\t\t}\n\t}\n\n\twatchInParentDirectory() {\n\t\tif (!this.parentWatcher) {\n\t\t\tconst parentDir = path.dirname(this.path);\n\t\t\t// avoid watching in the root directory\n\t\t\t// removing directories in the root directory is not supported\n\t\t\tif (path.dirname(parentDir) === parentDir) return;\n\n\t\t\tthis.parentWatcher = this.watcherManager.watchFile(this.path, 1);\n\t\t\tthis.parentWatcher.on(\"change\", (mtime, type) => {\n\t\t\t\tif (this.closed) return;\n\n\t\t\t\t// On non-osx platforms we don't need this watcher to detect\n\t\t\t\t// directory removal, as an EPERM error indicates that\n\t\t\t\tif ((!IS_OSX || this.polledWatching) && this.parentWatcher) {\n\t\t\t\t\tthis.parentWatcher.close();\n\t\t\t\t\tthis.parentWatcher = null;\n\t\t\t\t}\n\t\t\t\t// Try to create the watcher when parent directory is found\n\t\t\t\tif (!this.watcher) {\n\t\t\t\t\tthis.createWatcher();\n\t\t\t\t\tthis.doScan(false);\n\n\t\t\t\t\t// directory was created so we emit an event\n\t\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\t\tw.emit(\"change\", this.path, mtime, type, false)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.parentWatcher.on(\"remove\", () => {\n\t\t\t\tthis.onDirectoryRemoved(\"parent directory removed\");\n\t\t\t});\n\t\t}\n\t}\n\n\tdoScan(initial) {\n\t\tif (this.scanning) {\n\t\t\tif (this.scanAgain) {\n\t\t\t\tif (!initial) this.scanAgainInitial = false;\n\t\t\t} else {\n\t\t\t\tthis.scanAgain = true;\n\t\t\t\tthis.scanAgainInitial = initial;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.scanning = true;\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = undefined;\n\t\t}\n\t\tprocess.nextTick(() => {\n\t\t\tif (this.closed) return;\n\t\t\tfs.readdir(this.path, (err, items) => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"EPERM\") {\n\t\t\t\t\t\tthis.onDirectoryRemoved(\"scan readdir failed\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.onScanError(err);\n\t\t\t\t\t}\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (parent directory missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemPaths = new Set(\n\t\t\t\t\titems.map(item => path.join(this.path, item.normalize(\"NFC\")))\n\t\t\t\t);\n\t\t\t\tfor (const file of this.files.keys()) {\n\t\t\t\t\tif (!itemPaths.has(file)) {\n\t\t\t\t\t\tthis.setMissing(file, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tif (!itemPaths.has(directory)) {\n\t\t\t\t\t\tthis.setMissing(directory, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t// Early repeat of scan\n\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\tthis.doScan(initial);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemFinished = needCalls(itemPaths.size + 1, () => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanRemoved = null;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tconst missingWatchers = new Map(this.watchers);\n\t\t\t\t\t\tmissingWatchers.delete(withoutCase(this.path));\n\t\t\t\t\t\tfor (const item of itemPaths) {\n\t\t\t\t\t\t\tmissingWatchers.delete(withoutCase(item));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const watchers of missingWatchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t\tthis.onScanFinished();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor (const itemPath of itemPaths) {\n\t\t\t\t\tfs.lstat(itemPath, (err2, stats) => {\n\t\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\t\tif (err2) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terr2.code === \"ENOENT\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EPERM\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EACCES\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EBUSY\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.setMissing(itemPath, initial, \"scan (\" + err2.code + \")\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.onScanError(err2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemFinished();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\"scan (file)\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\t\tif (!initial || !this.directories.has(itemPath))\n\t\t\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\t\t\"scan (dir)\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\titemFinished();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\titemFinished();\n\t\t\t});\n\t\t});\n\t}\n\n\tgetTimes() {\n\t\tconst obj = Object.create(null);\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tobj[file] = Math.max(entry.safeTime, entry.timestamp);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tconst times = w.directoryWatcher.getTimes();\n\t\t\t\tfor (const file of Object.keys(times)) {\n\t\t\t\t\tconst time = times[file];\n\t\t\t\t\tsafeTime = Math.max(safeTime, time);\n\t\t\t\t\tobj[file] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj[this.path] = safeTime;\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!Object.prototype.hasOwnProperty.call(obj, path)) {\n\t\t\t\t\t\tobj[path] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}\n\n\tcollectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tfileTimestamps.set(file, entry);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tsafeTime = Math.max(\n\t\t\t\t\tsafeTime,\n\t\t\t\t\tw.directoryWatcher.collectTimeInfoEntries(\n\t\t\t\t\t\tfileTimestamps,\n\t\t\t\t\t\tdirectoryTimestamps\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, {\n\t\t\t\tsafeTime\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const dir of this.directories.keys()) {\n\t\t\t\t// No additional info about this directory\n\t\t\t\t// but maybe another DirectoryWatcher has info\n\t\t\t\tfileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t\tif (!directoryTimestamps.has(dir))\n\t\t\t\t\tdirectoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!fileTimestamps.has(path)) {\n\t\t\t\t\t\tfileTimestamps.set(path, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn safeTime;\n\t}\n\n\tclose() {\n\t\tthis.closed = true;\n\t\tthis.initialScan = false;\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tw.close();\n\t\t\t}\n\t\t\tthis.directories.clear();\n\t\t}\n\t\tif (this.parentWatcher) {\n\t\t\tthis.parentWatcher.close();\n\t\t\tthis.parentWatcher = null;\n\t\t}\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nmodule.exports = DirectoryWatcher;\nmodule.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;\n\nfunction fixupEntryAccuracy(entry) {\n\tif (entry.accuracy > FS_ACCURACY) {\n\t\tentry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY;\n\t\tentry.accuracy = FS_ACCURACY;\n\t}\n}\n\nfunction ensureFsAccuracy(mtime) {\n\tif (!mtime) return;\n\tif (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;\n\telse if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;\n\telse if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;\n\telse if (FS_ACCURACY > 1000 && mtime % 1000 !== 0) FS_ACCURACY = 1000;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}