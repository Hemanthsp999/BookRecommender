{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass MemoryWithGcCachePlugin {\n  constructor(_ref) {\n    let {\n      maxGenerations\n    } = _ref;\n    this._maxGenerations = maxGenerations;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const maxGenerations = this._maxGenerations;\n    /** @type {Map<string, { etag: Etag | null, data: any }>} */\n    const cache = new Map();\n    /** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n    const oldCache = new Map();\n    let generation = 0;\n    let cachePosition = 0;\n    const logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n    compiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", () => {\n      generation++;\n      let clearedEntries = 0;\n      let lastClearedIdentifier;\n      // Avoid coverage problems due indirect changes\n      /* istanbul ignore next */\n      for (const [identifier, entry] of oldCache) {\n        if (entry.until > generation) break;\n        oldCache.delete(identifier);\n        if (cache.get(identifier) === undefined) {\n          cache.delete(identifier);\n          clearedEntries++;\n          lastClearedIdentifier = identifier;\n        }\n      }\n      if (clearedEntries > 0 || oldCache.size > 0) {\n        logger.log(`${cache.size - oldCache.size} active entries, ${oldCache.size} recently unused cached entries${clearedEntries > 0 ? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}` : \"\"}`);\n      }\n      let i = cache.size / maxGenerations | 0;\n      let j = cachePosition >= cache.size ? 0 : cachePosition;\n      cachePosition = j + i;\n      for (const [identifier, entry] of cache) {\n        if (j !== 0) {\n          j--;\n          continue;\n        }\n        if (entry !== undefined) {\n          // We don't delete the cache entry, but set it to undefined instead\n          // This reserves the location in the data table and avoids rehashing\n          // when constantly adding and removing entries.\n          // It will be deleted when removed from oldCache.\n          cache.set(identifier, undefined);\n          oldCache.delete(identifier);\n          oldCache.set(identifier, {\n            entry,\n            until: generation + maxGenerations\n          });\n          if (i-- === 0) break;\n        }\n      }\n    });\n    compiler.cache.hooks.store.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, data) => {\n      cache.set(identifier, {\n        etag,\n        data\n      });\n    });\n    compiler.cache.hooks.get.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, gotHandlers) => {\n      const cacheEntry = cache.get(identifier);\n      if (cacheEntry === null) {\n        return null;\n      } else if (cacheEntry !== undefined) {\n        return cacheEntry.etag === etag ? cacheEntry.data : null;\n      }\n      const oldCacheEntry = oldCache.get(identifier);\n      if (oldCacheEntry !== undefined) {\n        const cacheEntry = oldCacheEntry.entry;\n        if (cacheEntry === null) {\n          oldCache.delete(identifier);\n          cache.set(identifier, cacheEntry);\n          return null;\n        } else {\n          if (cacheEntry.etag !== etag) return null;\n          oldCache.delete(identifier);\n          cache.set(identifier, cacheEntry);\n          return cacheEntry.data;\n        }\n      }\n      gotHandlers.push((result, callback) => {\n        if (result === undefined) {\n          cache.set(identifier, null);\n        } else {\n          cache.set(identifier, {\n            etag,\n            data: result\n          });\n        }\n        return callback();\n      });\n    });\n    compiler.cache.hooks.shutdown.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, () => {\n      cache.clear();\n      oldCache.clear();\n    });\n  }\n}\nmodule.exports = MemoryWithGcCachePlugin;","map":{"version":3,"names":["Cache","require","MemoryWithGcCachePlugin","constructor","_ref","maxGenerations","_maxGenerations","apply","compiler","cache","Map","oldCache","generation","cachePosition","logger","getInfrastructureLogger","hooks","afterDone","tap","clearedEntries","lastClearedIdentifier","identifier","entry","until","delete","get","undefined","size","log","i","j","set","store","name","stage","STAGE_MEMORY","etag","data","gotHandlers","cacheEntry","oldCacheEntry","push","result","callback","shutdown","clear","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/cache/MemoryWithGcCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass MemoryWithGcCachePlugin {\n\tconstructor({ maxGenerations }) {\n\t\tthis._maxGenerations = maxGenerations;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst maxGenerations = this._maxGenerations;\n\t\t/** @type {Map<string, { etag: Etag | null, data: any }>} */\n\t\tconst cache = new Map();\n\t\t/** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n\t\tconst oldCache = new Map();\n\t\tlet generation = 0;\n\t\tlet cachePosition = 0;\n\t\tconst logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n\t\tcompiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", () => {\n\t\t\tgeneration++;\n\t\t\tlet clearedEntries = 0;\n\t\t\tlet lastClearedIdentifier;\n\t\t\t// Avoid coverage problems due indirect changes\n\t\t\t/* istanbul ignore next */\n\t\t\tfor (const [identifier, entry] of oldCache) {\n\t\t\t\tif (entry.until > generation) break;\n\n\t\t\t\toldCache.delete(identifier);\n\t\t\t\tif (cache.get(identifier) === undefined) {\n\t\t\t\t\tcache.delete(identifier);\n\t\t\t\t\tclearedEntries++;\n\t\t\t\t\tlastClearedIdentifier = identifier;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clearedEntries > 0 || oldCache.size > 0) {\n\t\t\t\tlogger.log(\n\t\t\t\t\t`${cache.size - oldCache.size} active entries, ${\n\t\t\t\t\t\toldCache.size\n\t\t\t\t\t} recently unused cached entries${\n\t\t\t\t\t\tclearedEntries > 0\n\t\t\t\t\t\t\t? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}`\n\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tlet i = (cache.size / maxGenerations) | 0;\n\t\t\tlet j = cachePosition >= cache.size ? 0 : cachePosition;\n\t\t\tcachePosition = j + i;\n\t\t\tfor (const [identifier, entry] of cache) {\n\t\t\t\tif (j !== 0) {\n\t\t\t\t\tj--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (entry !== undefined) {\n\t\t\t\t\t// We don't delete the cache entry, but set it to undefined instead\n\t\t\t\t\t// This reserves the location in the data table and avoids rehashing\n\t\t\t\t\t// when constantly adding and removing entries.\n\t\t\t\t\t// It will be deleted when removed from oldCache.\n\t\t\t\t\tcache.set(identifier, undefined);\n\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\toldCache.set(identifier, {\n\t\t\t\t\t\tentry,\n\t\t\t\t\t\tuntil: generation + maxGenerations\n\t\t\t\t\t});\n\t\t\t\t\tif (i-- === 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tcache.set(identifier, { etag, data });\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.get.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst cacheEntry = cache.get(identifier);\n\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (cacheEntry !== undefined) {\n\t\t\t\t\treturn cacheEntry.etag === etag ? cacheEntry.data : null;\n\t\t\t\t}\n\t\t\t\tconst oldCacheEntry = oldCache.get(identifier);\n\t\t\t\tif (oldCacheEntry !== undefined) {\n\t\t\t\t\tconst cacheEntry = oldCacheEntry.entry;\n\t\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cacheEntry.etag !== etag) return null;\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn cacheEntry.data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tcache.set(identifier, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcache.set(identifier, { etag, data: result });\n\t\t\t\t\t}\n\t\t\t\t\treturn callback();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.shutdown.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t() => {\n\t\t\t\tcache.clear();\n\t\t\t\toldCache.clear();\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MemoryWithGcCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}