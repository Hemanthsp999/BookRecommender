{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n\n/**\n * @template T\n */\nclass Node {\n  /**\n   * @param {T} item the value of the node\n   */\n  constructor(item) {\n    this.item = item;\n    /** @type {Set<Node<T>>} */\n    this.dependencies = new Set();\n    this.marker = NO_MARKER;\n    /** @type {Cycle<T> | undefined} */\n    this.cycle = undefined;\n    this.incoming = 0;\n  }\n}\n\n/**\n * @template T\n */\nclass Cycle {\n  constructor() {\n    /** @type {Set<Node<T>>} */\n    this.nodes = new Set();\n  }\n}\n\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\nmodule.exports = (items, getDependencies) => {\n  /** @type {Map<T, Node<T>>} */\n  const itemToNode = new Map();\n  for (const item of items) {\n    const node = new Node(item);\n    itemToNode.set(item, node);\n  }\n\n  // early exit when there is only a single item\n  if (itemToNode.size <= 1) return items;\n\n  // grab all the dependencies\n  for (const node of itemToNode.values()) {\n    for (const dep of getDependencies(node.item)) {\n      const depNode = itemToNode.get(dep);\n      if (depNode !== undefined) {\n        node.dependencies.add(depNode);\n      }\n    }\n  }\n\n  // Set of current root modules\n  // items will be removed if a new reference to it has been found\n  /** @type {Set<Node<T>>} */\n  const roots = new Set();\n\n  // Set of current cycles without references to it\n  // cycles will be removed if a new reference to it has been found\n  // that is not part of the cycle\n  /** @type {Set<Cycle<T>>} */\n  const rootCycles = new Set();\n\n  // For all non-marked nodes\n  for (const selectedNode of itemToNode.values()) {\n    if (selectedNode.marker === NO_MARKER) {\n      // deep-walk all referenced modules\n      // in a non-recursive way\n\n      // start by entering the selected node\n      selectedNode.marker = IN_PROGRESS_MARKER;\n\n      // keep a stack to avoid recursive walk\n      /** @type {StackEntry<T>[]} */\n      const stack = [{\n        node: selectedNode,\n        openEdges: Array.from(selectedNode.dependencies)\n      }];\n\n      // process the top item until stack is empty\n      while (stack.length > 0) {\n        const topOfStack = stack[stack.length - 1];\n\n        // Are there still edges unprocessed in the current node?\n        if (topOfStack.openEdges.length > 0) {\n          // Process one dependency\n          const dependency = topOfStack.openEdges.pop();\n          switch (dependency.marker) {\n            case NO_MARKER:\n              // dependency has not be visited yet\n              // mark it as in-progress and recurse\n              stack.push({\n                node: dependency,\n                openEdges: Array.from(dependency.dependencies)\n              });\n              dependency.marker = IN_PROGRESS_MARKER;\n              break;\n            case IN_PROGRESS_MARKER:\n              {\n                // It's a in-progress cycle\n                let cycle = dependency.cycle;\n                if (!cycle) {\n                  cycle = new Cycle();\n                  cycle.nodes.add(dependency);\n                  dependency.cycle = cycle;\n                }\n                // set cycle property for each node in the cycle\n                // if nodes are already part of a cycle\n                // we merge the cycles to a shared cycle\n                for (let i = stack.length - 1; stack[i].node !== dependency; i--) {\n                  const node = stack[i].node;\n                  if (node.cycle) {\n                    if (node.cycle !== cycle) {\n                      // merge cycles\n                      for (const cycleNode of node.cycle.nodes) {\n                        cycleNode.cycle = cycle;\n                        cycle.nodes.add(cycleNode);\n                      }\n                    }\n                  } else {\n                    node.cycle = cycle;\n                    cycle.nodes.add(node);\n                  }\n                }\n                // don't recurse into dependencies\n                // these are already on the stack\n                break;\n              }\n            case DONE_AND_ROOT_MARKER:\n              // This node has be visited yet and is currently a root node\n              // But as this is a new reference to the node\n              // it's not really a root\n              // so we have to convert it to a normal node\n              dependency.marker = DONE_MARKER;\n              roots.delete(dependency);\n              break;\n            case DONE_MAYBE_ROOT_CYCLE_MARKER:\n              // This node has be visited yet and\n              // is maybe currently part of a completed root cycle\n              // we found a new reference to the cycle\n              // so it's not really a root cycle\n              // remove the cycle from the root cycles\n              // and convert it to a normal node\n              rootCycles.delete(dependency.cycle);\n              dependency.marker = DONE_MARKER;\n              break;\n            // DONE_MARKER: nothing to do, don't recurse into dependencies\n          }\n        } else {\n          // All dependencies of the current node has been visited\n          // we leave the node\n          stack.pop();\n          topOfStack.node.marker = DONE_MARKER;\n        }\n      }\n      const cycle = selectedNode.cycle;\n      if (cycle) {\n        for (const node of cycle.nodes) {\n          node.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n        }\n        rootCycles.add(cycle);\n      } else {\n        selectedNode.marker = DONE_AND_ROOT_MARKER;\n        roots.add(selectedNode);\n      }\n    }\n  }\n\n  // Extract roots from root cycles\n  // We take the nodes with most incoming edges\n  // inside of the cycle\n  for (const cycle of rootCycles) {\n    let max = 0;\n    /** @type {Set<Node<T>>} */\n    const cycleRoots = new Set();\n    const nodes = cycle.nodes;\n    for (const node of nodes) {\n      for (const dep of node.dependencies) {\n        if (nodes.has(dep)) {\n          dep.incoming++;\n          if (dep.incoming < max) continue;\n          if (dep.incoming > max) {\n            cycleRoots.clear();\n            max = dep.incoming;\n          }\n          cycleRoots.add(dep);\n        }\n      }\n    }\n    for (const cycleRoot of cycleRoots) {\n      roots.add(cycleRoot);\n    }\n  }\n\n  // When roots were found, return them\n  if (roots.size > 0) {\n    return Array.from(roots, r => r.item);\n  } else {\n    throw new Error(\"Implementation of findGraphRoots is broken\");\n  }\n};","map":{"version":3,"names":["NO_MARKER","IN_PROGRESS_MARKER","DONE_MARKER","DONE_MAYBE_ROOT_CYCLE_MARKER","DONE_AND_ROOT_MARKER","Node","constructor","item","dependencies","Set","marker","cycle","undefined","incoming","Cycle","nodes","module","exports","items","getDependencies","itemToNode","Map","node","set","size","values","dep","depNode","get","add","roots","rootCycles","selectedNode","stack","openEdges","Array","from","length","topOfStack","dependency","pop","push","i","cycleNode","delete","max","cycleRoots","has","clear","cycleRoot","r","Error"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/findGraphRoots.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item the value of the node\n\t */\n\tconstructor(item) {\n\t\tthis.item = item;\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.dependencies = new Set();\n\t\tthis.marker = NO_MARKER;\n\t\t/** @type {Cycle<T> | undefined} */\n\t\tthis.cycle = undefined;\n\t\tthis.incoming = 0;\n\t}\n}\n\n/**\n * @template T\n */\nclass Cycle {\n\tconstructor() {\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.nodes = new Set();\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\nmodule.exports = (items, getDependencies) => {\n\t/** @type {Map<T, Node<T>>} */\n\tconst itemToNode = new Map();\n\tfor (const item of items) {\n\t\tconst node = new Node(item);\n\t\titemToNode.set(item, node);\n\t}\n\n\t// early exit when there is only a single item\n\tif (itemToNode.size <= 1) return items;\n\n\t// grab all the dependencies\n\tfor (const node of itemToNode.values()) {\n\t\tfor (const dep of getDependencies(node.item)) {\n\t\t\tconst depNode = itemToNode.get(dep);\n\t\t\tif (depNode !== undefined) {\n\t\t\t\tnode.dependencies.add(depNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set of current root modules\n\t// items will be removed if a new reference to it has been found\n\t/** @type {Set<Node<T>>} */\n\tconst roots = new Set();\n\n\t// Set of current cycles without references to it\n\t// cycles will be removed if a new reference to it has been found\n\t// that is not part of the cycle\n\t/** @type {Set<Cycle<T>>} */\n\tconst rootCycles = new Set();\n\n\t// For all non-marked nodes\n\tfor (const selectedNode of itemToNode.values()) {\n\t\tif (selectedNode.marker === NO_MARKER) {\n\t\t\t// deep-walk all referenced modules\n\t\t\t// in a non-recursive way\n\n\t\t\t// start by entering the selected node\n\t\t\tselectedNode.marker = IN_PROGRESS_MARKER;\n\n\t\t\t// keep a stack to avoid recursive walk\n\t\t\t/** @type {StackEntry<T>[]} */\n\t\t\tconst stack = [\n\t\t\t\t{\n\t\t\t\t\tnode: selectedNode,\n\t\t\t\t\topenEdges: Array.from(selectedNode.dependencies)\n\t\t\t\t}\n\t\t\t];\n\n\t\t\t// process the top item until stack is empty\n\t\t\twhile (stack.length > 0) {\n\t\t\t\tconst topOfStack = stack[stack.length - 1];\n\n\t\t\t\t// Are there still edges unprocessed in the current node?\n\t\t\t\tif (topOfStack.openEdges.length > 0) {\n\t\t\t\t\t// Process one dependency\n\t\t\t\t\tconst dependency = topOfStack.openEdges.pop();\n\t\t\t\t\tswitch (dependency.marker) {\n\t\t\t\t\t\tcase NO_MARKER:\n\t\t\t\t\t\t\t// dependency has not be visited yet\n\t\t\t\t\t\t\t// mark it as in-progress and recurse\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\tnode: dependency,\n\t\t\t\t\t\t\t\topenEdges: Array.from(dependency.dependencies)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdependency.marker = IN_PROGRESS_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_PROGRESS_MARKER: {\n\t\t\t\t\t\t\t// It's a in-progress cycle\n\t\t\t\t\t\t\tlet cycle = dependency.cycle;\n\t\t\t\t\t\t\tif (!cycle) {\n\t\t\t\t\t\t\t\tcycle = new Cycle();\n\t\t\t\t\t\t\t\tcycle.nodes.add(dependency);\n\t\t\t\t\t\t\t\tdependency.cycle = cycle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// set cycle property for each node in the cycle\n\t\t\t\t\t\t\t// if nodes are already part of a cycle\n\t\t\t\t\t\t\t// we merge the cycles to a shared cycle\n\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\tlet i = stack.length - 1;\n\t\t\t\t\t\t\t\tstack[i].node !== dependency;\n\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst node = stack[i].node;\n\t\t\t\t\t\t\t\tif (node.cycle) {\n\t\t\t\t\t\t\t\t\tif (node.cycle !== cycle) {\n\t\t\t\t\t\t\t\t\t\t// merge cycles\n\t\t\t\t\t\t\t\t\t\tfor (const cycleNode of node.cycle.nodes) {\n\t\t\t\t\t\t\t\t\t\t\tcycleNode.cycle = cycle;\n\t\t\t\t\t\t\t\t\t\t\tcycle.nodes.add(cycleNode);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode.cycle = cycle;\n\t\t\t\t\t\t\t\t\tcycle.nodes.add(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// don't recurse into dependencies\n\t\t\t\t\t\t\t// these are already on the stack\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DONE_AND_ROOT_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and is currently a root node\n\t\t\t\t\t\t\t// But as this is a new reference to the node\n\t\t\t\t\t\t\t// it's not really a root\n\t\t\t\t\t\t\t// so we have to convert it to a normal node\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\troots.delete(dependency);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase DONE_MAYBE_ROOT_CYCLE_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and\n\t\t\t\t\t\t\t// is maybe currently part of a completed root cycle\n\t\t\t\t\t\t\t// we found a new reference to the cycle\n\t\t\t\t\t\t\t// so it's not really a root cycle\n\t\t\t\t\t\t\t// remove the cycle from the root cycles\n\t\t\t\t\t\t\t// and convert it to a normal node\n\t\t\t\t\t\t\trootCycles.delete(dependency.cycle);\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// DONE_MARKER: nothing to do, don't recurse into dependencies\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// All dependencies of the current node has been visited\n\t\t\t\t\t// we leave the node\n\t\t\t\t\tstack.pop();\n\t\t\t\t\ttopOfStack.node.marker = DONE_MARKER;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst cycle = selectedNode.cycle;\n\t\t\tif (cycle) {\n\t\t\t\tfor (const node of cycle.nodes) {\n\t\t\t\t\tnode.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n\t\t\t\t}\n\t\t\t\trootCycles.add(cycle);\n\t\t\t} else {\n\t\t\t\tselectedNode.marker = DONE_AND_ROOT_MARKER;\n\t\t\t\troots.add(selectedNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Extract roots from root cycles\n\t// We take the nodes with most incoming edges\n\t// inside of the cycle\n\tfor (const cycle of rootCycles) {\n\t\tlet max = 0;\n\t\t/** @type {Set<Node<T>>} */\n\t\tconst cycleRoots = new Set();\n\t\tconst nodes = cycle.nodes;\n\t\tfor (const node of nodes) {\n\t\t\tfor (const dep of node.dependencies) {\n\t\t\t\tif (nodes.has(dep)) {\n\t\t\t\t\tdep.incoming++;\n\t\t\t\t\tif (dep.incoming < max) continue;\n\t\t\t\t\tif (dep.incoming > max) {\n\t\t\t\t\t\tcycleRoots.clear();\n\t\t\t\t\t\tmax = dep.incoming;\n\t\t\t\t\t}\n\t\t\t\t\tcycleRoots.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cycleRoot of cycleRoots) {\n\t\t\troots.add(cycleRoot);\n\t\t}\n\t}\n\n\t// When roots were found, return them\n\tif (roots.size > 0) {\n\t\treturn Array.from(roots, r => r.item);\n\t} else {\n\t\tthrow new Error(\"Implementation of findGraphRoots is broken\");\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}