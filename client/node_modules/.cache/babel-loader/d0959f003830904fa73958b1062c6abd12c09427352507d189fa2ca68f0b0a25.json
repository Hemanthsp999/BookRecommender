{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst {\n  first\n} = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\nclass GetChunkFilenameRuntimeModule extends RuntimeModule {\n  /**\n   * @param {string} contentType the contentType to use the content hash for\n   * @param {string} name kind of filename\n   * @param {string} global function name to be assigned\n   * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n   * @param {boolean} allChunks when false, only async chunks are included\n   */\n  constructor(contentType, name, global, getFilenameForChunk, allChunks) {\n    super(`get ${name} chunk filename`);\n    this.contentType = contentType;\n    this.global = global;\n    this.getFilenameForChunk = getFilenameForChunk;\n    this.allChunks = allChunks;\n    this.dependentHash = true;\n  }\n\n  /**\n   * @returns {string} runtime code\n   */\n  generate() {\n    const {\n      global,\n      chunk,\n      chunkGraph,\n      contentType,\n      getFilenameForChunk,\n      allChunks,\n      compilation\n    } = this;\n    const {\n      runtimeTemplate\n    } = compilation;\n\n    /** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n    const chunkFilenames = new Map();\n    let maxChunks = 0;\n    /** @type {string} */\n    let dynamicFilename;\n\n    /**\n     * @param {Chunk} c the chunk\n     * @returns {void}\n     */\n    const addChunk = c => {\n      const chunkFilename = getFilenameForChunk(c);\n      if (chunkFilename) {\n        let set = chunkFilenames.get(chunkFilename);\n        if (set === undefined) {\n          chunkFilenames.set(chunkFilename, set = new Set());\n        }\n        set.add(c);\n        if (typeof chunkFilename === \"string\") {\n          if (set.size < maxChunks) return;\n          if (set.size === maxChunks) {\n            if (chunkFilename.length < dynamicFilename.length) return;\n            if (chunkFilename.length === dynamicFilename.length) {\n              if (chunkFilename < dynamicFilename) return;\n            }\n          }\n          maxChunks = set.size;\n          dynamicFilename = chunkFilename;\n        }\n      }\n    };\n\n    /** @type {string[]} */\n    const includedChunksMessages = [];\n    if (allChunks) {\n      includedChunksMessages.push(\"all chunks\");\n      for (const c of chunk.getAllReferencedChunks()) {\n        addChunk(c);\n      }\n    } else {\n      includedChunksMessages.push(\"async chunks\");\n      for (const c of chunk.getAllAsyncChunks()) {\n        addChunk(c);\n      }\n      const includeEntries = chunkGraph.getTreeRuntimeRequirements(chunk).has(RuntimeGlobals.ensureChunkIncludeEntries);\n      if (includeEntries) {\n        includedChunksMessages.push(\"sibling chunks for the entrypoint\");\n        for (const c of chunkGraph.getChunkEntryDependentChunksIterable(chunk)) {\n          addChunk(c);\n        }\n      }\n    }\n    for (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {\n      addChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n    }\n\n    /** @type {Map<string, Set<string | number>>} */\n    const staticUrls = new Map();\n    /** @type {Set<Chunk>} */\n    const dynamicUrlChunks = new Set();\n\n    /**\n     * @param {Chunk} c the chunk\n     * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n     * @returns {void}\n     */\n    const addStaticUrl = (c, chunkFilename) => {\n      /**\n       * @param {string | number} value a value\n       * @returns {string} string to put in quotes\n       */\n      const unquotedStringify = value => {\n        const str = `${value}`;\n        if (str.length >= 5 && str === `${c.id}`) {\n          // This is shorter and generates the same result\n          return '\" + chunkId + \"';\n        }\n        const s = JSON.stringify(str);\n        return s.slice(1, s.length - 1);\n      };\n      /**\n       * @param {string} value string\n       * @returns {function(number): string} string to put in quotes with length\n       */\n      const unquotedStringifyWithLength = value => length => unquotedStringify(`${value}`.slice(0, length));\n      const chunkFilenameValue = typeof chunkFilename === \"function\" ? JSON.stringify(chunkFilename({\n        chunk: c,\n        contentHashType: contentType\n      })) : JSON.stringify(chunkFilename);\n      const staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n        hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n        hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n        chunk: {\n          id: unquotedStringify(c.id),\n          hash: unquotedStringify(c.renderedHash),\n          hashWithLength: unquotedStringifyWithLength(c.renderedHash),\n          name: unquotedStringify(c.name || c.id),\n          contentHash: {\n            [contentType]: unquotedStringify(c.contentHash[contentType])\n          },\n          contentHashWithLength: {\n            [contentType]: unquotedStringifyWithLength(c.contentHash[contentType])\n          }\n        },\n        contentHashType: contentType\n      });\n      let set = staticUrls.get(staticChunkFilename);\n      if (set === undefined) {\n        staticUrls.set(staticChunkFilename, set = new Set());\n      }\n      set.add(c.id);\n    };\n    for (const [filename, chunks] of chunkFilenames) {\n      if (filename !== dynamicFilename) {\n        for (const c of chunks) addStaticUrl(c, filename);\n      } else {\n        for (const c of chunks) dynamicUrlChunks.add(c);\n      }\n    }\n\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {string} code with static mapping of results of fn\n     */\n    const createMap = fn => {\n      const obj = {};\n      let useId = false;\n      let lastKey;\n      let entries = 0;\n      for (const c of dynamicUrlChunks) {\n        const value = fn(c);\n        if (value === c.id) {\n          useId = true;\n        } else {\n          obj[c.id] = value;\n          lastKey = c.id;\n          entries++;\n        }\n      }\n      if (entries === 0) return \"chunkId\";\n      if (entries === 1) {\n        return useId ? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(obj[lastKey])} : chunkId)` : JSON.stringify(obj[lastKey]);\n      }\n      return useId ? `(${JSON.stringify(obj)}[chunkId] || chunkId)` : `${JSON.stringify(obj)}[chunkId]`;\n    };\n\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {string} code with static mapping of results of fn for including in quoted string\n     */\n    const mapExpr = fn => {\n      return `\" + ${createMap(fn)} + \"`;\n    };\n\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n     */\n    const mapExprWithLength = fn => length => {\n      return `\" + ${createMap(c => `${fn(c)}`.slice(0, length))} + \"`;\n    };\n    const url = dynamicFilename && compilation.getPath(JSON.stringify(dynamicFilename), {\n      hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n      hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n      chunk: {\n        id: `\" + chunkId + \"`,\n        hash: mapExpr(c => c.renderedHash),\n        hashWithLength: mapExprWithLength(c => c.renderedHash),\n        name: mapExpr(c => c.name || c.id),\n        contentHash: {\n          [contentType]: mapExpr(c => c.contentHash[contentType])\n        },\n        contentHashWithLength: {\n          [contentType]: mapExprWithLength(c => c.contentHash[contentType])\n        }\n      },\n      contentHashType: contentType\n    });\n    return Template.asString([`// This function allow to reference ${includedChunksMessages.join(\" and \")}`, `${global} = ${runtimeTemplate.basicFunction(\"chunkId\", staticUrls.size > 0 ? [\"// return url for filenames not based on template\",\n    // it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n    Template.asString(Array.from(staticUrls, _ref => {\n      let [url, ids] = _ref;\n      const condition = ids.size === 1 ? `chunkId === ${JSON.stringify(first(ids))}` : `{${Array.from(ids, id => `${JSON.stringify(id)}:1`).join(\",\")}}[chunkId]`;\n      return `if (${condition}) return ${url};`;\n    })), \"// return url for filenames based on template\", `return ${url};`] : [\"// return url for filenames based on template\", `return ${url};`])};`]);\n  }\n}\nmodule.exports = GetChunkFilenameRuntimeModule;","map":{"version":3,"names":["RuntimeGlobals","require","RuntimeModule","Template","first","GetChunkFilenameRuntimeModule","constructor","contentType","name","global","getFilenameForChunk","allChunks","dependentHash","generate","chunk","chunkGraph","compilation","runtimeTemplate","chunkFilenames","Map","maxChunks","dynamicFilename","addChunk","c","chunkFilename","set","get","undefined","Set","add","size","length","includedChunksMessages","push","getAllReferencedChunks","getAllAsyncChunks","includeEntries","getTreeRuntimeRequirements","has","ensureChunkIncludeEntries","getChunkEntryDependentChunksIterable","entrypoint","getAllReferencedAsyncEntrypoints","chunks","staticUrls","dynamicUrlChunks","addStaticUrl","unquotedStringify","value","str","id","s","JSON","stringify","slice","unquotedStringifyWithLength","chunkFilenameValue","contentHashType","staticChunkFilename","getPath","hash","getFullHash","hashWithLength","renderedHash","contentHash","contentHashWithLength","filename","createMap","fn","obj","useId","lastKey","entries","mapExpr","mapExprWithLength","url","asString","join","basicFunction","Array","from","_ref","ids","condition","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/runtime/GetChunkFilenameRuntimeModule.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst { first } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\nclass GetChunkFilenameRuntimeModule extends RuntimeModule {\n\t/**\n\t * @param {string} contentType the contentType to use the content hash for\n\t * @param {string} name kind of filename\n\t * @param {string} global function name to be assigned\n\t * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n\t * @param {boolean} allChunks when false, only async chunks are included\n\t */\n\tconstructor(contentType, name, global, getFilenameForChunk, allChunks) {\n\t\tsuper(`get ${name} chunk filename`);\n\t\tthis.contentType = contentType;\n\t\tthis.global = global;\n\t\tthis.getFilenameForChunk = getFilenameForChunk;\n\t\tthis.allChunks = allChunks;\n\t\tthis.dependentHash = true;\n\t}\n\n\t/**\n\t * @returns {string} runtime code\n\t */\n\tgenerate() {\n\t\tconst {\n\t\t\tglobal,\n\t\t\tchunk,\n\t\t\tchunkGraph,\n\t\t\tcontentType,\n\t\t\tgetFilenameForChunk,\n\t\t\tallChunks,\n\t\t\tcompilation\n\t\t} = this;\n\t\tconst { runtimeTemplate } = compilation;\n\n\t\t/** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n\t\tconst chunkFilenames = new Map();\n\t\tlet maxChunks = 0;\n\t\t/** @type {string} */\n\t\tlet dynamicFilename;\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChunk = c => {\n\t\t\tconst chunkFilename = getFilenameForChunk(c);\n\t\t\tif (chunkFilename) {\n\t\t\t\tlet set = chunkFilenames.get(chunkFilename);\n\t\t\t\tif (set === undefined) {\n\t\t\t\t\tchunkFilenames.set(chunkFilename, (set = new Set()));\n\t\t\t\t}\n\t\t\t\tset.add(c);\n\t\t\t\tif (typeof chunkFilename === \"string\") {\n\t\t\t\t\tif (set.size < maxChunks) return;\n\t\t\t\t\tif (set.size === maxChunks) {\n\t\t\t\t\t\tif (chunkFilename.length < dynamicFilename.length) return;\n\t\t\t\t\t\tif (chunkFilename.length === dynamicFilename.length) {\n\t\t\t\t\t\t\tif (chunkFilename < dynamicFilename) return;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxChunks = set.size;\n\t\t\t\t\tdynamicFilename = chunkFilename;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/** @type {string[]} */\n\t\tconst includedChunksMessages = [];\n\t\tif (allChunks) {\n\t\t\tincludedChunksMessages.push(\"all chunks\");\n\t\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t} else {\n\t\t\tincludedChunksMessages.push(\"async chunks\");\n\t\t\tfor (const c of chunk.getAllAsyncChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t\tconst includeEntries = chunkGraph\n\t\t\t\t.getTreeRuntimeRequirements(chunk)\n\t\t\t\t.has(RuntimeGlobals.ensureChunkIncludeEntries);\n\t\t\tif (includeEntries) {\n\t\t\t\tincludedChunksMessages.push(\"sibling chunks for the entrypoint\");\n\t\t\t\tfor (const c of chunkGraph.getChunkEntryDependentChunksIterable(\n\t\t\t\t\tchunk\n\t\t\t\t)) {\n\t\t\t\t\taddChunk(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {\n\t\t\taddChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n\t\t}\n\n\t\t/** @type {Map<string, Set<string | number>>} */\n\t\tconst staticUrls = new Map();\n\t\t/** @type {Set<Chunk>} */\n\t\tconst dynamicUrlChunks = new Set();\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addStaticUrl = (c, chunkFilename) => {\n\t\t\t/**\n\t\t\t * @param {string | number} value a value\n\t\t\t * @returns {string} string to put in quotes\n\t\t\t */\n\t\t\tconst unquotedStringify = value => {\n\t\t\t\tconst str = `${value}`;\n\t\t\t\tif (str.length >= 5 && str === `${c.id}`) {\n\t\t\t\t\t// This is shorter and generates the same result\n\t\t\t\t\treturn '\" + chunkId + \"';\n\t\t\t\t}\n\t\t\t\tconst s = JSON.stringify(str);\n\t\t\t\treturn s.slice(1, s.length - 1);\n\t\t\t};\n\t\t\t/**\n\t\t\t * @param {string} value string\n\t\t\t * @returns {function(number): string} string to put in quotes with length\n\t\t\t */\n\t\t\tconst unquotedStringifyWithLength = value => length =>\n\t\t\t\tunquotedStringify(`${value}`.slice(0, length));\n\t\t\tconst chunkFilenameValue =\n\t\t\t\ttypeof chunkFilename === \"function\"\n\t\t\t\t\t? JSON.stringify(\n\t\t\t\t\t\t\tchunkFilename({\n\t\t\t\t\t\t\t\tchunk: c,\n\t\t\t\t\t\t\t\tcontentHashType: contentType\n\t\t\t\t\t\t\t})\n\t\t\t\t\t  )\n\t\t\t\t\t: JSON.stringify(chunkFilename);\n\t\t\tconst staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: unquotedStringify(c.id),\n\t\t\t\t\thash: unquotedStringify(c.renderedHash),\n\t\t\t\t\thashWithLength: unquotedStringifyWithLength(c.renderedHash),\n\t\t\t\t\tname: unquotedStringify(c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: unquotedStringify(c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: unquotedStringifyWithLength(\n\t\t\t\t\t\t\tc.contentHash[contentType]\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\t\t\tlet set = staticUrls.get(staticChunkFilename);\n\t\t\tif (set === undefined) {\n\t\t\t\tstaticUrls.set(staticChunkFilename, (set = new Set()));\n\t\t\t}\n\t\t\tset.add(c.id);\n\t\t};\n\n\t\tfor (const [filename, chunks] of chunkFilenames) {\n\t\t\tif (filename !== dynamicFilename) {\n\t\t\t\tfor (const c of chunks) addStaticUrl(c, filename);\n\t\t\t} else {\n\t\t\t\tfor (const c of chunks) dynamicUrlChunks.add(c);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn\n\t\t */\n\t\tconst createMap = fn => {\n\t\t\tconst obj = {};\n\t\t\tlet useId = false;\n\t\t\tlet lastKey;\n\t\t\tlet entries = 0;\n\t\t\tfor (const c of dynamicUrlChunks) {\n\t\t\t\tconst value = fn(c);\n\t\t\t\tif (value === c.id) {\n\t\t\t\t\tuseId = true;\n\t\t\t\t} else {\n\t\t\t\t\tobj[c.id] = value;\n\t\t\t\t\tlastKey = c.id;\n\t\t\t\t\tentries++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (entries === 0) return \"chunkId\";\n\t\t\tif (entries === 1) {\n\t\t\t\treturn useId\n\t\t\t\t\t? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(\n\t\t\t\t\t\t\tobj[lastKey]\n\t\t\t\t\t  )} : chunkId)`\n\t\t\t\t\t: JSON.stringify(obj[lastKey]);\n\t\t\t}\n\t\t\treturn useId\n\t\t\t\t? `(${JSON.stringify(obj)}[chunkId] || chunkId)`\n\t\t\t\t: `${JSON.stringify(obj)}[chunkId]`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn for including in quoted string\n\t\t */\n\t\tconst mapExpr = fn => {\n\t\t\treturn `\" + ${createMap(fn)} + \"`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n\t\t */\n\t\tconst mapExprWithLength = fn => length => {\n\t\t\treturn `\" + ${createMap(c => `${fn(c)}`.slice(0, length))} + \"`;\n\t\t};\n\n\t\tconst url =\n\t\t\tdynamicFilename &&\n\t\t\tcompilation.getPath(JSON.stringify(dynamicFilename), {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: `\" + chunkId + \"`,\n\t\t\t\t\thash: mapExpr(c => c.renderedHash),\n\t\t\t\t\thashWithLength: mapExprWithLength(c => c.renderedHash),\n\t\t\t\t\tname: mapExpr(c => c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: mapExpr(c => c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: mapExprWithLength(c => c.contentHash[contentType])\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\n\t\treturn Template.asString([\n\t\t\t`// This function allow to reference ${includedChunksMessages.join(\n\t\t\t\t\" and \"\n\t\t\t)}`,\n\t\t\t`${global} = ${runtimeTemplate.basicFunction(\n\t\t\t\t\"chunkId\",\n\n\t\t\t\tstaticUrls.size > 0\n\t\t\t\t\t? [\n\t\t\t\t\t\t\t\"// return url for filenames not based on template\",\n\t\t\t\t\t\t\t// it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n\t\t\t\t\t\t\tTemplate.asString(\n\t\t\t\t\t\t\t\tArray.from(staticUrls, ([url, ids]) => {\n\t\t\t\t\t\t\t\t\tconst condition =\n\t\t\t\t\t\t\t\t\t\tids.size === 1\n\t\t\t\t\t\t\t\t\t\t\t? `chunkId === ${JSON.stringify(first(ids))}`\n\t\t\t\t\t\t\t\t\t\t\t: `{${Array.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tids,\n\t\t\t\t\t\t\t\t\t\t\t\t\tid => `${JSON.stringify(id)}:1`\n\t\t\t\t\t\t\t\t\t\t\t  ).join(\",\")}}[chunkId]`;\n\t\t\t\t\t\t\t\t\treturn `if (${condition}) return ${url};`;\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\"// return url for filenames based on template\",\n\t\t\t\t\t\t\t`return ${url};`\n\t\t\t\t\t  ]\n\t\t\t\t\t: [\"// return url for filenames based on template\", `return ${url};`]\n\t\t\t)};`\n\t\t]);\n\t}\n}\n\nmodule.exports = GetChunkFilenameRuntimeModule;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}