{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @template K\n * @template V\n */\nclass StackedCacheMap {\n  constructor() {\n    /** @type {Map<K, V>} */\n    this.map = new Map();\n    /** @type {ReadonlyMap<K, V>[]} */\n    this.stack = [];\n  }\n\n  /**\n   * @param {ReadonlyMap<K, V>} map map to add\n   * @param {boolean} immutable if 'map' is immutable and StackedCacheMap can keep referencing it\n   */\n  addAll(map, immutable) {\n    if (immutable) {\n      this.stack.push(map);\n\n      // largest map should go first\n      for (let i = this.stack.length - 1; i > 0; i--) {\n        const beforeLast = this.stack[i - 1];\n        if (beforeLast.size >= map.size) break;\n        this.stack[i] = beforeLast;\n        this.stack[i - 1] = map;\n      }\n    } else {\n      for (const [key, value] of map) {\n        this.map.set(key, value);\n      }\n    }\n  }\n\n  /**\n   * @param {K} item the key of the element to add\n   * @param {V} value the value of the element to add\n   * @returns {void}\n   */\n  set(item, value) {\n    this.map.set(item, value);\n  }\n\n  /**\n   * @param {K} item the item to delete\n   * @returns {void}\n   */\n  delete(item) {\n    throw new Error(\"Items can't be deleted from a StackedCacheMap\");\n  }\n\n  /**\n   * @param {K} item the item to test\n   * @returns {boolean} true if the item exists in this set\n   */\n  has(item) {\n    throw new Error(\"Checking StackedCacheMap.has before reading is inefficient, use StackedCacheMap.get and check for undefined\");\n  }\n\n  /**\n   * @param {K} item the key of the element to return\n   * @returns {V} the value of the element\n   */\n  get(item) {\n    for (const map of this.stack) {\n      const value = map.get(item);\n      if (value !== undefined) return value;\n    }\n    return this.map.get(item);\n  }\n  clear() {\n    this.stack.length = 0;\n    this.map.clear();\n  }\n\n  /**\n   * @returns {number} size of the map\n   */\n  get size() {\n    let size = this.map.size;\n    for (const map of this.stack) {\n      size += map.size;\n    }\n    return size;\n  }\n\n  /**\n   * @returns {Iterator<[K, V]>} iterator\n   */\n  [Symbol.iterator]() {\n    const iterators = this.stack.map(map => map[Symbol.iterator]());\n    let current = this.map[Symbol.iterator]();\n    return {\n      next() {\n        let result = current.next();\n        while (result.done && iterators.length > 0) {\n          current = iterators.pop();\n          result = current.next();\n        }\n        return result;\n      }\n    };\n  }\n}\nmodule.exports = StackedCacheMap;","map":{"version":3,"names":["StackedCacheMap","constructor","map","Map","stack","addAll","immutable","push","i","length","beforeLast","size","key","value","set","item","delete","Error","has","get","undefined","clear","Symbol","iterator","iterators","current","next","result","done","pop","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/StackedCacheMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @template K\n * @template V\n */\nclass StackedCacheMap {\n\tconstructor() {\n\t\t/** @type {Map<K, V>} */\n\t\tthis.map = new Map();\n\t\t/** @type {ReadonlyMap<K, V>[]} */\n\t\tthis.stack = [];\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<K, V>} map map to add\n\t * @param {boolean} immutable if 'map' is immutable and StackedCacheMap can keep referencing it\n\t */\n\taddAll(map, immutable) {\n\t\tif (immutable) {\n\t\t\tthis.stack.push(map);\n\n\t\t\t// largest map should go first\n\t\t\tfor (let i = this.stack.length - 1; i > 0; i--) {\n\t\t\t\tconst beforeLast = this.stack[i - 1];\n\t\t\t\tif (beforeLast.size >= map.size) break;\n\t\t\t\tthis.stack[i] = beforeLast;\n\t\t\t\tthis.stack[i - 1] = map;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of map) {\n\t\t\t\tthis.map.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to add\n\t * @param {V} value the value of the element to add\n\t * @returns {void}\n\t */\n\tset(item, value) {\n\t\tthis.map.set(item, value);\n\t}\n\n\t/**\n\t * @param {K} item the item to delete\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tthrow new Error(\"Items can't be deleted from a StackedCacheMap\");\n\t}\n\n\t/**\n\t * @param {K} item the item to test\n\t * @returns {boolean} true if the item exists in this set\n\t */\n\thas(item) {\n\t\tthrow new Error(\n\t\t\t\"Checking StackedCacheMap.has before reading is inefficient, use StackedCacheMap.get and check for undefined\"\n\t\t);\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to return\n\t * @returns {V} the value of the element\n\t */\n\tget(item) {\n\t\tfor (const map of this.stack) {\n\t\t\tconst value = map.get(item);\n\t\t\tif (value !== undefined) return value;\n\t\t}\n\t\treturn this.map.get(item);\n\t}\n\n\tclear() {\n\t\tthis.stack.length = 0;\n\t\tthis.map.clear();\n\t}\n\n\t/**\n\t * @returns {number} size of the map\n\t */\n\tget size() {\n\t\tlet size = this.map.size;\n\t\tfor (const map of this.stack) {\n\t\t\tsize += map.size;\n\t\t}\n\t\treturn size;\n\t}\n\n\t/**\n\t * @returns {Iterator<[K, V]>} iterator\n\t */\n\t[Symbol.iterator]() {\n\t\tconst iterators = this.stack.map(map => map[Symbol.iterator]());\n\t\tlet current = this.map[Symbol.iterator]();\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tlet result = current.next();\n\t\t\t\twhile (result.done && iterators.length > 0) {\n\t\t\t\t\tcurrent = iterators.pop();\n\t\t\t\t\tresult = current.next();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = StackedCacheMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}