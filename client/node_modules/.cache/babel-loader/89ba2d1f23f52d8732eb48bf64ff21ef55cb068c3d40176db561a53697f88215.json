{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\nconst {\n  RawSource,\n  CachedSource,\n  CompatSource\n} = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst {\n  compareSelect,\n  compareStrings\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\nconst EMPTY_SET = new Set();\nconst addToList = (itemOrItems, list) => {\n  if (Array.isArray(itemOrItems)) {\n    for (const item of itemOrItems) {\n      list.add(item);\n    }\n  } else if (itemOrItems) {\n    list.add(itemOrItems);\n  }\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n  // Buffer.equals compares size first so this should be efficient enough\n  // If it becomes a performance problem we can use a map and group by size\n  // instead of looping over all assets.\n  const result = [];\n  outer: for (const value of input) {\n    const buf = fn(value);\n    for (const other of result) {\n      if (buf.equals(other)) continue outer;\n    }\n    result.push(buf);\n  }\n  return result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\nconst cachedSourceMap = new WeakMap();\nconst toCachedSource = source => {\n  if (source instanceof CachedSource) {\n    return source;\n  }\n  const entry = cachedSourceMap.get(source);\n  if (entry !== undefined) return entry;\n  const newSource = new CachedSource(CompatSource.from(source));\n  cachedSourceMap.set(source, newSource);\n  return newSource;\n};\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\nclass RealContentHashPlugin {\n  /**\n   * @param {Compilation} compilation the compilation\n   * @returns {CompilationHooks} the attached hooks\n   */\n  static getCompilationHooks(compilation) {\n    if (!(compilation instanceof Compilation)) {\n      throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n    }\n    let hooks = compilationHooksMap.get(compilation);\n    if (hooks === undefined) {\n      hooks = {\n        updateHash: new SyncBailHook([\"content\", \"oldHash\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n    return hooks;\n  }\n\n  /**\n   * @param {Object} options options object\n   * @param {string | Hash} options.hashFunction the hash function to use\n   * @param {string} options.hashDigest the hash digest to use\n   */\n  constructor(_ref) {\n    let {\n      hashFunction,\n      hashDigest\n    } = _ref;\n    this._hashFunction = hashFunction;\n    this._hashDigest = hashDigest;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n      const cacheAnalyse = compilation.getCache(\"RealContentHashPlugin|analyse\");\n      const cacheGenerate = compilation.getCache(\"RealContentHashPlugin|generate\");\n      const hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n      compilation.hooks.processAssets.tapPromise({\n        name: \"RealContentHashPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n      }, async () => {\n        const assets = compilation.getAssets();\n        /** @type {AssetInfoForRealContentHash[]} */\n        const assetsWithInfo = [];\n        const hashToAssets = new Map();\n        for (const {\n          source,\n          info,\n          name\n        } of assets) {\n          const cachedSource = toCachedSource(source);\n          const content = cachedSource.source();\n          /** @type {Set<string>} */\n          const hashes = new Set();\n          addToList(info.contenthash, hashes);\n          const data = {\n            name,\n            info,\n            source: cachedSource,\n            /** @type {RawSource | undefined} */\n            newSource: undefined,\n            /** @type {RawSource | undefined} */\n            newSourceWithoutOwn: undefined,\n            content,\n            /** @type {Set<string>} */\n            ownHashes: undefined,\n            contentComputePromise: undefined,\n            contentComputeWithoutOwnPromise: undefined,\n            /** @type {Set<string>} */\n            referencedHashes: undefined,\n            hashes\n          };\n          assetsWithInfo.push(data);\n          for (const hash of hashes) {\n            const list = hashToAssets.get(hash);\n            if (list === undefined) {\n              hashToAssets.set(hash, [data]);\n            } else {\n              list.push(data);\n            }\n          }\n        }\n        if (hashToAssets.size === 0) return;\n        const hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join(\"|\"), \"g\");\n        await Promise.all(assetsWithInfo.map(async asset => {\n          const {\n            name,\n            source,\n            content,\n            hashes\n          } = asset;\n          if (Buffer.isBuffer(content)) {\n            asset.referencedHashes = EMPTY_SET;\n            asset.ownHashes = EMPTY_SET;\n            return;\n          }\n          const etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join(\"|\"));\n          [asset.referencedHashes, asset.ownHashes] = await cacheAnalyse.providePromise(name, etag, () => {\n            const referencedHashes = new Set();\n            let ownHashes = new Set();\n            const inContent = content.match(hashRegExp);\n            if (inContent) {\n              for (const hash of inContent) {\n                if (hashes.has(hash)) {\n                  ownHashes.add(hash);\n                  continue;\n                }\n                referencedHashes.add(hash);\n              }\n            }\n            return [referencedHashes, ownHashes];\n          });\n        }));\n        const getDependencies = hash => {\n          const assets = hashToAssets.get(hash);\n          if (!assets) {\n            const referencingAssets = assetsWithInfo.filter(asset => asset.referencedHashes.has(hash));\n            const err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets.map(a => {\n              const match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(a.content);\n              return ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n            }).join(\"\\n\")}`);\n            compilation.errors.push(err);\n            return undefined;\n          }\n          const hashes = new Set();\n          for (const {\n            referencedHashes,\n            ownHashes\n          } of assets) {\n            if (!ownHashes.has(hash)) {\n              for (const hash of ownHashes) {\n                hashes.add(hash);\n              }\n            }\n            for (const hash of referencedHashes) {\n              hashes.add(hash);\n            }\n          }\n          return hashes;\n        };\n        const hashInfo = hash => {\n          const assets = hashToAssets.get(hash);\n          return `${hash} (${Array.from(assets, a => a.name)})`;\n        };\n        const hashesInOrder = new Set();\n        for (const hash of hashToAssets.keys()) {\n          const add = (hash, stack) => {\n            const deps = getDependencies(hash);\n            if (!deps) return;\n            stack.add(hash);\n            for (const dep of deps) {\n              if (hashesInOrder.has(dep)) continue;\n              if (stack.has(dep)) {\n                throw new Error(`Circular hash dependency ${Array.from(stack, hashInfo).join(\" -> \")} -> ${hashInfo(dep)}`);\n              }\n              add(dep, stack);\n            }\n            hashesInOrder.add(hash);\n            stack.delete(hash);\n          };\n          if (hashesInOrder.has(hash)) continue;\n          add(hash, new Set());\n        }\n        const hashToNewHash = new Map();\n        const getEtag = asset => cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from(asset.referencedHashes, hash => hashToNewHash.get(hash)).join(\"|\"));\n        const computeNewContent = asset => {\n          if (asset.contentComputePromise) return asset.contentComputePromise;\n          return asset.contentComputePromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name;\n              const etag = getEtag(asset);\n              asset.newSource = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => hashToNewHash.get(hash));\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n        const computeNewContentWithoutOwn = asset => {\n          if (asset.contentComputeWithoutOwnPromise) return asset.contentComputeWithoutOwnPromise;\n          return asset.contentComputeWithoutOwnPromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name + \"|without-own\";\n              const etag = getEtag(asset);\n              asset.newSourceWithoutOwn = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => {\n                  if (asset.ownHashes.has(hash)) {\n                    return \"\";\n                  }\n                  return hashToNewHash.get(hash);\n                });\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n        const comparator = compareSelect(a => a.name, compareStrings);\n        for (const oldHash of hashesInOrder) {\n          const assets = hashToAssets.get(oldHash);\n          assets.sort(comparator);\n          await Promise.all(assets.map(asset => asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset)));\n          const assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n            if (asset.ownHashes.has(oldHash)) {\n              return asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer();\n            } else {\n              return asset.newSource ? asset.newSource.buffer() : asset.source.buffer();\n            }\n          });\n          let newHash = hooks.updateHash.call(assetsContent, oldHash);\n          if (!newHash) {\n            const hash = createHash(this._hashFunction);\n            if (compilation.outputOptions.hashSalt) {\n              hash.update(compilation.outputOptions.hashSalt);\n            }\n            for (const content of assetsContent) {\n              hash.update(content);\n            }\n            const digest = hash.digest(this._hashDigest);\n            newHash = /** @type {string} */digest.slice(0, oldHash.length);\n          }\n          hashToNewHash.set(oldHash, newHash);\n        }\n        await Promise.all(assetsWithInfo.map(async asset => {\n          await computeNewContent(asset);\n          const newName = asset.name.replace(hashRegExp, hash => hashToNewHash.get(hash));\n          const infoUpdate = {};\n          const hash = asset.info.contenthash;\n          infoUpdate.contenthash = Array.isArray(hash) ? hash.map(hash => hashToNewHash.get(hash)) : hashToNewHash.get(hash);\n          if (asset.newSource !== undefined) {\n            compilation.updateAsset(asset.name, asset.newSource, infoUpdate);\n          } else {\n            compilation.updateAsset(asset.name, asset.source, infoUpdate);\n          }\n          if (asset.name !== newName) {\n            compilation.renameAsset(asset.name, newName);\n          }\n        }));\n      });\n    });\n  }\n}\nmodule.exports = RealContentHashPlugin;","map":{"version":3,"names":["SyncBailHook","require","RawSource","CachedSource","CompatSource","Compilation","WebpackError","compareSelect","compareStrings","createHash","EMPTY_SET","Set","addToList","itemOrItems","list","Array","isArray","item","add","mapAndDeduplicateBuffers","input","fn","result","outer","value","buf","other","equals","push","quoteMeta","str","replace","cachedSourceMap","WeakMap","toCachedSource","source","entry","get","undefined","newSource","from","set","compilationHooksMap","RealContentHashPlugin","getCompilationHooks","compilation","TypeError","hooks","updateHash","constructor","_ref","hashFunction","hashDigest","_hashFunction","_hashDigest","apply","compiler","tap","cacheAnalyse","getCache","cacheGenerate","processAssets","tapPromise","name","stage","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","assets","getAssets","assetsWithInfo","hashToAssets","Map","info","cachedSource","content","hashes","contenthash","data","newSourceWithoutOwn","ownHashes","contentComputePromise","contentComputeWithoutOwnPromise","referencedHashes","hash","size","hashRegExp","RegExp","keys","join","Promise","all","map","asset","Buffer","isBuffer","etag","mergeEtags","getLazyHashedEtag","providePromise","inContent","match","has","getDependencies","referencingAssets","filter","err","a","exec","errors","hashInfo","hashesInOrder","stack","deps","dep","Error","delete","hashToNewHash","getEtag","computeNewContent","some","identifier","newContent","computeNewContentWithoutOwn","comparator","oldHash","sort","assetsContent","buffer","newHash","call","outputOptions","hashSalt","update","digest","slice","length","newName","infoUpdate","updateAsset","renameAsset","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/RealContentHashPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource, CachedSource, CompatSource } = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst { compareSelect, compareStrings } = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\nconst EMPTY_SET = new Set();\n\nconst addToList = (itemOrItems, list) => {\n\tif (Array.isArray(itemOrItems)) {\n\t\tfor (const item of itemOrItems) {\n\t\t\tlist.add(item);\n\t\t}\n\t} else if (itemOrItems) {\n\t\tlist.add(itemOrItems);\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n\t// Buffer.equals compares size first so this should be efficient enough\n\t// If it becomes a performance problem we can use a map and group by size\n\t// instead of looping over all assets.\n\tconst result = [];\n\touter: for (const value of input) {\n\t\tconst buf = fn(value);\n\t\tfor (const other of result) {\n\t\t\tif (buf.equals(other)) continue outer;\n\t\t}\n\t\tresult.push(buf);\n\t}\n\treturn result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\nconst toCachedSource = source => {\n\tif (source instanceof CachedSource) {\n\t\treturn source;\n\t}\n\tconst entry = cachedSourceMap.get(source);\n\tif (entry !== undefined) return entry;\n\tconst newSource = new CachedSource(CompatSource.from(source));\n\tcachedSourceMap.set(source, newSource);\n\treturn newSource;\n};\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\tupdateHash: new SyncBailHook([\"content\", \"oldHash\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\t/**\n\t * @param {Object} options options object\n\t * @param {string | Hash} options.hashFunction the hash function to use\n\t * @param {string} options.hashDigest the hash digest to use\n\t */\n\tconstructor({ hashFunction, hashDigest }) {\n\t\tthis._hashFunction = hashFunction;\n\t\tthis._hashDigest = hashDigest;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n\t\t\tconst cacheAnalyse = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|analyse\"\n\t\t\t);\n\t\t\tconst cacheGenerate = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|generate\"\n\t\t\t);\n\t\t\tconst hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n\t\t\tcompilation.hooks.processAssets.tapPromise(\n\t\t\t\t{\n\t\t\t\t\tname: \"RealContentHashPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n\t\t\t\t},\n\t\t\t\tasync () => {\n\t\t\t\t\tconst assets = compilation.getAssets();\n\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\n\t\t\t\t\tconst assetsWithInfo = [];\n\t\t\t\t\tconst hashToAssets = new Map();\n\t\t\t\t\tfor (const { source, info, name } of assets) {\n\t\t\t\t\t\tconst cachedSource = toCachedSource(source);\n\t\t\t\t\t\tconst content = cachedSource.source();\n\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\taddToList(info.contenthash, hashes);\n\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\tsource: cachedSource,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSource: undefined,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSourceWithoutOwn: undefined,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\townHashes: undefined,\n\t\t\t\t\t\t\tcontentComputePromise: undefined,\n\t\t\t\t\t\t\tcontentComputeWithoutOwnPromise: undefined,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\treferencedHashes: undefined,\n\t\t\t\t\t\t\thashes\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassetsWithInfo.push(data);\n\t\t\t\t\t\tfor (const hash of hashes) {\n\t\t\t\t\t\t\tconst list = hashToAssets.get(hash);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\thashToAssets.set(hash, [data]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.push(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hashToAssets.size === 0) return;\n\t\t\t\t\tconst hashRegExp = new RegExp(\n\t\t\t\t\t\tArray.from(hashToAssets.keys(), quoteMeta).join(\"|\"),\n\t\t\t\t\t\t\"g\"\n\t\t\t\t\t);\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tconst { name, source, content, hashes } = asset;\n\t\t\t\t\t\t\tif (Buffer.isBuffer(content)) {\n\t\t\t\t\t\t\t\tasset.referencedHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\tasset.ownHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst etag = cacheAnalyse.mergeEtags(\n\t\t\t\t\t\t\t\tcacheAnalyse.getLazyHashedEtag(source),\n\t\t\t\t\t\t\t\tArray.from(hashes).join(\"|\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t[asset.referencedHashes, asset.ownHashes] =\n\t\t\t\t\t\t\t\tawait cacheAnalyse.providePromise(name, etag, () => {\n\t\t\t\t\t\t\t\t\tconst referencedHashes = new Set();\n\t\t\t\t\t\t\t\t\tlet ownHashes = new Set();\n\t\t\t\t\t\t\t\t\tconst inContent = content.match(hashRegExp);\n\t\t\t\t\t\t\t\t\tif (inContent) {\n\t\t\t\t\t\t\t\t\t\tfor (const hash of inContent) {\n\t\t\t\t\t\t\t\t\t\t\tif (hashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\townHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treferencedHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn [referencedHashes, ownHashes];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t\tconst getDependencies = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\tif (!assets) {\n\t\t\t\t\t\t\tconst referencingAssets = assetsWithInfo.filter(asset =>\n\t\t\t\t\t\t\t\tasset.referencedHashes.has(hash)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets\n\t.map(a => {\n\t\tconst match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(\n\t\t\ta.content\n\t\t);\n\t\treturn ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n\t})\n\t.join(\"\\n\")}`);\n\t\t\t\t\t\t\tcompilation.errors.push(err);\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\tfor (const { referencedHashes, ownHashes } of assets) {\n\t\t\t\t\t\t\tif (!ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\tfor (const hash of ownHashes) {\n\t\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const hash of referencedHashes) {\n\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn hashes;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashInfo = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\treturn `${hash} (${Array.from(assets, a => a.name)})`;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashesInOrder = new Set();\n\t\t\t\t\tfor (const hash of hashToAssets.keys()) {\n\t\t\t\t\t\tconst add = (hash, stack) => {\n\t\t\t\t\t\t\tconst deps = getDependencies(hash);\n\t\t\t\t\t\t\tif (!deps) return;\n\t\t\t\t\t\t\tstack.add(hash);\n\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\tif (hashesInOrder.has(dep)) continue;\n\t\t\t\t\t\t\t\tif (stack.has(dep)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Circular hash dependency ${Array.from(\n\t\t\t\t\t\t\t\t\t\t\tstack,\n\t\t\t\t\t\t\t\t\t\t\thashInfo\n\t\t\t\t\t\t\t\t\t\t).join(\" -> \")} -> ${hashInfo(dep)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd(dep, stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thashesInOrder.add(hash);\n\t\t\t\t\t\t\tstack.delete(hash);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (hashesInOrder.has(hash)) continue;\n\t\t\t\t\t\tadd(hash, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tconst hashToNewHash = new Map();\n\t\t\t\t\tconst getEtag = asset =>\n\t\t\t\t\t\tcacheGenerate.mergeEtags(\n\t\t\t\t\t\t\tcacheGenerate.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\tArray.from(asset.referencedHashes, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t).join(\"|\")\n\t\t\t\t\t\t);\n\t\t\t\t\tconst computeNewContent = asset => {\n\t\t\t\t\t\tif (asset.contentComputePromise) return asset.contentComputePromise;\n\t\t\t\t\t\treturn (asset.contentComputePromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name;\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSource = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst computeNewContentWithoutOwn = asset => {\n\t\t\t\t\t\tif (asset.contentComputeWithoutOwnPromise)\n\t\t\t\t\t\t\treturn asset.contentComputeWithoutOwnPromise;\n\t\t\t\t\t\treturn (asset.contentComputeWithoutOwnPromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name + \"|without-own\";\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSourceWithoutOwn = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(\n\t\t\t\t\t\t\t\t\t\t\thashRegExp,\n\t\t\t\t\t\t\t\t\t\t\thash => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (asset.ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn hashToNewHash.get(hash);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst comparator = compareSelect(a => a.name, compareStrings);\n\t\t\t\t\tfor (const oldHash of hashesInOrder) {\n\t\t\t\t\t\tconst assets = hashToAssets.get(oldHash);\n\t\t\t\t\t\tassets.sort(comparator);\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tassets.map(asset =>\n\t\t\t\t\t\t\t\tasset.ownHashes.has(oldHash)\n\t\t\t\t\t\t\t\t\t? computeNewContentWithoutOwn(asset)\n\t\t\t\t\t\t\t\t\t: computeNewContent(asset)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n\t\t\t\t\t\t\tif (asset.ownHashes.has(oldHash)) {\n\t\t\t\t\t\t\t\treturn asset.newSourceWithoutOwn\n\t\t\t\t\t\t\t\t\t? asset.newSourceWithoutOwn.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn asset.newSource\n\t\t\t\t\t\t\t\t\t? asset.newSource.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet newHash = hooks.updateHash.call(assetsContent, oldHash);\n\t\t\t\t\t\tif (!newHash) {\n\t\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\t\t\t\tif (compilation.outputOptions.hashSalt) {\n\t\t\t\t\t\t\t\thash.update(compilation.outputOptions.hashSalt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const content of assetsContent) {\n\t\t\t\t\t\t\t\thash.update(content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst digest = hash.digest(this._hashDigest);\n\t\t\t\t\t\t\tnewHash = /** @type {string} */ (digest.slice(0, oldHash.length));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashToNewHash.set(oldHash, newHash);\n\t\t\t\t\t}\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tawait computeNewContent(asset);\n\t\t\t\t\t\t\tconst newName = asset.name.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst infoUpdate = {};\n\t\t\t\t\t\t\tconst hash = asset.info.contenthash;\n\t\t\t\t\t\t\tinfoUpdate.contenthash = Array.isArray(hash)\n\t\t\t\t\t\t\t\t? hash.map(hash => hashToNewHash.get(hash))\n\t\t\t\t\t\t\t\t: hashToNewHash.get(hash);\n\n\t\t\t\t\t\t\tif (asset.newSource !== undefined) {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\tasset.name,\n\t\t\t\t\t\t\t\t\tasset.newSource,\n\t\t\t\t\t\t\t\t\tinfoUpdate\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(asset.name, asset.source, infoUpdate);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (asset.name !== newName) {\n\t\t\t\t\t\t\t\tcompilation.renameAsset(asset.name, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = RealContentHashPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}