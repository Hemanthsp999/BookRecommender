{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst nextTick = require(\"process\").nextTick;\n\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\n/** @typedef {any} BaseFileSystem */\n\n/**\n * @template T\n * @typedef {import(\"./Resolver\").FileSystemCallback<T>} FileSystemCallback<T>\n */\n\n/**\n * @param {string} path path\n * @returns {string} dirname\n */\nconst dirname = path => {\n  let idx = path.length - 1;\n  while (idx >= 0) {\n    const c = path.charCodeAt(idx);\n    // slash or backslash\n    if (c === 47 || c === 92) break;\n    idx--;\n  }\n  if (idx < 0) return \"\";\n  return path.slice(0, idx);\n};\n\n/**\n * @template T\n * @param {FileSystemCallback<T>[]} callbacks callbacks\n * @param {Error | undefined} err error\n * @param {T} result result\n */\nconst runCallbacks = (callbacks, err, result) => {\n  if (callbacks.length === 1) {\n    callbacks[0](err, result);\n    callbacks.length = 0;\n    return;\n  }\n  let error;\n  for (const callback of callbacks) {\n    try {\n      callback(err, result);\n    } catch (e) {\n      if (!error) error = e;\n    }\n  }\n  callbacks.length = 0;\n  if (error) throw error;\n};\nclass OperationMergerBackend {\n  /**\n   * @param {function} provider async method in filesystem\n   * @param {function} syncProvider sync method in filesystem\n   * @param {BaseFileSystem} providerContext call context for the provider methods\n   */\n  constructor(provider, syncProvider, providerContext) {\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    this._activeAsyncOperations = new Map();\n    this.provide = this._provider ?\n    /**\n     * @param {string} path path\n     * @param {any} options options\n     * @param {function} callback callback\n     * @returns {any} result\n     */\n    (path, options, callback) => {\n      if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n      }\n      if (options) {\n        return this._provider.call(this._providerContext, path, options, callback);\n      }\n      if (typeof path !== \"string\") {\n        callback(new TypeError(\"path must be a string\"));\n        return;\n      }\n      let callbacks = this._activeAsyncOperations.get(path);\n      if (callbacks) {\n        callbacks.push(callback);\n        return;\n      }\n      this._activeAsyncOperations.set(path, callbacks = [callback]);\n      provider(path,\n      /**\n       * @param {Error} err error\n       * @param {any} result result\n       */\n      (err, result) => {\n        this._activeAsyncOperations.delete(path);\n        runCallbacks(callbacks, err, result);\n      });\n    } : null;\n    this.provideSync = this._syncProvider ?\n    /**\n     * @param {string} path path\n     * @param {any} options options\n     * @returns {any} result\n     */\n    (path, options) => {\n      return this._syncProvider.call(this._providerContext, path, options);\n    } : null;\n  }\n  purge() {}\n  purgeParent() {}\n}\n\n/*\n\nIDLE:\n\tinsert data: goto SYNC\n\nSYNC:\n\tbefore provide: run ticks\n\tevent loop tick: goto ASYNC_ACTIVE\n\nASYNC:\n\ttimeout: run tick, goto ASYNC_PASSIVE\n\nASYNC_PASSIVE:\n\tbefore provide: run ticks\n\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\n                                                          ^                             |\n                                                          +---------[insert data]-------+\n*/\n\nconst STORAGE_MODE_IDLE = 0;\nconst STORAGE_MODE_SYNC = 1;\nconst STORAGE_MODE_ASYNC = 2;\nclass CacheBackend {\n  /**\n   * @param {number} duration max cache duration of items\n   * @param {function} provider async method\n   * @param {function} syncProvider sync method\n   * @param {BaseFileSystem} providerContext call context for the provider methods\n   */\n  constructor(duration, provider, syncProvider, providerContext) {\n    this._duration = duration;\n    this._provider = provider;\n    this._syncProvider = syncProvider;\n    this._providerContext = providerContext;\n    /** @type {Map<string, FileSystemCallback<any>[]>} */\n    this._activeAsyncOperations = new Map();\n    /** @type {Map<string, { err?: Error, result?: any, level: Set<string> }>} */\n    this._data = new Map();\n    /** @type {Set<string>[]} */\n    this._levels = [];\n    for (let i = 0; i < 10; i++) this._levels.push(new Set());\n    for (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\n    this._currentLevel = 0;\n    this._tickInterval = Math.floor(duration / this._levels.length);\n    /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\n    this._mode = STORAGE_MODE_IDLE;\n\n    /** @type {NodeJS.Timeout | undefined} */\n    this._timeout = undefined;\n    /** @type {number | undefined} */\n    this._nextDecay = undefined;\n\n    // @ts-ignore\n    this.provide = provider ? this.provide.bind(this) : null;\n    // @ts-ignore\n    this.provideSync = syncProvider ? this.provideSync.bind(this) : null;\n  }\n\n  /**\n   * @param {string} path path\n   * @param {any} options options\n   * @param {FileSystemCallback<any>} callback callback\n   * @returns {void}\n   */\n  provide(path, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = undefined;\n    }\n    if (typeof path !== \"string\") {\n      callback(new TypeError(\"path must be a string\"));\n      return;\n    }\n    if (options) {\n      return this._provider.call(this._providerContext, path, options, callback);\n    }\n\n    // When in sync mode we can move to async mode\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._enterAsyncMode();\n    }\n\n    // Check in cache\n    let cacheEntry = this._data.get(path);\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) return nextTick(callback, cacheEntry.err);\n      return nextTick(callback, null, cacheEntry.result);\n    }\n\n    // Check if there is already the same operation running\n    let callbacks = this._activeAsyncOperations.get(path);\n    if (callbacks !== undefined) {\n      callbacks.push(callback);\n      return;\n    }\n    this._activeAsyncOperations.set(path, callbacks = [callback]);\n\n    // Run the operation\n    this._provider.call(this._providerContext, path,\n    /**\n     * @param {Error} [err] error\n     * @param {any} [result] result\n     */\n    (err, result) => {\n      this._activeAsyncOperations.delete(path);\n      this._storeResult(path, err, result);\n\n      // Enter async mode if not yet done\n      this._enterAsyncMode();\n      runCallbacks( /** @type {FileSystemCallback<any>[]} */callbacks, err, result);\n    });\n  }\n\n  /**\n   * @param {string} path path\n   * @param {any} options options\n   * @returns {any} result\n   */\n  provideSync(path, options) {\n    if (typeof path !== \"string\") {\n      throw new TypeError(\"path must be a string\");\n    }\n    if (options) {\n      return this._syncProvider.call(this._providerContext, path, options);\n    }\n\n    // In sync mode we may have to decay some cache items\n    if (this._mode === STORAGE_MODE_SYNC) {\n      this._runDecays();\n    }\n\n    // Check in cache\n    let cacheEntry = this._data.get(path);\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.err) throw cacheEntry.err;\n      return cacheEntry.result;\n    }\n\n    // Get all active async operations\n    // This sync operation will also complete them\n    const callbacks = this._activeAsyncOperations.get(path);\n    this._activeAsyncOperations.delete(path);\n\n    // Run the operation\n    // When in idle mode, we will enter sync mode\n    let result;\n    try {\n      result = this._syncProvider.call(this._providerContext, path);\n    } catch (err) {\n      this._storeResult(path, /** @type {Error} */err, undefined);\n      this._enterSyncModeWhenIdle();\n      if (callbacks) {\n        runCallbacks(callbacks, /** @type {Error} */err, undefined);\n      }\n      throw err;\n    }\n    this._storeResult(path, undefined, result);\n    this._enterSyncModeWhenIdle();\n    if (callbacks) {\n      runCallbacks(callbacks, undefined, result);\n    }\n    return result;\n  }\n\n  /**\n   * @param {string|string[]|Set<string>} [what] what to purge\n   */\n  purge(what) {\n    if (!what) {\n      if (this._mode !== STORAGE_MODE_IDLE) {\n        this._data.clear();\n        for (const level of this._levels) {\n          level.clear();\n        }\n        this._enterIdleMode();\n      }\n    } else if (typeof what === \"string\") {\n      for (let [key, data] of this._data) {\n        if (key.startsWith(what)) {\n          this._data.delete(key);\n          data.level.delete(key);\n        }\n      }\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    } else {\n      for (let [key, data] of this._data) {\n        for (const item of what) {\n          if (key.startsWith(item)) {\n            this._data.delete(key);\n            data.level.delete(key);\n            break;\n          }\n        }\n      }\n      if (this._data.size === 0) {\n        this._enterIdleMode();\n      }\n    }\n  }\n\n  /**\n   * @param {string|string[]|Set<string>} [what] what to purge\n   */\n  purgeParent(what) {\n    if (!what) {\n      this.purge();\n    } else if (typeof what === \"string\") {\n      this.purge(dirname(what));\n    } else {\n      const set = new Set();\n      for (const item of what) {\n        set.add(dirname(item));\n      }\n      this.purge(set);\n    }\n  }\n\n  /**\n   * @param {string} path path\n   * @param {undefined | Error} err error\n   * @param {any} result result\n   */\n  _storeResult(path, err, result) {\n    if (this._data.has(path)) return;\n    const level = this._levels[this._currentLevel];\n    this._data.set(path, {\n      err,\n      result,\n      level\n    });\n    level.add(path);\n  }\n  _decayLevel() {\n    const nextLevel = (this._currentLevel + 1) % this._levels.length;\n    const decay = this._levels[nextLevel];\n    this._currentLevel = nextLevel;\n    for (let item of decay) {\n      this._data.delete(item);\n    }\n    decay.clear();\n    if (this._data.size === 0) {\n      this._enterIdleMode();\n    } else {\n      /** @type {number} */\n      this._nextDecay += this._tickInterval;\n    }\n  }\n  _runDecays() {\n    while ( /** @type {number} */this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE) {\n      this._decayLevel();\n    }\n  }\n  _enterAsyncMode() {\n    let timeout = 0;\n    switch (this._mode) {\n      case STORAGE_MODE_ASYNC:\n        return;\n      case STORAGE_MODE_IDLE:\n        this._nextDecay = Date.now() + this._tickInterval;\n        timeout = this._tickInterval;\n        break;\n      case STORAGE_MODE_SYNC:\n        this._runDecays();\n        // _runDecays may change the mode\n        if ( /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC}*/\n        this._mode === STORAGE_MODE_IDLE) return;\n        timeout = Math.max(0, /** @type {number} */this._nextDecay - Date.now());\n        break;\n    }\n    this._mode = STORAGE_MODE_ASYNC;\n    const ref = setTimeout(() => {\n      this._mode = STORAGE_MODE_SYNC;\n      this._runDecays();\n    }, timeout);\n    if (ref.unref) ref.unref();\n    this._timeout = ref;\n  }\n  _enterSyncModeWhenIdle() {\n    if (this._mode === STORAGE_MODE_IDLE) {\n      this._mode = STORAGE_MODE_SYNC;\n      this._nextDecay = Date.now() + this._tickInterval;\n    }\n  }\n  _enterIdleMode() {\n    this._mode = STORAGE_MODE_IDLE;\n    this._nextDecay = undefined;\n    if (this._timeout) clearTimeout(this._timeout);\n  }\n}\n\n/**\n * @template {function} Provider\n * @template {function} AsyncProvider\n * @template FileSystem\n * @param {number} duration duration in ms files are cached\n * @param {Provider} provider provider\n * @param {AsyncProvider} syncProvider sync provider\n * @param {FileSystem} providerContext provider context\n * @returns {OperationMergerBackend | CacheBackend} backend\n */\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\n  if (duration > 0) {\n    return new CacheBackend(duration, provider, syncProvider, providerContext);\n  }\n  return new OperationMergerBackend(provider, syncProvider, providerContext);\n};\nmodule.exports = class CachedInputFileSystem {\n  /**\n   * @param {BaseFileSystem} fileSystem file system\n   * @param {number} duration duration in ms files are cached\n   */\n  constructor(fileSystem, duration) {\n    this.fileSystem = fileSystem;\n    this._lstatBackend = createBackend(duration, this.fileSystem.lstat, this.fileSystem.lstatSync, this.fileSystem);\n    const lstat = this._lstatBackend.provide;\n    this.lstat = /** @type {FileSystem[\"lstat\"]} */lstat;\n    const lstatSync = this._lstatBackend.provideSync;\n    this.lstatSync = /** @type {SyncFileSystem[\"lstatSync\"]} */lstatSync;\n    this._statBackend = createBackend(duration, this.fileSystem.stat, this.fileSystem.statSync, this.fileSystem);\n    const stat = this._statBackend.provide;\n    this.stat = /** @type {FileSystem[\"stat\"]} */stat;\n    const statSync = this._statBackend.provideSync;\n    this.statSync = /** @type {SyncFileSystem[\"statSync\"]} */statSync;\n    this._readdirBackend = createBackend(duration, this.fileSystem.readdir, this.fileSystem.readdirSync, this.fileSystem);\n    const readdir = this._readdirBackend.provide;\n    this.readdir = /** @type {FileSystem[\"readdir\"]} */readdir;\n    const readdirSync = this._readdirBackend.provideSync;\n    this.readdirSync = /** @type {SyncFileSystem[\"readdirSync\"]} */\n    readdirSync;\n    this._readFileBackend = createBackend(duration, this.fileSystem.readFile, this.fileSystem.readFileSync, this.fileSystem);\n    const readFile = this._readFileBackend.provide;\n    this.readFile = /** @type {FileSystem[\"readFile\"]} */readFile;\n    const readFileSync = this._readFileBackend.provideSync;\n    this.readFileSync = /** @type {SyncFileSystem[\"readFileSync\"]} */\n    readFileSync;\n    this._readJsonBackend = createBackend(duration,\n    // prettier-ignore\n    this.fileSystem.readJson || this.readFile && (\n    /**\n     * @param {string} path path\n     * @param {FileSystemCallback<any>} callback\n     */\n    (path, callback) => {\n      this.readFile(path, (err, buffer) => {\n        if (err) return callback(err);\n        if (!buffer || buffer.length === 0) return callback(new Error(\"No file content\"));\n        let data;\n        try {\n          data = JSON.parse(buffer.toString(\"utf-8\"));\n        } catch (e) {\n          return callback( /** @type {Error} */e);\n        }\n        callback(null, data);\n      });\n    }),\n    // prettier-ignore\n    this.fileSystem.readJsonSync || this.readFileSync && (\n    /**\n     * @param {string} path path\n     * @returns {any} result\n     */\n    path => {\n      const buffer = this.readFileSync(path);\n      const data = JSON.parse(buffer.toString(\"utf-8\"));\n      return data;\n    }), this.fileSystem);\n    const readJson = this._readJsonBackend.provide;\n    this.readJson = /** @type {FileSystem[\"readJson\"]} */readJson;\n    const readJsonSync = this._readJsonBackend.provideSync;\n    this.readJsonSync = /** @type {SyncFileSystem[\"readJsonSync\"]} */\n    readJsonSync;\n    this._readlinkBackend = createBackend(duration, this.fileSystem.readlink, this.fileSystem.readlinkSync, this.fileSystem);\n    const readlink = this._readlinkBackend.provide;\n    this.readlink = /** @type {FileSystem[\"readlink\"]} */readlink;\n    const readlinkSync = this._readlinkBackend.provideSync;\n    this.readlinkSync = /** @type {SyncFileSystem[\"readlinkSync\"]} */\n    readlinkSync;\n  }\n\n  /**\n   * @param {string|string[]|Set<string>} [what] what to purge\n   */\n  purge(what) {\n    this._statBackend.purge(what);\n    this._lstatBackend.purge(what);\n    this._readdirBackend.purgeParent(what);\n    this._readFileBackend.purge(what);\n    this._readlinkBackend.purge(what);\n    this._readJsonBackend.purge(what);\n  }\n};","map":{"version":3,"names":["nextTick","require","dirname","path","idx","length","c","charCodeAt","slice","runCallbacks","callbacks","err","result","error","callback","e","OperationMergerBackend","constructor","provider","syncProvider","providerContext","_provider","_syncProvider","_providerContext","_activeAsyncOperations","Map","provide","options","undefined","call","TypeError","get","push","set","delete","provideSync","purge","purgeParent","STORAGE_MODE_IDLE","STORAGE_MODE_SYNC","STORAGE_MODE_ASYNC","CacheBackend","duration","_duration","_data","_levels","i","Set","_currentLevel","_tickInterval","Math","floor","_mode","_timeout","_nextDecay","bind","_enterAsyncMode","cacheEntry","_storeResult","_runDecays","_enterSyncModeWhenIdle","what","clear","level","_enterIdleMode","key","data","startsWith","size","item","add","has","_decayLevel","nextLevel","decay","Date","now","timeout","max","ref","setTimeout","unref","clearTimeout","createBackend","module","exports","CachedInputFileSystem","fileSystem","_lstatBackend","lstat","lstatSync","_statBackend","stat","statSync","_readdirBackend","readdir","readdirSync","_readFileBackend","readFile","readFileSync","_readJsonBackend","readJson","buffer","Error","JSON","parse","toString","readJsonSync","_readlinkBackend","readlink","readlinkSync"],"sources":["/home/hemanth/react-project/client/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst nextTick = require(\"process\").nextTick;\n\n/** @typedef {import(\"./Resolver\").FileSystem} FileSystem */\n/** @typedef {import(\"./Resolver\").SyncFileSystem} SyncFileSystem */\n/** @typedef {any} BaseFileSystem */\n\n/**\n * @template T\n * @typedef {import(\"./Resolver\").FileSystemCallback<T>} FileSystemCallback<T>\n */\n\n/**\n * @param {string} path path\n * @returns {string} dirname\n */\nconst dirname = path => {\n\tlet idx = path.length - 1;\n\twhile (idx >= 0) {\n\t\tconst c = path.charCodeAt(idx);\n\t\t// slash or backslash\n\t\tif (c === 47 || c === 92) break;\n\t\tidx--;\n\t}\n\tif (idx < 0) return \"\";\n\treturn path.slice(0, idx);\n};\n\n/**\n * @template T\n * @param {FileSystemCallback<T>[]} callbacks callbacks\n * @param {Error | undefined} err error\n * @param {T} result result\n */\nconst runCallbacks = (callbacks, err, result) => {\n\tif (callbacks.length === 1) {\n\t\tcallbacks[0](err, result);\n\t\tcallbacks.length = 0;\n\t\treturn;\n\t}\n\tlet error;\n\tfor (const callback of callbacks) {\n\t\ttry {\n\t\t\tcallback(err, result);\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t}\n\tcallbacks.length = 0;\n\tif (error) throw error;\n};\n\nclass OperationMergerBackend {\n\t/**\n\t * @param {function} provider async method in filesystem\n\t * @param {function} syncProvider sync method in filesystem\n\t * @param {BaseFileSystem} providerContext call context for the provider methods\n\t */\n\tconstructor(provider, syncProvider, providerContext) {\n\t\tthis._provider = provider;\n\t\tthis._syncProvider = syncProvider;\n\t\tthis._providerContext = providerContext;\n\t\tthis._activeAsyncOperations = new Map();\n\n\t\tthis.provide = this._provider\n\t\t\t? /**\n\t\t\t   * @param {string} path path\n\t\t\t   * @param {any} options options\n\t\t\t   * @param {function} callback callback\n\t\t\t   * @returns {any} result\n\t\t\t   */\n\t\t\t  (path, options, callback) => {\n\t\t\t\t\tif (typeof options === \"function\") {\n\t\t\t\t\t\tcallback = options;\n\t\t\t\t\t\toptions = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (options) {\n\t\t\t\t\t\treturn this._provider.call(\n\t\t\t\t\t\t\tthis._providerContext,\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof path !== \"string\") {\n\t\t\t\t\t\tcallback(new TypeError(\"path must be a string\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet callbacks = this._activeAsyncOperations.get(path);\n\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._activeAsyncOperations.set(path, (callbacks = [callback]));\n\t\t\t\t\tprovider(\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Error} err error\n\t\t\t\t\t\t * @param {any} result result\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tthis._activeAsyncOperations.delete(path);\n\t\t\t\t\t\t\trunCallbacks(callbacks, err, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t  }\n\t\t\t: null;\n\t\tthis.provideSync = this._syncProvider\n\t\t\t? /**\n\t\t\t   * @param {string} path path\n\t\t\t   * @param {any} options options\n\t\t\t   * @returns {any} result\n\t\t\t   */\n\t\t\t  (path, options) => {\n\t\t\t\t\treturn this._syncProvider.call(this._providerContext, path, options);\n\t\t\t  }\n\t\t\t: null;\n\t}\n\n\tpurge() {}\n\tpurgeParent() {}\n}\n\n/*\n\nIDLE:\n\tinsert data: goto SYNC\n\nSYNC:\n\tbefore provide: run ticks\n\tevent loop tick: goto ASYNC_ACTIVE\n\nASYNC:\n\ttimeout: run tick, goto ASYNC_PASSIVE\n\nASYNC_PASSIVE:\n\tbefore provide: run ticks\n\nIDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE\n                                                          ^                             |\n                                                          +---------[insert data]-------+\n*/\n\nconst STORAGE_MODE_IDLE = 0;\nconst STORAGE_MODE_SYNC = 1;\nconst STORAGE_MODE_ASYNC = 2;\n\nclass CacheBackend {\n\t/**\n\t * @param {number} duration max cache duration of items\n\t * @param {function} provider async method\n\t * @param {function} syncProvider sync method\n\t * @param {BaseFileSystem} providerContext call context for the provider methods\n\t */\n\tconstructor(duration, provider, syncProvider, providerContext) {\n\t\tthis._duration = duration;\n\t\tthis._provider = provider;\n\t\tthis._syncProvider = syncProvider;\n\t\tthis._providerContext = providerContext;\n\t\t/** @type {Map<string, FileSystemCallback<any>[]>} */\n\t\tthis._activeAsyncOperations = new Map();\n\t\t/** @type {Map<string, { err?: Error, result?: any, level: Set<string> }>} */\n\t\tthis._data = new Map();\n\t\t/** @type {Set<string>[]} */\n\t\tthis._levels = [];\n\t\tfor (let i = 0; i < 10; i++) this._levels.push(new Set());\n\t\tfor (let i = 5000; i < duration; i += 500) this._levels.push(new Set());\n\t\tthis._currentLevel = 0;\n\t\tthis._tickInterval = Math.floor(duration / this._levels.length);\n\t\t/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */\n\t\tthis._mode = STORAGE_MODE_IDLE;\n\n\t\t/** @type {NodeJS.Timeout | undefined} */\n\t\tthis._timeout = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis._nextDecay = undefined;\n\n\t\t// @ts-ignore\n\t\tthis.provide = provider ? this.provide.bind(this) : null;\n\t\t// @ts-ignore\n\t\tthis.provideSync = syncProvider ? this.provideSync.bind(this) : null;\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {any} options options\n\t * @param {FileSystemCallback<any>} callback callback\n\t * @returns {void}\n\t */\n\tprovide(path, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = undefined;\n\t\t}\n\t\tif (typeof path !== \"string\") {\n\t\t\tcallback(new TypeError(\"path must be a string\"));\n\t\t\treturn;\n\t\t}\n\t\tif (options) {\n\t\t\treturn this._provider.call(\n\t\t\t\tthis._providerContext,\n\t\t\t\tpath,\n\t\t\t\toptions,\n\t\t\t\tcallback\n\t\t\t);\n\t\t}\n\n\t\t// When in sync mode we can move to async mode\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\n\t\t\tthis._enterAsyncMode();\n\t\t}\n\n\t\t// Check in cache\n\t\tlet cacheEntry = this._data.get(path);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.err) return nextTick(callback, cacheEntry.err);\n\t\t\treturn nextTick(callback, null, cacheEntry.result);\n\t\t}\n\n\t\t// Check if there is already the same operation running\n\t\tlet callbacks = this._activeAsyncOperations.get(path);\n\t\tif (callbacks !== undefined) {\n\t\t\tcallbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tthis._activeAsyncOperations.set(path, (callbacks = [callback]));\n\n\t\t// Run the operation\n\t\tthis._provider.call(\n\t\t\tthis._providerContext,\n\t\t\tpath,\n\t\t\t/**\n\t\t\t * @param {Error} [err] error\n\t\t\t * @param {any} [result] result\n\t\t\t */\n\t\t\t(err, result) => {\n\t\t\t\tthis._activeAsyncOperations.delete(path);\n\t\t\t\tthis._storeResult(path, err, result);\n\n\t\t\t\t// Enter async mode if not yet done\n\t\t\t\tthis._enterAsyncMode();\n\n\t\t\t\trunCallbacks(\n\t\t\t\t\t/** @type {FileSystemCallback<any>[]} */ (callbacks),\n\t\t\t\t\terr,\n\t\t\t\t\tresult\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {any} options options\n\t * @returns {any} result\n\t */\n\tprovideSync(path, options) {\n\t\tif (typeof path !== \"string\") {\n\t\t\tthrow new TypeError(\"path must be a string\");\n\t\t}\n\t\tif (options) {\n\t\t\treturn this._syncProvider.call(this._providerContext, path, options);\n\t\t}\n\n\t\t// In sync mode we may have to decay some cache items\n\t\tif (this._mode === STORAGE_MODE_SYNC) {\n\t\t\tthis._runDecays();\n\t\t}\n\n\t\t// Check in cache\n\t\tlet cacheEntry = this._data.get(path);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.err) throw cacheEntry.err;\n\t\t\treturn cacheEntry.result;\n\t\t}\n\n\t\t// Get all active async operations\n\t\t// This sync operation will also complete them\n\t\tconst callbacks = this._activeAsyncOperations.get(path);\n\t\tthis._activeAsyncOperations.delete(path);\n\n\t\t// Run the operation\n\t\t// When in idle mode, we will enter sync mode\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = this._syncProvider.call(this._providerContext, path);\n\t\t} catch (err) {\n\t\t\tthis._storeResult(path, /** @type {Error} */ (err), undefined);\n\t\t\tthis._enterSyncModeWhenIdle();\n\t\t\tif (callbacks) {\n\t\t\t\trunCallbacks(callbacks, /** @type {Error} */ (err), undefined);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t\tthis._storeResult(path, undefined, result);\n\t\tthis._enterSyncModeWhenIdle();\n\t\tif (callbacks) {\n\t\t\trunCallbacks(callbacks, undefined, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {string|string[]|Set<string>} [what] what to purge\n\t */\n\tpurge(what) {\n\t\tif (!what) {\n\t\t\tif (this._mode !== STORAGE_MODE_IDLE) {\n\t\t\t\tthis._data.clear();\n\t\t\t\tfor (const level of this._levels) {\n\t\t\t\t\tlevel.clear();\n\t\t\t\t}\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t} else if (typeof what === \"string\") {\n\t\t\tfor (let [key, data] of this._data) {\n\t\t\t\tif (key.startsWith(what)) {\n\t\t\t\t\tthis._data.delete(key);\n\t\t\t\t\tdata.level.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._data.size === 0) {\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let [key, data] of this._data) {\n\t\t\t\tfor (const item of what) {\n\t\t\t\t\tif (key.startsWith(item)) {\n\t\t\t\t\t\tthis._data.delete(key);\n\t\t\t\t\t\tdata.level.delete(key);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._data.size === 0) {\n\t\t\t\tthis._enterIdleMode();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string|string[]|Set<string>} [what] what to purge\n\t */\n\tpurgeParent(what) {\n\t\tif (!what) {\n\t\t\tthis.purge();\n\t\t} else if (typeof what === \"string\") {\n\t\t\tthis.purge(dirname(what));\n\t\t} else {\n\t\t\tconst set = new Set();\n\t\t\tfor (const item of what) {\n\t\t\t\tset.add(dirname(item));\n\t\t\t}\n\t\t\tthis.purge(set);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {undefined | Error} err error\n\t * @param {any} result result\n\t */\n\t_storeResult(path, err, result) {\n\t\tif (this._data.has(path)) return;\n\t\tconst level = this._levels[this._currentLevel];\n\t\tthis._data.set(path, { err, result, level });\n\t\tlevel.add(path);\n\t}\n\n\t_decayLevel() {\n\t\tconst nextLevel = (this._currentLevel + 1) % this._levels.length;\n\t\tconst decay = this._levels[nextLevel];\n\t\tthis._currentLevel = nextLevel;\n\t\tfor (let item of decay) {\n\t\t\tthis._data.delete(item);\n\t\t}\n\t\tdecay.clear();\n\t\tif (this._data.size === 0) {\n\t\t\tthis._enterIdleMode();\n\t\t} else {\n\t\t\t/** @type {number} */\n\t\t\t(this._nextDecay) += this._tickInterval;\n\t\t}\n\t}\n\n\t_runDecays() {\n\t\twhile (\n\t\t\t/** @type {number} */ (this._nextDecay) <= Date.now() &&\n\t\t\tthis._mode !== STORAGE_MODE_IDLE\n\t\t) {\n\t\t\tthis._decayLevel();\n\t\t}\n\t}\n\n\t_enterAsyncMode() {\n\t\tlet timeout = 0;\n\t\tswitch (this._mode) {\n\t\t\tcase STORAGE_MODE_ASYNC:\n\t\t\t\treturn;\n\t\t\tcase STORAGE_MODE_IDLE:\n\t\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\n\t\t\t\ttimeout = this._tickInterval;\n\t\t\t\tbreak;\n\t\t\tcase STORAGE_MODE_SYNC:\n\t\t\t\tthis._runDecays();\n\t\t\t\t// _runDecays may change the mode\n\t\t\t\tif (\n\t\t\t\t\t/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC}*/\n\t\t\t\t\t(this._mode) === STORAGE_MODE_IDLE\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\ttimeout = Math.max(\n\t\t\t\t\t0,\n\t\t\t\t\t/** @type {number} */ (this._nextDecay) - Date.now()\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._mode = STORAGE_MODE_ASYNC;\n\t\tconst ref = setTimeout(() => {\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\n\t\t\tthis._runDecays();\n\t\t}, timeout);\n\t\tif (ref.unref) ref.unref();\n\t\tthis._timeout = ref;\n\t}\n\n\t_enterSyncModeWhenIdle() {\n\t\tif (this._mode === STORAGE_MODE_IDLE) {\n\t\t\tthis._mode = STORAGE_MODE_SYNC;\n\t\t\tthis._nextDecay = Date.now() + this._tickInterval;\n\t\t}\n\t}\n\n\t_enterIdleMode() {\n\t\tthis._mode = STORAGE_MODE_IDLE;\n\t\tthis._nextDecay = undefined;\n\t\tif (this._timeout) clearTimeout(this._timeout);\n\t}\n}\n\n/**\n * @template {function} Provider\n * @template {function} AsyncProvider\n * @template FileSystem\n * @param {number} duration duration in ms files are cached\n * @param {Provider} provider provider\n * @param {AsyncProvider} syncProvider sync provider\n * @param {FileSystem} providerContext provider context\n * @returns {OperationMergerBackend | CacheBackend} backend\n */\nconst createBackend = (duration, provider, syncProvider, providerContext) => {\n\tif (duration > 0) {\n\t\treturn new CacheBackend(duration, provider, syncProvider, providerContext);\n\t}\n\treturn new OperationMergerBackend(provider, syncProvider, providerContext);\n};\n\nmodule.exports = class CachedInputFileSystem {\n\t/**\n\t * @param {BaseFileSystem} fileSystem file system\n\t * @param {number} duration duration in ms files are cached\n\t */\n\tconstructor(fileSystem, duration) {\n\t\tthis.fileSystem = fileSystem;\n\n\t\tthis._lstatBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.lstat,\n\t\t\tthis.fileSystem.lstatSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst lstat = this._lstatBackend.provide;\n\t\tthis.lstat = /** @type {FileSystem[\"lstat\"]} */ (lstat);\n\t\tconst lstatSync = this._lstatBackend.provideSync;\n\t\tthis.lstatSync = /** @type {SyncFileSystem[\"lstatSync\"]} */ (lstatSync);\n\n\t\tthis._statBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.stat,\n\t\t\tthis.fileSystem.statSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst stat = this._statBackend.provide;\n\t\tthis.stat = /** @type {FileSystem[\"stat\"]} */ (stat);\n\t\tconst statSync = this._statBackend.provideSync;\n\t\tthis.statSync = /** @type {SyncFileSystem[\"statSync\"]} */ (statSync);\n\n\t\tthis._readdirBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readdir,\n\t\t\tthis.fileSystem.readdirSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readdir = this._readdirBackend.provide;\n\t\tthis.readdir = /** @type {FileSystem[\"readdir\"]} */ (readdir);\n\t\tconst readdirSync = this._readdirBackend.provideSync;\n\t\tthis.readdirSync = /** @type {SyncFileSystem[\"readdirSync\"]} */ (\n\t\t\treaddirSync\n\t\t);\n\n\t\tthis._readFileBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readFile,\n\t\t\tthis.fileSystem.readFileSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readFile = this._readFileBackend.provide;\n\t\tthis.readFile = /** @type {FileSystem[\"readFile\"]} */ (readFile);\n\t\tconst readFileSync = this._readFileBackend.provideSync;\n\t\tthis.readFileSync = /** @type {SyncFileSystem[\"readFileSync\"]} */ (\n\t\t\treadFileSync\n\t\t);\n\n\t\tthis._readJsonBackend = createBackend(\n\t\t\tduration,\n\t\t\t// prettier-ignore\n\t\t\tthis.fileSystem.readJson ||\n\t\t\t\t(this.readFile &&\n\t\t\t\t\t(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} path path\n\t\t\t\t\t\t * @param {FileSystemCallback<any>} callback\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(path, callback) => {\n\t\t\t\t\t\t\tthis.readFile(path, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tif (!buffer || buffer.length === 0)\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"No file content\"));\n\t\t\t\t\t\t\t\tlet data;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tdata = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\treturn callback(/** @type {Error} */ (e));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcallback(null, data);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t// prettier-ignore\n\t\t\tthis.fileSystem.readJsonSync ||\n\t\t\t\t(this.readFileSync &&\n\t\t\t\t\t(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} path path\n\t\t\t\t\t\t * @returns {any} result\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(path) => {\n\t\t\t\t\t\t\tconst buffer = this.readFileSync(path);\n\t\t\t\t\t\t\tconst data = JSON.parse(buffer.toString(\"utf-8\"));\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t}\n\t\t\t\t )),\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readJson = this._readJsonBackend.provide;\n\t\tthis.readJson = /** @type {FileSystem[\"readJson\"]} */ (readJson);\n\t\tconst readJsonSync = this._readJsonBackend.provideSync;\n\t\tthis.readJsonSync = /** @type {SyncFileSystem[\"readJsonSync\"]} */ (\n\t\t\treadJsonSync\n\t\t);\n\n\t\tthis._readlinkBackend = createBackend(\n\t\t\tduration,\n\t\t\tthis.fileSystem.readlink,\n\t\t\tthis.fileSystem.readlinkSync,\n\t\t\tthis.fileSystem\n\t\t);\n\t\tconst readlink = this._readlinkBackend.provide;\n\t\tthis.readlink = /** @type {FileSystem[\"readlink\"]} */ (readlink);\n\t\tconst readlinkSync = this._readlinkBackend.provideSync;\n\t\tthis.readlinkSync = /** @type {SyncFileSystem[\"readlinkSync\"]} */ (\n\t\t\treadlinkSync\n\t\t);\n\t}\n\n\t/**\n\t * @param {string|string[]|Set<string>} [what] what to purge\n\t */\n\tpurge(what) {\n\t\tthis._statBackend.purge(what);\n\t\tthis._lstatBackend.purge(what);\n\t\tthis._readdirBackend.purgeParent(what);\n\t\tthis._readFileBackend.purge(what);\n\t\tthis._readlinkBackend.purge(what);\n\t\tthis._readJsonBackend.purge(what);\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,SAAS,CAAC,CAACD,QAAQ;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAME,OAAO,GAAGC,IAAI,IAAI;EACvB,IAAIC,GAAG,GAAGD,IAAI,CAACE,MAAM,GAAG,CAAC;EACzB,OAAOD,GAAG,IAAI,CAAC,EAAE;IAChB,MAAME,CAAC,GAAGH,IAAI,CAACI,UAAU,CAACH,GAAG,CAAC;IAC9B;IACA,IAAIE,CAAC,KAAK,EAAE,IAAIA,CAAC,KAAK,EAAE,EAAE;IAC1BF,GAAG,EAAE;EACN;EACA,IAAIA,GAAG,GAAG,CAAC,EAAE,OAAO,EAAE;EACtB,OAAOD,IAAI,CAACK,KAAK,CAAC,CAAC,EAAEJ,GAAG,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,YAAY,GAAGA,CAACC,SAAS,EAAEC,GAAG,EAAEC,MAAM,KAAK;EAChD,IAAIF,SAAS,CAACL,MAAM,KAAK,CAAC,EAAE;IAC3BK,SAAS,CAAC,CAAC,CAAC,CAACC,GAAG,EAAEC,MAAM,CAAC;IACzBF,SAAS,CAACL,MAAM,GAAG,CAAC;IACpB;EACD;EACA,IAAIQ,KAAK;EACT,KAAK,MAAMC,QAAQ,IAAIJ,SAAS,EAAE;IACjC,IAAI;MACHI,QAAQ,CAACH,GAAG,EAAEC,MAAM,CAAC;IACtB,CAAC,CAAC,OAAOG,CAAC,EAAE;MACX,IAAI,CAACF,KAAK,EAAEA,KAAK,GAAGE,CAAC;IACtB;EACD;EACAL,SAAS,CAACL,MAAM,GAAG,CAAC;EACpB,IAAIQ,KAAK,EAAE,MAAMA,KAAK;AACvB,CAAC;AAED,MAAMG,sBAAsB,CAAC;EAC5B;AACD;AACA;AACA;AACA;EACCC,WAAWA,CAACC,QAAQ,EAAEC,YAAY,EAAEC,eAAe,EAAE;IACpD,IAAI,CAACC,SAAS,GAAGH,QAAQ;IACzB,IAAI,CAACI,aAAa,GAAGH,YAAY;IACjC,IAAI,CAACI,gBAAgB,GAAGH,eAAe;IACvC,IAAI,CAACI,sBAAsB,GAAG,IAAIC,GAAG,CAAC,CAAC;IAEvC,IAAI,CAACC,OAAO,GAAG,IAAI,CAACL,SAAS;IAC1B;AACL;AACA;AACA;AACA;AACA;IACK,CAAClB,IAAI,EAAEwB,OAAO,EAAEb,QAAQ,KAAK;MAC7B,IAAI,OAAOa,OAAO,KAAK,UAAU,EAAE;QAClCb,QAAQ,GAAGa,OAAO;QAClBA,OAAO,GAAGC,SAAS;MACpB;MACA,IAAID,OAAO,EAAE;QACZ,OAAO,IAAI,CAACN,SAAS,CAACQ,IAAI,CACzB,IAAI,CAACN,gBAAgB,EACrBpB,IAAI,EACJwB,OAAO,EACPb,QACD,CAAC;MACF;MACA,IAAI,OAAOX,IAAI,KAAK,QAAQ,EAAE;QAC7BW,QAAQ,CAAC,IAAIgB,SAAS,CAAC,uBAAuB,CAAC,CAAC;QAChD;MACD;MACA,IAAIpB,SAAS,GAAG,IAAI,CAACc,sBAAsB,CAACO,GAAG,CAAC5B,IAAI,CAAC;MACrD,IAAIO,SAAS,EAAE;QACdA,SAAS,CAACsB,IAAI,CAAClB,QAAQ,CAAC;QACxB;MACD;MACA,IAAI,CAACU,sBAAsB,CAACS,GAAG,CAAC9B,IAAI,EAAGO,SAAS,GAAG,CAACI,QAAQ,CAAE,CAAC;MAC/DI,QAAQ,CACPf,IAAI;MACJ;AACN;AACA;AACA;MACM,CAACQ,GAAG,EAAEC,MAAM,KAAK;QAChB,IAAI,CAACY,sBAAsB,CAACU,MAAM,CAAC/B,IAAI,CAAC;QACxCM,YAAY,CAACC,SAAS,EAAEC,GAAG,EAAEC,MAAM,CAAC;MACrC,CACD,CAAC;IACD,CAAC,GACD,IAAI;IACP,IAAI,CAACuB,WAAW,GAAG,IAAI,CAACb,aAAa;IAClC;AACL;AACA;AACA;AACA;IACK,CAACnB,IAAI,EAAEwB,OAAO,KAAK;MACnB,OAAO,IAAI,CAACL,aAAa,CAACO,IAAI,CAAC,IAAI,CAACN,gBAAgB,EAAEpB,IAAI,EAAEwB,OAAO,CAAC;IACpE,CAAC,GACD,IAAI;EACR;EAEAS,KAAKA,CAAA,EAAG,CAAC;EACTC,WAAWA,CAAA,EAAG,CAAC;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,iBAAiB,GAAG,CAAC;AAC3B,MAAMC,kBAAkB,GAAG,CAAC;AAE5B,MAAMC,YAAY,CAAC;EAClB;AACD;AACA;AACA;AACA;AACA;EACCxB,WAAWA,CAACyB,QAAQ,EAAExB,QAAQ,EAAEC,YAAY,EAAEC,eAAe,EAAE;IAC9D,IAAI,CAACuB,SAAS,GAAGD,QAAQ;IACzB,IAAI,CAACrB,SAAS,GAAGH,QAAQ;IACzB,IAAI,CAACI,aAAa,GAAGH,YAAY;IACjC,IAAI,CAACI,gBAAgB,GAAGH,eAAe;IACvC;IACA,IAAI,CAACI,sBAAsB,GAAG,IAAIC,GAAG,CAAC,CAAC;IACvC;IACA,IAAI,CAACmB,KAAK,GAAG,IAAInB,GAAG,CAAC,CAAC;IACtB;IACA,IAAI,CAACoB,OAAO,GAAG,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE,IAAI,CAACD,OAAO,CAACb,IAAI,CAAC,IAAIe,GAAG,CAAC,CAAC,CAAC;IACzD,KAAK,IAAID,CAAC,GAAG,IAAI,EAAEA,CAAC,GAAGJ,QAAQ,EAAEI,CAAC,IAAI,GAAG,EAAE,IAAI,CAACD,OAAO,CAACb,IAAI,CAAC,IAAIe,GAAG,CAAC,CAAC,CAAC;IACvE,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACT,QAAQ,GAAG,IAAI,CAACG,OAAO,CAACxC,MAAM,CAAC;IAC/D;IACA,IAAI,CAAC+C,KAAK,GAAGd,iBAAiB;;IAE9B;IACA,IAAI,CAACe,QAAQ,GAAGzB,SAAS;IACzB;IACA,IAAI,CAAC0B,UAAU,GAAG1B,SAAS;;IAE3B;IACA,IAAI,CAACF,OAAO,GAAGR,QAAQ,GAAG,IAAI,CAACQ,OAAO,CAAC6B,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI;IACxD;IACA,IAAI,CAACpB,WAAW,GAAGhB,YAAY,GAAG,IAAI,CAACgB,WAAW,CAACoB,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI;EACrE;;EAEA;AACD;AACA;AACA;AACA;AACA;EACC7B,OAAOA,CAACvB,IAAI,EAAEwB,OAAO,EAAEb,QAAQ,EAAE;IAChC,IAAI,OAAOa,OAAO,KAAK,UAAU,EAAE;MAClCb,QAAQ,GAAGa,OAAO;MAClBA,OAAO,GAAGC,SAAS;IACpB;IACA,IAAI,OAAOzB,IAAI,KAAK,QAAQ,EAAE;MAC7BW,QAAQ,CAAC,IAAIgB,SAAS,CAAC,uBAAuB,CAAC,CAAC;MAChD;IACD;IACA,IAAIH,OAAO,EAAE;MACZ,OAAO,IAAI,CAACN,SAAS,CAACQ,IAAI,CACzB,IAAI,CAACN,gBAAgB,EACrBpB,IAAI,EACJwB,OAAO,EACPb,QACD,CAAC;IACF;;IAEA;IACA,IAAI,IAAI,CAACsC,KAAK,KAAKb,iBAAiB,EAAE;MACrC,IAAI,CAACiB,eAAe,CAAC,CAAC;IACvB;;IAEA;IACA,IAAIC,UAAU,GAAG,IAAI,CAACb,KAAK,CAACb,GAAG,CAAC5B,IAAI,CAAC;IACrC,IAAIsD,UAAU,KAAK7B,SAAS,EAAE;MAC7B,IAAI6B,UAAU,CAAC9C,GAAG,EAAE,OAAOX,QAAQ,CAACc,QAAQ,EAAE2C,UAAU,CAAC9C,GAAG,CAAC;MAC7D,OAAOX,QAAQ,CAACc,QAAQ,EAAE,IAAI,EAAE2C,UAAU,CAAC7C,MAAM,CAAC;IACnD;;IAEA;IACA,IAAIF,SAAS,GAAG,IAAI,CAACc,sBAAsB,CAACO,GAAG,CAAC5B,IAAI,CAAC;IACrD,IAAIO,SAAS,KAAKkB,SAAS,EAAE;MAC5BlB,SAAS,CAACsB,IAAI,CAAClB,QAAQ,CAAC;MACxB;IACD;IACA,IAAI,CAACU,sBAAsB,CAACS,GAAG,CAAC9B,IAAI,EAAGO,SAAS,GAAG,CAACI,QAAQ,CAAE,CAAC;;IAE/D;IACA,IAAI,CAACO,SAAS,CAACQ,IAAI,CAClB,IAAI,CAACN,gBAAgB,EACrBpB,IAAI;IACJ;AACH;AACA;AACA;IACG,CAACQ,GAAG,EAAEC,MAAM,KAAK;MAChB,IAAI,CAACY,sBAAsB,CAACU,MAAM,CAAC/B,IAAI,CAAC;MACxC,IAAI,CAACuD,YAAY,CAACvD,IAAI,EAAEQ,GAAG,EAAEC,MAAM,CAAC;;MAEpC;MACA,IAAI,CAAC4C,eAAe,CAAC,CAAC;MAEtB/C,YAAY,EACX,wCAA0CC,SAAS,EACnDC,GAAG,EACHC,MACD,CAAC;IACF,CACD,CAAC;EACF;;EAEA;AACD;AACA;AACA;AACA;EACCuB,WAAWA,CAAChC,IAAI,EAAEwB,OAAO,EAAE;IAC1B,IAAI,OAAOxB,IAAI,KAAK,QAAQ,EAAE;MAC7B,MAAM,IAAI2B,SAAS,CAAC,uBAAuB,CAAC;IAC7C;IACA,IAAIH,OAAO,EAAE;MACZ,OAAO,IAAI,CAACL,aAAa,CAACO,IAAI,CAAC,IAAI,CAACN,gBAAgB,EAAEpB,IAAI,EAAEwB,OAAO,CAAC;IACrE;;IAEA;IACA,IAAI,IAAI,CAACyB,KAAK,KAAKb,iBAAiB,EAAE;MACrC,IAAI,CAACoB,UAAU,CAAC,CAAC;IAClB;;IAEA;IACA,IAAIF,UAAU,GAAG,IAAI,CAACb,KAAK,CAACb,GAAG,CAAC5B,IAAI,CAAC;IACrC,IAAIsD,UAAU,KAAK7B,SAAS,EAAE;MAC7B,IAAI6B,UAAU,CAAC9C,GAAG,EAAE,MAAM8C,UAAU,CAAC9C,GAAG;MACxC,OAAO8C,UAAU,CAAC7C,MAAM;IACzB;;IAEA;IACA;IACA,MAAMF,SAAS,GAAG,IAAI,CAACc,sBAAsB,CAACO,GAAG,CAAC5B,IAAI,CAAC;IACvD,IAAI,CAACqB,sBAAsB,CAACU,MAAM,CAAC/B,IAAI,CAAC;;IAExC;IACA;IACA,IAAIS,MAAM;IACV,IAAI;MACHA,MAAM,GAAG,IAAI,CAACU,aAAa,CAACO,IAAI,CAAC,IAAI,CAACN,gBAAgB,EAAEpB,IAAI,CAAC;IAC9D,CAAC,CAAC,OAAOQ,GAAG,EAAE;MACb,IAAI,CAAC+C,YAAY,CAACvD,IAAI,EAAE,oBAAsBQ,GAAG,EAAGiB,SAAS,CAAC;MAC9D,IAAI,CAACgC,sBAAsB,CAAC,CAAC;MAC7B,IAAIlD,SAAS,EAAE;QACdD,YAAY,CAACC,SAAS,EAAE,oBAAsBC,GAAG,EAAGiB,SAAS,CAAC;MAC/D;MACA,MAAMjB,GAAG;IACV;IACA,IAAI,CAAC+C,YAAY,CAACvD,IAAI,EAAEyB,SAAS,EAAEhB,MAAM,CAAC;IAC1C,IAAI,CAACgD,sBAAsB,CAAC,CAAC;IAC7B,IAAIlD,SAAS,EAAE;MACdD,YAAY,CAACC,SAAS,EAAEkB,SAAS,EAAEhB,MAAM,CAAC;IAC3C;IACA,OAAOA,MAAM;EACd;;EAEA;AACD;AACA;EACCwB,KAAKA,CAACyB,IAAI,EAAE;IACX,IAAI,CAACA,IAAI,EAAE;MACV,IAAI,IAAI,CAACT,KAAK,KAAKd,iBAAiB,EAAE;QACrC,IAAI,CAACM,KAAK,CAACkB,KAAK,CAAC,CAAC;QAClB,KAAK,MAAMC,KAAK,IAAI,IAAI,CAAClB,OAAO,EAAE;UACjCkB,KAAK,CAACD,KAAK,CAAC,CAAC;QACd;QACA,IAAI,CAACE,cAAc,CAAC,CAAC;MACtB;IACD,CAAC,MAAM,IAAI,OAAOH,IAAI,KAAK,QAAQ,EAAE;MACpC,KAAK,IAAI,CAACI,GAAG,EAAEC,IAAI,CAAC,IAAI,IAAI,CAACtB,KAAK,EAAE;QACnC,IAAIqB,GAAG,CAACE,UAAU,CAACN,IAAI,CAAC,EAAE;UACzB,IAAI,CAACjB,KAAK,CAACV,MAAM,CAAC+B,GAAG,CAAC;UACtBC,IAAI,CAACH,KAAK,CAAC7B,MAAM,CAAC+B,GAAG,CAAC;QACvB;MACD;MACA,IAAI,IAAI,CAACrB,KAAK,CAACwB,IAAI,KAAK,CAAC,EAAE;QAC1B,IAAI,CAACJ,cAAc,CAAC,CAAC;MACtB;IACD,CAAC,MAAM;MACN,KAAK,IAAI,CAACC,GAAG,EAAEC,IAAI,CAAC,IAAI,IAAI,CAACtB,KAAK,EAAE;QACnC,KAAK,MAAMyB,IAAI,IAAIR,IAAI,EAAE;UACxB,IAAII,GAAG,CAACE,UAAU,CAACE,IAAI,CAAC,EAAE;YACzB,IAAI,CAACzB,KAAK,CAACV,MAAM,CAAC+B,GAAG,CAAC;YACtBC,IAAI,CAACH,KAAK,CAAC7B,MAAM,CAAC+B,GAAG,CAAC;YACtB;UACD;QACD;MACD;MACA,IAAI,IAAI,CAACrB,KAAK,CAACwB,IAAI,KAAK,CAAC,EAAE;QAC1B,IAAI,CAACJ,cAAc,CAAC,CAAC;MACtB;IACD;EACD;;EAEA;AACD;AACA;EACC3B,WAAWA,CAACwB,IAAI,EAAE;IACjB,IAAI,CAACA,IAAI,EAAE;MACV,IAAI,CAACzB,KAAK,CAAC,CAAC;IACb,CAAC,MAAM,IAAI,OAAOyB,IAAI,KAAK,QAAQ,EAAE;MACpC,IAAI,CAACzB,KAAK,CAAClC,OAAO,CAAC2D,IAAI,CAAC,CAAC;IAC1B,CAAC,MAAM;MACN,MAAM5B,GAAG,GAAG,IAAIc,GAAG,CAAC,CAAC;MACrB,KAAK,MAAMsB,IAAI,IAAIR,IAAI,EAAE;QACxB5B,GAAG,CAACqC,GAAG,CAACpE,OAAO,CAACmE,IAAI,CAAC,CAAC;MACvB;MACA,IAAI,CAACjC,KAAK,CAACH,GAAG,CAAC;IAChB;EACD;;EAEA;AACD;AACA;AACA;AACA;EACCyB,YAAYA,CAACvD,IAAI,EAAEQ,GAAG,EAAEC,MAAM,EAAE;IAC/B,IAAI,IAAI,CAACgC,KAAK,CAAC2B,GAAG,CAACpE,IAAI,CAAC,EAAE;IAC1B,MAAM4D,KAAK,GAAG,IAAI,CAAClB,OAAO,CAAC,IAAI,CAACG,aAAa,CAAC;IAC9C,IAAI,CAACJ,KAAK,CAACX,GAAG,CAAC9B,IAAI,EAAE;MAAEQ,GAAG;MAAEC,MAAM;MAAEmD;IAAM,CAAC,CAAC;IAC5CA,KAAK,CAACO,GAAG,CAACnE,IAAI,CAAC;EAChB;EAEAqE,WAAWA,CAAA,EAAG;IACb,MAAMC,SAAS,GAAG,CAAC,IAAI,CAACzB,aAAa,GAAG,CAAC,IAAI,IAAI,CAACH,OAAO,CAACxC,MAAM;IAChE,MAAMqE,KAAK,GAAG,IAAI,CAAC7B,OAAO,CAAC4B,SAAS,CAAC;IACrC,IAAI,CAACzB,aAAa,GAAGyB,SAAS;IAC9B,KAAK,IAAIJ,IAAI,IAAIK,KAAK,EAAE;MACvB,IAAI,CAAC9B,KAAK,CAACV,MAAM,CAACmC,IAAI,CAAC;IACxB;IACAK,KAAK,CAACZ,KAAK,CAAC,CAAC;IACb,IAAI,IAAI,CAAClB,KAAK,CAACwB,IAAI,KAAK,CAAC,EAAE;MAC1B,IAAI,CAACJ,cAAc,CAAC,CAAC;IACtB,CAAC,MAAM;MACN;MACC,IAAI,CAACV,UAAU,IAAK,IAAI,CAACL,aAAa;IACxC;EACD;EAEAU,UAAUA,CAAA,EAAG;IACZ,QACC,qBAAuB,IAAI,CAACL,UAAU,IAAKqB,IAAI,CAACC,GAAG,CAAC,CAAC,IACrD,IAAI,CAACxB,KAAK,KAAKd,iBAAiB,EAC/B;MACD,IAAI,CAACkC,WAAW,CAAC,CAAC;IACnB;EACD;EAEAhB,eAAeA,CAAA,EAAG;IACjB,IAAIqB,OAAO,GAAG,CAAC;IACf,QAAQ,IAAI,CAACzB,KAAK;MACjB,KAAKZ,kBAAkB;QACtB;MACD,KAAKF,iBAAiB;QACrB,IAAI,CAACgB,UAAU,GAAGqB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC3B,aAAa;QACjD4B,OAAO,GAAG,IAAI,CAAC5B,aAAa;QAC5B;MACD,KAAKV,iBAAiB;QACrB,IAAI,CAACoB,UAAU,CAAC,CAAC;QACjB;QACA,KACC;QACC,IAAI,CAACP,KAAK,KAAMd,iBAAiB,EAElC;QACDuC,OAAO,GAAG3B,IAAI,CAAC4B,GAAG,CACjB,CAAC,EACD,qBAAuB,IAAI,CAACxB,UAAU,GAAIqB,IAAI,CAACC,GAAG,CAAC,CACpD,CAAC;QACD;IACF;IACA,IAAI,CAACxB,KAAK,GAAGZ,kBAAkB;IAC/B,MAAMuC,GAAG,GAAGC,UAAU,CAAC,MAAM;MAC5B,IAAI,CAAC5B,KAAK,GAAGb,iBAAiB;MAC9B,IAAI,CAACoB,UAAU,CAAC,CAAC;IAClB,CAAC,EAAEkB,OAAO,CAAC;IACX,IAAIE,GAAG,CAACE,KAAK,EAAEF,GAAG,CAACE,KAAK,CAAC,CAAC;IAC1B,IAAI,CAAC5B,QAAQ,GAAG0B,GAAG;EACpB;EAEAnB,sBAAsBA,CAAA,EAAG;IACxB,IAAI,IAAI,CAACR,KAAK,KAAKd,iBAAiB,EAAE;MACrC,IAAI,CAACc,KAAK,GAAGb,iBAAiB;MAC9B,IAAI,CAACe,UAAU,GAAGqB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC3B,aAAa;IAClD;EACD;EAEAe,cAAcA,CAAA,EAAG;IAChB,IAAI,CAACZ,KAAK,GAAGd,iBAAiB;IAC9B,IAAI,CAACgB,UAAU,GAAG1B,SAAS;IAC3B,IAAI,IAAI,CAACyB,QAAQ,EAAE6B,YAAY,CAAC,IAAI,CAAC7B,QAAQ,CAAC;EAC/C;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8B,aAAa,GAAGA,CAACzC,QAAQ,EAAExB,QAAQ,EAAEC,YAAY,EAAEC,eAAe,KAAK;EAC5E,IAAIsB,QAAQ,GAAG,CAAC,EAAE;IACjB,OAAO,IAAID,YAAY,CAACC,QAAQ,EAAExB,QAAQ,EAAEC,YAAY,EAAEC,eAAe,CAAC;EAC3E;EACA,OAAO,IAAIJ,sBAAsB,CAACE,QAAQ,EAAEC,YAAY,EAAEC,eAAe,CAAC;AAC3E,CAAC;AAEDgE,MAAM,CAACC,OAAO,GAAG,MAAMC,qBAAqB,CAAC;EAC5C;AACD;AACA;AACA;EACCrE,WAAWA,CAACsE,UAAU,EAAE7C,QAAQ,EAAE;IACjC,IAAI,CAAC6C,UAAU,GAAGA,UAAU;IAE5B,IAAI,CAACC,aAAa,GAAGL,aAAa,CACjCzC,QAAQ,EACR,IAAI,CAAC6C,UAAU,CAACE,KAAK,EACrB,IAAI,CAACF,UAAU,CAACG,SAAS,EACzB,IAAI,CAACH,UACN,CAAC;IACD,MAAME,KAAK,GAAG,IAAI,CAACD,aAAa,CAAC9D,OAAO;IACxC,IAAI,CAAC+D,KAAK,GAAG,kCAAoCA,KAAM;IACvD,MAAMC,SAAS,GAAG,IAAI,CAACF,aAAa,CAACrD,WAAW;IAChD,IAAI,CAACuD,SAAS,GAAG,0CAA4CA,SAAU;IAEvE,IAAI,CAACC,YAAY,GAAGR,aAAa,CAChCzC,QAAQ,EACR,IAAI,CAAC6C,UAAU,CAACK,IAAI,EACpB,IAAI,CAACL,UAAU,CAACM,QAAQ,EACxB,IAAI,CAACN,UACN,CAAC;IACD,MAAMK,IAAI,GAAG,IAAI,CAACD,YAAY,CAACjE,OAAO;IACtC,IAAI,CAACkE,IAAI,GAAG,iCAAmCA,IAAK;IACpD,MAAMC,QAAQ,GAAG,IAAI,CAACF,YAAY,CAACxD,WAAW;IAC9C,IAAI,CAAC0D,QAAQ,GAAG,yCAA2CA,QAAS;IAEpE,IAAI,CAACC,eAAe,GAAGX,aAAa,CACnCzC,QAAQ,EACR,IAAI,CAAC6C,UAAU,CAACQ,OAAO,EACvB,IAAI,CAACR,UAAU,CAACS,WAAW,EAC3B,IAAI,CAACT,UACN,CAAC;IACD,MAAMQ,OAAO,GAAG,IAAI,CAACD,eAAe,CAACpE,OAAO;IAC5C,IAAI,CAACqE,OAAO,GAAG,oCAAsCA,OAAQ;IAC7D,MAAMC,WAAW,GAAG,IAAI,CAACF,eAAe,CAAC3D,WAAW;IACpD,IAAI,CAAC6D,WAAW,GAAG;IAClBA,WACA;IAED,IAAI,CAACC,gBAAgB,GAAGd,aAAa,CACpCzC,QAAQ,EACR,IAAI,CAAC6C,UAAU,CAACW,QAAQ,EACxB,IAAI,CAACX,UAAU,CAACY,YAAY,EAC5B,IAAI,CAACZ,UACN,CAAC;IACD,MAAMW,QAAQ,GAAG,IAAI,CAACD,gBAAgB,CAACvE,OAAO;IAC9C,IAAI,CAACwE,QAAQ,GAAG,qCAAuCA,QAAS;IAChE,MAAMC,YAAY,GAAG,IAAI,CAACF,gBAAgB,CAAC9D,WAAW;IACtD,IAAI,CAACgE,YAAY,GAAG;IACnBA,YACA;IAED,IAAI,CAACC,gBAAgB,GAAGjB,aAAa,CACpCzC,QAAQ;IACR;IACA,IAAI,CAAC6C,UAAU,CAACc,QAAQ,IACtB,IAAI,CAACH,QAAQ;IAEZ;AACN;AACA;AACA;IACM,CAAC/F,IAAI,EAAEW,QAAQ,KAAK;MACnB,IAAI,CAACoF,QAAQ,CAAC/F,IAAI,EAAE,CAACQ,GAAG,EAAE2F,MAAM,KAAK;QACpC,IAAI3F,GAAG,EAAE,OAAOG,QAAQ,CAACH,GAAG,CAAC;QAC7B,IAAI,CAAC2F,MAAM,IAAIA,MAAM,CAACjG,MAAM,KAAK,CAAC,EACjC,OAAOS,QAAQ,CAAC,IAAIyF,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAC9C,IAAIrC,IAAI;QACR,IAAI;UACHA,IAAI,GAAGsC,IAAI,CAACC,KAAK,CAACH,MAAM,CAACI,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC5C,CAAC,CAAC,OAAO3F,CAAC,EAAE;UACX,OAAOD,QAAQ,EAAC,oBAAsBC,CAAE,CAAC;QAC1C;QACAD,QAAQ,CAAC,IAAI,EAAEoD,IAAI,CAAC;MACrB,CAAC,CAAC;IACH,CAAC,CACF;IACF;IACA,IAAI,CAACqB,UAAU,CAACoB,YAAY,IAC1B,IAAI,CAACR,YAAY;IAEhB;AACN;AACA;AACA;IACOhG,IAAI,IAAK;MACT,MAAMmG,MAAM,GAAG,IAAI,CAACH,YAAY,CAAChG,IAAI,CAAC;MACtC,MAAM+D,IAAI,GAAGsC,IAAI,CAACC,KAAK,CAACH,MAAM,CAACI,QAAQ,CAAC,OAAO,CAAC,CAAC;MACjD,OAAOxC,IAAI;IACZ,CAAC,CACA,EACJ,IAAI,CAACqB,UACN,CAAC;IACD,MAAMc,QAAQ,GAAG,IAAI,CAACD,gBAAgB,CAAC1E,OAAO;IAC9C,IAAI,CAAC2E,QAAQ,GAAG,qCAAuCA,QAAS;IAChE,MAAMM,YAAY,GAAG,IAAI,CAACP,gBAAgB,CAACjE,WAAW;IACtD,IAAI,CAACwE,YAAY,GAAG;IACnBA,YACA;IAED,IAAI,CAACC,gBAAgB,GAAGzB,aAAa,CACpCzC,QAAQ,EACR,IAAI,CAAC6C,UAAU,CAACsB,QAAQ,EACxB,IAAI,CAACtB,UAAU,CAACuB,YAAY,EAC5B,IAAI,CAACvB,UACN,CAAC;IACD,MAAMsB,QAAQ,GAAG,IAAI,CAACD,gBAAgB,CAAClF,OAAO;IAC9C,IAAI,CAACmF,QAAQ,GAAG,qCAAuCA,QAAS;IAChE,MAAMC,YAAY,GAAG,IAAI,CAACF,gBAAgB,CAACzE,WAAW;IACtD,IAAI,CAAC2E,YAAY,GAAG;IACnBA,YACA;EACF;;EAEA;AACD;AACA;EACC1E,KAAKA,CAACyB,IAAI,EAAE;IACX,IAAI,CAAC8B,YAAY,CAACvD,KAAK,CAACyB,IAAI,CAAC;IAC7B,IAAI,CAAC2B,aAAa,CAACpD,KAAK,CAACyB,IAAI,CAAC;IAC9B,IAAI,CAACiC,eAAe,CAACzD,WAAW,CAACwB,IAAI,CAAC;IACtC,IAAI,CAACoC,gBAAgB,CAAC7D,KAAK,CAACyB,IAAI,CAAC;IACjC,IAAI,CAAC+C,gBAAgB,CAACxE,KAAK,CAACyB,IAAI,CAAC;IACjC,IAAI,CAACuC,gBAAgB,CAAChE,KAAK,CAACyB,IAAI,CAAC;EAClC;AACD,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}