{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst isWeakKey = thing => typeof thing === \"object\" && thing !== null;\n\n/**\n * @template {any[]} T\n * @template V\n */\nclass WeakTupleMap {\n  constructor() {\n    /** @private */\n    this.f = 0;\n    /** @private @type {any} */\n    this.v = undefined;\n    /** @private @type {Map<object, WeakTupleMap<T, V>> | undefined} */\n    this.m = undefined;\n    /** @private @type {WeakMap<object, WeakTupleMap<T, V>> | undefined} */\n    this.w = undefined;\n  }\n\n  /**\n   * @param {[...T, V]} args tuple\n   * @returns {void}\n   */\n  set() {\n    var _ref;\n    /** @type {WeakTupleMap<T, V>} */\n    let node = this;\n    for (let i = 0; i < arguments.length - 1; i++) {\n      node = node._get(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n    }\n    node._setValue((_ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]));\n  }\n\n  /**\n   * @param {T} args tuple\n   * @returns {boolean} true, if the tuple is in the Set\n   */\n  has() {\n    /** @type {WeakTupleMap<T, V>} */\n    let node = this;\n    for (let i = 0; i < arguments.length; i++) {\n      node = node._peek(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      if (node === undefined) return false;\n    }\n    return node._hasValue();\n  }\n\n  /**\n   * @param {T} args tuple\n   * @returns {V} the value\n   */\n  get() {\n    /** @type {WeakTupleMap<T, V>} */\n    let node = this;\n    for (let i = 0; i < arguments.length; i++) {\n      node = node._peek(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      if (node === undefined) return undefined;\n    }\n    return node._getValue();\n  }\n\n  /**\n   * @param {[...T, function(): V]} args tuple\n   * @returns {V} the value\n   */\n  provide() {\n    /** @type {WeakTupleMap<T, V>} */\n    let node = this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    for (let i = 0; i < args.length - 1; i++) {\n      node = node._get(args[i]);\n    }\n    if (node._hasValue()) return node._getValue();\n    const fn = args[args.length - 1];\n    const newValue = fn(...args.slice(0, -1));\n    node._setValue(newValue);\n    return newValue;\n  }\n\n  /**\n   * @param {T} args tuple\n   * @returns {void}\n   */\n  delete() {\n    /** @type {WeakTupleMap<T, V>} */\n    let node = this;\n    for (let i = 0; i < arguments.length; i++) {\n      node = node._peek(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      if (node === undefined) return;\n    }\n    node._deleteValue();\n  }\n\n  /**\n   * @returns {void}\n   */\n  clear() {\n    this.f = 0;\n    this.v = undefined;\n    this.w = undefined;\n    this.m = undefined;\n  }\n  _getValue() {\n    return this.v;\n  }\n  _hasValue() {\n    return (this.f & 1) === 1;\n  }\n  _setValue(v) {\n    this.f |= 1;\n    this.v = v;\n  }\n  _deleteValue() {\n    this.f &= 6;\n    this.v = undefined;\n  }\n  _peek(thing) {\n    if (isWeakKey(thing)) {\n      if ((this.f & 4) !== 4) return undefined;\n      return this.w.get(thing);\n    } else {\n      if ((this.f & 2) !== 2) return undefined;\n      return this.m.get(thing);\n    }\n  }\n  _get(thing) {\n    if (isWeakKey(thing)) {\n      if ((this.f & 4) !== 4) {\n        const newMap = new WeakMap();\n        this.f |= 4;\n        const newNode = new WeakTupleMap();\n        (this.w = newMap).set(thing, newNode);\n        return newNode;\n      }\n      const entry = this.w.get(thing);\n      if (entry !== undefined) {\n        return entry;\n      }\n      const newNode = new WeakTupleMap();\n      this.w.set(thing, newNode);\n      return newNode;\n    } else {\n      if ((this.f & 2) !== 2) {\n        const newMap = new Map();\n        this.f |= 2;\n        const newNode = new WeakTupleMap();\n        (this.m = newMap).set(thing, newNode);\n        return newNode;\n      }\n      const entry = this.m.get(thing);\n      if (entry !== undefined) {\n        return entry;\n      }\n      const newNode = new WeakTupleMap();\n      this.m.set(thing, newNode);\n      return newNode;\n    }\n  }\n}\nmodule.exports = WeakTupleMap;","map":{"version":3,"names":["isWeakKey","thing","WeakTupleMap","constructor","f","v","undefined","m","w","set","_ref","node","i","arguments","length","_get","_setValue","has","_peek","_hasValue","get","_getValue","provide","_len","args","Array","_key","fn","newValue","slice","delete","_deleteValue","clear","newMap","WeakMap","newNode","entry","Map","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/WeakTupleMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst isWeakKey = thing => typeof thing === \"object\" && thing !== null;\n\n/**\n * @template {any[]} T\n * @template V\n */\nclass WeakTupleMap {\n\tconstructor() {\n\t\t/** @private */\n\t\tthis.f = 0;\n\t\t/** @private @type {any} */\n\t\tthis.v = undefined;\n\t\t/** @private @type {Map<object, WeakTupleMap<T, V>> | undefined} */\n\t\tthis.m = undefined;\n\t\t/** @private @type {WeakMap<object, WeakTupleMap<T, V>> | undefined} */\n\t\tthis.w = undefined;\n\t}\n\n\t/**\n\t * @param {[...T, V]} args tuple\n\t * @returns {void}\n\t */\n\tset(...args) {\n\t\t/** @type {WeakTupleMap<T, V>} */\n\t\tlet node = this;\n\t\tfor (let i = 0; i < args.length - 1; i++) {\n\t\t\tnode = node._get(args[i]);\n\t\t}\n\t\tnode._setValue(args[args.length - 1]);\n\t}\n\n\t/**\n\t * @param {T} args tuple\n\t * @returns {boolean} true, if the tuple is in the Set\n\t */\n\thas(...args) {\n\t\t/** @type {WeakTupleMap<T, V>} */\n\t\tlet node = this;\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tnode = node._peek(args[i]);\n\t\t\tif (node === undefined) return false;\n\t\t}\n\t\treturn node._hasValue();\n\t}\n\n\t/**\n\t * @param {T} args tuple\n\t * @returns {V} the value\n\t */\n\tget(...args) {\n\t\t/** @type {WeakTupleMap<T, V>} */\n\t\tlet node = this;\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tnode = node._peek(args[i]);\n\t\t\tif (node === undefined) return undefined;\n\t\t}\n\t\treturn node._getValue();\n\t}\n\n\t/**\n\t * @param {[...T, function(): V]} args tuple\n\t * @returns {V} the value\n\t */\n\tprovide(...args) {\n\t\t/** @type {WeakTupleMap<T, V>} */\n\t\tlet node = this;\n\t\tfor (let i = 0; i < args.length - 1; i++) {\n\t\t\tnode = node._get(args[i]);\n\t\t}\n\t\tif (node._hasValue()) return node._getValue();\n\t\tconst fn = args[args.length - 1];\n\t\tconst newValue = fn(...args.slice(0, -1));\n\t\tnode._setValue(newValue);\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * @param {T} args tuple\n\t * @returns {void}\n\t */\n\tdelete(...args) {\n\t\t/** @type {WeakTupleMap<T, V>} */\n\t\tlet node = this;\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tnode = node._peek(args[i]);\n\t\t\tif (node === undefined) return;\n\t\t}\n\t\tnode._deleteValue();\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tclear() {\n\t\tthis.f = 0;\n\t\tthis.v = undefined;\n\t\tthis.w = undefined;\n\t\tthis.m = undefined;\n\t}\n\n\t_getValue() {\n\t\treturn this.v;\n\t}\n\n\t_hasValue() {\n\t\treturn (this.f & 1) === 1;\n\t}\n\n\t_setValue(v) {\n\t\tthis.f |= 1;\n\t\tthis.v = v;\n\t}\n\n\t_deleteValue() {\n\t\tthis.f &= 6;\n\t\tthis.v = undefined;\n\t}\n\n\t_peek(thing) {\n\t\tif (isWeakKey(thing)) {\n\t\t\tif ((this.f & 4) !== 4) return undefined;\n\t\t\treturn this.w.get(thing);\n\t\t} else {\n\t\t\tif ((this.f & 2) !== 2) return undefined;\n\t\t\treturn this.m.get(thing);\n\t\t}\n\t}\n\n\t_get(thing) {\n\t\tif (isWeakKey(thing)) {\n\t\t\tif ((this.f & 4) !== 4) {\n\t\t\t\tconst newMap = new WeakMap();\n\t\t\t\tthis.f |= 4;\n\t\t\t\tconst newNode = new WeakTupleMap();\n\t\t\t\t(this.w = newMap).set(thing, newNode);\n\t\t\t\treturn newNode;\n\t\t\t}\n\t\t\tconst entry = this.w.get(thing);\n\t\t\tif (entry !== undefined) {\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tconst newNode = new WeakTupleMap();\n\t\t\tthis.w.set(thing, newNode);\n\t\t\treturn newNode;\n\t\t} else {\n\t\t\tif ((this.f & 2) !== 2) {\n\t\t\t\tconst newMap = new Map();\n\t\t\t\tthis.f |= 2;\n\t\t\t\tconst newNode = new WeakTupleMap();\n\t\t\t\t(this.m = newMap).set(thing, newNode);\n\t\t\t\treturn newNode;\n\t\t\t}\n\t\t\tconst entry = this.m.get(thing);\n\t\t\tif (entry !== undefined) {\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tconst newNode = new WeakTupleMap();\n\t\t\tthis.m.set(thing, newNode);\n\t\t\treturn newNode;\n\t\t}\n\t}\n}\n\nmodule.exports = WeakTupleMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}