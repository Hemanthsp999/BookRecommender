{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\nconst WebpackError = require(\"../WebpackError\");\nconst {\n  requestToId\n} = require(\"../ids/IdHelpers\");\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst {\n  compareModulesByIdentifier,\n  compareIterables\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\nconst memoize = require(\"../util/memoize\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\nconst defaultGetName = /** @type {GetName} */() => {};\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\n/** @type {WeakMap<Module, string>} */\nconst getKeyCache = new WeakMap();\n\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\nconst hashFilename = (name, outputOptions) => {\n  const digest = /** @type {string} */\n  createHash(outputOptions.hashFunction).update(name).digest(outputOptions.hashDigest);\n  return digest.slice(0, 8);\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\nconst getRequests = chunk => {\n  let requests = 0;\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n  return requests;\n};\nconst mapObject = (obj, fn) => {\n  const newObj = Object.create(null);\n  for (const key of Object.keys(obj)) {\n    newObj[key] = fn(obj[key], key);\n  }\n  return newObj;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n  return false;\n};\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority;\n  // 2. by number of chunks\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount;\n  // 3. by size reduction\n  const aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n  const bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce;\n  // 4. by cache group index\n  const indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n  if (indexDiff) return indexDiff;\n  // 5. by number of modules (to be able to compare by identifier)\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff;\n  // 6. by module identifiers\n  modulesA.sort();\n  modulesB.sort();\n  return compareModuleIterables(modulesA, modulesB);\n};\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\nconst normalizeSizes = (value, defaultSizeTypes) => {\n  if (typeof value === \"number\") {\n    /** @type {Record<string, number>} */\n    const o = {};\n    for (const sizeType of defaultSizeTypes) o[sizeType] = value;\n    return o;\n  } else if (typeof value === \"object\" && value !== null) {\n    return {\n      ...value\n    };\n  } else {\n    return {};\n  }\n};\n\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\nconst mergeSizes = function () {\n  /** @type {SplitChunksSizes} */\n  let merged = {};\n  for (let i = arguments.length - 1; i >= 0; i--) {\n    merged = Object.assign(merged, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  }\n  return merged;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\nconst hasNonZeroSizes = sizes => {\n  for (const key of Object.keys(sizes)) {\n    if (sizes[key] > 0) return true;\n  }\n  return false;\n};\n\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\nconst combineSizes = (a, b, combine) => {\n  const aKeys = new Set(Object.keys(a));\n  const bKeys = new Set(Object.keys(b));\n  /** @type {SplitChunksSizes} */\n  const result = {};\n  for (const key of aKeys) {\n    if (bKeys.has(key)) {\n      result[key] = combine(a[key], b[key]);\n    } else {\n      result[key] = a[key];\n    }\n  }\n  for (const key of bKeys) {\n    if (!aKeys.has(key)) {\n      result[key] = b[key];\n    }\n  }\n  return result;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\nconst checkMinSize = (sizes, minSize) => {\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) return false;\n  }\n  return true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n  for (const key of Object.keys(minSizeReduction)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size * chunkCount < minSizeReduction[key]) return false;\n  }\n  return true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\nconst getViolatingMinSizes = (sizes, minSize) => {\n  let list;\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) {\n      if (list === undefined) list = [key];else list.push(key);\n    }\n  }\n  return list;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\nconst totalSize = sizes => {\n  let size = 0;\n  for (const key of Object.keys(sizes)) {\n    size += sizes[key];\n  }\n  return size;\n};\n\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\nconst normalizeName = name => {\n  if (typeof name === \"string\") {\n    return () => name;\n  }\n  if (typeof name === \"function\") {\n    return (/** @type {GetName} */name\n    );\n  }\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\nconst normalizeChunksFilter = chunks => {\n  if (chunks === \"initial\") {\n    return INITIAL_CHUNK_FILTER;\n  }\n  if (chunks === \"async\") {\n    return ASYNC_CHUNK_FILTER;\n  }\n  if (chunks === \"all\") {\n    return ALL_CHUNK_FILTER;\n  }\n  if (typeof chunks === \"function\") {\n    return chunks;\n  }\n};\n\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n  if (typeof cacheGroups === \"function\") {\n    return cacheGroups;\n  }\n  if (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n    /** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n    const handlers = [];\n    for (const key of Object.keys(cacheGroups)) {\n      const option = cacheGroups[key];\n      if (option === false) {\n        continue;\n      }\n      if (typeof option === \"string\" || option instanceof RegExp) {\n        const source = createCacheGroupSource({}, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option, module, context)) {\n            results.push(source);\n          }\n        });\n      } else if (typeof option === \"function\") {\n        const cache = new WeakMap();\n        handlers.push((module, context, results) => {\n          const result = option(module);\n          if (result) {\n            const groups = Array.isArray(result) ? result : [result];\n            for (const group of groups) {\n              const cachedSource = cache.get(group);\n              if (cachedSource !== undefined) {\n                results.push(cachedSource);\n              } else {\n                const source = createCacheGroupSource(group, key, defaultSizeTypes);\n                cache.set(group, source);\n                results.push(source);\n              }\n            }\n          }\n        });\n      } else {\n        const source = createCacheGroupSource(option, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option.test, module, context) && checkModuleType(option.type, module) && checkModuleLayer(option.layer, module)) {\n            results.push(source);\n          }\n        });\n      }\n    }\n    /**\n     * @param {Module} module the current module\n     * @param {CacheGroupsContext} context the current context\n     * @returns {CacheGroupSource[]} the matching cache groups\n     */\n    const fn = (module, context) => {\n      /** @type {CacheGroupSource[]} */\n      let results = [];\n      for (const fn of handlers) {\n        fn(module, context, results);\n      }\n      return results;\n    };\n    return fn;\n  }\n  return () => null;\n};\n\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\nconst checkTest = (test, module, context) => {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module, context);\n  }\n  if (typeof test === \"boolean\") return test;\n  if (typeof test === \"string\") {\n    const name = module.nameForCondition();\n    return name && name.startsWith(test);\n  }\n  if (test instanceof RegExp) {\n    const name = module.nameForCondition();\n    return name && test.test(name);\n  }\n  return false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleType = (test, module) => {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module.type);\n  }\n  if (typeof test === \"string\") {\n    const type = module.type;\n    return test === type;\n  }\n  if (test instanceof RegExp) {\n    const type = module.type;\n    return test.test(type);\n  }\n  return false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleLayer = (test, module) => {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module.layer);\n  }\n  if (typeof test === \"string\") {\n    const layer = module.layer;\n    return test === \"\" ? !layer : layer && layer.startsWith(test);\n  }\n  if (test instanceof RegExp) {\n    const layer = module.layer;\n    return test.test(layer);\n  }\n  return false;\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n  const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n  const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n  const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n  return {\n    key,\n    priority: options.priority,\n    getName: normalizeName(options.name),\n    chunksFilter: normalizeChunksFilter(options.chunks),\n    enforce: options.enforce,\n    minSize,\n    minSizeReduction,\n    minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n    enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n    maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n    maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n    minChunks: options.minChunks,\n    maxAsyncRequests: options.maxAsyncRequests,\n    maxInitialRequests: options.maxInitialRequests,\n    filename: options.filename,\n    idHint: options.idHint,\n    automaticNameDelimiter: options.automaticNameDelimiter,\n    reuseExistingChunk: options.reuseExistingChunk,\n    usedExports: options.usedExports\n  };\n};\nmodule.exports = class SplitChunksPlugin {\n  /**\n   * @param {OptimizationSplitChunksOptions=} options plugin options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const defaultSizeTypes = options.defaultSizeTypes || [\"javascript\", \"unknown\"];\n    const fallbackCacheGroup = options.fallbackCacheGroup || {};\n    const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n    const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n    const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n    /** @type {SplitChunksOptions} */\n    this.options = {\n      chunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n      defaultSizeTypes,\n      minSize,\n      minSizeReduction,\n      minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n      enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n      maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n      maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: normalizeCacheGroups(options.cacheGroups, defaultSizeTypes),\n      getName: options.name ? normalizeName(options.name) : defaultGetName,\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      usedExports: options.usedExports,\n      fallbackCacheGroup: {\n        chunksFilter: normalizeChunksFilter(fallbackCacheGroup.chunks || options.chunks || \"all\"),\n        minSize: mergeSizes(normalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes), minSize),\n        maxAsyncSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxAsyncSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        maxInitialSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxInitialSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        automaticNameDelimiter: fallbackCacheGroup.automaticNameDelimiter || options.automaticNameDelimiter || \"~\"\n      }\n    };\n\n    /** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n    this._cacheGroupCache = new WeakMap();\n  }\n\n  /**\n   * @param {CacheGroupSource} cacheGroupSource source\n   * @returns {CacheGroup} the cache group (cached)\n   */\n  _getCacheGroup(cacheGroupSource) {\n    const cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n    if (cacheEntry !== undefined) return cacheEntry;\n    const minSize = mergeSizes(cacheGroupSource.minSize, cacheGroupSource.enforce ? undefined : this.options.minSize);\n    const minSizeReduction = mergeSizes(cacheGroupSource.minSizeReduction, cacheGroupSource.enforce ? undefined : this.options.minSizeReduction);\n    const minRemainingSize = mergeSizes(cacheGroupSource.minRemainingSize, cacheGroupSource.enforce ? undefined : this.options.minRemainingSize);\n    const enforceSizeThreshold = mergeSizes(cacheGroupSource.enforceSizeThreshold, cacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold);\n    const cacheGroup = {\n      key: cacheGroupSource.key,\n      priority: cacheGroupSource.priority || 0,\n      chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n      minSize,\n      minSizeReduction,\n      minRemainingSize,\n      enforceSizeThreshold,\n      maxAsyncSize: mergeSizes(cacheGroupSource.maxAsyncSize, cacheGroupSource.enforce ? undefined : this.options.maxAsyncSize),\n      maxInitialSize: mergeSizes(cacheGroupSource.maxInitialSize, cacheGroupSource.enforce ? undefined : this.options.maxInitialSize),\n      minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n      maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n      maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n      getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n      usedExports: cacheGroupSource.usedExports !== undefined ? cacheGroupSource.usedExports : this.options.usedExports,\n      filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n      automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n      idHint: cacheGroupSource.idHint !== undefined ? cacheGroupSource.idHint : cacheGroupSource.key,\n      reuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n      _validateSize: hasNonZeroSizes(minSize),\n      _validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n      _minSizeForMaxSize: mergeSizes(cacheGroupSource.minSize, this.options.minSize),\n      _conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n    };\n    this._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n    return cacheGroup;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const cachedMakePathsRelative = makePathsRelative.bindContextCache(compiler.context, compiler.root);\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      const logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"SplitChunksPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true;\n        logger.time(\"prepare\");\n        const chunkGraph = compilation.chunkGraph;\n        const moduleGraph = compilation.moduleGraph;\n        // Give each selected chunk an index (to create strings from chunks)\n        /** @type {Map<Chunk, bigint>} */\n        const chunkIndexMap = new Map();\n        const ZERO = BigInt(\"0\");\n        const ONE = BigInt(\"1\");\n        const START = ONE << BigInt(\"31\");\n        let index = START;\n        for (const chunk of chunks) {\n          chunkIndexMap.set(chunk, index | BigInt(Math.random() * 0x7fffffff | 0));\n          index = index << ONE;\n        }\n        /**\n         * @param {Iterable<Chunk>} chunks list of chunks\n         * @returns {bigint | Chunk} key of the chunks\n         */\n        const getKey = chunks => {\n          const iterator = chunks[Symbol.iterator]();\n          let result = iterator.next();\n          if (result.done) return ZERO;\n          const first = result.value;\n          result = iterator.next();\n          if (result.done) return first;\n          let key = chunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n          while (!(result = iterator.next()).done) {\n            const raw = chunkIndexMap.get(result.value);\n            key = key ^ raw;\n          }\n          return key;\n        };\n        const keyToString = key => {\n          if (typeof key === \"bigint\") return key.toString(16);\n          return chunkIndexMap.get(key).toString(16);\n        };\n        const getChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n          const singleChunkSets = new Set();\n          for (const module of compilation.modules) {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n            if (typeof chunksKey === \"bigint\") {\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(chunks));\n              }\n            } else {\n              singleChunkSets.add(chunksKey);\n            }\n          }\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        });\n\n        /**\n         * @param {Module} module the module\n         * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n         */\n        const groupChunksByExports = module => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const groupedByUsedExports = new Map();\n          for (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n            const key = exportsInfo.getUsageKey(chunk.runtime);\n            const list = groupedByUsedExports.get(key);\n            if (list !== undefined) {\n              list.push(chunk);\n            } else {\n              groupedByUsedExports.set(key, [chunk]);\n            }\n          }\n          return groupedByUsedExports.values();\n        };\n\n        /** @type {Map<Module, Iterable<Chunk[]>>} */\n        const groupedByExportsMap = new Map();\n        const getExportsChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n          const singleChunkSets = new Set();\n          for (const module of compilation.modules) {\n            const groupedChunks = Array.from(groupChunksByExports(module));\n            groupedByExportsMap.set(module, groupedChunks);\n            for (const chunks of groupedChunks) {\n              if (chunks.length === 1) {\n                singleChunkSets.add(chunks[0]);\n              } else {\n                const chunksKey = /** @type {bigint} */getKey(chunks);\n                if (!chunkSetsInGraph.has(chunksKey)) {\n                  chunkSetsInGraph.set(chunksKey, new Set(chunks));\n                }\n              }\n            }\n          }\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        });\n\n        // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n        const groupChunkSetsByCount = chunkSets => {\n          /** @type {Map<number, Array<Set<Chunk>>>} */\n          const chunkSetsByCount = new Map();\n          for (const chunksSet of chunkSets) {\n            const count = chunksSet.size;\n            let array = chunkSetsByCount.get(count);\n            if (array === undefined) {\n              array = [];\n              chunkSetsByCount.set(count, array);\n            }\n            array.push(chunksSet);\n          }\n          return chunkSetsByCount;\n        };\n        const getChunkSetsByCount = memoize(() => groupChunkSetsByCount(getChunkSetsInGraph().chunkSetsInGraph.values()));\n        const getExportsChunkSetsByCount = memoize(() => groupChunkSetsByCount(getExportsChunkSetsInGraph().chunkSetsInGraph.values()));\n\n        // Create a list of possible combinations\n        const createGetCombinations = (chunkSets, singleChunkSets, chunkSetsByCount) => {\n          /** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n          const combinationsCache = new Map();\n          return key => {\n            const cacheEntry = combinationsCache.get(key);\n            if (cacheEntry !== undefined) return cacheEntry;\n            if (key instanceof Chunk) {\n              const result = [key];\n              combinationsCache.set(key, result);\n              return result;\n            }\n            const chunksSet = chunkSets.get(key);\n            /** @type {(Set<Chunk> | Chunk)[]} */\n            const array = [chunksSet];\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n            for (const chunk of singleChunkSets) {\n              if (chunksSet.has(chunk)) {\n                array.push(chunk);\n              }\n            }\n            combinationsCache.set(key, array);\n            return array;\n          };\n        };\n        const getCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getChunkSetsByCount());\n        });\n        const getCombinations = key => getCombinationsFactory()(key);\n        const getExportsCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getExportsChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getExportsChunkSetsByCount());\n        });\n        const getExportsCombinations = key => getExportsCombinationsFactory()(key);\n\n        /**\n         * @typedef {Object} SelectedChunksResult\n         * @property {Chunk[]} chunks the list of chunks\n         * @property {bigint | Chunk} key a key of the list\n         */\n\n        /** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n        const selectedChunksCacheByChunksSet = new WeakMap();\n\n        /**\n         * get list and key by applying the filter function to the list\n         * It is cached for performance reasons\n         * @param {Set<Chunk> | Chunk} chunks list of chunks\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n         * @returns {SelectedChunksResult} list and key\n         */\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n          let entry2 = entry.get(chunkFilter);\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n            if (chunks instanceof Chunk) {\n              if (chunkFilter(chunks)) selectedChunks.push(chunks);\n            } else {\n              for (const chunk of chunks) {\n                if (chunkFilter(chunk)) selectedChunks.push(chunk);\n              }\n            }\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n          return entry2;\n        };\n\n        /** @type {Map<string, boolean>} */\n        const alreadyValidatedParents = new Map();\n        /** @type {Set<string>} */\n        const alreadyReportedErrors = new Set();\n\n        // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n        /** @type {Map<string, ChunksInfoItem>} */\n        const chunksInfoMap = new Map();\n\n        /**\n         * @param {CacheGroup} cacheGroup the current cache group\n         * @param {number} cacheGroupIndex the index of the cache group of ordering\n         * @param {Chunk[]} selectedChunks chunks selected for this module\n         * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n         * @param {Module} module the current module\n         * @returns {void}\n         */\n        const addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return;\n          // Determine name for split chunk\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key);\n          // Check if the name is ok\n          const existingChunk = compilation.namedChunks.get(name);\n          if (existingChunk) {\n            const parentValidationKey = `${name}|${typeof selectedChunksKey === \"bigint\" ? selectedChunksKey : selectedChunksKey.debugId}`;\n            const valid = alreadyValidatedParents.get(parentValidationKey);\n            if (valid === false) return;\n            if (valid === undefined) {\n              // Module can only be moved into the existing chunk if the existing chunk\n              // is a parent of all selected chunks\n              let isInAllParents = true;\n              /** @type {Set<ChunkGroup>} */\n              const queue = new Set();\n              for (const chunk of selectedChunks) {\n                for (const group of chunk.groupsIterable) {\n                  queue.add(group);\n                }\n              }\n              for (const group of queue) {\n                if (existingChunk.isInGroup(group)) continue;\n                let hasParent = false;\n                for (const parent of group.parentsIterable) {\n                  hasParent = true;\n                  queue.add(parent);\n                }\n                if (!hasParent) {\n                  isInAllParents = false;\n                }\n              }\n              const valid = isInAllParents;\n              alreadyValidatedParents.set(parentValidationKey, valid);\n              if (!valid) {\n                if (!alreadyReportedErrors.has(name)) {\n                  alreadyReportedErrors.add(name);\n                  compilation.errors.push(new WebpackError(\"SplitChunksPlugin\\n\" + `Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` + `Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` + \"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" + 'HINT: You can omit \"name\" to automatically create a name.\\n' + \"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" + \"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" + \"Remove this entrypoint and add modules to cache group's 'test' instead. \" + \"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" + \"See migration guide of more info.\"));\n                }\n                return;\n              }\n            }\n          }\n          // Create key for maps\n          // When it has a name we use the name as key\n          // Otherwise we create the key from chunks and cache group key\n          // This automatically merges equal names\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${keyToString(selectedChunksKey)}`);\n          // Add module to maps\n          let info = chunksInfoMap.get(key);\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, compareModulesByIdentifier),\n              cacheGroup,\n              cacheGroupIndex,\n              name,\n              sizes: {},\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n          const oldSize = info.modules.size;\n          info.modules.add(module);\n          if (info.modules.size !== oldSize) {\n            for (const type of module.getSourceTypes()) {\n              info.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n            }\n          }\n          const oldChunksKeysSize = info.chunksKeys.size;\n          info.chunksKeys.add(selectedChunksKey);\n          if (oldChunksKeysSize !== info.chunksKeys.size) {\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        };\n        const context = {\n          moduleGraph,\n          chunkGraph\n        };\n        logger.timeEnd(\"prepare\");\n        logger.time(\"modules\");\n\n        // Walk through all modules\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module, context);\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          }\n\n          // Prepare some values (usedExports = false)\n          const getCombs = memoize(() => {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n            return getCombinations(chunksKey);\n          });\n\n          // Prepare some values (usedExports = true)\n          const getCombsByUsedExports = memoize(() => {\n            // fill the groupedByExportsMap\n            getExportsChunkSetsInGraph();\n            /** @type {Set<Set<Chunk> | Chunk>} */\n            const set = new Set();\n            const groupedByUsedExports = groupedByExportsMap.get(module);\n            for (const chunks of groupedByUsedExports) {\n              const chunksKey = getKey(chunks);\n              for (const comb of getExportsCombinations(chunksKey)) set.add(comb);\n            }\n            return set;\n          });\n          let cacheGroupIndex = 0;\n          for (const cacheGroupSource of cacheGroups) {\n            const cacheGroup = this._getCacheGroup(cacheGroupSource);\n            const combs = cacheGroup.usedExports ? getCombsByUsedExports() : getCombs();\n            // For all combination of chunk selection\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              const count = chunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n              if (count < cacheGroup.minChunks) continue;\n              // Select chunks by configuration\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n            }\n            cacheGroupIndex++;\n          }\n        }\n        logger.timeEnd(\"modules\");\n        logger.time(\"queue\");\n\n        /**\n         * @param {ChunksInfoItem} info entry\n         * @param {string[]} sourceTypes source types to be removed\n         */\n        const removeModulesWithSourceType = (info, sourceTypes) => {\n          for (const module of info.modules) {\n            const types = module.getSourceTypes();\n            if (sourceTypes.some(type => types.has(type))) {\n              info.modules.delete(module);\n              for (const type of types) {\n                info.sizes[type] -= module.size(type);\n              }\n            }\n          }\n        };\n\n        /**\n         * @param {ChunksInfoItem} info entry\n         * @returns {boolean} true, if entry become empty\n         */\n        const removeMinSizeViolatingModules = info => {\n          if (!info.cacheGroup._validateSize) return false;\n          const violatingSizes = getViolatingMinSizes(info.sizes, info.cacheGroup.minSize);\n          if (violatingSizes === undefined) return false;\n          removeModulesWithSourceType(info, violatingSizes);\n          return info.modules.size === 0;\n        };\n\n        // Filter items were size < minSize\n        for (const [key, info] of chunksInfoMap) {\n          if (removeMinSizeViolatingModules(info)) {\n            chunksInfoMap.delete(key);\n          } else if (!checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n            chunksInfoMap.delete(key);\n          }\n        }\n\n        /**\n         * @typedef {Object} MaxSizeQueueItem\n         * @property {SplitChunksSizes} minSize\n         * @property {SplitChunksSizes} maxAsyncSize\n         * @property {SplitChunksSizes} maxInitialSize\n         * @property {string} automaticNameDelimiter\n         * @property {string[]} keys\n         */\n\n        /** @type {Map<Chunk, MaxSizeQueueItem>} */\n        const maxSizeQueueMap = new Map();\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n            if (bestEntry === undefined || compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name;\n          // Variable for the new chunk (lazy created)\n          /** @type {Chunk} */\n          let newChunk;\n          // When no chunk name, check if we can reuse a chunk instead of creating a new one\n          let isExistingChunk = false;\n          let isReusedWithAllModules = false;\n          if (chunkName) {\n            const chunkByName = compilation.namedChunks.get(chunkName);\n            if (chunkByName !== undefined) {\n              newChunk = chunkByName;\n              const oldSize = item.chunks.size;\n              item.chunks.delete(newChunk);\n              isExistingChunk = item.chunks.size !== oldSize;\n            }\n          } else if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunkGraph.getNumberOfChunkModules(chunk) !== item.modules.size) {\n                continue;\n              }\n              if (item.chunks.size > 1 && chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n                continue;\n              }\n              for (const module of item.modules) {\n                if (!chunkGraph.isModuleInChunk(module, chunk)) {\n                  continue outer;\n                }\n              }\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n            }\n            if (newChunk) {\n              item.chunks.delete(newChunk);\n              chunkName = undefined;\n              isExistingChunk = true;\n              isReusedWithAllModules = true;\n            }\n          }\n          const enforced = item.cacheGroup._conditionalEnforce && checkMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n          const usedChunks = new Set(item.chunks);\n\n          // Check if maxRequests condition can be fulfilled\n          if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n            for (const chunk of usedChunks) {\n              // respect max requests\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n              if (isFinite(maxRequests) && getRequests(chunk) >= maxRequests) {\n                usedChunks.delete(chunk);\n              }\n            }\n          }\n          outer: for (const chunk of usedChunks) {\n            for (const module of item.modules) {\n              if (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n            }\n            usedChunks.delete(chunk);\n          }\n\n          // Were some (invalid) chunks removed from usedChunks?\n          // => readd all modules to the queue, as things could have been changed\n          if (usedChunks.size < item.chunks.size) {\n            if (isExistingChunk) usedChunks.add(newChunk);\n            if (usedChunks.size >= item.cacheGroup.minChunks) {\n              const chunksArr = Array.from(usedChunks);\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);\n              }\n            }\n            continue;\n          }\n\n          // Validate minRemainingSize constraint when a single chunk is left over\n          if (!enforced && item.cacheGroup._validateRemainingSize && usedChunks.size === 1) {\n            const [chunk] = usedChunks;\n            let chunkSizes = Object.create(null);\n            for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n              if (!item.modules.has(module)) {\n                for (const type of module.getSourceTypes()) {\n                  chunkSizes[type] = (chunkSizes[type] || 0) + module.size(type);\n                }\n              }\n            }\n            const violatingSizes = getViolatingMinSizes(chunkSizes, item.cacheGroup.minRemainingSize);\n            if (violatingSizes !== undefined) {\n              const oldModulesSize = item.modules.size;\n              removeModulesWithSourceType(item, violatingSizes);\n              if (item.modules.size > 0 && item.modules.size !== oldModulesSize) {\n                // queue this item again to be processed again\n                // without violating modules\n                chunksInfoMap.set(bestEntryKey, item);\n              }\n              continue;\n            }\n          }\n\n          // Create the new chunk if not reusing one\n          if (newChunk === undefined) {\n            newChunk = compilation.addChunk(chunkName);\n          }\n          // Walk through all chunks\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          }\n\n          // Add a note to the chunk\n          newChunk.chunkReason = (newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") + (isReusedWithAllModules ? \"reused as split chunk\" : \"split chunk\");\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`;\n          }\n          if (item.cacheGroup.filename) {\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n          if (item.cacheGroup.idHint) {\n            newChunk.idNameHints.add(item.cacheGroup.idHint);\n          }\n          if (!isReusedWithAllModules) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (!module.chunkCondition(newChunk, compilation)) continue;\n              // Add module to new chunk\n              chunkGraph.connectChunkAndModule(newChunk, module);\n              // Remove module from used chunks\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          }\n          if (Object.keys(item.cacheGroup.maxAsyncSize).length > 0 || Object.keys(item.cacheGroup.maxInitialSize).length > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.minSize, item.cacheGroup._minSizeForMaxSize, Math.max) : item.cacheGroup.minSize,\n              maxAsyncSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxAsyncSize, item.cacheGroup.maxAsyncSize, Math.min) : item.cacheGroup.maxAsyncSize,\n              maxInitialSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxInitialSize, item.cacheGroup.maxInitialSize, Math.min) : item.cacheGroup.maxInitialSize,\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          }\n\n          // remove all modules from other entries and update size\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, usedChunks)) {\n              // update modules and total size\n              // may remove it from the map when < minSize\n              let updated = false;\n              for (const module of item.modules) {\n                if (info.modules.has(module)) {\n                  // remove module\n                  info.modules.delete(module);\n                  // update size\n                  for (const key of module.getSourceTypes()) {\n                    info.sizes[key] -= module.size(key);\n                  }\n                  updated = true;\n                }\n              }\n              if (updated) {\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n                if (removeMinSizeViolatingModules(info) || !checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n              }\n            }\n          }\n        }\n        logger.timeEnd(\"queue\");\n        logger.time(\"maxSize\");\n\n        /** @type {Set<string>} */\n        const incorrectMinMaxSizeSet = new Set();\n        const {\n          outputOptions\n        } = compilation;\n\n        // Make sure that maxSize is fulfilled\n        const {\n          fallbackCacheGroup\n        } = this.options;\n        for (const chunk of Array.from(compilation.chunks)) {\n          const chunkConfig = maxSizeQueueMap.get(chunk);\n          const {\n            minSize,\n            maxAsyncSize,\n            maxInitialSize,\n            automaticNameDelimiter\n          } = chunkConfig || fallbackCacheGroup;\n          if (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk)) continue;\n          /** @type {SplitChunksSizes} */\n          let maxSize;\n          if (chunk.isOnlyInitial()) {\n            maxSize = maxInitialSize;\n          } else if (chunk.canBeInitial()) {\n            maxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n          } else {\n            maxSize = maxAsyncSize;\n          }\n          if (Object.keys(maxSize).length === 0) {\n            continue;\n          }\n          for (const key of Object.keys(maxSize)) {\n            const maxSizeValue = maxSize[key];\n            const minSizeValue = minSize[key];\n            if (typeof minSizeValue === \"number\" && minSizeValue > maxSizeValue) {\n              const keys = chunkConfig && chunkConfig.keys;\n              const warningKey = `${keys && keys.join()} ${minSizeValue} ${maxSizeValue}`;\n              if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                incorrectMinMaxSizeSet.add(warningKey);\n                compilation.warnings.push(new MinMaxSizeWarning(keys, minSizeValue, maxSizeValue));\n              }\n            }\n          }\n          const results = deterministicGroupingForModules({\n            minSize,\n            maxSize: mapObject(maxSize, (value, key) => {\n              const minSizeValue = minSize[key];\n              return typeof minSizeValue === \"number\" ? Math.max(value, minSizeValue) : value;\n            }),\n            items: chunkGraph.getChunkModulesIterable(chunk),\n            getKey(module) {\n              const cache = getKeyCache.get(module);\n              if (cache !== undefined) return cache;\n              const ident = cachedMakePathsRelative(module.identifier());\n              const nameForCondition = module.nameForCondition && module.nameForCondition();\n              const name = nameForCondition ? cachedMakePathsRelative(nameForCondition) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident, outputOptions);\n              const key = requestToId(fullKey);\n              getKeyCache.set(module, key);\n              return key;\n            },\n            getSize(module) {\n              const size = Object.create(null);\n              for (const key of module.getSourceTypes()) {\n                size[key] = module.size(key);\n              }\n              return size;\n            }\n          });\n          if (results.length <= 1) {\n            continue;\n          }\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key, outputOptions) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name, outputOptions);\n            }\n            if (i !== results.length - 1) {\n              const newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason;\n              // Add all modules to the new chunk\n              for (const module of group.items) {\n                if (!module.chunkCondition(newPart, compilation)) {\n                  continue;\n                }\n                // Add module to new chunk\n                chunkGraph.connectChunkAndModule(newPart, module);\n                // Remove module from used chunks\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            } else {\n              // change the chunk to be a part\n              chunk.name = name;\n            }\n          }\n        }\n        logger.timeEnd(\"maxSize\");\n      });\n    });\n  }\n};","map":{"version":3,"names":["Chunk","require","STAGE_ADVANCED","WebpackError","requestToId","isSubset","SortableSet","compareModulesByIdentifier","compareIterables","createHash","deterministicGrouping","makePathsRelative","memoize","MinMaxSizeWarning","defaultGetName","deterministicGroupingForModules","getKeyCache","WeakMap","hashFilename","name","outputOptions","digest","hashFunction","update","hashDigest","slice","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","mapObject","obj","fn","newObj","Object","create","key","keys","isOverlap","a","b","item","has","compareModuleIterables","compareEntries","diffPriority","cacheGroup","priority","diffCount","size","aSizeReduce","totalSize","sizes","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modules","modulesB","diff","sort","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","normalizeSizes","value","defaultSizeTypes","o","sizeType","mergeSizes","merged","i","arguments","assign","undefined","hasNonZeroSizes","combineSizes","combine","aKeys","Set","bKeys","result","checkMinSize","minSize","checkMinSizeReduction","minSizeReduction","chunkCount","getViolatingMinSizes","list","push","normalizeName","normalizeChunksFilter","normalizeCacheGroups","cacheGroups","handlers","option","RegExp","source","createCacheGroupSource","module","context","results","checkTest","cache","groups","Array","isArray","group","cachedSource","get","set","test","checkModuleType","type","checkModuleLayer","layer","nameForCondition","startsWith","options","maxSize","getName","chunksFilter","enforce","minRemainingSize","enforceSizeThreshold","maxAsyncSize","maxInitialSize","minChunks","maxAsyncRequests","maxInitialRequests","filename","idHint","automaticNameDelimiter","reuseExistingChunk","usedExports","exports","SplitChunksPlugin","constructor","fallbackCacheGroup","hidePathInfo","getCacheGroups","_cacheGroupCache","_getCacheGroup","cacheGroupSource","cacheEntry","Infinity","_validateSize","_validateRemainingSize","_minSizeForMaxSize","_conditionalEnforce","apply","compiler","cachedMakePathsRelative","bindContextCache","root","hooks","thisCompilation","tap","compilation","logger","getLogger","alreadyOptimized","unseal","optimizeChunks","stage","time","chunkGraph","moduleGraph","chunkIndexMap","Map","ZERO","BigInt","ONE","START","index","random","getKey","iterator","Symbol","next","done","first","raw","keyToString","toString","getChunkSetsInGraph","chunkSetsInGraph","singleChunkSets","getModuleChunksIterable","chunksKey","add","groupChunksByExports","exportsInfo","getExportsInfo","groupedByUsedExports","getUsageKey","runtime","values","groupedByExportsMap","getExportsChunkSetsInGraph","groupedChunks","from","groupChunkSetsByCount","chunkSets","chunkSetsByCount","chunksSet","count","array","getChunkSetsByCount","getExportsChunkSetsByCount","createGetCombinations","combinationsCache","setArray","getCombinationsFactory","getCombinations","getExportsCombinationsFactory","getExportsCombinations","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","alreadyValidatedParents","alreadyReportedErrors","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","existingChunk","namedChunks","parentValidationKey","debugId","valid","isInAllParents","queue","isInGroup","hasParent","parent","parentsIterable","errors","info","reuseableChunks","chunksKeys","oldSize","getSourceTypes","oldChunksKeysSize","timeEnd","getCombs","getCombsByUsedExports","comb","combs","chunkCombination","removeModulesWithSourceType","sourceTypes","types","some","delete","removeMinSizeViolatingModules","violatingSizes","maxSizeQueueMap","bestEntryKey","bestEntry","pair","chunkName","newChunk","isExistingChunk","isReusedWithAllModules","chunkByName","outer","getNumberOfChunkModules","getNumberOfEntryModules","isModuleInChunk","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","chunkSizes","getChunkModulesIterable","oldModulesSize","addChunk","split","chunkReason","filenameTemplate","idNameHints","chunkCondition","connectChunkAndModule","disconnectChunkAndModule","oldMaxSizeSettings","concat","updated","incorrectMinMaxSizeSet","chunkConfig","maxSizeValue","minSizeValue","warningKey","join","warnings","items","ident","identifier","replace","fullKey","getSize","newPart"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst WebpackError = require(\"../WebpackError\");\nconst { requestToId } = require(\"../ids/IdHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareIterables\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst memoize = require(\"../util/memoize\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\nconst defaultGetName = /** @type {GetName} */ (() => {});\n\nconst deterministicGroupingForModules =\n\t/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (\n\t\tdeterministicGrouping\n\t);\n\n/** @type {WeakMap<Module, string>} */\nconst getKeyCache = new WeakMap();\n\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\nconst hashFilename = (name, outputOptions) => {\n\tconst digest = /** @type {string} */ (\n\t\tcreateHash(outputOptions.hashFunction)\n\t\t\t.update(name)\n\t\t\t.digest(outputOptions.hashDigest)\n\t);\n\treturn digest.slice(0, 8);\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst mapObject = (obj, fn) => {\n\tconst newObj = Object.create(null);\n\tfor (const key of Object.keys(obj)) {\n\t\tnewObj[key] = fn(obj[key], key);\n\t}\n\treturn newObj;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n\tconst bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\treturn compareModuleIterables(modulesA, modulesB);\n};\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\nconst normalizeSizes = (value, defaultSizeTypes) => {\n\tif (typeof value === \"number\") {\n\t\t/** @type {Record<string, number>} */\n\t\tconst o = {};\n\t\tfor (const sizeType of defaultSizeTypes) o[sizeType] = value;\n\t\treturn o;\n\t} else if (typeof value === \"object\" && value !== null) {\n\t\treturn { ...value };\n\t} else {\n\t\treturn {};\n\t}\n};\n\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\nconst mergeSizes = (...sizes) => {\n\t/** @type {SplitChunksSizes} */\n\tlet merged = {};\n\tfor (let i = sizes.length - 1; i >= 0; i--) {\n\t\tmerged = Object.assign(merged, sizes[i]);\n\t}\n\treturn merged;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\nconst hasNonZeroSizes = sizes => {\n\tfor (const key of Object.keys(sizes)) {\n\t\tif (sizes[key] > 0) return true;\n\t}\n\treturn false;\n};\n\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\nconst combineSizes = (a, b, combine) => {\n\tconst aKeys = new Set(Object.keys(a));\n\tconst bKeys = new Set(Object.keys(b));\n\t/** @type {SplitChunksSizes} */\n\tconst result = {};\n\tfor (const key of aKeys) {\n\t\tif (bKeys.has(key)) {\n\t\t\tresult[key] = combine(a[key], b[key]);\n\t\t} else {\n\t\t\tresult[key] = a[key];\n\t\t}\n\t}\n\tfor (const key of bKeys) {\n\t\tif (!aKeys.has(key)) {\n\t\t\tresult[key] = b[key];\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\nconst checkMinSize = (sizes, minSize) => {\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n\tfor (const key of Object.keys(minSizeReduction)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size * chunkCount < minSizeReduction[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\nconst getViolatingMinSizes = (sizes, minSize) => {\n\tlet list;\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) {\n\t\t\tif (list === undefined) list = [key];\n\t\t\telse list.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\nconst totalSize = sizes => {\n\tlet size = 0;\n\tfor (const key of Object.keys(sizes)) {\n\t\tsize += sizes[key];\n\t}\n\treturn size;\n};\n\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\nconst normalizeName = name => {\n\tif (typeof name === \"string\") {\n\t\treturn () => name;\n\t}\n\tif (typeof name === \"function\") {\n\t\treturn /** @type {GetName} */ (name);\n\t}\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\nconst normalizeChunksFilter = chunks => {\n\tif (chunks === \"initial\") {\n\t\treturn INITIAL_CHUNK_FILTER;\n\t}\n\tif (chunks === \"async\") {\n\t\treturn ASYNC_CHUNK_FILTER;\n\t}\n\tif (chunks === \"all\") {\n\t\treturn ALL_CHUNK_FILTER;\n\t}\n\tif (typeof chunks === \"function\") {\n\t\treturn chunks;\n\t}\n};\n\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n\tif (typeof cacheGroups === \"function\") {\n\t\treturn cacheGroups;\n\t}\n\tif (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n\t\t/** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n\t\tconst handlers = [];\n\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\tconst option = cacheGroups[key];\n\t\t\tif (option === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof option === \"string\" || option instanceof RegExp) {\n\t\t\t\tconst source = createCacheGroupSource({}, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (checkTest(option, module, context)) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (typeof option === \"function\") {\n\t\t\t\tconst cache = new WeakMap();\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tconst result = option(module);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tconst groups = Array.isArray(result) ? result : [result];\n\t\t\t\t\t\tfor (const group of groups) {\n\t\t\t\t\t\t\tconst cachedSource = cache.get(group);\n\t\t\t\t\t\t\tif (cachedSource !== undefined) {\n\t\t\t\t\t\t\t\tresults.push(cachedSource);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst source = createCacheGroupSource(\n\t\t\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tdefaultSizeTypes\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcache.set(group, source);\n\t\t\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst source = createCacheGroupSource(option, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckTest(option.test, module, context) &&\n\t\t\t\t\t\tcheckModuleType(option.type, module) &&\n\t\t\t\t\t\tcheckModuleLayer(option.layer, module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @param {Module} module the current module\n\t\t * @param {CacheGroupsContext} context the current context\n\t\t * @returns {CacheGroupSource[]} the matching cache groups\n\t\t */\n\t\tconst fn = (module, context) => {\n\t\t\t/** @type {CacheGroupSource[]} */\n\t\t\tlet results = [];\n\t\t\tfor (const fn of handlers) {\n\t\t\t\tfn(module, context, results);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\treturn fn;\n\t}\n\treturn () => null;\n};\n\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\nconst checkTest = (test, module, context) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module, context);\n\t}\n\tif (typeof test === \"boolean\") return test;\n\tif (typeof test === \"string\") {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && name.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && test.test(name);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleType = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.type);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst type = module.type;\n\t\treturn test === type;\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst type = module.type;\n\t\treturn test.test(type);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleLayer = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.layer);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst layer = module.layer;\n\t\treturn test === \"\" ? !layer : layer && layer.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst layer = module.layer;\n\t\treturn test.test(layer);\n\t}\n\treturn false;\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\tconst minSizeReduction = normalizeSizes(\n\t\toptions.minSizeReduction,\n\t\tdefaultSizeTypes\n\t);\n\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\treturn {\n\t\tkey,\n\t\tpriority: options.priority,\n\t\tgetName: normalizeName(options.name),\n\t\tchunksFilter: normalizeChunksFilter(options.chunks),\n\t\tenforce: options.enforce,\n\t\tminSize,\n\t\tminSizeReduction,\n\t\tminRemainingSize: mergeSizes(\n\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\tminSize\n\t\t),\n\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\toptions.enforceSizeThreshold,\n\t\t\tdefaultSizeTypes\n\t\t),\n\t\tmaxAsyncSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tmaxInitialSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tminChunks: options.minChunks,\n\t\tmaxAsyncRequests: options.maxAsyncRequests,\n\t\tmaxInitialRequests: options.maxInitialRequests,\n\t\tfilename: options.filename,\n\t\tidHint: options.idHint,\n\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\treuseExistingChunk: options.reuseExistingChunk,\n\t\tusedExports: options.usedExports\n\t};\n};\n\nmodule.exports = class SplitChunksPlugin {\n\t/**\n\t * @param {OptimizationSplitChunksOptions=} options plugin options\n\t */\n\tconstructor(options = {}) {\n\t\tconst defaultSizeTypes = options.defaultSizeTypes || [\n\t\t\t\"javascript\",\n\t\t\t\"unknown\"\n\t\t];\n\t\tconst fallbackCacheGroup = options.fallbackCacheGroup || {};\n\t\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\t\tconst minSizeReduction = normalizeSizes(\n\t\t\toptions.minSizeReduction,\n\t\t\tdefaultSizeTypes\n\t\t);\n\t\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n\t\t/** @type {SplitChunksOptions} */\n\t\tthis.options = {\n\t\t\tchunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n\t\t\tdefaultSizeTypes,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\t\tminSize\n\t\t\t),\n\t\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\t\toptions.enforceSizeThreshold,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: normalizeCacheGroups(\n\t\t\t\toptions.cacheGroups,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tgetName: options.name ? normalizeName(options.name) : defaultGetName,\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tusedExports: options.usedExports,\n\t\t\tfallbackCacheGroup: {\n\t\t\t\tchunksFilter: normalizeChunksFilter(\n\t\t\t\t\tfallbackCacheGroup.chunks || options.chunks || \"all\"\n\t\t\t\t),\n\t\t\t\tminSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes),\n\t\t\t\t\tminSize\n\t\t\t\t),\n\t\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\tfallbackCacheGroup.automaticNameDelimiter ||\n\t\t\t\t\toptions.automaticNameDelimiter ||\n\t\t\t\t\t\"~\"\n\t\t\t}\n\t\t};\n\n\t\t/** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\t\tthis._cacheGroupCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {CacheGroupSource} cacheGroupSource source\n\t * @returns {CacheGroup} the cache group (cached)\n\t */\n\t_getCacheGroup(cacheGroupSource) {\n\t\tconst cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst minSize = mergeSizes(\n\t\t\tcacheGroupSource.minSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSize\n\t\t);\n\t\tconst minSizeReduction = mergeSizes(\n\t\t\tcacheGroupSource.minSizeReduction,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSizeReduction\n\t\t);\n\t\tconst minRemainingSize = mergeSizes(\n\t\t\tcacheGroupSource.minRemainingSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minRemainingSize\n\t\t);\n\t\tconst enforceSizeThreshold = mergeSizes(\n\t\t\tcacheGroupSource.enforceSizeThreshold,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold\n\t\t);\n\t\tconst cacheGroup = {\n\t\t\tkey: cacheGroupSource.key,\n\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\tchunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize,\n\t\t\tenforceSizeThreshold,\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxAsyncSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxAsyncSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxInitialSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxInitialSize\n\t\t\t),\n\t\t\tminChunks:\n\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? 1\n\t\t\t\t\t: this.options.minChunks,\n\t\t\tmaxAsyncRequests:\n\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\tmaxInitialRequests:\n\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\tgetName:\n\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t: this.options.getName,\n\t\t\tusedExports:\n\t\t\t\tcacheGroupSource.usedExports !== undefined\n\t\t\t\t\t? cacheGroupSource.usedExports\n\t\t\t\t\t: this.options.usedExports,\n\t\t\tfilename:\n\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t: this.options.filename,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\tidHint:\n\t\t\t\tcacheGroupSource.idHint !== undefined\n\t\t\t\t\t? cacheGroupSource.idHint\n\t\t\t\t\t: cacheGroupSource.key,\n\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n\t\t\t_validateSize: hasNonZeroSizes(minSize),\n\t\t\t_validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n\t\t\t_minSizeForMaxSize: mergeSizes(\n\t\t\t\tcacheGroupSource.minSize,\n\t\t\t\tthis.options.minSize\n\t\t\t),\n\t\t\t_conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n\t\t};\n\t\tthis._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\t\treturn cacheGroup;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tconst logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"SplitChunksPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\tlogger.time(\"prepare\");\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\t/** @type {Map<Chunk, bigint>} */\n\t\t\t\t\tconst chunkIndexMap = new Map();\n\t\t\t\t\tconst ZERO = BigInt(\"0\");\n\t\t\t\t\tconst ONE = BigInt(\"1\");\n\t\t\t\t\tconst START = ONE << BigInt(\"31\");\n\t\t\t\t\tlet index = START;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tchunkIndexMap.set(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tindex | BigInt((Math.random() * 0x7fffffff) | 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tindex = index << ONE;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Iterable<Chunk>} chunks list of chunks\n\t\t\t\t\t * @returns {bigint | Chunk} key of the chunks\n\t\t\t\t\t */\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\tconst iterator = chunks[Symbol.iterator]();\n\t\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\t\tif (result.done) return ZERO;\n\t\t\t\t\t\tconst first = result.value;\n\t\t\t\t\t\tresult = iterator.next();\n\t\t\t\t\t\tif (result.done) return first;\n\t\t\t\t\t\tlet key =\n\t\t\t\t\t\t\tchunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\t\t\t\t\t\twhile (!(result = iterator.next()).done) {\n\t\t\t\t\t\t\tconst raw = chunkIndexMap.get(result.value);\n\t\t\t\t\t\t\tkey = key ^ raw;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t};\n\t\t\t\t\tconst keyToString = key => {\n\t\t\t\t\t\tif (typeof key === \"bigint\") return key.toString(16);\n\t\t\t\t\t\treturn chunkIndexMap.get(key).toString(16);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\tif (typeof chunksKey === \"bigint\") {\n\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsingleChunkSets.add(chunksKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module the module\n\t\t\t\t\t * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n\t\t\t\t\t */\n\t\t\t\t\tconst groupChunksByExports = module => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst groupedByUsedExports = new Map();\n\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n\t\t\t\t\t\t\tconst key = exportsInfo.getUsageKey(chunk.runtime);\n\t\t\t\t\t\t\tconst list = groupedByUsedExports.get(key);\n\t\t\t\t\t\t\tif (list !== undefined) {\n\t\t\t\t\t\t\t\tlist.push(chunk);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgroupedByUsedExports.set(key, [chunk]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn groupedByUsedExports.values();\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<Module, Iterable<Chunk[]>>} */\n\t\t\t\t\tconst groupedByExportsMap = new Map();\n\n\t\t\t\t\tconst getExportsChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst groupedChunks = Array.from(groupChunksByExports(module));\n\t\t\t\t\t\t\tgroupedByExportsMap.set(module, groupedChunks);\n\t\t\t\t\t\t\tfor (const chunks of groupedChunks) {\n\t\t\t\t\t\t\t\tif (chunks.length === 1) {\n\t\t\t\t\t\t\t\t\tsingleChunkSets.add(chunks[0]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst chunksKey = /** @type {bigint} */ (getKey(chunks));\n\t\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\tconst groupChunkSetsByCount = chunkSets => {\n\t\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\t\tfor (const chunksSet of chunkSets) {\n\t\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chunkSetsByCount;\n\t\t\t\t\t};\n\t\t\t\t\tconst getChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tconst getExportsChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst createGetCombinations = (\n\t\t\t\t\t\tchunkSets,\n\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\tchunkSetsByCount\n\t\t\t\t\t) => {\n\t\t\t\t\t\t/** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n\t\t\t\t\t\tconst combinationsCache = new Map();\n\n\t\t\t\t\t\treturn key => {\n\t\t\t\t\t\t\tconst cacheEntry = combinationsCache.get(key);\n\t\t\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\t\t\t\t\tif (key instanceof Chunk) {\n\t\t\t\t\t\t\t\tconst result = [key];\n\t\t\t\t\t\t\t\tcombinationsCache.set(key, result);\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst chunksSet = chunkSets.get(key);\n\t\t\t\t\t\t\t/** @type {(Set<Chunk> | Chunk)[]} */\n\t\t\t\t\t\t\tconst array = [chunksSet];\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const chunk of singleChunkSets) {\n\t\t\t\t\t\t\t\tif (chunksSet.has(chunk)) {\n\t\t\t\t\t\t\t\t\tarray.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsCache.set(key, array);\n\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } = getChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getCombinations = key => getCombinationsFactory()(key);\n\n\t\t\t\t\tconst getExportsCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } =\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetExportsChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getExportsCombinations = key =>\n\t\t\t\t\t\tgetExportsCombinationsFactory()(key);\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {bigint | Chunk} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk> | Chunk} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tif (chunks instanceof Chunk) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunks)) selectedChunks.push(chunks);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<string, boolean>} */\n\t\t\t\t\tconst alreadyValidatedParents = new Map();\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst alreadyReportedErrors = new Set();\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {CacheGroup} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Check if the name is ok\n\t\t\t\t\t\tconst existingChunk = compilation.namedChunks.get(name);\n\t\t\t\t\t\tif (existingChunk) {\n\t\t\t\t\t\t\tconst parentValidationKey = `${name}|${\n\t\t\t\t\t\t\t\ttypeof selectedChunksKey === \"bigint\"\n\t\t\t\t\t\t\t\t\t? selectedChunksKey\n\t\t\t\t\t\t\t\t\t: selectedChunksKey.debugId\n\t\t\t\t\t\t\t}`;\n\t\t\t\t\t\t\tconst valid = alreadyValidatedParents.get(parentValidationKey);\n\t\t\t\t\t\t\tif (valid === false) return;\n\t\t\t\t\t\t\tif (valid === undefined) {\n\t\t\t\t\t\t\t\t// Module can only be moved into the existing chunk if the existing chunk\n\t\t\t\t\t\t\t\t// is a parent of all selected chunks\n\t\t\t\t\t\t\t\tlet isInAllParents = true;\n\t\t\t\t\t\t\t\t/** @type {Set<ChunkGroup>} */\n\t\t\t\t\t\t\t\tconst queue = new Set();\n\t\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\t\tfor (const group of chunk.groupsIterable) {\n\t\t\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\t\tif (existingChunk.isInGroup(group)) continue;\n\t\t\t\t\t\t\t\t\tlet hasParent = false;\n\t\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\t\thasParent = true;\n\t\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!hasParent) {\n\t\t\t\t\t\t\t\t\t\tisInAllParents = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst valid = isInAllParents;\n\t\t\t\t\t\t\t\talreadyValidatedParents.set(parentValidationKey, valid);\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tif (!alreadyReportedErrors.has(name)) {\n\t\t\t\t\t\t\t\t\t\talreadyReportedErrors.add(name);\n\t\t\t\t\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t'HINT: You can omit \"name\" to automatically create a name.\\n' +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remove this entrypoint and add modules to cache group's 'test' instead. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"See migration guide of more info.\"\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Otherwise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name\n\t\t\t\t\t\t\t\t? ` name:${name}`\n\t\t\t\t\t\t\t\t: ` chunks:${keyToString(selectedChunksKey)}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tcompareModulesByIdentifier\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsizes: {},\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\tinfo.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldChunksKeysSize = info.chunksKeys.size;\n\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\tif (oldChunksKeysSize !== info.chunksKeys.size) {\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.timeEnd(\"prepare\");\n\n\t\t\t\t\tlogger.time(\"modules\");\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module, context);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values (usedExports = false)\n\t\t\t\t\t\tconst getCombs = memoize(() => {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\treturn getCombinations(chunksKey);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Prepare some values (usedExports = true)\n\t\t\t\t\t\tconst getCombsByUsedExports = memoize(() => {\n\t\t\t\t\t\t\t// fill the groupedByExportsMap\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\t\t/** @type {Set<Set<Chunk> | Chunk>} */\n\t\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\t\tconst groupedByUsedExports = groupedByExportsMap.get(module);\n\t\t\t\t\t\t\tfor (const chunks of groupedByUsedExports) {\n\t\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\t\tfor (const comb of getExportsCombinations(chunksKey))\n\t\t\t\t\t\t\t\t\tset.add(comb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn set;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst cacheGroup = this._getCacheGroup(cacheGroupSource);\n\n\t\t\t\t\t\t\tconst combs = cacheGroup.usedExports\n\t\t\t\t\t\t\t\t? getCombsByUsedExports()\n\t\t\t\t\t\t\t\t: getCombs();\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tconst count =\n\t\t\t\t\t\t\t\t\tchunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n\t\t\t\t\t\t\t\tif (count < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst { chunks: selectedChunks, key: selectedChunksKey } =\n\t\t\t\t\t\t\t\t\tgetSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"modules\");\n\n\t\t\t\t\tlogger.time(\"queue\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @param {string[]} sourceTypes source types to be removed\n\t\t\t\t\t */\n\t\t\t\t\tconst removeModulesWithSourceType = (info, sourceTypes) => {\n\t\t\t\t\t\tfor (const module of info.modules) {\n\t\t\t\t\t\t\tconst types = module.getSourceTypes();\n\t\t\t\t\t\t\tif (sourceTypes.some(type => types.has(type))) {\n\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\tfor (const type of types) {\n\t\t\t\t\t\t\t\t\tinfo.sizes[type] -= module.size(type);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @returns {boolean} true, if entry become empty\n\t\t\t\t\t */\n\t\t\t\t\tconst removeMinSizeViolatingModules = info => {\n\t\t\t\t\t\tif (!info.cacheGroup._validateSize) return false;\n\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\tinfo.cacheGroup.minSize\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (violatingSizes === undefined) return false;\n\t\t\t\t\t\tremoveModulesWithSourceType(info, violatingSizes);\n\t\t\t\t\t\treturn info.modules.size === 0;\n\t\t\t\t\t};\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\tif (removeMinSizeViolatingModules(info)) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} MaxSizeQueueItem\n\t\t\t\t\t * @property {SplitChunksSizes} minSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxAsyncSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxInitialSize\n\t\t\t\t\t * @property {string} automaticNameDelimiter\n\t\t\t\t\t * @property {string[]} keys\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {Map<Chunk, MaxSizeQueueItem>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tbestEntry === undefined ||\n\t\t\t\t\t\t\t\tcompareEntries(bestEntry, info) < 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isExistingChunk = false;\n\t\t\t\t\t\tlet isReusedWithAllModules = false;\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tconst chunkByName = compilation.namedChunks.get(chunkName);\n\t\t\t\t\t\t\tif (chunkByName !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk = chunkByName;\n\t\t\t\t\t\t\t\tconst oldSize = item.chunks.size;\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tisExistingChunk = item.chunks.size !== oldSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) !==\n\t\t\t\t\t\t\t\t\titem.modules.size\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.chunks.size > 1 &&\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfEntryModules(chunk) > 0\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newChunk) {\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisExistingChunk = true;\n\t\t\t\t\t\t\t\tisReusedWithAllModules = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\tcheckMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n\n\t\t\t\t\t\tconst usedChunks = new Set(item.chunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < item.chunks.size) {\n\t\t\t\t\t\t\tif (isExistingChunk) usedChunks.add(newChunk);\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Validate minRemainingSize constraint when a single chunk is left over\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\titem.cacheGroup._validateRemainingSize &&\n\t\t\t\t\t\t\tusedChunks.size === 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst [chunk] = usedChunks;\n\t\t\t\t\t\t\tlet chunkSizes = Object.create(null);\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (!item.modules.has(module)) {\n\t\t\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\tchunkSizes[type] =\n\t\t\t\t\t\t\t\t\t\t\t(chunkSizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\t\tchunkSizes,\n\t\t\t\t\t\t\t\titem.cacheGroup.minRemainingSize\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (violatingSizes !== undefined) {\n\t\t\t\t\t\t\t\tconst oldModulesSize = item.modules.size;\n\t\t\t\t\t\t\t\tremoveModulesWithSourceType(item, violatingSizes);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.modules.size > 0 &&\n\t\t\t\t\t\t\t\t\titem.modules.size !== oldModulesSize\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// queue this item again to be processed again\n\t\t\t\t\t\t\t\t\t// without violating modules\n\t\t\t\t\t\t\t\t\tchunksInfoMap.set(bestEntryKey, item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (newChunk === undefined) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason =\n\t\t\t\t\t\t\t(newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") +\n\t\t\t\t\t\t\t(isReusedWithAllModules\n\t\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t\t: \"split chunk\");\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.idHint) {\n\t\t\t\t\t\t\tnewChunk.idNameHints.add(item.cacheGroup.idHint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReusedWithAllModules) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk, compilation)) continue;\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxAsyncSize).length > 0 ||\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxInitialSize).length > 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.minSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup._minSizeForMaxSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.max\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.minSize,\n\t\t\t\t\t\t\t\tmaxAsyncSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\tmaxInitialSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tlet updated = false;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (info.modules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t// remove module\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t\t// update size\n\t\t\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes[key] -= module.size(key);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (updated) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tremoveMinSizeViolatingModules(info) ||\n\t\t\t\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"queue\");\n\n\t\t\t\t\tlogger.time(\"maxSize\");\n\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\tconst { outputOptions } = compilation;\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tconst { fallbackCacheGroup } = this.options;\n\t\t\t\t\tfor (const chunk of Array.from(compilation.chunks)) {\n\t\t\t\t\t\tconst chunkConfig = maxSizeQueueMap.get(chunk);\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxAsyncSize,\n\t\t\t\t\t\t\tmaxInitialSize,\n\t\t\t\t\t\t\tautomaticNameDelimiter\n\t\t\t\t\t\t} = chunkConfig || fallbackCacheGroup;\n\t\t\t\t\t\tif (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t/** @type {SplitChunksSizes} */\n\t\t\t\t\t\tlet maxSize;\n\t\t\t\t\t\tif (chunk.isOnlyInitial()) {\n\t\t\t\t\t\t\tmaxSize = maxInitialSize;\n\t\t\t\t\t\t} else if (chunk.canBeInitial()) {\n\t\t\t\t\t\t\tmaxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxSize = maxAsyncSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Object.keys(maxSize).length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const key of Object.keys(maxSize)) {\n\t\t\t\t\t\t\tconst maxSizeValue = maxSize[key];\n\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof minSizeValue === \"number\" &&\n\t\t\t\t\t\t\t\tminSizeValue > maxSizeValue\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst keys = chunkConfig && chunkConfig.keys;\n\t\t\t\t\t\t\t\tconst warningKey = `${\n\t\t\t\t\t\t\t\t\tkeys && keys.join()\n\t\t\t\t\t\t\t\t} ${minSizeValue} ${maxSizeValue}`;\n\t\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSizeValue, maxSizeValue)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxSize: mapObject(maxSize, (value, key) => {\n\t\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\t\treturn typeof minSizeValue === \"number\"\n\t\t\t\t\t\t\t\t\t? Math.max(value, minSizeValue)\n\t\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\titems: chunkGraph.getChunkModulesIterable(chunk),\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst cache = getKeyCache.get(module);\n\t\t\t\t\t\t\t\tif (cache !== undefined) return cache;\n\t\t\t\t\t\t\t\tconst ident = cachedMakePathsRelative(module.identifier());\n\t\t\t\t\t\t\t\tconst nameForCondition =\n\t\t\t\t\t\t\t\t\tmodule.nameForCondition && module.nameForCondition();\n\t\t\t\t\t\t\t\tconst name = nameForCondition\n\t\t\t\t\t\t\t\t\t? cachedMakePathsRelative(nameForCondition)\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(ident, outputOptions);\n\t\t\t\t\t\t\t\tconst key = requestToId(fullKey);\n\t\t\t\t\t\t\t\tgetKeyCache.set(module, key);\n\t\t\t\t\t\t\t\treturn key;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\tconst size = Object.create(null);\n\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\tsize[key] = module.size(key);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (results.length <= 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key, outputOptions)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name, outputOptions);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tconst newPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart, compilation)) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"maxSize\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}