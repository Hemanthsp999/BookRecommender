{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst forEachBail = require(\"./forEachBail\");\nconst {\n  PathType,\n  getType\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {string | Array<string> | false} Alias */\n/** @typedef {{alias: Alias, name: string, onlyModule?: boolean}} AliasOption */\n\nmodule.exports = class AliasPlugin {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {AliasOption | Array<AliasOption>} options options\n   * @param {string | ResolveStepHook} target target\n   */\n  constructor(source, options, target) {\n    this.source = source;\n    this.options = Array.isArray(options) ? options : [options];\n    this.target = target;\n  }\n\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n  apply(resolver) {\n    const target = resolver.ensureHook(this.target);\n    /**\n     * @param {string} maybeAbsolutePath path\n     * @returns {null|string} absolute path with slash ending\n     */\n    const getAbsolutePathWithSlashEnding = maybeAbsolutePath => {\n      const type = getType(maybeAbsolutePath);\n      if (type === PathType.AbsolutePosix || type === PathType.AbsoluteWin) {\n        return resolver.join(maybeAbsolutePath, \"_\").slice(0, -1);\n      }\n      return null;\n    };\n    /**\n     * @param {string} path path\n     * @param {string} maybeSubPath sub path\n     * @returns {boolean} true, if path is sub path\n     */\n    const isSubPath = (path, maybeSubPath) => {\n      const absolutePath = getAbsolutePathWithSlashEnding(maybeSubPath);\n      if (!absolutePath) return false;\n      return path.startsWith(absolutePath);\n    };\n    resolver.getHook(this.source).tapAsync(\"AliasPlugin\", (request, resolveContext, callback) => {\n      const innerRequest = request.request || request.path;\n      if (!innerRequest) return callback();\n      forEachBail(this.options, (item, callback) => {\n        /** @type {boolean} */\n        let shouldStop = false;\n        if (innerRequest === item.name || !item.onlyModule && (request.request ? innerRequest.startsWith(`${item.name}/`) : isSubPath(innerRequest, item.name))) {\n          /** @type {string} */\n          const remainingRequest = innerRequest.slice(item.name.length);\n          /**\n           * @param {Alias} alias alias\n           * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n           * @returns {void}\n           */\n          const resolveWithAlias = (alias, callback) => {\n            if (alias === false) {\n              /** @type {ResolveRequest} */\n              const ignoreObj = {\n                ...request,\n                path: false\n              };\n              if (typeof resolveContext.yield === \"function\") {\n                resolveContext.yield(ignoreObj);\n                return callback(null, null);\n              }\n              return callback(null, ignoreObj);\n            }\n            if (innerRequest !== alias && !innerRequest.startsWith(alias + \"/\")) {\n              shouldStop = true;\n              const newRequestStr = alias + remainingRequest;\n              /** @type {ResolveRequest} */\n              const obj = {\n                ...request,\n                request: newRequestStr,\n                fullySpecified: false\n              };\n              return resolver.doResolve(target, obj, \"aliased with mapping '\" + item.name + \"': '\" + alias + \"' to '\" + newRequestStr + \"'\", resolveContext, (err, result) => {\n                if (err) return callback(err);\n                if (result) return callback(null, result);\n                return callback();\n              });\n            }\n            return callback();\n          };\n          /**\n           * @param {null|Error} [err] error\n           * @param {null|ResolveRequest} [result] result\n           * @returns {void}\n           */\n          const stoppingCallback = (err, result) => {\n            if (err) return callback(err);\n            if (result) return callback(null, result);\n            // Don't allow other aliasing or raw request\n            if (shouldStop) return callback(null, null);\n            return callback();\n          };\n          if (Array.isArray(item.alias)) {\n            return forEachBail(item.alias, resolveWithAlias, stoppingCallback);\n          } else {\n            return resolveWithAlias(item.alias, stoppingCallback);\n          }\n        }\n        return callback();\n      }, callback);\n    });\n  }\n};","map":{"version":3,"names":["forEachBail","require","PathType","getType","module","exports","AliasPlugin","constructor","source","options","target","Array","isArray","apply","resolver","ensureHook","getAbsolutePathWithSlashEnding","maybeAbsolutePath","type","AbsolutePosix","AbsoluteWin","join","slice","isSubPath","path","maybeSubPath","absolutePath","startsWith","getHook","tapAsync","request","resolveContext","callback","innerRequest","item","shouldStop","name","onlyModule","remainingRequest","length","resolveWithAlias","alias","ignoreObj","yield","newRequestStr","obj","fullySpecified","doResolve","err","result","stoppingCallback"],"sources":["/home/hemanth/react-project/client/node_modules/enhanced-resolve/lib/AliasPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst forEachBail = require(\"./forEachBail\");\nconst { PathType, getType } = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {string | Array<string> | false} Alias */\n/** @typedef {{alias: Alias, name: string, onlyModule?: boolean}} AliasOption */\n\nmodule.exports = class AliasPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {AliasOption | Array<AliasOption>} options options\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = Array.isArray(options) ? options : [options];\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\t/**\n\t\t * @param {string} maybeAbsolutePath path\n\t\t * @returns {null|string} absolute path with slash ending\n\t\t */\n\t\tconst getAbsolutePathWithSlashEnding = maybeAbsolutePath => {\n\t\t\tconst type = getType(maybeAbsolutePath);\n\t\t\tif (type === PathType.AbsolutePosix || type === PathType.AbsoluteWin) {\n\t\t\t\treturn resolver.join(maybeAbsolutePath, \"_\").slice(0, -1);\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\t/**\n\t\t * @param {string} path path\n\t\t * @param {string} maybeSubPath sub path\n\t\t * @returns {boolean} true, if path is sub path\n\t\t */\n\t\tconst isSubPath = (path, maybeSubPath) => {\n\t\t\tconst absolutePath = getAbsolutePathWithSlashEnding(maybeSubPath);\n\t\t\tif (!absolutePath) return false;\n\t\t\treturn path.startsWith(absolutePath);\n\t\t};\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"AliasPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst innerRequest = request.request || request.path;\n\t\t\t\tif (!innerRequest) return callback();\n\t\t\t\tforEachBail(\n\t\t\t\t\tthis.options,\n\t\t\t\t\t(item, callback) => {\n\t\t\t\t\t\t/** @type {boolean} */\n\t\t\t\t\t\tlet shouldStop = false;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinnerRequest === item.name ||\n\t\t\t\t\t\t\t(!item.onlyModule &&\n\t\t\t\t\t\t\t\t(request.request\n\t\t\t\t\t\t\t\t\t? innerRequest.startsWith(`${item.name}/`)\n\t\t\t\t\t\t\t\t\t: isSubPath(innerRequest, item.name)))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\tconst remainingRequest = innerRequest.slice(item.name.length);\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Alias} alias alias\n\t\t\t\t\t\t\t * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst resolveWithAlias = (alias, callback) => {\n\t\t\t\t\t\t\t\tif (alias === false) {\n\t\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\t\t\t\tconst ignoreObj = {\n\t\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\t\tpath: false\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif (typeof resolveContext.yield === \"function\") {\n\t\t\t\t\t\t\t\t\t\tresolveContext.yield(ignoreObj);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, null);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn callback(null, ignoreObj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tinnerRequest !== alias &&\n\t\t\t\t\t\t\t\t\t!innerRequest.startsWith(alias + \"/\")\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tshouldStop = true;\n\t\t\t\t\t\t\t\t\tconst newRequestStr = alias + remainingRequest;\n\t\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\t\t\t\trequest: newRequestStr,\n\t\t\t\t\t\t\t\t\t\tfullySpecified: false\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\t\t\"aliased with mapping '\" +\n\t\t\t\t\t\t\t\t\t\t\titem.name +\n\t\t\t\t\t\t\t\t\t\t\t\"': '\" +\n\t\t\t\t\t\t\t\t\t\t\talias +\n\t\t\t\t\t\t\t\t\t\t\t\"' to '\" +\n\t\t\t\t\t\t\t\t\t\t\tnewRequestStr +\n\t\t\t\t\t\t\t\t\t\t\t\"'\",\n\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {null|Error} [err] error\n\t\t\t\t\t\t\t * @param {null|ResolveRequest} [result] result\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst stoppingCallback = (err, result) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\t\t// Don't allow other aliasing or raw request\n\t\t\t\t\t\t\t\tif (shouldStop) return callback(null, null);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (Array.isArray(item.alias)) {\n\t\t\t\t\t\t\t\treturn forEachBail(\n\t\t\t\t\t\t\t\t\titem.alias,\n\t\t\t\t\t\t\t\t\tresolveWithAlias,\n\t\t\t\t\t\t\t\t\tstoppingCallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn resolveWithAlias(item.alias, stoppingCallback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}