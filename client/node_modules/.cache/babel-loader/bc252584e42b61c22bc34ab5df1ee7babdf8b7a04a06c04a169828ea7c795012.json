{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst {\n  HookMap,\n  SyncHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\nconst {\n  cachedCleverMerge,\n  removeOperations,\n  resolveByProperty\n} = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n\n// need to be hoisted on module level for caching identity\nconst EMPTY_RESOLVE_OPTIONS = {};\n\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\nconst convertToResolveOptions = resolveOptionsWithDepType => {\n  const {\n    dependencyType,\n    plugins,\n    ...remaining\n  } = resolveOptionsWithDepType;\n\n  // check type compat\n  /** @type {Partial<ResolveOptions>} */\n  const partialOptions = {\n    ...remaining,\n    plugins: plugins && /** @type {ResolvePluginInstance[]} */\n    plugins.filter(item => item !== \"...\")\n  };\n  if (!partialOptions.fileSystem) {\n    throw new Error(\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\");\n  }\n  // These weird types validate that we checked all non-optional properties\n  const options = /** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */\n  partialOptions;\n  return removeOperations(resolveByProperty(options, \"byDependency\", dependencyType));\n};\n\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\nmodule.exports = class ResolverFactory {\n  constructor() {\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n      resolveOptions: new HookMap(() => new SyncWaterfallHook([\"resolveOptions\"])),\n      /** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n      resolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"]))\n    });\n    /** @type {Map<string, ResolverCache>} */\n    this.cache = new Map();\n  }\n\n  /**\n   * @param {string} type type of resolver\n   * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n   * @returns {ResolverWithOptions} the resolver\n   */\n  get(type) {\n    let resolveOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_RESOLVE_OPTIONS;\n    let typedCaches = this.cache.get(type);\n    if (!typedCaches) {\n      typedCaches = {\n        direct: new WeakMap(),\n        stringified: new Map()\n      };\n      this.cache.set(type, typedCaches);\n    }\n    const cachedResolver = typedCaches.direct.get(resolveOptions);\n    if (cachedResolver) {\n      return cachedResolver;\n    }\n    const ident = JSON.stringify(resolveOptions);\n    const resolver = typedCaches.stringified.get(ident);\n    if (resolver) {\n      typedCaches.direct.set(resolveOptions, resolver);\n      return resolver;\n    }\n    const newResolver = this._create(type, resolveOptions);\n    typedCaches.direct.set(resolveOptions, newResolver);\n    typedCaches.stringified.set(ident, newResolver);\n    return newResolver;\n  }\n\n  /**\n   * @param {string} type type of resolver\n   * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n   * @returns {ResolverWithOptions} the resolver\n   */\n  _create(type, resolveOptionsWithDepType) {\n    /** @type {ResolveOptionsWithDependencyType} */\n    const originalResolveOptions = {\n      ...resolveOptionsWithDepType\n    };\n    const resolveOptions = convertToResolveOptions(this.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType));\n    const resolver = /** @type {ResolverWithOptions} */\n    Factory.createResolver(resolveOptions);\n    if (!resolver) {\n      throw new Error(\"No resolver created\");\n    }\n    /** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n    const childCache = new WeakMap();\n    resolver.withOptions = options => {\n      const cacheEntry = childCache.get(options);\n      if (cacheEntry !== undefined) return cacheEntry;\n      const mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n      const resolver = this.get(type, mergedOptions);\n      childCache.set(options, resolver);\n      return resolver;\n    };\n    this.hooks.resolver.for(type).call(resolver, resolveOptions, originalResolveOptions);\n    return resolver;\n  }\n};","map":{"version":3,"names":["Factory","require","ResolverFactory","HookMap","SyncHook","SyncWaterfallHook","cachedCleverMerge","removeOperations","resolveByProperty","EMPTY_RESOLVE_OPTIONS","convertToResolveOptions","resolveOptionsWithDepType","dependencyType","plugins","remaining","partialOptions","filter","item","fileSystem","Error","options","module","exports","constructor","hooks","Object","freeze","resolveOptions","resolver","cache","Map","get","type","arguments","length","undefined","typedCaches","direct","WeakMap","stringified","set","cachedResolver","ident","JSON","stringify","newResolver","_create","originalResolveOptions","for","call","createResolver","childCache","withOptions","cacheEntry","mergedOptions"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/ResolverFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst { HookMap, SyncHook, SyncWaterfallHook } = require(\"tapable\");\nconst {\n\tcachedCleverMerge,\n\tremoveOperations,\n\tresolveByProperty\n} = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n\n// need to be hoisted on module level for caching identity\nconst EMPTY_RESOLVE_OPTIONS = {};\n\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\nconst convertToResolveOptions = resolveOptionsWithDepType => {\n\tconst { dependencyType, plugins, ...remaining } = resolveOptionsWithDepType;\n\n\t// check type compat\n\t/** @type {Partial<ResolveOptions>} */\n\tconst partialOptions = {\n\t\t...remaining,\n\t\tplugins:\n\t\t\tplugins &&\n\t\t\t/** @type {ResolvePluginInstance[]} */ (\n\t\t\t\tplugins.filter(item => item !== \"...\")\n\t\t\t)\n\t};\n\n\tif (!partialOptions.fileSystem) {\n\t\tthrow new Error(\n\t\t\t\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\"\n\t\t);\n\t}\n\t// These weird types validate that we checked all non-optional properties\n\tconst options =\n\t\t/** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */ (\n\t\t\tpartialOptions\n\t\t);\n\n\treturn removeOperations(\n\t\tresolveByProperty(options, \"byDependency\", dependencyType)\n\t);\n};\n\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\nmodule.exports = class ResolverFactory {\n\tconstructor() {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolveOptions: new HookMap(\n\t\t\t\t() => new SyncWaterfallHook([\"resolveOptions\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolver: new HookMap(\n\t\t\t\t() => new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"])\n\t\t\t)\n\t\t});\n\t\t/** @type {Map<string, ResolverCache>} */\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\tget(type, resolveOptions = EMPTY_RESOLVE_OPTIONS) {\n\t\tlet typedCaches = this.cache.get(type);\n\t\tif (!typedCaches) {\n\t\t\ttypedCaches = {\n\t\t\t\tdirect: new WeakMap(),\n\t\t\t\tstringified: new Map()\n\t\t\t};\n\t\t\tthis.cache.set(type, typedCaches);\n\t\t}\n\t\tconst cachedResolver = typedCaches.direct.get(resolveOptions);\n\t\tif (cachedResolver) {\n\t\t\treturn cachedResolver;\n\t\t}\n\t\tconst ident = JSON.stringify(resolveOptions);\n\t\tconst resolver = typedCaches.stringified.get(ident);\n\t\tif (resolver) {\n\t\t\ttypedCaches.direct.set(resolveOptions, resolver);\n\t\t\treturn resolver;\n\t\t}\n\t\tconst newResolver = this._create(type, resolveOptions);\n\t\ttypedCaches.direct.set(resolveOptions, newResolver);\n\t\ttypedCaches.stringified.set(ident, newResolver);\n\t\treturn newResolver;\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\t_create(type, resolveOptionsWithDepType) {\n\t\t/** @type {ResolveOptionsWithDependencyType} */\n\t\tconst originalResolveOptions = { ...resolveOptionsWithDepType };\n\n\t\tconst resolveOptions = convertToResolveOptions(\n\t\t\tthis.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType)\n\t\t);\n\t\tconst resolver = /** @type {ResolverWithOptions} */ (\n\t\t\tFactory.createResolver(resolveOptions)\n\t\t);\n\t\tif (!resolver) {\n\t\t\tthrow new Error(\"No resolver created\");\n\t\t}\n\t\t/** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n\t\tconst childCache = new WeakMap();\n\t\tresolver.withOptions = options => {\n\t\t\tconst cacheEntry = childCache.get(options);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tconst mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\t\t\tconst resolver = this.get(type, mergedOptions);\n\t\t\tchildCache.set(options, resolver);\n\t\t\treturn resolver;\n\t\t};\n\t\tthis.hooks.resolver\n\t\t\t.for(type)\n\t\t\t.call(resolver, resolveOptions, originalResolveOptions);\n\t\treturn resolver;\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}