{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  STAGE_BASIC\n} = require(\"../OptimizationStages\");\nconst Queue = require(\"../util/Queue\");\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass RemoveParentModulesPlugin {\n  /**\n   * @param {Compiler} compiler the compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n      const handler = (chunks, chunkGroups) => {\n        const chunkGraph = compilation.chunkGraph;\n        const queue = new Queue();\n        const availableModulesMap = new WeakMap();\n        for (const chunkGroup of compilation.entrypoints.values()) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n        for (const chunkGroup of compilation.asyncEntrypoints) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n        while (queue.length > 0) {\n          const chunkGroup = queue.dequeue();\n          let availableModules = availableModulesMap.get(chunkGroup);\n          let changed = false;\n          for (const parent of chunkGroup.parentsIterable) {\n            const availableModulesInParent = availableModulesMap.get(parent);\n            if (availableModulesInParent !== undefined) {\n              // If we know the available modules in parent: process these\n              if (availableModules === undefined) {\n                // if we have not own info yet: create new entry\n                availableModules = new Set(availableModulesInParent);\n                for (const chunk of parent.chunks) {\n                  for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n                    availableModules.add(m);\n                  }\n                }\n                availableModulesMap.set(chunkGroup, availableModules);\n                changed = true;\n              } else {\n                for (const m of availableModules) {\n                  if (!chunkGraph.isModuleInChunkGroup(m, parent) && !availableModulesInParent.has(m)) {\n                    availableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              }\n            }\n          }\n          if (changed) {\n            // if something changed: enqueue our children\n            for (const child of chunkGroup.childrenIterable) {\n              queue.enqueue(child);\n            }\n          }\n        }\n\n        // now we have available modules for every chunk\n        for (const chunk of chunks) {\n          const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));\n          if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n          const availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n          const numberOfModules = chunkGraph.getNumberOfChunkModules(chunk);\n          const toRemove = new Set();\n          if (numberOfModules < availableModules.size) {\n            for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n              if (availableModules.has(m)) {\n                toRemove.add(m);\n              }\n            }\n          } else {\n            for (const m of availableModules) {\n              if (chunkGraph.isModuleInChunk(m, chunk)) {\n                toRemove.add(m);\n              }\n            }\n          }\n          for (const module of toRemove) {\n            chunkGraph.disconnectChunkAndModule(chunk, module);\n          }\n        }\n      };\n      compilation.hooks.optimizeChunks.tap({\n        name: \"RemoveParentModulesPlugin\",\n        stage: STAGE_BASIC\n      }, handler);\n    });\n  }\n}\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"names":["STAGE_BASIC","require","Queue","intersect","RemoveParentModulesPlugin","apply","compiler","hooks","compilation","tap","handler","chunks","chunkGroups","chunkGraph","queue","availableModulesMap","WeakMap","chunkGroup","entrypoints","values","set","Set","child","childrenIterable","enqueue","asyncEntrypoints","length","dequeue","availableModules","get","changed","parent","parentsIterable","availableModulesInParent","undefined","chunk","m","getChunkModulesIterable","add","isModuleInChunkGroup","has","delete","availableModulesSets","Array","from","groupsIterable","some","s","numberOfModules","getNumberOfChunkModules","toRemove","size","isModuleInChunk","module","disconnectChunkAndModule","optimizeChunks","name","stage","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_BASIC } = require(\"../OptimizationStages\");\nconst Queue = require(\"../util/Queue\");\nconst { intersect } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass RemoveParentModulesPlugin {\n\t/**\n\t * @param {Compiler} compiler the compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst queue = new Queue();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const chunkGroup of compilation.asyncEntrypoints) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst chunkGroup = queue.dequeue();\n\t\t\t\t\tlet availableModules = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModules === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModules = new Set(availableModulesInParent);\n\t\t\t\t\t\t\t\tfor (const chunk of parent.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.add(m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModules);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!chunkGraph.isModuleInChunkGroup(m, parent) &&\n\t\t\t\t\t\t\t\t\t\t!availableModulesInParent.has(m)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\t\t\t\t\tconst availableModules =\n\t\t\t\t\t\tavailableModulesSets.length === 1\n\t\t\t\t\t\t\t? availableModulesSets[0]\n\t\t\t\t\t\t\t: intersect(availableModulesSets);\n\t\t\t\t\tconst numberOfModules = chunkGraph.getNumberOfChunkModules(chunk);\n\t\t\t\t\tconst toRemove = new Set();\n\t\t\t\t\tif (numberOfModules < availableModules.size) {\n\t\t\t\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\tif (availableModules.has(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(m, chunk)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of toRemove) {\n\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"RemoveParentModulesPlugin\",\n\t\t\t\t\tstage: STAGE_BASIC\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}