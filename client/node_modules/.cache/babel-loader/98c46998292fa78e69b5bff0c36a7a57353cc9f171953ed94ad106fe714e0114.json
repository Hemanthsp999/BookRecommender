{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @param {string} str string\n * @returns {string} quoted meta\n */\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * @param {string} str string\n * @returns {string} string\n */\nconst toSimpleString = str => {\n  if (`${+str}` === str) {\n    return str;\n  }\n  return JSON.stringify(str);\n};\n\n/**\n * @param {Record<string|number, boolean>} map value map\n * @returns {boolean|(function(string): string)} true/false, when unconditionally true/false, or a template function to determine the value at runtime\n */\nconst compileBooleanMatcher = map => {\n  const positiveItems = Object.keys(map).filter(i => map[i]);\n  const negativeItems = Object.keys(map).filter(i => !map[i]);\n  if (positiveItems.length === 0) return false;\n  if (negativeItems.length === 0) return true;\n  return compileBooleanMatcherFromLists(positiveItems, negativeItems);\n};\n\n/**\n * @param {string[]} positiveItems positive items\n * @param {string[]} negativeItems negative items\n * @returns {function(string): string} a template function to determine the value at runtime\n */\nconst compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {\n  if (positiveItems.length === 0) return () => \"false\";\n  if (negativeItems.length === 0) return () => \"true\";\n  if (positiveItems.length === 1) return value => `${toSimpleString(positiveItems[0])} == ${value}`;\n  if (negativeItems.length === 1) return value => `${toSimpleString(negativeItems[0])} != ${value}`;\n  const positiveRegexp = itemsToRegexp(positiveItems);\n  const negativeRegexp = itemsToRegexp(negativeItems);\n  if (positiveRegexp.length <= negativeRegexp.length) {\n    return value => `/^${positiveRegexp}$/.test(${value})`;\n  } else {\n    return value => `!/^${negativeRegexp}$/.test(${value})`;\n  }\n};\n\n/**\n * @param {Set<string>} itemsSet items set\n * @param {(str: string) => string | false} getKey get key function\n * @param {(str: Array<string>) => boolean} condition condition\n * @returns {Array<Array<string>>} list of common items\n */\nconst popCommonItems = (itemsSet, getKey, condition) => {\n  /** @type {Map<string, Array<string>>} */\n  const map = new Map();\n  for (const item of itemsSet) {\n    const key = getKey(item);\n    if (key) {\n      let list = map.get(key);\n      if (list === undefined) {\n        /** @type {Array<string>} */\n        list = [];\n        map.set(key, list);\n      }\n      list.push(item);\n    }\n  }\n  /** @type {Array<Array<string>>} */\n  const result = [];\n  for (const list of map.values()) {\n    if (condition(list)) {\n      for (const item of list) {\n        itemsSet.delete(item);\n      }\n      result.push(list);\n    }\n  }\n  return result;\n};\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common prefix\n */\nconst getCommonPrefix = items => {\n  let prefix = items[0];\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n    for (let p = 0; p < prefix.length; p++) {\n      if (item[p] !== prefix[p]) {\n        prefix = prefix.slice(0, p);\n        break;\n      }\n    }\n  }\n  return prefix;\n};\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common suffix\n */\nconst getCommonSuffix = items => {\n  let suffix = items[0];\n  for (let i = 1; i < items.length; i++) {\n    const item = items[i];\n    for (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {\n      if (item[p] !== suffix[s]) {\n        suffix = suffix.slice(s + 1);\n        break;\n      }\n    }\n  }\n  return suffix;\n};\n\n/**\n * @param {Array<string>} itemsArr array of items\n * @returns {string} regexp\n */\nconst itemsToRegexp = itemsArr => {\n  if (itemsArr.length === 1) {\n    return quoteMeta(itemsArr[0]);\n  }\n  /** @type {Array<string>} */\n  const finishedItems = [];\n\n  // merge single char items: (a|b|c|d|ef) => ([abcd]|ef)\n  let countOfSingleCharItems = 0;\n  for (const item of itemsArr) {\n    if (item.length === 1) {\n      countOfSingleCharItems++;\n    }\n  }\n  // special case for only single char items\n  if (countOfSingleCharItems === itemsArr.length) {\n    return `[${quoteMeta(itemsArr.sort().join(\"\"))}]`;\n  }\n  const items = new Set(itemsArr.sort());\n  if (countOfSingleCharItems > 2) {\n    let singleCharItems = \"\";\n    for (const item of items) {\n      if (item.length === 1) {\n        singleCharItems += item;\n        items.delete(item);\n      }\n    }\n    finishedItems.push(`[${quoteMeta(singleCharItems)}]`);\n  }\n\n  // special case for 2 items with common prefix/suffix\n  if (finishedItems.length === 0 && items.size === 2) {\n    const prefix = getCommonPrefix(itemsArr);\n    const suffix = getCommonSuffix(itemsArr.map(item => item.slice(prefix.length)));\n    if (prefix.length > 0 || suffix.length > 0) {\n      return `${quoteMeta(prefix)}${itemsToRegexp(itemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined)))}${quoteMeta(suffix)}`;\n    }\n  }\n\n  // special case for 2 items with common suffix\n  if (finishedItems.length === 0 && items.size === 2) {\n    /** @type {Iterator<string>} */\n    const it = items[Symbol.iterator]();\n    const a = it.next().value;\n    const b = it.next().value;\n    if (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {\n      return `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])}${quoteMeta(a.slice(-1))}`;\n    }\n  }\n\n  // find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)\n  const prefixed = popCommonItems(items, item => item.length >= 1 ? item[0] : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0][1] === list[1][1];\n  });\n  for (const prefixedItems of prefixed) {\n    const prefix = getCommonPrefix(prefixedItems);\n    finishedItems.push(`${quoteMeta(prefix)}${itemsToRegexp(prefixedItems.map(i => i.slice(prefix.length)))}`);\n  }\n\n  // find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)\n  const suffixed = popCommonItems(items, item => item.length >= 1 ? item.slice(-1) : false, list => {\n    if (list.length >= 3) return true;\n    if (list.length <= 1) return false;\n    return list[0].slice(-2) === list[1].slice(-2);\n  });\n  for (const suffixedItems of suffixed) {\n    const suffix = getCommonSuffix(suffixedItems);\n    finishedItems.push(`${itemsToRegexp(suffixedItems.map(i => i.slice(0, -suffix.length)))}${quoteMeta(suffix)}`);\n  }\n\n  // TODO further optimize regexp, i. e.\n  // use ranges: (1|2|3|4|a) => [1-4a]\n  const conditional = finishedItems.concat(Array.from(items, quoteMeta));\n  if (conditional.length === 1) return conditional[0];\n  return `(${conditional.join(\"|\")})`;\n};\ncompileBooleanMatcher.fromLists = compileBooleanMatcherFromLists;\ncompileBooleanMatcher.itemsToRegexp = itemsToRegexp;\nmodule.exports = compileBooleanMatcher;","map":{"version":3,"names":["quoteMeta","str","replace","toSimpleString","JSON","stringify","compileBooleanMatcher","map","positiveItems","Object","keys","filter","i","negativeItems","length","compileBooleanMatcherFromLists","value","positiveRegexp","itemsToRegexp","negativeRegexp","popCommonItems","itemsSet","getKey","condition","Map","item","key","list","get","undefined","set","push","result","values","delete","getCommonPrefix","items","prefix","p","slice","getCommonSuffix","suffix","s","itemsArr","finishedItems","countOfSingleCharItems","sort","join","Set","singleCharItems","size","it","Symbol","iterator","a","next","b","prefixed","prefixedItems","suffixed","suffixedItems","conditional","concat","Array","from","fromLists","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/compileBooleanMatcher.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @param {string} str string\n * @returns {string} quoted meta\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * @param {string} str string\n * @returns {string} string\n */\nconst toSimpleString = str => {\n\tif (`${+str}` === str) {\n\t\treturn str;\n\t}\n\treturn JSON.stringify(str);\n};\n\n/**\n * @param {Record<string|number, boolean>} map value map\n * @returns {boolean|(function(string): string)} true/false, when unconditionally true/false, or a template function to determine the value at runtime\n */\nconst compileBooleanMatcher = map => {\n\tconst positiveItems = Object.keys(map).filter(i => map[i]);\n\tconst negativeItems = Object.keys(map).filter(i => !map[i]);\n\tif (positiveItems.length === 0) return false;\n\tif (negativeItems.length === 0) return true;\n\treturn compileBooleanMatcherFromLists(positiveItems, negativeItems);\n};\n\n/**\n * @param {string[]} positiveItems positive items\n * @param {string[]} negativeItems negative items\n * @returns {function(string): string} a template function to determine the value at runtime\n */\nconst compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {\n\tif (positiveItems.length === 0) return () => \"false\";\n\tif (negativeItems.length === 0) return () => \"true\";\n\tif (positiveItems.length === 1)\n\t\treturn value => `${toSimpleString(positiveItems[0])} == ${value}`;\n\tif (negativeItems.length === 1)\n\t\treturn value => `${toSimpleString(negativeItems[0])} != ${value}`;\n\tconst positiveRegexp = itemsToRegexp(positiveItems);\n\tconst negativeRegexp = itemsToRegexp(negativeItems);\n\tif (positiveRegexp.length <= negativeRegexp.length) {\n\t\treturn value => `/^${positiveRegexp}$/.test(${value})`;\n\t} else {\n\t\treturn value => `!/^${negativeRegexp}$/.test(${value})`;\n\t}\n};\n\n/**\n * @param {Set<string>} itemsSet items set\n * @param {(str: string) => string | false} getKey get key function\n * @param {(str: Array<string>) => boolean} condition condition\n * @returns {Array<Array<string>>} list of common items\n */\nconst popCommonItems = (itemsSet, getKey, condition) => {\n\t/** @type {Map<string, Array<string>>} */\n\tconst map = new Map();\n\tfor (const item of itemsSet) {\n\t\tconst key = getKey(item);\n\t\tif (key) {\n\t\t\tlet list = map.get(key);\n\t\t\tif (list === undefined) {\n\t\t\t\t/** @type {Array<string>} */\n\t\t\t\tlist = [];\n\t\t\t\tmap.set(key, list);\n\t\t\t}\n\t\t\tlist.push(item);\n\t\t}\n\t}\n\t/** @type {Array<Array<string>>} */\n\tconst result = [];\n\tfor (const list of map.values()) {\n\t\tif (condition(list)) {\n\t\t\tfor (const item of list) {\n\t\t\t\titemsSet.delete(item);\n\t\t\t}\n\t\t\tresult.push(list);\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common prefix\n */\nconst getCommonPrefix = items => {\n\tlet prefix = items[0];\n\tfor (let i = 1; i < items.length; i++) {\n\t\tconst item = items[i];\n\t\tfor (let p = 0; p < prefix.length; p++) {\n\t\t\tif (item[p] !== prefix[p]) {\n\t\t\t\tprefix = prefix.slice(0, p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn prefix;\n};\n\n/**\n * @param {Array<string>} items items\n * @returns {string} common suffix\n */\nconst getCommonSuffix = items => {\n\tlet suffix = items[0];\n\tfor (let i = 1; i < items.length; i++) {\n\t\tconst item = items[i];\n\t\tfor (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {\n\t\t\tif (item[p] !== suffix[s]) {\n\t\t\t\tsuffix = suffix.slice(s + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn suffix;\n};\n\n/**\n * @param {Array<string>} itemsArr array of items\n * @returns {string} regexp\n */\nconst itemsToRegexp = itemsArr => {\n\tif (itemsArr.length === 1) {\n\t\treturn quoteMeta(itemsArr[0]);\n\t}\n\t/** @type {Array<string>} */\n\tconst finishedItems = [];\n\n\t// merge single char items: (a|b|c|d|ef) => ([abcd]|ef)\n\tlet countOfSingleCharItems = 0;\n\tfor (const item of itemsArr) {\n\t\tif (item.length === 1) {\n\t\t\tcountOfSingleCharItems++;\n\t\t}\n\t}\n\t// special case for only single char items\n\tif (countOfSingleCharItems === itemsArr.length) {\n\t\treturn `[${quoteMeta(itemsArr.sort().join(\"\"))}]`;\n\t}\n\tconst items = new Set(itemsArr.sort());\n\tif (countOfSingleCharItems > 2) {\n\t\tlet singleCharItems = \"\";\n\t\tfor (const item of items) {\n\t\t\tif (item.length === 1) {\n\t\t\t\tsingleCharItems += item;\n\t\t\t\titems.delete(item);\n\t\t\t}\n\t\t}\n\t\tfinishedItems.push(`[${quoteMeta(singleCharItems)}]`);\n\t}\n\n\t// special case for 2 items with common prefix/suffix\n\tif (finishedItems.length === 0 && items.size === 2) {\n\t\tconst prefix = getCommonPrefix(itemsArr);\n\t\tconst suffix = getCommonSuffix(\n\t\t\titemsArr.map(item => item.slice(prefix.length))\n\t\t);\n\t\tif (prefix.length > 0 || suffix.length > 0) {\n\t\t\treturn `${quoteMeta(prefix)}${itemsToRegexp(\n\t\t\t\titemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined))\n\t\t\t)}${quoteMeta(suffix)}`;\n\t\t}\n\t}\n\n\t// special case for 2 items with common suffix\n\tif (finishedItems.length === 0 && items.size === 2) {\n\t\t/** @type {Iterator<string>} */\n\t\tconst it = items[Symbol.iterator]();\n\t\tconst a = it.next().value;\n\t\tconst b = it.next().value;\n\t\tif (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {\n\t\t\treturn `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])}${quoteMeta(\n\t\t\t\ta.slice(-1)\n\t\t\t)}`;\n\t\t}\n\t}\n\n\t// find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)\n\tconst prefixed = popCommonItems(\n\t\titems,\n\t\titem => (item.length >= 1 ? item[0] : false),\n\t\tlist => {\n\t\t\tif (list.length >= 3) return true;\n\t\t\tif (list.length <= 1) return false;\n\t\t\treturn list[0][1] === list[1][1];\n\t\t}\n\t);\n\tfor (const prefixedItems of prefixed) {\n\t\tconst prefix = getCommonPrefix(prefixedItems);\n\t\tfinishedItems.push(\n\t\t\t`${quoteMeta(prefix)}${itemsToRegexp(\n\t\t\t\tprefixedItems.map(i => i.slice(prefix.length))\n\t\t\t)}`\n\t\t);\n\t}\n\n\t// find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)\n\tconst suffixed = popCommonItems(\n\t\titems,\n\t\titem => (item.length >= 1 ? item.slice(-1) : false),\n\t\tlist => {\n\t\t\tif (list.length >= 3) return true;\n\t\t\tif (list.length <= 1) return false;\n\t\t\treturn list[0].slice(-2) === list[1].slice(-2);\n\t\t}\n\t);\n\tfor (const suffixedItems of suffixed) {\n\t\tconst suffix = getCommonSuffix(suffixedItems);\n\t\tfinishedItems.push(\n\t\t\t`${itemsToRegexp(\n\t\t\t\tsuffixedItems.map(i => i.slice(0, -suffix.length))\n\t\t\t)}${quoteMeta(suffix)}`\n\t\t);\n\t}\n\n\t// TODO further optimize regexp, i. e.\n\t// use ranges: (1|2|3|4|a) => [1-4a]\n\tconst conditional = finishedItems.concat(Array.from(items, quoteMeta));\n\tif (conditional.length === 1) return conditional[0];\n\treturn `(${conditional.join(\"|\")})`;\n};\n\ncompileBooleanMatcher.fromLists = compileBooleanMatcherFromLists;\ncompileBooleanMatcher.itemsToRegexp = itemsToRegexp;\nmodule.exports = compileBooleanMatcher;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}