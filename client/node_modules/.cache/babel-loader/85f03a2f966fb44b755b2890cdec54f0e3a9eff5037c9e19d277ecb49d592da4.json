{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst {\n  intersect\n} = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst StringXor = require(\"./util/StringXor\");\nconst {\n  compareModulesByIdentifier,\n  compareChunkGroupsByIndex,\n  compareModulesById\n} = require(\"./util/comparators\");\nconst {\n  createArrayToSetDeprecationSet\n} = require(\"./util/deprecation\");\nconst {\n  mergeRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   * @param {boolean} backCompat enable backward-compatibility\n   */\n  constructor(name) {\n    let backCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    /** @type {number | string | null} */\n    this.id = null;\n    /** @type {(number|string)[] | null} */\n    this.ids = null;\n    /** @type {number} */\n    this.debugId = debugId++;\n    /** @type {string} */\n    this.name = name;\n    /** @type {SortableSet<string>} */\n    this.idNameHints = new SortableSet();\n    /** @type {boolean} */\n    this.preventIntegration = false;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n    this.filenameTemplate = undefined;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n    this.cssFilenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n    this._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n    /** @type {RuntimeSpec} */\n    this.runtime = undefined;\n    /** @type {Set<string>} */\n    this.files = backCompat ? new ChunkFilesSet() : new Set();\n    /** @type {Set<string>} */\n    this.auxiliaryFiles = new Set();\n    /** @type {boolean} */\n    this.rendered = false;\n    /** @type {string=} */\n    this.hash = undefined;\n    /** @type {Record<string, string>} */\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n    this.renderedHash = undefined;\n    /** @type {string=} */\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n    this.extraAsync = false;\n  }\n\n  // TODO remove in webpack 6\n  // BACKWARD-COMPAT START\n  get entryModule() {\n    const entryModules = Array.from(ChunkGraph.getChunkGraphForChunk(this, \"Chunk.entryModule\", \"DEP_WEBPACK_CHUNK_ENTRY_MODULE\").getChunkEntryModulesIterable(this));\n    if (entryModules.length === 0) {\n      return undefined;\n    } else if (entryModules.length === 1) {\n      return entryModules[0];\n    } else {\n      throw new Error(\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\");\n    }\n  }\n\n  /**\n   * @returns {boolean} true, if the chunk contains an entry module\n   */\n  hasEntryModule() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasEntryModule\", \"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\").getNumberOfEntryModules(this) > 0;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, if the chunk could be added\n   */\n  addModule(module) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.addModule\", \"DEP_WEBPACK_CHUNK_ADD_MODULE\");\n    if (chunkGraph.isModuleInChunk(module, this)) return false;\n    chunkGraph.connectChunkAndModule(this, module);\n    return true;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n  removeModule(module) {\n    ChunkGraph.getChunkGraphForChunk(this, \"Chunk.removeModule\", \"DEP_WEBPACK_CHUNK_REMOVE_MODULE\").disconnectChunkAndModule(this, module);\n  }\n\n  /**\n   * @returns {number} the number of module which are contained in this chunk\n   */\n  getNumberOfModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getNumberOfModules\", \"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\").getNumberOfChunkModules(this);\n  }\n  get modulesIterable() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesIterable\", \"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\");\n    return chunkGraph.getOrderedChunkModulesIterable(this, compareModulesByIdentifier);\n  }\n\n  /**\n   * @param {Chunk} otherChunk the chunk to compare with\n   * @returns {-1|0|1} the comparison result\n   */\n  compareTo(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.compareTo\", \"DEP_WEBPACK_CHUNK_COMPARE_TO\");\n    return chunkGraph.compareChunks(this, otherChunk);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, if the chunk contains the module\n   */\n  containsModule(module) {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.containsModule\", \"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\").isModuleInChunk(module, this);\n  }\n\n  /**\n   * @returns {Module[]} the modules for this chunk\n   */\n  getModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getModules\", \"DEP_WEBPACK_CHUNK_GET_MODULES\").getChunkModules(this);\n  }\n\n  /**\n   * @returns {void}\n   */\n  remove() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.remove\", \"DEP_WEBPACK_CHUNK_REMOVE\");\n    chunkGraph.disconnectChunk(this);\n    this.disconnectFromGroups();\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {Chunk} otherChunk the target chunk\n   * @returns {void}\n   */\n  moveModule(module, otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.moveModule\", \"DEP_WEBPACK_CHUNK_MOVE_MODULE\");\n    chunkGraph.disconnectChunkAndModule(this, module);\n    chunkGraph.connectChunkAndModule(otherChunk, module);\n  }\n\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @returns {boolean} true, if the specified chunk has been integrated\n   */\n  integrate(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integrate\", \"DEP_WEBPACK_CHUNK_INTEGRATE\");\n    if (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n      chunkGraph.integrateChunks(this, otherChunk);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @returns {boolean} true, if chunks could be integrated\n   */\n  canBeIntegrated(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.canBeIntegrated\", \"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\");\n    return chunkGraph.canChunksBeIntegrated(this, otherChunk);\n  }\n\n  /**\n   * @returns {boolean} true, if this chunk contains no module\n   */\n  isEmpty() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.isEmpty\", \"DEP_WEBPACK_CHUNK_IS_EMPTY\");\n    return chunkGraph.getNumberOfChunkModules(this) === 0;\n  }\n\n  /**\n   * @returns {number} total size of all modules in this chunk\n   */\n  modulesSize() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesSize\", \"DEP_WEBPACK_CHUNK_MODULES_SIZE\");\n    return chunkGraph.getChunkModulesSize(this);\n  }\n\n  /**\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of this chunk\n   */\n  size() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.size\", \"DEP_WEBPACK_CHUNK_SIZE\");\n    return chunkGraph.getChunkSize(this, options);\n  }\n\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk or false if the chunk can't be integrated\n   */\n  integratedSize(otherChunk, options) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integratedSize\", \"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\");\n    return chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n  }\n\n  /**\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @returns {ChunkModuleMaps} module map information\n   */\n  getChunkModuleMaps(filterFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getChunkModuleMaps\", \"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\");\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkModuleHashMap = Object.create(null);\n    for (const asyncChunk of this.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n      for (const module of chunkGraph.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(chunkGraph))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n          const moduleId = chunkGraph.getModuleId(module);\n          array.push(moduleId);\n          chunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(module, undefined);\n        }\n      }\n    }\n    return {\n      id: chunkModuleIdMap,\n      hash: chunkModuleHashMap\n    };\n  }\n\n  /**\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n  hasModuleInGraph(filterFn, filterChunkFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasModuleInGraph\", \"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\");\n    return chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n  }\n\n  /**\n   * @deprecated\n   * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n   * @returns {ChunkMaps} the chunk map information\n   */\n  getChunkMaps(realHash) {\n    /** @type {Record<string|number, string>} */\n    const chunkHashMap = Object.create(null);\n    /** @type {Record<string|number, Record<string, string>>} */\n    const chunkContentHashMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkNameMap = Object.create(null);\n    for (const chunk of this.getAllAsyncChunks()) {\n      chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n      for (const key of Object.keys(chunk.contentHash)) {\n        if (!chunkContentHashMap[key]) {\n          chunkContentHashMap[key] = Object.create(null);\n        }\n        chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n      }\n      if (chunk.name) {\n        chunkNameMap[chunk.id] = chunk.name;\n      }\n    }\n    return {\n      hash: chunkHashMap,\n      contentHash: chunkContentHashMap,\n      name: chunkNameMap\n    };\n  }\n  // BACKWARD-COMPAT END\n\n  /**\n   * @returns {boolean} whether or not the Chunk will have a runtime\n   */\n  hasRuntime() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether or not this chunk can be an initial chunk\n   */\n  canBeInitial() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial()) return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether this chunk can only be an initial chunk\n   */\n  isOnlyInitial() {\n    if (this._groups.size <= 0) return false;\n    for (const chunkGroup of this._groups) {\n      if (!chunkGroup.isInitial()) return false;\n    }\n    return true;\n  }\n\n  /**\n   * @returns {EntryOptions | undefined} the entry options for this chunk\n   */\n  getEntryOptions() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint) {\n        return chunkGroup.options;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n   * @returns {void}\n   */\n  addGroup(chunkGroup) {\n    this._groups.add(chunkGroup);\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n   * @returns {void}\n   */\n  removeGroup(chunkGroup) {\n    this._groups.delete(chunkGroup);\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup to check\n   * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n   */\n  isInGroup(chunkGroup) {\n    return this._groups.has(chunkGroup);\n  }\n\n  /**\n   * @returns {number} the amount of groups that the said chunk is in\n   */\n  getNumberOfGroups() {\n    return this._groups.size;\n  }\n\n  /**\n   * @returns {SortableSet<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n   */\n  get groupsIterable() {\n    this._groups.sort();\n    return this._groups;\n  }\n\n  /**\n   * @returns {void}\n   */\n  disconnectFromGroups() {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.removeChunk(this);\n    }\n  }\n\n  /**\n   * @param {Chunk} newChunk the new chunk that will be split out of\n   * @returns {void}\n   */\n  split(newChunk) {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.insertChunk(newChunk, this);\n      newChunk.addGroup(chunkGroup);\n    }\n    for (const idHint of this.idNameHints) {\n      newChunk.idNameHints.add(idHint);\n    }\n    newChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n  }\n\n  /**\n   * @param {Hash} hash hash (will be modified)\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n  updateHash(hash, chunkGraph) {\n    hash.update(`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `);\n    const xor = new StringXor();\n    for (const m of chunkGraph.getChunkModulesIterable(this)) {\n      xor.add(chunkGraph.getModuleHash(m, this.runtime));\n    }\n    xor.updateHash(hash);\n    const entryModules = chunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n    for (const [m, chunkGroup] of entryModules) {\n      hash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n    }\n  }\n\n  /**\n   * @returns {Set<Chunk>} a set of all the async chunks\n   */\n  getAllAsyncChunks() {\n    const queue = new Set();\n    const chunks = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    const initialQueue = new Set(this.groupsIterable);\n    for (const chunkGroup of initialQueue) {\n      for (const child of chunkGroup.childrenIterable) {\n        if (child instanceof Entrypoint) {\n          initialQueue.add(child);\n        } else {\n          queue.add(child);\n        }\n      }\n    }\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          chunks.add(chunk);\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return chunks;\n  }\n\n  /**\n   * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n   */\n  getAllInitialChunks() {\n    const chunks = new Set();\n    const queue = new Set(this.groupsIterable);\n    for (const group of queue) {\n      if (group.isInitial()) {\n        for (const c of group.chunks) chunks.add(c);\n        for (const g of group.childrenIterable) queue.add(g);\n      }\n    }\n    return chunks;\n  }\n\n  /**\n   * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n   */\n  getAllReferencedChunks() {\n    const queue = new Set(this.groupsIterable);\n    const chunks = new Set();\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        chunks.add(chunk);\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return chunks;\n  }\n\n  /**\n   * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n   */\n  getAllReferencedAsyncEntrypoints() {\n    const queue = new Set(this.groupsIterable);\n    const entrypoints = new Set();\n    for (const chunkGroup of queue) {\n      for (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n        entrypoints.add(entrypoint);\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return entrypoints;\n  }\n\n  /**\n   * @returns {boolean} true, if the chunk references async chunks\n   */\n  hasAsyncChunks() {\n    const queue = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    for (const chunkGroup of this.groupsIterable) {\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          return true;\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n   * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n   */\n  getChildIdsByOrders(chunkGraph, filterFn) {\n    /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n    const lists = new Map();\n    for (const group of this.groupsIterable) {\n      if (group.chunks[group.chunks.length - 1] === this) {\n        for (const childGroup of group.childrenIterable) {\n          for (const key of Object.keys(childGroup.options)) {\n            if (key.endsWith(\"Order\")) {\n              const name = key.slice(0, key.length - \"Order\".length);\n              let list = lists.get(name);\n              if (list === undefined) {\n                list = [];\n                lists.set(name, list);\n              }\n              list.push({\n                order: childGroup.options[key],\n                group: childGroup\n              });\n            }\n          }\n        }\n      }\n    }\n    /** @type {Record<string, (string | number)[]>} */\n    const result = Object.create(null);\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      /** @type {Set<string | number>} */\n      const chunkIdSet = new Set();\n      for (const item of list) {\n        for (const chunk of item.group.chunks) {\n          if (filterFn && !filterFn(chunk, chunkGraph)) continue;\n          chunkIdSet.add(chunk.id);\n        }\n      }\n      if (chunkIdSet.size > 0) {\n        result[name] = Array.from(chunkIdSet);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {string} type option name\n   * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n   */\n  getChildrenOfTypeInOrder(chunkGraph, type) {\n    const list = [];\n    for (const group of this.groupsIterable) {\n      for (const childGroup of group.childrenIterable) {\n        const order = childGroup.options[type];\n        if (order === undefined) continue;\n        list.push({\n          order,\n          group,\n          childGroup\n        });\n      }\n    }\n    if (list.length === 0) return undefined;\n    list.sort((a, b) => {\n      const cmp = b.order - a.order;\n      if (cmp !== 0) return cmp;\n      return a.group.compareTo(chunkGraph, b.group);\n    });\n    const result = [];\n    let lastEntry;\n    for (const {\n      group,\n      childGroup\n    } of list) {\n      if (lastEntry && lastEntry.onChunks === group.chunks) {\n        for (const chunk of childGroup.chunks) {\n          lastEntry.chunks.add(chunk);\n        }\n      } else {\n        result.push(lastEntry = {\n          onChunks: group.chunks,\n          chunks: new Set(childGroup.chunks)\n        });\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n   * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n   */\n  getChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n    /** @type {Record<string|number, Record<string, (string | number)[]>>} */\n    const chunkMaps = Object.create(null);\n\n    /**\n     * @param {Chunk} chunk a chunk\n     * @returns {void}\n     */\n    const addChildIdsByOrdersToMap = chunk => {\n      const data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n      for (const key of Object.keys(data)) {\n        let chunkMap = chunkMaps[key];\n        if (chunkMap === undefined) {\n          chunkMaps[key] = chunkMap = Object.create(null);\n        }\n        chunkMap[chunk.id] = data[key];\n      }\n    };\n    if (includeDirectChildren) {\n      /** @type {Set<Chunk>} */\n      const chunks = new Set();\n      for (const chunkGroup of this.groupsIterable) {\n        for (const chunk of chunkGroup.chunks) {\n          chunks.add(chunk);\n        }\n      }\n      for (const chunk of chunks) {\n        addChildIdsByOrdersToMap(chunk);\n      }\n    }\n    for (const chunk of this.getAllAsyncChunks()) {\n      addChildIdsByOrdersToMap(chunk);\n    }\n    return chunkMaps;\n  }\n}\nmodule.exports = Chunk;","map":{"version":3,"names":["ChunkGraph","require","Entrypoint","intersect","SortableSet","StringXor","compareModulesByIdentifier","compareChunkGroupsByIndex","compareModulesById","createArrayToSetDeprecationSet","mergeRuntime","ChunkFilesSet","debugId","Chunk","constructor","name","backCompat","arguments","length","undefined","id","ids","idNameHints","preventIntegration","filenameTemplate","cssFilenameTemplate","_groups","runtime","files","Set","auxiliaryFiles","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","entryModule","entryModules","Array","from","getChunkGraphForChunk","getChunkEntryModulesIterable","Error","hasEntryModule","getNumberOfEntryModules","addModule","module","chunkGraph","isModuleInChunk","connectChunkAndModule","removeModule","disconnectChunkAndModule","getNumberOfModules","getNumberOfChunkModules","modulesIterable","getOrderedChunkModulesIterable","compareTo","otherChunk","compareChunks","containsModule","getModules","getChunkModules","remove","disconnectChunk","disconnectFromGroups","moveModule","integrate","canChunksBeIntegrated","integrateChunks","canBeIntegrated","isEmpty","modulesSize","getChunkModulesSize","size","options","getChunkSize","integratedSize","getIntegratedChunksSize","getChunkModuleMaps","filterFn","chunkModuleIdMap","chunkModuleHashMap","asyncChunk","getAllAsyncChunks","array","moduleId","getModuleId","push","getRenderedModuleHash","hasModuleInGraph","filterChunkFn","getChunkMaps","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","chunk","key","keys","hasRuntime","chunkGroup","getRuntimeChunk","canBeInitial","isInitial","isOnlyInitial","getEntryOptions","addGroup","add","removeGroup","delete","isInGroup","has","getNumberOfGroups","groupsIterable","sort","removeChunk","split","newChunk","insertChunk","idHint","updateHash","update","join","xor","m","getChunkModulesIterable","getModuleHash","getChunkEntryModulesWithChunkGroupIterable","queue","chunks","initialChunks","g","initialQueue","child","childrenIterable","getAllInitialChunks","group","c","getAllReferencedChunks","getAllReferencedAsyncEntrypoints","entrypoints","entrypoint","asyncEntrypointsIterable","hasAsyncChunks","getChildIdsByOrders","lists","Map","childGroup","endsWith","slice","list","get","set","order","result","a","b","cmp","chunkIdSet","item","getChildrenOfTypeInOrder","type","lastEntry","onChunks","getChildIdsByOrdersMap","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","data","chunkMap","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/Chunk.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst { intersect } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst StringXor = require(\"./util/StringXor\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunkGroupsByIndex,\n\tcompareModulesById\n} = require(\"./util/comparators\");\nconst { createArrayToSetDeprecationSet } = require(\"./util/deprecation\");\nconst { mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t * @param {boolean} backCompat enable backward-compatibility\n\t */\n\tconstructor(name, backCompat = true) {\n\t\t/** @type {number | string | null} */\n\t\tthis.id = null;\n\t\t/** @type {(number|string)[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {SortableSet<string>} */\n\t\tthis.idNameHints = new SortableSet();\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.cssFilenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n\t\t/** @type {RuntimeSpec} */\n\t\tthis.runtime = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.files = backCompat ? new ChunkFilesSet() : new Set();\n\t\t/** @type {Set<string>} */\n\t\tthis.auxiliaryFiles = new Set();\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Record<string, string>} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t}\n\n\t// TODO remove in webpack 6\n\t// BACKWARD-COMPAT START\n\tget entryModule() {\n\t\tconst entryModules = Array.from(\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.entryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_ENTRY_MODULE\"\n\t\t\t).getChunkEntryModulesIterable(this)\n\t\t);\n\t\tif (entryModules.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (entryModules.length === 1) {\n\t\t\treturn entryModules[0];\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk contains an entry module\n\t */\n\thasEntryModule() {\n\t\treturn (\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.hasEntryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\"\n\t\t\t).getNumberOfEntryModules(this) > 0\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk could be added\n\t */\n\taddModule(module) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.addModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_ADD_MODULE\"\n\t\t);\n\t\tif (chunkGraph.isModuleInChunk(module, this)) return false;\n\t\tchunkGraph.connectChunkAndModule(this, module);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tremoveModule(module) {\n\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.removeModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE_MODULE\"\n\t\t).disconnectChunkAndModule(this, module);\n\t}\n\n\t/**\n\t * @returns {number} the number of module which are contained in this chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getNumberOfModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\"\n\t\t).getNumberOfChunkModules(this);\n\t}\n\n\tget modulesIterable() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesIterable\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\"\n\t\t);\n\t\treturn chunkGraph.getOrderedChunkModulesIterable(\n\t\t\tthis,\n\t\t\tcompareModulesByIdentifier\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare with\n\t * @returns {-1|0|1} the comparison result\n\t */\n\tcompareTo(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.compareTo\",\n\t\t\t\"DEP_WEBPACK_CHUNK_COMPARE_TO\"\n\t\t);\n\t\treturn chunkGraph.compareChunks(this, otherChunk);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tcontainsModule(module) {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.containsModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\"\n\t\t).isModuleInChunk(module, this);\n\t}\n\n\t/**\n\t * @returns {Module[]} the modules for this chunk\n\t */\n\tgetModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_MODULES\"\n\t\t).getChunkModules(this);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.remove\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE\"\n\t\t);\n\t\tchunkGraph.disconnectChunk(this);\n\t\tthis.disconnectFromGroups();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Chunk} otherChunk the target chunk\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.moveModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MOVE_MODULE\"\n\t\t);\n\t\tchunkGraph.disconnectChunkAndModule(this, module);\n\t\tchunkGraph.connectChunkAndModule(otherChunk, module);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if the specified chunk has been integrated\n\t */\n\tintegrate(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integrate\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATE\"\n\t\t);\n\t\tif (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n\t\t\tchunkGraph.integrateChunks(this, otherChunk);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanBeIntegrated(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.canBeIntegrated\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\"\n\t\t);\n\t\treturn chunkGraph.canChunksBeIntegrated(this, otherChunk);\n\t}\n\n\t/**\n\t * @returns {boolean} true, if this chunk contains no module\n\t */\n\tisEmpty() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.isEmpty\",\n\t\t\t\"DEP_WEBPACK_CHUNK_IS_EMPTY\"\n\t\t);\n\t\treturn chunkGraph.getNumberOfChunkModules(this) === 0;\n\t}\n\n\t/**\n\t * @returns {number} total size of all modules in this chunk\n\t */\n\tmodulesSize() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkModulesSize(this);\n\t}\n\n\t/**\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of this chunk\n\t */\n\tsize(options = {}) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.size\",\n\t\t\t\"DEP_WEBPACK_CHUNK_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkSize(this, options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if the chunk can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integratedSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getChunkModuleMaps\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\"\n\t\t);\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t\tchunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tundefined\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.hasModuleInGraph\",\n\t\t\t\"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\"\n\t\t);\n\t\treturn chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\t// BACKWARD-COMPAT END\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {EntryOptions | undefined} the entry options for this chunk\n\t */\n\tgetEntryOptions() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\treturn chunkGroup.options;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {void}\n\t */\n\taddGroup(chunkGroup) {\n\t\tthis._groups.add(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {void}\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tthis._groups.delete(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups that the said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {SortableSet<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\tthis._groups.sort();\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdisconnectFromGroups() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t\tfor (const idHint of this.idNameHints) {\n\t\t\tnewChunk.idNameHints.add(idHint);\n\t\t}\n\t\tnewChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n\t}\n\n\t/**\n\t * @param {Hash} hash hash (will be modified)\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tupdateHash(hash, chunkGraph) {\n\t\thash.update(\n\t\t\t`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `\n\t\t);\n\t\tconst xor = new StringXor();\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(this)) {\n\t\t\txor.add(chunkGraph.getModuleHash(m, this.runtime));\n\t\t}\n\t\txor.updateHash(hash);\n\t\tconst entryModules =\n\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\t\tfor (const [m, chunkGroup] of entryModules) {\n\t\t\thash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tconst initialQueue = new Set(this.groupsIterable);\n\n\t\tfor (const chunkGroup of initialQueue) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tif (child instanceof Entrypoint) {\n\t\t\t\t\tinitialQueue.add(child);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n\t */\n\tgetAllInitialChunks() {\n\t\tconst chunks = new Set();\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tfor (const group of queue) {\n\t\t\tif (group.isInitial()) {\n\t\t\t\tfor (const c of group.chunks) chunks.add(c);\n\t\t\t\tfor (const g of group.childrenIterable) queue.add(g);\n\t\t\t}\n\t\t}\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n\t */\n\tgetAllReferencedChunks() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunks = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tchunks.add(chunk);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n\t */\n\tgetAllReferencedAsyncEntrypoints() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst entrypoints = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n\t\t\t\tentrypoints.add(entrypoint);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn entrypoints;\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk references async chunks\n\t */\n\thasAsyncChunks() {\n\t\tconst queue = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders(chunkGraph, filterFn) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\tconst name = key.slice(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\tlist = [];\n\t\t\t\t\t\t\t\tlists.set(name, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, (string | number)[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\t/** @type {Set<string | number>} */\n\t\t\tconst chunkIdSet = new Set();\n\t\t\tfor (const item of list) {\n\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\tif (filterFn && !filterFn(chunk, chunkGraph)) continue;\n\t\t\t\t\tchunkIdSet.add(chunk.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chunkIdSet.size > 0) {\n\t\t\t\tresult[name] = Array.from(chunkIdSet);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {string} type option name\n\t * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n\t */\n\tgetChildrenOfTypeInOrder(chunkGraph, type) {\n\t\tconst list = [];\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\tconst order = childGroup.options[type];\n\t\t\t\tif (order === undefined) continue;\n\t\t\t\tlist.push({\n\t\t\t\t\torder,\n\t\t\t\t\tgroup,\n\t\t\t\t\tchildGroup\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (list.length === 0) return undefined;\n\t\tlist.sort((a, b) => {\n\t\t\tconst cmp = b.order - a.order;\n\t\t\tif (cmp !== 0) return cmp;\n\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t});\n\t\tconst result = [];\n\t\tlet lastEntry;\n\t\tfor (const { group, childGroup } of list) {\n\t\t\tif (lastEntry && lastEntry.onChunks === group.chunks) {\n\t\t\t\tfor (const chunk of childGroup.chunks) {\n\t\t\t\t\tlastEntry.chunks.add(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(\n\t\t\t\t\t(lastEntry = {\n\t\t\t\t\t\tonChunks: group.chunks,\n\t\t\t\t\t\tchunks: new Set(childGroup.chunks)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n\t */\n\tgetChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n\t\t/** @type {Record<string|number, Record<string, (string | number)[]>>} */\n\t\tconst chunkMaps = Object.create(null);\n\n\t\t/**\n\t\t * @param {Chunk} chunk a chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\t/** @type {Set<Chunk>} */\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n}\n\nmodule.exports = Chunk;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}