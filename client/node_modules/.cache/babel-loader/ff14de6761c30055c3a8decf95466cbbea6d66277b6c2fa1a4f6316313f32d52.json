{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  compareNumbers\n} = require(\"./util/comparators\");\nconst identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\nclass RecordIdsPlugin {\n  /**\n   * @param {Object} options Options object\n   * @param {boolean=} options.portableIds true, when ids need to be portable\n   */\n  constructor(options) {\n    this.options = options || {};\n  }\n\n  /**\n   * @param {Compiler} compiler the Compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    const portableIds = this.options.portableIds;\n    const makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n\n    /**\n     * @param {Module} module the module\n     * @returns {string} the (portable) identifier\n     */\n    const getModuleIdentifier = module => {\n      if (portableIds) {\n        return makePathsRelative(module.identifier());\n      }\n      return module.identifier();\n    };\n    compiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n      compilation.hooks.recordModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        const chunkGraph = compilation.chunkGraph;\n        if (!records.modules) records.modules = {};\n        if (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n        /** @type {Set<number>} */\n        const usedIds = new Set();\n        for (const module of modules) {\n          const moduleId = chunkGraph.getModuleId(module);\n          if (typeof moduleId !== \"number\") continue;\n          const identifier = getModuleIdentifier(module);\n          records.modules.byIdentifier[identifier] = moduleId;\n          usedIds.add(moduleId);\n        }\n        records.modules.usedIds = Array.from(usedIds).sort(compareNumbers);\n      });\n      compilation.hooks.reviveModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        if (!records.modules) return;\n        if (records.modules.byIdentifier) {\n          const chunkGraph = compilation.chunkGraph;\n          /** @type {Set<number>} */\n          const usedIds = new Set();\n          for (const module of modules) {\n            const moduleId = chunkGraph.getModuleId(module);\n            if (moduleId !== null) continue;\n            const identifier = getModuleIdentifier(module);\n            const id = records.modules.byIdentifier[identifier];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            chunkGraph.setModuleId(module, id);\n          }\n        }\n        if (Array.isArray(records.modules.usedIds)) {\n          compilation.usedModuleIds = new Set(records.modules.usedIds);\n        }\n      });\n\n      /**\n       * @param {Chunk} chunk the chunk\n       * @returns {string[]} sources of the chunk\n       */\n      const getChunkSources = chunk => {\n        /** @type {string[]} */\n        const sources = [];\n        for (const chunkGroup of chunk.groupsIterable) {\n          const index = chunkGroup.chunks.indexOf(chunk);\n          if (chunkGroup.name) {\n            sources.push(`${index} ${chunkGroup.name}`);\n          } else {\n            for (const origin of chunkGroup.origins) {\n              if (origin.module) {\n                if (origin.request) {\n                  sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.request}`);\n                } else if (typeof origin.loc === \"string\") {\n                  sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`);\n                } else if (origin.loc && typeof origin.loc === \"object\" && \"start\" in origin.loc) {\n                  sources.push(`${index} ${getModuleIdentifier(origin.module)} ${JSON.stringify(origin.loc.start)}`);\n                }\n              }\n            }\n          }\n        }\n        return sources;\n      };\n      compilation.hooks.recordChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) records.chunks = {};\n        if (!records.chunks.byName) records.chunks.byName = {};\n        if (!records.chunks.bySource) records.chunks.bySource = {};\n        /** @type {Set<number>} */\n        const usedIds = new Set();\n        for (const chunk of chunks) {\n          if (typeof chunk.id !== \"number\") continue;\n          const name = chunk.name;\n          if (name) records.chunks.byName[name] = chunk.id;\n          const sources = getChunkSources(chunk);\n          for (const source of sources) {\n            records.chunks.bySource[source] = chunk.id;\n          }\n          usedIds.add(chunk.id);\n        }\n        records.chunks.usedIds = Array.from(usedIds).sort(compareNumbers);\n      });\n      compilation.hooks.reviveChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) return;\n        /** @type {Set<number>} */\n        const usedIds = new Set();\n        if (records.chunks.byName) {\n          for (const chunk of chunks) {\n            if (chunk.id !== null) continue;\n            if (!chunk.name) continue;\n            const id = records.chunks.byName[chunk.name];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            chunk.id = id;\n            chunk.ids = [id];\n          }\n        }\n        if (records.chunks.bySource) {\n          for (const chunk of chunks) {\n            if (chunk.id !== null) continue;\n            const sources = getChunkSources(chunk);\n            for (const source of sources) {\n              const id = records.chunks.bySource[source];\n              if (id === undefined) continue;\n              if (usedIds.has(id)) continue;\n              usedIds.add(id);\n              chunk.id = id;\n              chunk.ids = [id];\n              break;\n            }\n          }\n        }\n        if (Array.isArray(records.chunks.usedIds)) {\n          compilation.usedChunkIds = new Set(records.chunks.usedIds);\n        }\n      });\n    });\n  }\n}\nmodule.exports = RecordIdsPlugin;","map":{"version":3,"names":["compareNumbers","require","identifierUtils","RecordIdsPlugin","constructor","options","apply","compiler","portableIds","makePathsRelative","bindContextCache","context","root","getModuleIdentifier","module","identifier","hooks","compilation","tap","recordModules","modules","records","chunkGraph","byIdentifier","usedIds","Set","moduleId","getModuleId","add","Array","from","sort","reviveModules","id","undefined","has","setModuleId","isArray","usedModuleIds","getChunkSources","chunk","sources","chunkGroup","groupsIterable","index","chunks","indexOf","name","push","origin","origins","request","loc","JSON","stringify","start","recordChunks","byName","bySource","source","reviveChunks","ids","usedChunkIds","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/RecordIdsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { compareNumbers } = require(\"./util/comparators\");\nconst identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\nclass RecordIdsPlugin {\n\t/**\n\t * @param {Object} options Options object\n\t * @param {boolean=} options.portableIds true, when ids need to be portable\n\t */\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the Compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst portableIds = this.options.portableIds;\n\n\t\tconst makePathsRelative =\n\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\tcompiler.context,\n\t\t\t\tcompiler.root\n\t\t\t);\n\n\t\t/**\n\t\t * @param {Module} module the module\n\t\t * @returns {string} the (portable) identifier\n\t\t */\n\t\tconst getModuleIdentifier = module => {\n\t\t\tif (portableIds) {\n\t\t\t\treturn makePathsRelative(module.identifier());\n\t\t\t}\n\t\t\treturn module.identifier();\n\t\t};\n\n\t\tcompiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.recordModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tif (!records.modules) records.modules = {};\n\t\t\t\t\tif (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\t\tif (typeof moduleId !== \"number\") continue;\n\t\t\t\t\t\tconst identifier = getModuleIdentifier(module);\n\t\t\t\t\t\trecords.modules.byIdentifier[identifier] = moduleId;\n\t\t\t\t\t\tusedIds.add(moduleId);\n\t\t\t\t\t}\n\t\t\t\t\trecords.modules.usedIds = Array.from(usedIds).sort(compareNumbers);\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) return;\n\t\t\t\t\tif (records.modules.byIdentifier) {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\t\t\tif (moduleId !== null) continue;\n\t\t\t\t\t\t\tconst identifier = getModuleIdentifier(module);\n\t\t\t\t\t\t\tconst id = records.modules.byIdentifier[identifier];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tchunkGraph.setModuleId(module, id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.modules.usedIds)) {\n\t\t\t\t\t\tcompilation.usedModuleIds = new Set(records.modules.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {string[]} sources of the chunk\n\t\t\t */\n\t\t\tconst getChunkSources = chunk => {\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tconst sources = [];\n\t\t\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\t\t\tconst index = chunkGroup.chunks.indexOf(chunk);\n\t\t\t\t\tif (chunkGroup.name) {\n\t\t\t\t\t\tsources.push(`${index} ${chunkGroup.name}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const origin of chunkGroup.origins) {\n\t\t\t\t\t\t\tif (origin.module) {\n\t\t\t\t\t\t\t\tif (origin.request) {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\t\torigin.request\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (typeof origin.loc === \"string\") {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\t\torigin.loc\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\torigin.loc &&\n\t\t\t\t\t\t\t\t\ttypeof origin.loc === \"object\" &&\n\t\t\t\t\t\t\t\t\t\"start\" in origin.loc\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(\n\t\t\t\t\t\t\t\t\t\t\torigin.module\n\t\t\t\t\t\t\t\t\t\t)} ${JSON.stringify(origin.loc.start)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sources;\n\t\t\t};\n\n\t\t\tcompilation.hooks.recordChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) records.chunks = {};\n\t\t\t\t\tif (!records.chunks.byName) records.chunks.byName = {};\n\t\t\t\t\tif (!records.chunks.bySource) records.chunks.bySource = {};\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tif (typeof chunk.id !== \"number\") continue;\n\t\t\t\t\t\tconst name = chunk.name;\n\t\t\t\t\t\tif (name) records.chunks.byName[name] = chunk.id;\n\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\trecords.chunks.bySource[source] = chunk.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\trecords.chunks.usedIds = Array.from(usedIds).sort(compareNumbers);\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) return;\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tif (records.chunks.byName) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tif (chunk.id !== null) continue;\n\t\t\t\t\t\t\tif (!chunk.name) continue;\n\t\t\t\t\t\t\tconst id = records.chunks.byName[chunk.name];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t\tchunk.ids = [id];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (records.chunks.bySource) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tif (chunk.id !== null) continue;\n\t\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\t\tconst id = records.chunks.bySource[source];\n\t\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t\t\tchunk.ids = [id];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.chunks.usedIds)) {\n\t\t\t\t\t\tcompilation.usedChunkIds = new Set(records.chunks.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RecordIdsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}