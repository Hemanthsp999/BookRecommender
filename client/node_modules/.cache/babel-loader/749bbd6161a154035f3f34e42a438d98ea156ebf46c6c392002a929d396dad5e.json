{"ast":null,"code":"\"use strict\";\n\nconst WebSocket = require(\"ws\");\nconst BaseServer = require(\"./BaseServer\");\n\n/** @typedef {import(\"../Server\").WebSocketServerConfiguration} WebSocketServerConfiguration */\n/** @typedef {import(\"../Server\").ClientConnection} ClientConnection */\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  static heartbeatInterval = 1000;\n\n  /**\n   * @param {import(\"../Server\")} server\n   */\n  constructor(server) {\n    super(server);\n\n    /** @type {import(\"ws\").ServerOptions} */\n    const options = {\n      ... /** @type {WebSocketServerConfiguration} */\n      this.server.options.webSocketServer.options,\n      clientTracking: false\n    };\n    const isNoServerMode = typeof options.port === \"undefined\" && typeof options.server === \"undefined\";\n    if (isNoServerMode) {\n      options.noServer = true;\n    }\n    this.implementation = new WebSocket.Server(options);\n\n    /** @type {import(\"http\").Server} */\n    this.server.server.on(\"upgrade\",\n    /**\n     * @param {import(\"http\").IncomingMessage} req\n     * @param {import(\"stream\").Duplex} sock\n     * @param {Buffer} head\n     */\n    (req, sock, head) => {\n      if (!this.implementation.shouldHandle(req)) {\n        return;\n      }\n      this.implementation.handleUpgrade(req, sock, head, connection => {\n        this.implementation.emit(\"connection\", connection, req);\n      });\n    });\n    this.implementation.on(\"error\",\n    /**\n     * @param {Error} err\n     */\n    err => {\n      this.server.logger.error(err.message);\n    });\n    const interval = setInterval(() => {\n      this.clients.forEach(\n      /**\n       * @param {ClientConnection} client\n       */\n      client => {\n        if (client.isAlive === false) {\n          client.terminate();\n          return;\n        }\n        client.isAlive = false;\n        client.ping(() => {});\n      });\n    }, WebsocketServer.heartbeatInterval);\n    this.implementation.on(\"connection\",\n    /**\n     * @param {ClientConnection} client\n     */\n    client => {\n      this.clients.push(client);\n      client.isAlive = true;\n      client.on(\"pong\", () => {\n        client.isAlive = true;\n      });\n      client.on(\"close\", () => {\n        this.clients.splice(this.clients.indexOf(client), 1);\n      });\n    });\n    this.implementation.on(\"close\", () => {\n      clearInterval(interval);\n    });\n  }\n};","map":{"version":3,"names":["WebSocket","require","BaseServer","module","exports","WebsocketServer","heartbeatInterval","constructor","server","options","webSocketServer","clientTracking","isNoServerMode","port","noServer","implementation","Server","on","req","sock","head","shouldHandle","handleUpgrade","connection","emit","err","logger","error","message","interval","setInterval","clients","forEach","client","isAlive","terminate","ping","push","splice","indexOf","clearInterval"],"sources":["/home/hemanth/react-project/client/node_modules/webpack-dev-server/lib/servers/WebsocketServer.js"],"sourcesContent":["\"use strict\";\n\nconst WebSocket = require(\"ws\");\nconst BaseServer = require(\"./BaseServer\");\n\n/** @typedef {import(\"../Server\").WebSocketServerConfiguration} WebSocketServerConfiguration */\n/** @typedef {import(\"../Server\").ClientConnection} ClientConnection */\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  static heartbeatInterval = 1000;\n\n  /**\n   * @param {import(\"../Server\")} server\n   */\n  constructor(server) {\n    super(server);\n\n    /** @type {import(\"ws\").ServerOptions} */\n    const options = {\n      .../** @type {WebSocketServerConfiguration} */\n      (this.server.options.webSocketServer).options,\n      clientTracking: false,\n    };\n    const isNoServerMode =\n      typeof options.port === \"undefined\" &&\n      typeof options.server === \"undefined\";\n\n    if (isNoServerMode) {\n      options.noServer = true;\n    }\n\n    this.implementation = new WebSocket.Server(options);\n\n    /** @type {import(\"http\").Server} */\n    (this.server.server).on(\n      \"upgrade\",\n      /**\n       * @param {import(\"http\").IncomingMessage} req\n       * @param {import(\"stream\").Duplex} sock\n       * @param {Buffer} head\n       */\n      (req, sock, head) => {\n        if (!this.implementation.shouldHandle(req)) {\n          return;\n        }\n\n        this.implementation.handleUpgrade(req, sock, head, (connection) => {\n          this.implementation.emit(\"connection\", connection, req);\n        });\n      }\n    );\n\n    this.implementation.on(\n      \"error\",\n      /**\n       * @param {Error} err\n       */\n      (err) => {\n        this.server.logger.error(err.message);\n      }\n    );\n\n    const interval = setInterval(() => {\n      this.clients.forEach(\n        /**\n         * @param {ClientConnection} client\n         */\n        (client) => {\n          if (client.isAlive === false) {\n            client.terminate();\n\n            return;\n          }\n\n          client.isAlive = false;\n          client.ping(() => {});\n        }\n      );\n    }, WebsocketServer.heartbeatInterval);\n\n    this.implementation.on(\n      \"connection\",\n      /**\n       * @param {ClientConnection} client\n       */\n      (client) => {\n        this.clients.push(client);\n\n        client.isAlive = true;\n\n        client.on(\"pong\", () => {\n          client.isAlive = true;\n        });\n\n        client.on(\"close\", () => {\n          this.clients.splice(this.clients.indexOf(client), 1);\n        });\n      }\n    );\n\n    this.implementation.on(\"close\", () => {\n      clearInterval(interval);\n    });\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}