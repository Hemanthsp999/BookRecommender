{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst {\n  Tracer\n} = require(\"chrome-trace-event\");\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_DYNAMIC,\n  JAVASCRIPT_MODULE_TYPE_ESM,\n  WEBASSEMBLY_MODULE_TYPE_ASYNC,\n  WEBASSEMBLY_MODULE_TYPE_SYNC,\n  JSON_MODULE_TYPE\n} = require(\"../ModuleTypeConstants\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst {\n  dirname,\n  mkdirpSync\n} = require(\"../util/fs\");\n\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/debug/ProfilingPlugin.check.js\"), () => require(\"../../schemas/plugins/debug/ProfilingPlugin.json\"), {\n  name: \"Profiling Plugin\",\n  baseDataPath: \"options\"\n});\nlet inspector = undefined;\ntry {\n  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n  inspector = require(\"inspector\");\n} catch (e) {\n  console.log(\"Unable to CPU profile in < node 8.0\");\n}\nclass Profiler {\n  constructor(inspector) {\n    this.session = undefined;\n    this.inspector = inspector;\n    this._startTime = 0;\n  }\n  hasSession() {\n    return this.session !== undefined;\n  }\n  startProfiling() {\n    if (this.inspector === undefined) {\n      return Promise.resolve();\n    }\n    try {\n      this.session = new inspector.Session();\n      this.session.connect();\n    } catch (_) {\n      this.session = undefined;\n      return Promise.resolve();\n    }\n    const hrtime = process.hrtime();\n    this._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n    return Promise.all([this.sendCommand(\"Profiler.setSamplingInterval\", {\n      interval: 100\n    }), this.sendCommand(\"Profiler.enable\"), this.sendCommand(\"Profiler.start\")]);\n  }\n\n  /**\n   * @param {string} method method name\n   * @param {object} [params] params\n   * @returns {Promise<TODO>} Promise for the result\n   */\n  sendCommand(method, params) {\n    if (this.hasSession()) {\n      return new Promise((res, rej) => {\n        return this.session.post(method, params, (err, params) => {\n          if (err !== null) {\n            rej(err);\n          } else {\n            res(params);\n          }\n        });\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n  destroy() {\n    if (this.hasSession()) {\n      this.session.disconnect();\n    }\n    return Promise.resolve();\n  }\n  stopProfiling() {\n    return this.sendCommand(\"Profiler.stop\").then(_ref => {\n      let {\n        profile\n      } = _ref;\n      const hrtime = process.hrtime();\n      const endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n      // Avoid coverage problems due indirect changes\n      /* istanbul ignore next */\n      if (profile.startTime < this._startTime || profile.endTime > endTime) {\n        // In some cases timestamps mismatch and we need to adjust them\n        // Both process.hrtime and the inspector timestamps claim to be relative\n        // to a unknown point in time. But they do not guarantee that this is the\n        // same point in time.\n        const duration = profile.endTime - profile.startTime;\n        const ownDuration = endTime - this._startTime;\n        const untracked = Math.max(0, ownDuration - duration);\n        profile.startTime = this._startTime + untracked / 2;\n        profile.endTime = endTime - untracked / 2;\n      }\n      return {\n        profile\n      };\n    });\n  }\n}\n\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {IntermediateFileSystem} fs filesystem used for output\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\nconst createTrace = (fs, outputPath) => {\n  const trace = new Tracer();\n  const profiler = new Profiler(inspector);\n  if (/\\/|\\\\/.test(outputPath)) {\n    const dirPath = dirname(fs, outputPath);\n    mkdirpSync(fs, dirPath);\n  }\n  const fsStream = fs.createWriteStream(outputPath);\n  let counter = 0;\n  trace.pipe(fsStream);\n  // These are critical events that need to be inserted so that tools like\n  // chrome dev tools can load the profile.\n  trace.instantEvent({\n    name: \"TracingStartedInPage\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\",\n        page: \"0xfff\",\n        frames: [{\n          frame: \"0xfff\",\n          url: \"webpack\",\n          name: \"\"\n        }]\n      }\n    }\n  });\n  trace.instantEvent({\n    name: \"TracingStartedInBrowser\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\"\n      }\n    }\n  });\n  return {\n    trace,\n    counter,\n    profiler,\n    end: callback => {\n      trace.push(\"]\");\n      // Wait until the write stream finishes.\n      fsStream.on(\"close\", () => {\n        callback();\n      });\n      // Tear down the readable trace stream.\n      trace.push(null);\n    }\n  };\n};\nconst PLUGIN_NAME = \"ProfilingPlugin\";\nclass ProfilingPlugin {\n  /**\n   * @param {ProfilingPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.outputPath = options.outputPath || \"events.json\";\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const tracer = createTrace(compiler.intermediateFileSystem, this.outputPath);\n    tracer.profiler.startProfiling();\n\n    // Compiler Hooks\n    Object.keys(compiler.hooks).forEach(hookName => {\n      const hook = compiler.hooks[hookName];\n      if (hook) {\n        hook.intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n      }\n    });\n    Object.keys(compiler.resolverFactory.hooks).forEach(hookName => {\n      const hook = compiler.resolverFactory.hooks[hookName];\n      if (hook) {\n        hook.intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n      }\n    });\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, _ref2) => {\n      let {\n        normalModuleFactory,\n        contextModuleFactory\n      } = _ref2;\n      interceptAllHooksFor(compilation, tracer, \"Compilation\");\n      interceptAllHooksFor(normalModuleFactory, tracer, \"Normal Module Factory\");\n      interceptAllHooksFor(contextModuleFactory, tracer, \"Context Module Factory\");\n      interceptAllParserHooks(normalModuleFactory, tracer);\n      interceptAllJavascriptModulesPluginHooks(compilation, tracer);\n    });\n\n    // We need to write out the CPU profile when we are all done.\n    compiler.hooks.done.tapAsync({\n      name: PLUGIN_NAME,\n      stage: Infinity\n    }, (stats, callback) => {\n      if (compiler.watchMode) return callback();\n      tracer.profiler.stopProfiling().then(parsedResults => {\n        if (parsedResults === undefined) {\n          tracer.profiler.destroy();\n          tracer.end(callback);\n          return;\n        }\n        const cpuStartTime = parsedResults.profile.startTime;\n        const cpuEndTime = parsedResults.profile.endTime;\n        tracer.trace.completeEvent({\n          name: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n          id: ++tracer.counter,\n          cat: [\"toplevel\"],\n          ts: cpuStartTime,\n          args: {\n            src_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n            src_func: \"Accept\"\n          }\n        });\n        tracer.trace.completeEvent({\n          name: \"EvaluateScript\",\n          id: ++tracer.counter,\n          cat: [\"devtools.timeline\"],\n          ts: cpuStartTime,\n          dur: cpuEndTime - cpuStartTime,\n          args: {\n            data: {\n              url: \"webpack\",\n              lineNumber: 1,\n              columnNumber: 1,\n              frame: \"0xFFF\"\n            }\n          }\n        });\n        tracer.trace.instantEvent({\n          name: \"CpuProfile\",\n          id: ++tracer.counter,\n          cat: [\"disabled-by-default-devtools.timeline\"],\n          ts: cpuEndTime,\n          args: {\n            data: {\n              cpuProfile: parsedResults.profile\n            }\n          }\n        });\n        tracer.profiler.destroy();\n        tracer.end(callback);\n      });\n    });\n  }\n}\nconst interceptAllHooksFor = (instance, tracer, logLabel) => {\n  if (Reflect.has(instance, \"hooks\")) {\n    Object.keys(instance.hooks).forEach(hookName => {\n      const hook = instance.hooks[hookName];\n      if (hook && !hook._fakeHook) {\n        hook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n      }\n    });\n  }\n};\nconst interceptAllParserHooks = (moduleFactory, tracer) => {\n  const moduleTypes = [JAVASCRIPT_MODULE_TYPE_AUTO, JAVASCRIPT_MODULE_TYPE_DYNAMIC, JAVASCRIPT_MODULE_TYPE_ESM, JSON_MODULE_TYPE, WEBASSEMBLY_MODULE_TYPE_ASYNC, WEBASSEMBLY_MODULE_TYPE_SYNC];\n  moduleTypes.forEach(moduleType => {\n    moduleFactory.hooks.parser.for(moduleType).tap(PLUGIN_NAME, (parser, parserOpts) => {\n      interceptAllHooksFor(parser, tracer, \"Parser\");\n    });\n  });\n};\nconst interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {\n  interceptAllHooksFor({\n    hooks: require(\"../javascript/JavascriptModulesPlugin\").getCompilationHooks(compilation)\n  }, tracer, \"JavascriptModulesPlugin\");\n};\nconst makeInterceptorFor = (instance, tracer) => hookName => ({\n  register: tapInfo => {\n    const {\n      name,\n      type,\n      fn\n    } = tapInfo;\n    const newFn =\n    // Don't tap our own hooks to ensure stream can close cleanly\n    name === PLUGIN_NAME ? fn : makeNewProfiledTapFn(hookName, tracer, {\n      name,\n      type,\n      fn\n    });\n    return {\n      ...tapInfo,\n      fn: newFn\n    };\n  }\n});\n\n// TODO improve typing\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\nconst makeNewProfiledTapFn = (hookName, tracer, _ref3) => {\n  let {\n    name,\n    type,\n    fn\n  } = _ref3;\n  const defaultCategory = [\"blink.user_timing\"];\n  switch (type) {\n    case \"promise\":\n      return function () {\n        const id = ++tracer.counter;\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        const promise = /** @type {Promise<*>} */fn(...arguments);\n        return promise.then(r => {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          return r;\n        });\n      };\n    case \"async\":\n      return function () {\n        const id = ++tracer.counter;\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const callback = args.pop();\n        fn(...args, function () {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          callback(...arguments);\n        });\n      };\n    case \"sync\":\n      return function () {\n        const id = ++tracer.counter;\n        // Do not instrument ourself due to the CPU\n        // profile needing to be the last event in the trace.\n        if (name === PLUGIN_NAME) {\n          return fn(...arguments);\n        }\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        let r;\n        try {\n          r = fn(...arguments);\n        } catch (error) {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          throw error;\n        }\n        tracer.trace.end({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        return r;\n      };\n    default:\n      break;\n  }\n};\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;","map":{"version":3,"names":["Tracer","require","JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_DYNAMIC","JAVASCRIPT_MODULE_TYPE_ESM","WEBASSEMBLY_MODULE_TYPE_ASYNC","WEBASSEMBLY_MODULE_TYPE_SYNC","JSON_MODULE_TYPE","createSchemaValidation","dirname","mkdirpSync","validate","name","baseDataPath","inspector","undefined","e","console","log","Profiler","constructor","session","_startTime","hasSession","startProfiling","Promise","resolve","Session","connect","_","hrtime","process","Math","round","all","sendCommand","interval","method","params","res","rej","post","err","destroy","disconnect","stopProfiling","then","_ref","profile","endTime","startTime","duration","ownDuration","untracked","max","createTrace","fs","outputPath","trace","profiler","test","dirPath","fsStream","createWriteStream","counter","pipe","instantEvent","id","cat","args","data","sessionId","page","frames","frame","url","end","callback","push","on","PLUGIN_NAME","ProfilingPlugin","options","arguments","length","apply","compiler","tracer","intermediateFileSystem","Object","keys","hooks","forEach","hookName","hook","intercept","makeInterceptorFor","resolverFactory","compilation","tap","_ref2","normalModuleFactory","contextModuleFactory","interceptAllHooksFor","interceptAllParserHooks","interceptAllJavascriptModulesPluginHooks","done","tapAsync","stage","Infinity","stats","watchMode","parsedResults","cpuStartTime","cpuEndTime","completeEvent","ts","src_file","src_func","dur","lineNumber","columnNumber","cpuProfile","instance","logLabel","Reflect","has","_fakeHook","moduleFactory","moduleTypes","moduleType","parser","for","parserOpts","getCompilationHooks","register","tapInfo","type","fn","newFn","makeNewProfiledTapFn","_ref3","defaultCategory","begin","promise","r","_len","Array","_key","pop","error","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/debug/ProfilingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst { Tracer } = require(\"chrome-trace-event\");\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_DYNAMIC,\n\tJAVASCRIPT_MODULE_TYPE_ESM,\n\tWEBASSEMBLY_MODULE_TYPE_ASYNC,\n\tWEBASSEMBLY_MODULE_TYPE_SYNC,\n\tJSON_MODULE_TYPE\n} = require(\"../ModuleTypeConstants\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst { dirname, mkdirpSync } = require(\"../util/fs\");\n\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/debug/ProfilingPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/debug/ProfilingPlugin.json\"),\n\t{\n\t\tname: \"Profiling Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\nlet inspector = undefined;\n\ntry {\n\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\tinspector = require(\"inspector\");\n} catch (e) {\n\tconsole.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nclass Profiler {\n\tconstructor(inspector) {\n\t\tthis.session = undefined;\n\t\tthis.inspector = inspector;\n\t\tthis._startTime = 0;\n\t}\n\n\thasSession() {\n\t\treturn this.session !== undefined;\n\t}\n\n\tstartProfiling() {\n\t\tif (this.inspector === undefined) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\ttry {\n\t\t\tthis.session = new inspector.Session();\n\t\t\tthis.session.connect();\n\t\t} catch (_) {\n\t\t\tthis.session = undefined;\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst hrtime = process.hrtime();\n\t\tthis._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\n\t\treturn Promise.all([\n\t\t\tthis.sendCommand(\"Profiler.setSamplingInterval\", {\n\t\t\t\tinterval: 100\n\t\t\t}),\n\t\t\tthis.sendCommand(\"Profiler.enable\"),\n\t\t\tthis.sendCommand(\"Profiler.start\")\n\t\t]);\n\t}\n\n\t/**\n\t * @param {string} method method name\n\t * @param {object} [params] params\n\t * @returns {Promise<TODO>} Promise for the result\n\t */\n\tsendCommand(method, params) {\n\t\tif (this.hasSession()) {\n\t\t\treturn new Promise((res, rej) => {\n\t\t\t\treturn this.session.post(method, params, (err, params) => {\n\t\t\t\t\tif (err !== null) {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(params);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this.hasSession()) {\n\t\t\tthis.session.disconnect();\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\tstopProfiling() {\n\t\treturn this.sendCommand(\"Profiler.stop\").then(({ profile }) => {\n\t\t\tconst hrtime = process.hrtime();\n\t\t\tconst endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);\n\t\t\t// Avoid coverage problems due indirect changes\n\t\t\t/* istanbul ignore next */\n\t\t\tif (profile.startTime < this._startTime || profile.endTime > endTime) {\n\t\t\t\t// In some cases timestamps mismatch and we need to adjust them\n\t\t\t\t// Both process.hrtime and the inspector timestamps claim to be relative\n\t\t\t\t// to a unknown point in time. But they do not guarantee that this is the\n\t\t\t\t// same point in time.\n\t\t\t\tconst duration = profile.endTime - profile.startTime;\n\t\t\t\tconst ownDuration = endTime - this._startTime;\n\t\t\t\tconst untracked = Math.max(0, ownDuration - duration);\n\t\t\t\tprofile.startTime = this._startTime + untracked / 2;\n\t\t\t\tprofile.endTime = endTime - untracked / 2;\n\t\t\t}\n\t\t\treturn { profile };\n\t\t});\n\t}\n}\n\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {IntermediateFileSystem} fs filesystem used for output\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\nconst createTrace = (fs, outputPath) => {\n\tconst trace = new Tracer();\n\tconst profiler = new Profiler(inspector);\n\tif (/\\/|\\\\/.test(outputPath)) {\n\t\tconst dirPath = dirname(fs, outputPath);\n\t\tmkdirpSync(fs, dirPath);\n\t}\n\tconst fsStream = fs.createWriteStream(outputPath);\n\n\tlet counter = 0;\n\n\ttrace.pipe(fsStream);\n\t// These are critical events that need to be inserted so that tools like\n\t// chrome dev tools can load the profile.\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInPage\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\",\n\t\t\t\tpage: \"0xfff\",\n\t\t\t\tframes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tframe: \"0xfff\",\n\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\tname: \"\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t});\n\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInBrowser\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\"\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\ttrace,\n\t\tcounter,\n\t\tprofiler,\n\t\tend: callback => {\n\t\t\ttrace.push(\"]\");\n\t\t\t// Wait until the write stream finishes.\n\t\t\tfsStream.on(\"close\", () => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t\t// Tear down the readable trace stream.\n\t\t\ttrace.push(null);\n\t\t}\n\t};\n};\n\nconst PLUGIN_NAME = \"ProfilingPlugin\";\n\nclass ProfilingPlugin {\n\t/**\n\t * @param {ProfilingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\t\tthis.outputPath = options.outputPath || \"events.json\";\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst tracer = createTrace(\n\t\t\tcompiler.intermediateFileSystem,\n\t\t\tthis.outputPath\n\t\t);\n\t\ttracer.profiler.startProfiling();\n\n\t\t// Compiler Hooks\n\t\tObject.keys(compiler.hooks).forEach(hookName => {\n\t\t\tconst hook = compiler.hooks[hookName];\n\t\t\tif (hook) {\n\t\t\t\thook.intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n\t\t\t}\n\t\t});\n\n\t\tObject.keys(compiler.resolverFactory.hooks).forEach(hookName => {\n\t\t\tconst hook = compiler.resolverFactory.hooks[hookName];\n\t\t\tif (hook) {\n\t\t\t\thook.intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n\t\t\t}\n\t\t});\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory, contextModuleFactory }) => {\n\t\t\t\tinterceptAllHooksFor(compilation, tracer, \"Compilation\");\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tnormalModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Normal Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tcontextModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Context Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllParserHooks(normalModuleFactory, tracer);\n\t\t\t\tinterceptAllJavascriptModulesPluginHooks(compilation, tracer);\n\t\t\t}\n\t\t);\n\n\t\t// We need to write out the CPU profile when we are all done.\n\t\tcompiler.hooks.done.tapAsync(\n\t\t\t{\n\t\t\t\tname: PLUGIN_NAME,\n\t\t\t\tstage: Infinity\n\t\t\t},\n\t\t\t(stats, callback) => {\n\t\t\t\tif (compiler.watchMode) return callback();\n\t\t\t\ttracer.profiler.stopProfiling().then(parsedResults => {\n\t\t\t\t\tif (parsedResults === undefined) {\n\t\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\t\ttracer.end(callback);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cpuStartTime = parsedResults.profile.startTime;\n\t\t\t\t\tconst cpuEndTime = parsedResults.profile.endTime;\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"toplevel\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tsrc_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n\t\t\t\t\t\t\tsrc_func: \"Accept\"\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"EvaluateScript\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"devtools.timeline\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\tdur: cpuEndTime - cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\t\t\tlineNumber: 1,\n\t\t\t\t\t\t\t\tcolumnNumber: 1,\n\t\t\t\t\t\t\t\tframe: \"0xFFF\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.instantEvent({\n\t\t\t\t\t\tname: \"CpuProfile\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\t\t\t\t\tts: cpuEndTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tcpuProfile: parsedResults.profile\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\ttracer.end(callback);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nconst interceptAllHooksFor = (instance, tracer, logLabel) => {\n\tif (Reflect.has(instance, \"hooks\")) {\n\t\tObject.keys(instance.hooks).forEach(hookName => {\n\t\t\tconst hook = instance.hooks[hookName];\n\t\t\tif (hook && !hook._fakeHook) {\n\t\t\t\thook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n\t\t\t}\n\t\t});\n\t}\n};\n\nconst interceptAllParserHooks = (moduleFactory, tracer) => {\n\tconst moduleTypes = [\n\t\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\t\tJAVASCRIPT_MODULE_TYPE_DYNAMIC,\n\t\tJAVASCRIPT_MODULE_TYPE_ESM,\n\t\tJSON_MODULE_TYPE,\n\t\tWEBASSEMBLY_MODULE_TYPE_ASYNC,\n\t\tWEBASSEMBLY_MODULE_TYPE_SYNC\n\t];\n\n\tmoduleTypes.forEach(moduleType => {\n\t\tmoduleFactory.hooks.parser\n\t\t\t.for(moduleType)\n\t\t\t.tap(PLUGIN_NAME, (parser, parserOpts) => {\n\t\t\t\tinterceptAllHooksFor(parser, tracer, \"Parser\");\n\t\t\t});\n\t});\n};\n\nconst interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {\n\tinterceptAllHooksFor(\n\t\t{\n\t\t\thooks:\n\t\t\t\trequire(\"../javascript/JavascriptModulesPlugin\").getCompilationHooks(\n\t\t\t\t\tcompilation\n\t\t\t\t)\n\t\t},\n\t\ttracer,\n\t\t\"JavascriptModulesPlugin\"\n\t);\n};\n\nconst makeInterceptorFor = (instance, tracer) => hookName => ({\n\tregister: tapInfo => {\n\t\tconst { name, type, fn } = tapInfo;\n\t\tconst newFn =\n\t\t\t// Don't tap our own hooks to ensure stream can close cleanly\n\t\t\tname === PLUGIN_NAME\n\t\t\t\t? fn\n\t\t\t\t: makeNewProfiledTapFn(hookName, tracer, {\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tfn\n\t\t\t\t  });\n\t\treturn {\n\t\t\t...tapInfo,\n\t\t\tfn: newFn\n\t\t};\n\t}\n});\n\n// TODO improve typing\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\nconst makeNewProfiledTapFn = (hookName, tracer, { name, type, fn }) => {\n\tconst defaultCategory = [\"blink.user_timing\"];\n\n\tswitch (type) {\n\t\tcase \"promise\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst promise = /** @type {Promise<*>} */ (fn(...args));\n\t\t\t\treturn promise.then(r => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\treturn r;\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"async\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst callback = args.pop();\n\t\t\t\tfn(...args, (...r) => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tcallback(...r);\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"sync\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\t// Do not instrument ourself due to the CPU\n\t\t\t\t// profile needing to be the last event in the trace.\n\t\t\t\tif (name === PLUGIN_NAME) {\n\t\t\t\t\treturn fn(...args);\n\t\t\t\t}\n\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tlet r;\n\t\t\t\ttry {\n\t\t\t\t\tr = fn(...args);\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\ttracer.trace.end({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\treturn r;\n\t\t\t};\n\t\tdefault:\n\t\t\tbreak;\n\t}\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}