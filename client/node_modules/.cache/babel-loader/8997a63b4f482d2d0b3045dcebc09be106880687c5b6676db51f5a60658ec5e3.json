{"ast":null,"code":"var forge = require('node-forge');\n\n// a hexString is considered negative if it's most significant bit is 1\n// because serial numbers use ones' complement notation\n// this RFC in section 4.1.2.2 requires serial numbers to be positive\n// http://www.ietf.org/rfc/rfc5280.txt\nfunction toPositiveHex(hexString) {\n  var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);\n  if (mostSiginficativeHexAsInt < 8) {\n    return hexString;\n  }\n  mostSiginficativeHexAsInt -= 8;\n  return mostSiginficativeHexAsInt.toString() + hexString.substring(1);\n}\nfunction getAlgorithm(key) {\n  switch (key) {\n    case 'sha256':\n      return forge.md.sha256.create();\n    default:\n      return forge.md.sha1.create();\n  }\n}\n\n/**\n *\n * @param {forge.pki.CertificateField[]} attrs Attributes used for subject and issuer.\n * @param {object} options\n * @param {number} [options.days=365] the number of days before expiration\n * @param {number} [options.keySize=1024] the size for the private key in bits\n * @param {object} [options.extensions] additional extensions for the certificate\n * @param {string} [options.algorithm=\"sha1\"] The signature algorithm sha256 or sha1\n * @param {boolean} [options.pkcs7=false] include PKCS#7 as part of the output\n * @param {boolean} [options.clientCertificate=false] generate client cert signed by the original key\n * @param {string} [options.clientCertificateCN=\"John Doe jdoe123\"] client certificate's common name\n * @param {function} [done] Optional callback, if not provided the generation is synchronous\n * @returns\n */\nexports.generate = function generate(attrs, options, done) {\n  if (typeof attrs === 'function') {\n    done = attrs;\n    attrs = undefined;\n  } else if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n  options = options || {};\n  var generatePem = function (keyPair) {\n    var cert = forge.pki.createCertificate();\n    cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9))); // the serial number can be decimal or hex (if preceded by 0x)\n\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options.days || 365));\n    attrs = attrs || [{\n      name: 'commonName',\n      value: 'example.org'\n    }, {\n      name: 'countryName',\n      value: 'US'\n    }, {\n      shortName: 'ST',\n      value: 'Virginia'\n    }, {\n      name: 'localityName',\n      value: 'Blacksburg'\n    }, {\n      name: 'organizationName',\n      value: 'Test'\n    }, {\n      shortName: 'OU',\n      value: 'Test'\n    }];\n    cert.setSubject(attrs);\n    cert.setIssuer(attrs);\n    cert.publicKey = keyPair.publicKey;\n    cert.setExtensions(options.extensions || [{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'subjectAltName',\n      altNames: [{\n        type: 6,\n        // URI\n        value: 'http://example.org/webid#me'\n      }]\n    }]);\n    cert.sign(keyPair.privateKey, getAlgorithm(options && options.algorithm));\n    const fingerprint = forge.md.sha1.create().update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes()).digest().toHex().match(/.{2}/g).join(':');\n    var pem = {\n      private: forge.pki.privateKeyToPem(keyPair.privateKey),\n      public: forge.pki.publicKeyToPem(keyPair.publicKey),\n      cert: forge.pki.certificateToPem(cert),\n      fingerprint: fingerprint\n    };\n    if (options && options.pkcs7) {\n      var p7 = forge.pkcs7.createSignedData();\n      p7.addCertificate(cert);\n      pem.pkcs7 = forge.pkcs7.messageToPem(p7);\n    }\n    if (options && options.clientCertificate) {\n      var clientkeys = forge.pki.rsa.generateKeyPair(1024);\n      var clientcert = forge.pki.createCertificate();\n      clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));\n      clientcert.validity.notBefore = new Date();\n      clientcert.validity.notAfter = new Date();\n      clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);\n      var clientAttrs = JSON.parse(JSON.stringify(attrs));\n      for (var i = 0; i < clientAttrs.length; i++) {\n        if (clientAttrs[i].name === 'commonName') {\n          if (options.clientCertificateCN) clientAttrs[i] = {\n            name: 'commonName',\n            value: options.clientCertificateCN\n          };else clientAttrs[i] = {\n            name: 'commonName',\n            value: 'John Doe jdoe123'\n          };\n        }\n      }\n      clientcert.setSubject(clientAttrs);\n\n      // Set the issuer to the parent key\n      clientcert.setIssuer(attrs);\n      clientcert.publicKey = clientkeys.publicKey;\n\n      // Sign client cert with root cert\n      clientcert.sign(keyPair.privateKey);\n      pem.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);\n      pem.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);\n      pem.clientcert = forge.pki.certificateToPem(clientcert);\n      if (options.pkcs7) {\n        var clientp7 = forge.pkcs7.createSignedData();\n        clientp7.addCertificate(clientcert);\n        pem.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);\n      }\n    }\n    var caStore = forge.pki.createCaStore();\n    caStore.addCertificate(cert);\n    try {\n      forge.pki.verifyCertificateChain(caStore, [cert], function (vfd, depth, chain) {\n        if (vfd !== true) {\n          throw new Error('Certificate could not be verified.');\n        }\n        return true;\n      });\n    } catch (ex) {\n      throw new Error(ex);\n    }\n    return pem;\n  };\n  var keySize = options.keySize || 1024;\n  if (done) {\n    // async scenario\n    return forge.pki.rsa.generateKeyPair({\n      bits: keySize\n    }, function (err, keyPair) {\n      if (err) {\n        return done(err);\n      }\n      try {\n        return done(null, generatePem(keyPair));\n      } catch (ex) {\n        return done(ex);\n      }\n    });\n  }\n  var keyPair = options.keyPair ? {\n    privateKey: forge.pki.privateKeyFromPem(options.keyPair.privateKey),\n    publicKey: forge.pki.publicKeyFromPem(options.keyPair.publicKey)\n  } : forge.pki.rsa.generateKeyPair(keySize);\n  return generatePem(keyPair);\n};","map":{"version":3,"names":["forge","require","toPositiveHex","hexString","mostSiginficativeHexAsInt","parseInt","toString","substring","getAlgorithm","key","md","sha256","create","sha1","exports","generate","attrs","options","done","undefined","generatePem","keyPair","cert","pki","createCertificate","serialNumber","util","bytesToHex","random","getBytesSync","validity","notBefore","Date","notAfter","setDate","getDate","days","name","value","shortName","setSubject","setIssuer","publicKey","setExtensions","extensions","cA","keyCertSign","digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","altNames","type","sign","privateKey","algorithm","fingerprint","update","asn1","toDer","certificateToAsn1","getBytes","digest","toHex","match","join","pem","private","privateKeyToPem","public","publicKeyToPem","certificateToPem","pkcs7","p7","createSignedData","addCertificate","messageToPem","clientCertificate","clientkeys","rsa","generateKeyPair","clientcert","setFullYear","getFullYear","clientAttrs","JSON","parse","stringify","i","length","clientCertificateCN","clientprivate","clientpublic","clientp7","clientpkcs7","caStore","createCaStore","verifyCertificateChain","vfd","depth","chain","Error","ex","keySize","bits","err","privateKeyFromPem","publicKeyFromPem"],"sources":["/home/hemanth/react-project/client/node_modules/selfsigned/index.js"],"sourcesContent":["var forge = require('node-forge');\n\n// a hexString is considered negative if it's most significant bit is 1\n// because serial numbers use ones' complement notation\n// this RFC in section 4.1.2.2 requires serial numbers to be positive\n// http://www.ietf.org/rfc/rfc5280.txt\nfunction toPositiveHex(hexString){\n  var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);\n  if (mostSiginficativeHexAsInt < 8){\n    return hexString;\n  }\n\n  mostSiginficativeHexAsInt -= 8;\n  return mostSiginficativeHexAsInt.toString() + hexString.substring(1);\n}\n\nfunction getAlgorithm(key) {\n  switch (key) {\n    case 'sha256':\n      return forge.md.sha256.create();\n    default:\n      return forge.md.sha1.create();\n  }\n}\n\n/**\n *\n * @param {forge.pki.CertificateField[]} attrs Attributes used for subject and issuer.\n * @param {object} options\n * @param {number} [options.days=365] the number of days before expiration\n * @param {number} [options.keySize=1024] the size for the private key in bits\n * @param {object} [options.extensions] additional extensions for the certificate\n * @param {string} [options.algorithm=\"sha1\"] The signature algorithm sha256 or sha1\n * @param {boolean} [options.pkcs7=false] include PKCS#7 as part of the output\n * @param {boolean} [options.clientCertificate=false] generate client cert signed by the original key\n * @param {string} [options.clientCertificateCN=\"John Doe jdoe123\"] client certificate's common name\n * @param {function} [done] Optional callback, if not provided the generation is synchronous\n * @returns\n */\nexports.generate = function generate(attrs, options, done) {\n  if (typeof attrs === 'function') {\n    done = attrs;\n    attrs = undefined;\n  } else if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var generatePem = function (keyPair) {\n    var cert = forge.pki.createCertificate();\n\n    cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9))); // the serial number can be decimal or hex (if preceded by 0x)\n\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options.days || 365));\n\n    attrs = attrs || [{\n      name: 'commonName',\n      value: 'example.org'\n    }, {\n      name: 'countryName',\n      value: 'US'\n    }, {\n      shortName: 'ST',\n      value: 'Virginia'\n    }, {\n      name: 'localityName',\n      value: 'Blacksburg'\n    }, {\n      name: 'organizationName',\n      value: 'Test'\n    }, {\n      shortName: 'OU',\n      value: 'Test'\n    }];\n\n    cert.setSubject(attrs);\n    cert.setIssuer(attrs);\n\n    cert.publicKey = keyPair.publicKey;\n\n    cert.setExtensions(options.extensions || [{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'subjectAltName',\n      altNames: [{\n        type: 6, // URI\n        value: 'http://example.org/webid#me'\n      }]\n    }]);\n\n    cert.sign(keyPair.privateKey, getAlgorithm(options && options.algorithm));\n\n    const fingerprint = forge.md.sha1\n                          .create()\n                          .update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes())\n                          .digest()\n                          .toHex()\n                          .match(/.{2}/g)\n                          .join(':');\n\n    var pem = {\n      private:     forge.pki.privateKeyToPem(keyPair.privateKey),\n      public:      forge.pki.publicKeyToPem(keyPair.publicKey),\n      cert:        forge.pki.certificateToPem(cert),\n      fingerprint: fingerprint,\n    };\n\n    if (options && options.pkcs7) {\n      var p7 = forge.pkcs7.createSignedData();\n      p7.addCertificate(cert);\n      pem.pkcs7 = forge.pkcs7.messageToPem(p7);\n    }\n\n    if (options && options.clientCertificate) {\n      var clientkeys = forge.pki.rsa.generateKeyPair(1024);\n      var clientcert = forge.pki.createCertificate();\n      clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));\n      clientcert.validity.notBefore = new Date();\n      clientcert.validity.notAfter = new Date();\n      clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);\n\n      var clientAttrs = JSON.parse(JSON.stringify(attrs));\n\n      for(var i = 0; i < clientAttrs.length; i++) {\n        if(clientAttrs[i].name === 'commonName') {\n          if( options.clientCertificateCN )\n            clientAttrs[i] = { name: 'commonName', value: options.clientCertificateCN };\n          else\n            clientAttrs[i] = { name: 'commonName', value: 'John Doe jdoe123' };\n        }\n      }\n\n      clientcert.setSubject(clientAttrs);\n\n      // Set the issuer to the parent key\n      clientcert.setIssuer(attrs);\n\n      clientcert.publicKey = clientkeys.publicKey;\n\n      // Sign client cert with root cert\n      clientcert.sign(keyPair.privateKey);\n\n      pem.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);\n      pem.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);\n      pem.clientcert = forge.pki.certificateToPem(clientcert);\n\n      if (options.pkcs7) {\n        var clientp7 = forge.pkcs7.createSignedData();\n        clientp7.addCertificate(clientcert);\n        pem.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);\n      }\n    }\n\n    var caStore = forge.pki.createCaStore();\n    caStore.addCertificate(cert);\n\n    try {\n      forge.pki.verifyCertificateChain(caStore, [cert],\n        function (vfd, depth, chain) {\n          if (vfd !== true) {\n            throw new Error('Certificate could not be verified.');\n          }\n          return true;\n        });\n    }\n    catch(ex) {\n      throw new Error(ex);\n    }\n\n    return pem;\n  };\n\n  var keySize = options.keySize || 1024;\n\n  if (done) { // async scenario\n    return forge.pki.rsa.generateKeyPair({ bits: keySize }, function (err, keyPair) {\n      if (err) { return done(err); }\n\n      try {\n        return done(null, generatePem(keyPair));\n      } catch (ex) {\n        return done(ex);\n      }\n    });\n  }\n\n  var keyPair = options.keyPair ? {\n    privateKey: forge.pki.privateKeyFromPem(options.keyPair.privateKey),\n    publicKey: forge.pki.publicKeyFromPem(options.keyPair.publicKey)\n  } : forge.pki.rsa.generateKeyPair(keySize);\n\n  return generatePem(keyPair);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}