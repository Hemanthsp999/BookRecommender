{"ast":null,"code":"/*jshint node:true */\n\nvar assert = require('assert');\nexports.HTTPParser = HTTPParser;\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n  if (type === undefined) {\n    // Node v12+\n  } else {\n    this.initialize(type);\n  }\n  this.maxHeaderSize = HTTPParser.maxHeaderSize;\n}\nHTTPParser.prototype.initialize = function (type, async_resource) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n};\nHTTPParser.encoding = 'ascii';\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE';\n\n// Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\nvar kOnHeaders = HTTPParser.kOnHeaders = 1;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\nvar kOnBody = HTTPParser.kOnBody = 3;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;\n\n// Some handler stubs, needed for compatibility\nHTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function () {};\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n  get: function () {\n    // hack for backward compatibility\n    compatMode0_12 = false;\n    return 99;\n  }\n});\nvar methods = exports.methods = HTTPParser.methods = ['DELETE', 'GET', 'HEAD', 'POST', 'PUT', 'CONNECT', 'OPTIONS', 'TRACE', 'COPY', 'LOCK', 'MKCOL', 'MOVE', 'PROPFIND', 'PROPPATCH', 'SEARCH', 'UNLOCK', 'BIND', 'REBIND', 'UNBIND', 'ACL', 'REPORT', 'MKACTIVITY', 'CHECKOUT', 'MERGE', 'M-SEARCH', 'NOTIFY', 'SUBSCRIBE', 'UNSUBSCRIBE', 'PATCH', 'PURGE', 'MKCALENDAR', 'LINK', 'UNLINK', 'SOURCE'];\nvar method_connect = methods.indexOf('CONNECT');\nHTTPParser.prototype.reinitialize = HTTPParser;\nHTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function () {};\nHTTPParser.prototype._compatMode0_11 = false;\nHTTPParser.prototype.getAsyncId = function () {\n  return 0;\n};\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  }\n\n  // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n    this.hadError = true;\n    return err;\n  }\n  this.chunk = null;\n  length = this.offset - start;\n  if (headerState[this.state]) {\n    this.headerSize += length;\n    if (this.headerSize > (this.maxHeaderSize || HTTPParser.maxHeaderSize)) {\n      return new Error('max header size exceeded');\n    }\n  }\n  return length;\n};\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n};\n\n// These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\nHTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function () {};\n\n//For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n    chunk = this.chunk;\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) {\n      // \\n\n      var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  }\n  //line split over multiple chunks\n  this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n  this.offset = this.end;\n};\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n  if (k) {\n    // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = requestExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = responseExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4];\n  // Implied zero length.\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n  this.state = 'HEADER';\n};\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n  if (this.body_bytes !== null || this.isChunked) {\n    // || skipBody\n    return true;\n  }\n  return false;\n};\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  var info = this.info;\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n    var hasUpgradeHeader = false;\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n          break;\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n        case 'upgrade':\n          hasUpgradeHeader = true;\n          break;\n      }\n    }\n\n    // if both isChunked and hasContentLength, isChunked wins\n    // This is required so the body is parsed using the chunked method, and matches\n    // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n    // encoding into the body), and/or disable shouldKeepAlive to be more\n    // resilient.\n    if (this.isChunked && hasContentLength) {\n      hasContentLength = false;\n      this.body_bytes = null;\n    }\n\n    // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n    // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n    //   mandatory only when it is a 101 Switching Protocols response,\n    //   otherwise it is purely informational, to announce support.\n    if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {\n      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n    } else {\n      info.upgrade = info.method === method_connect;\n    }\n    if (this.isChunked && info.upgrade) {\n      this.isChunked = false;\n    }\n    info.shouldKeepAlive = this.shouldKeepAlive();\n    //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n    var skipBody;\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n    if (skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest();\n      // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n      //   need this \"return true;\" if it's an upgrade request.\n      return info.upgrade;\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  this.body_bytes = parseInt(line, 16);\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n    this.nextRequest();\n  }\n};\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n};\n\n// backward compat to node < 0.11.6\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function () {\n      return this[k];\n    },\n    set: function (to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      method_connect = 'CONNECT';\n      return this[k] = to;\n    }\n  });\n});\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}","map":{"version":3,"names":["assert","require","exports","HTTPParser","type","ok","REQUEST","RESPONSE","undefined","initialize","maxHeaderSize","prototype","async_resource","state","info","headers","upgrade","trailers","line","isChunked","connection","headerSize","body_bytes","isUserCall","hadError","encoding","kOnHeaders","kOnHeadersComplete","kOnBody","kOnMessageComplete","compatMode0_12","Object","defineProperty","get","methods","method_connect","indexOf","reinitialize","close","pause","resume","free","_compatMode0_11","getAsyncId","headerState","REQUEST_LINE","RESPONSE_LINE","HEADER","execute","chunk","start","length","TypeError","offset","end","err","Error","stateFinishAllowed","BODY_RAW","finish","userCall","consume","unconsume","getCurrentBuffer","self","ret","nextRequest","consumeLine","i","toString","charAt","substr","headerExp","headerContinueExp","parseHeader","parseErrorCode","match","exec","k","push","matchContinue","requestExp","method","url","versionMajor","versionMinor","responseExp","statusCode","statusMessage","shouldKeepAlive","hasContentLength","currentContentLengthValue","hasUpgradeHeader","toLowerCase","skipBody","BODY_CHUNKHEAD","parseInt","BODY_CHUNK","Math","min","BODY_CHUNKEMPTYLINE","equal","BODY_CHUNKTRAILERS","BODY_SIZED","forEach","name","set","to","code"],"sources":["/home/hemanth/react-project/client/node_modules/http-parser-js/http-parser.js"],"sourcesContent":["/*jshint node:true */\n\nvar assert = require('assert');\n\nexports.HTTPParser = HTTPParser;\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n  if (type === undefined) {\n    // Node v12+\n  } else {\n    this.initialize(type);\n  }\n  this.maxHeaderSize=HTTPParser.maxHeaderSize\n}\nHTTPParser.prototype.initialize = function (type, async_resource) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n};\n\nHTTPParser.encoding = 'ascii';\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE';\n\n// Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\nvar kOnHeaders = HTTPParser.kOnHeaders = 1;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\nvar kOnBody = HTTPParser.kOnBody = 3;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;\n\n// Some handler stubs, needed for compatibility\nHTTPParser.prototype[kOnHeaders] =\nHTTPParser.prototype[kOnHeadersComplete] =\nHTTPParser.prototype[kOnBody] =\nHTTPParser.prototype[kOnMessageComplete] = function () {};\n\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n    get: function () {\n      // hack for backward compatibility\n      compatMode0_12 = false;\n      return 99;\n    }\n  });\n\nvar methods = exports.methods = HTTPParser.methods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'COPY',\n  'LOCK',\n  'MKCOL',\n  'MOVE',\n  'PROPFIND',\n  'PROPPATCH',\n  'SEARCH',\n  'UNLOCK',\n  'BIND',\n  'REBIND',\n  'UNBIND',\n  'ACL',\n  'REPORT',\n  'MKACTIVITY',\n  'CHECKOUT',\n  'MERGE',\n  'M-SEARCH',\n  'NOTIFY',\n  'SUBSCRIBE',\n  'UNSUBSCRIBE',\n  'PATCH',\n  'PURGE',\n  'MKCALENDAR',\n  'LINK',\n  'UNLINK',\n  'SOURCE',\n];\nvar method_connect = methods.indexOf('CONNECT');\nHTTPParser.prototype.reinitialize = HTTPParser;\nHTTPParser.prototype.close =\nHTTPParser.prototype.pause =\nHTTPParser.prototype.resume =\nHTTPParser.prototype.free = function () {};\nHTTPParser.prototype._compatMode0_11 = false;\nHTTPParser.prototype.getAsyncId = function() { return 0; };\n\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  }\n\n  // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n    this.hadError = true;\n    return err;\n  }\n  this.chunk = null;\n  length = this.offset - start;\n  if (headerState[this.state]) {\n    this.headerSize += length;\n    if (this.headerSize > (this.maxHeaderSize||HTTPParser.maxHeaderSize)) {\n      return new Error('max header size exceeded');\n    }\n  }\n  return length;\n};\n\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n};\n\n// These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\nHTTPParser.prototype.consume =\nHTTPParser.prototype.unconsume =\nHTTPParser.prototype.getCurrentBuffer = function () {};\n\n//For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\n\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\n\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n      chunk = this.chunk;\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) { // \\n\n      var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  }\n  //line split over multiple chunks\n  this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n  this.offset = this.end;\n};\n\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n  if (k) { // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\n\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = requestExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\n\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = responseExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4];\n  // Implied zero length.\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n  this.state = 'HEADER';\n};\n\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n  if (this.body_bytes !== null || this.isChunked) { // || skipBody\n    return true;\n  }\n  return false;\n};\n\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  var info = this.info;\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n    var hasUpgradeHeader = false;\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n          break;\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n        case 'upgrade':\n          hasUpgradeHeader = true;\n          break;\n      }\n    }\n\n    // if both isChunked and hasContentLength, isChunked wins\n    // This is required so the body is parsed using the chunked method, and matches\n    // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n    // encoding into the body), and/or disable shouldKeepAlive to be more\n    // resilient.\n    if (this.isChunked && hasContentLength) {\n      hasContentLength = false;\n      this.body_bytes = null;\n    }\n\n    // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n    // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n    //   mandatory only when it is a 101 Switching Protocols response,\n    //   otherwise it is purely informational, to announce support.\n    if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {\n      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n    } else {\n      info.upgrade = info.method === method_connect;\n    }\n\n    if (this.isChunked && info.upgrade) {\n      this.isChunked = false;\n    }\n\n    info.shouldKeepAlive = this.shouldKeepAlive();\n    //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n    var skipBody;\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor,\n          info.versionMinor, info.headers, info.method, info.url, info.statusCode,\n          info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n    if (skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest();\n      // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n      //   need this \"return true;\" if it's an upgrade request.\n      return info.upgrade;\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  this.body_bytes = parseInt(line, 16);\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\n\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n    this.nextRequest();\n  }\n};\n\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\n\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n};\n\n// backward compat to node < 0.11.6\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function () {\n      return this[k];\n    },\n    set: function (to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      method_connect = 'CONNECT';\n      return (this[k] = to);\n    }\n  });\n});\n\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}