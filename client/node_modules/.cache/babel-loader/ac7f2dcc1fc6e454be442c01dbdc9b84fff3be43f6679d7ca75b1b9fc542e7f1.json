{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst ChunkGraph = require(\"../ChunkGraph\");\nconst ModuleGraph = require(\"../ModuleGraph\");\nconst {\n  STAGE_DEFAULT\n} = require(\"../OptimizationStages\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\nconst {\n  intersectRuntime,\n  mergeRuntimeOwned,\n  filterRuntime,\n  runtimeToString,\n  mergeRuntime\n} = require(\"../util/runtime\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\nconst formatBailoutReason = msg => {\n  return \"ModuleConcatenation bailout: \" + msg;\n};\nclass ModuleConcatenationPlugin {\n  constructor(options) {\n    if (typeof options !== \"object\") options = {};\n    this.options = options;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const {\n      _backCompat: backCompat\n    } = compiler;\n    compiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n      if (compilation.moduleMemCaches) {\n        throw new Error(\"optimization.concatenateModules can't be used with cacheUnaffected as module concatenation is a global effect\");\n      }\n      const moduleGraph = compilation.moduleGraph;\n      const bailoutReasonMap = new Map();\n      const setBailoutReason = (module, reason) => {\n        setInnerBailoutReason(module, reason);\n        moduleGraph.getOptimizationBailout(module).push(typeof reason === \"function\" ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));\n      };\n      const setInnerBailoutReason = (module, reason) => {\n        bailoutReasonMap.set(module, reason);\n      };\n      const getInnerBailoutReason = (module, requestShortener) => {\n        const reason = bailoutReasonMap.get(module);\n        if (typeof reason === \"function\") return reason(requestShortener);\n        return reason;\n      };\n      const formatBailoutWarning = (module, problem) => requestShortener => {\n        if (typeof problem === \"function\") {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}: ${problem(requestShortener)}`);\n        }\n        const reason = getInnerBailoutReason(module, requestShortener);\n        const reasonWithPrefix = reason ? `: ${reason}` : \"\";\n        if (module === problem) {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n        } else {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)} because of ${problem.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n        }\n      };\n      compilation.hooks.optimizeChunkModules.tapAsync({\n        name: \"ModuleConcatenationPlugin\",\n        stage: STAGE_DEFAULT\n      }, (allChunks, modules, callback) => {\n        const logger = compilation.getLogger(\"webpack.ModuleConcatenationPlugin\");\n        const {\n          chunkGraph,\n          moduleGraph\n        } = compilation;\n        const relevantModules = [];\n        const possibleInners = new Set();\n        const context = {\n          chunkGraph,\n          moduleGraph\n        };\n        logger.time(\"select relevant modules\");\n        for (const module of modules) {\n          let canBeRoot = true;\n          let canBeInner = true;\n          const bailoutReason = module.getConcatenationBailoutReason(context);\n          if (bailoutReason) {\n            setBailoutReason(module, bailoutReason);\n            continue;\n          }\n\n          // Must not be an async module\n          if (moduleGraph.isAsync(module)) {\n            setBailoutReason(module, `Module is async`);\n            continue;\n          }\n\n          // Must be in strict mode\n          if (!module.buildInfo.strict) {\n            setBailoutReason(module, `Module is not in strict mode`);\n            continue;\n          }\n\n          // Module must be in any chunk (we don't want to do useless work)\n          if (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n            setBailoutReason(module, \"Module is not in any chunk\");\n            continue;\n          }\n\n          // Exports must be known (and not dynamic)\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const relevantExports = exportsInfo.getRelevantExports(undefined);\n          const unknownReexports = relevantExports.filter(exportInfo => {\n            return exportInfo.isReexport() && !exportInfo.getTarget(moduleGraph);\n          });\n          if (unknownReexports.length > 0) {\n            setBailoutReason(module, `Reexports in this module do not have a static target (${Array.from(unknownReexports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            continue;\n          }\n\n          // Root modules must have a static list of exports\n          const unknownProvidedExports = relevantExports.filter(exportInfo => {\n            return exportInfo.provided !== true;\n          });\n          if (unknownProvidedExports.length > 0) {\n            setBailoutReason(module, `List of module exports is dynamic (${Array.from(unknownProvidedExports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            canBeRoot = false;\n          }\n\n          // Module must not be an entry point\n          if (chunkGraph.isEntryModule(module)) {\n            setInnerBailoutReason(module, \"Module is an entry point\");\n            canBeInner = false;\n          }\n          if (canBeRoot) relevantModules.push(module);\n          if (canBeInner) possibleInners.add(module);\n        }\n        logger.timeEnd(\"select relevant modules\");\n        logger.debug(`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`);\n        // sort by depth\n        // modules with lower depth are more likely suited as roots\n        // this improves performance, because modules already selected as inner are skipped\n        logger.time(\"sort relevant modules\");\n        relevantModules.sort((a, b) => {\n          return moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n        });\n        logger.timeEnd(\"sort relevant modules\");\n\n        /** @type {Statistics} */\n        const stats = {\n          cached: 0,\n          alreadyInConfig: 0,\n          invalidModule: 0,\n          incorrectChunks: 0,\n          incorrectDependency: 0,\n          incorrectModuleDependency: 0,\n          incorrectChunksOfImporter: 0,\n          incorrectRuntimeCondition: 0,\n          importerFailed: 0,\n          added: 0\n        };\n        let statsCandidates = 0;\n        let statsSizeSum = 0;\n        let statsEmptyConfigurations = 0;\n        logger.time(\"find modules to concatenate\");\n        const concatConfigurations = [];\n        const usedAsInner = new Set();\n        for (const currentRoot of relevantModules) {\n          // when used by another configuration as inner:\n          // the other configuration is better and we can skip this one\n          // TODO reconsider that when it's only used in a different runtime\n          if (usedAsInner.has(currentRoot)) continue;\n          let chunkRuntime = undefined;\n          for (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n            chunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n          }\n          const exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n          const filteredRuntime = filterRuntime(chunkRuntime, r => exportsInfo.isModuleUsed(r));\n          const activeRuntime = filteredRuntime === true ? chunkRuntime : filteredRuntime === false ? undefined : filteredRuntime;\n\n          // create a configuration with the root\n          const currentConfiguration = new ConcatConfiguration(currentRoot, activeRuntime);\n\n          // cache failures to add modules\n          const failureCache = new Map();\n\n          // potential optional import candidates\n          /** @type {Set<Module>} */\n          const candidates = new Set();\n\n          // try to add all imports\n          for (const imp of this._getImports(compilation, currentRoot, activeRuntime)) {\n            candidates.add(imp);\n          }\n          for (const imp of candidates) {\n            const impCandidates = new Set();\n            const problem = this._tryToAdd(compilation, currentConfiguration, imp, chunkRuntime, activeRuntime, possibleInners, impCandidates, failureCache, chunkGraph, true, stats);\n            if (problem) {\n              failureCache.set(imp, problem);\n              currentConfiguration.addWarning(imp, problem);\n            } else {\n              for (const c of impCandidates) {\n                candidates.add(c);\n              }\n            }\n          }\n          statsCandidates += candidates.size;\n          if (!currentConfiguration.isEmpty()) {\n            const modules = currentConfiguration.getModules();\n            statsSizeSum += modules.size;\n            concatConfigurations.push(currentConfiguration);\n            for (const module of modules) {\n              if (module !== currentConfiguration.rootModule) {\n                usedAsInner.add(module);\n              }\n            }\n          } else {\n            statsEmptyConfigurations++;\n            const optimizationBailouts = moduleGraph.getOptimizationBailout(currentRoot);\n            for (const warning of currentConfiguration.getWarningsSorted()) {\n              optimizationBailouts.push(formatBailoutWarning(warning[0], warning[1]));\n            }\n          }\n        }\n        logger.timeEnd(\"find modules to concatenate\");\n        logger.debug(`${concatConfigurations.length} successful concat configurations (avg size: ${statsSizeSum / concatConfigurations.length}), ${statsEmptyConfigurations} bailed out completely`);\n        logger.debug(`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`);\n        // HACK: Sort configurations by length and start with the longest one\n        // to get the biggest groups possible. Used modules are marked with usedModules\n        // TODO: Allow to reuse existing configuration while trying to add dependencies.\n        // This would improve performance. O(n^2) -> O(n)\n        logger.time(`sort concat configurations`);\n        concatConfigurations.sort((a, b) => {\n          return b.modules.size - a.modules.size;\n        });\n        logger.timeEnd(`sort concat configurations`);\n        const usedModules = new Set();\n        logger.time(\"create concatenated modules\");\n        asyncLib.each(concatConfigurations, (concatConfiguration, callback) => {\n          const rootModule = concatConfiguration.rootModule;\n\n          // Avoid overlapping configurations\n          // TODO: remove this when todo above is fixed\n          if (usedModules.has(rootModule)) return callback();\n          const modules = concatConfiguration.getModules();\n          for (const m of modules) {\n            usedModules.add(m);\n          }\n\n          // Create a new ConcatenatedModule\n          let newModule = ConcatenatedModule.create(rootModule, modules, concatConfiguration.runtime, compiler.root, compilation.outputOptions.hashFunction);\n          const build = () => {\n            newModule.build(compiler.options, compilation, null, null, err => {\n              if (err) {\n                if (!err.module) {\n                  err.module = newModule;\n                }\n                return callback(err);\n              }\n              integrate();\n            });\n          };\n          const integrate = () => {\n            if (backCompat) {\n              ChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n              ModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n            }\n            for (const warning of concatConfiguration.getWarningsSorted()) {\n              moduleGraph.getOptimizationBailout(newModule).push(formatBailoutWarning(warning[0], warning[1]));\n            }\n            moduleGraph.cloneModuleAttributes(rootModule, newModule);\n            for (const m of modules) {\n              // add to builtModules when one of the included modules was built\n              if (compilation.builtModules.has(m)) {\n                compilation.builtModules.add(newModule);\n              }\n              if (m !== rootModule) {\n                // attach external references to the concatenated module too\n                moduleGraph.copyOutgoingModuleConnections(m, newModule, c => {\n                  return c.originModule === m && !(c.dependency instanceof HarmonyImportDependency && modules.has(c.module));\n                });\n                // remove module from chunk\n                for (const chunk of chunkGraph.getModuleChunksIterable(rootModule)) {\n                  const sourceTypes = chunkGraph.getChunkModuleSourceTypes(chunk, m);\n                  if (sourceTypes.size === 1) {\n                    chunkGraph.disconnectChunkAndModule(chunk, m);\n                  } else {\n                    const newSourceTypes = new Set(sourceTypes);\n                    newSourceTypes.delete(\"javascript\");\n                    chunkGraph.setChunkModuleSourceTypes(chunk, m, newSourceTypes);\n                  }\n                }\n              }\n            }\n            compilation.modules.delete(rootModule);\n            ChunkGraph.clearChunkGraphForModule(rootModule);\n            ModuleGraph.clearModuleGraphForModule(rootModule);\n\n            // remove module from chunk\n            chunkGraph.replaceModule(rootModule, newModule);\n            // replace module references with the concatenated module\n            moduleGraph.moveModuleConnections(rootModule, newModule, c => {\n              const otherModule = c.module === rootModule ? c.originModule : c.module;\n              const innerConnection = c.dependency instanceof HarmonyImportDependency && modules.has(otherModule);\n              return !innerConnection;\n            });\n            // add concatenated module to the compilation\n            compilation.modules.add(newModule);\n            callback();\n          };\n          build();\n        }, err => {\n          logger.timeEnd(\"create concatenated modules\");\n          process.nextTick(callback.bind(null, err));\n        });\n      });\n    });\n  }\n\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope\n   * @returns {Set<Module>} the imported modules\n   */\n  _getImports(compilation, module, runtime) {\n    const moduleGraph = compilation.moduleGraph;\n    const set = new Set();\n    for (const dep of module.dependencies) {\n      // Get reference info only for harmony Dependencies\n      if (!(dep instanceof HarmonyImportDependency)) continue;\n      const connection = moduleGraph.getConnection(dep);\n      // Reference is valid and has a module\n      if (!connection || !connection.module || !connection.isTargetActive(runtime)) {\n        continue;\n      }\n      const importedNames = compilation.getDependencyReferencedExports(dep, undefined);\n      if (importedNames.every(i => Array.isArray(i) ? i.length > 0 : i.name.length > 0) || Array.isArray(moduleGraph.getProvidedExports(module))) {\n        set.add(connection.module);\n      }\n    }\n    return set;\n  }\n\n  /**\n   * @param {Compilation} compilation webpack compilation\n   * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope of the generated code\n   * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n   * @param {Set<Module>} possibleModules modules that are candidates\n   * @param {Set<Module>} candidates list of potential candidates (will be added to)\n   * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n   * @param {Statistics} statistics gathering metrics\n   * @returns {Module | function(RequestShortener): string} the problematic module\n   */\n  _tryToAdd(compilation, config, module, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, avoidMutateOnFailure, statistics) {\n    const cacheEntry = failureCache.get(module);\n    if (cacheEntry) {\n      statistics.cached++;\n      return cacheEntry;\n    }\n\n    // Already added?\n    if (config.has(module)) {\n      statistics.alreadyInConfig++;\n      return null;\n    }\n\n    // Not possible to add?\n    if (!possibleModules.has(module)) {\n      statistics.invalidModule++;\n      failureCache.set(module, module); // cache failures for performance\n      return module;\n    }\n\n    // Module must be in the correct chunks\n    const missingChunks = Array.from(chunkGraph.getModuleChunksIterable(config.rootModule)).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n    if (missingChunks.length > 0) {\n      const problem = requestShortener => {\n        const missingChunksList = Array.from(new Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        const chunks = Array.from(new Set(Array.from(chunkGraph.getModuleChunksIterable(module)).map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\", \")}, module is in chunk(s) ${chunks.join(\", \")})`;\n      };\n      statistics.incorrectChunks++;\n      failureCache.set(module, problem); // cache failures for performance\n      return problem;\n    }\n    const moduleGraph = compilation.moduleGraph;\n    const incomingConnections = moduleGraph.getIncomingConnectionsByOriginModule(module);\n    const incomingConnectionsFromNonModules = incomingConnections.get(null) || incomingConnections.get(undefined);\n    if (incomingConnectionsFromNonModules) {\n      const activeNonModulesConnections = incomingConnectionsFromNonModules.filter(connection => {\n        // We are not interested in inactive connections\n        // or connections without dependency\n        return connection.isActive(runtime);\n      });\n      if (activeNonModulesConnections.length > 0) {\n        const problem = requestShortener => {\n          const importingExplanations = new Set(activeNonModulesConnections.map(c => c.explanation).filter(Boolean));\n          const explanations = Array.from(importingExplanations).sort();\n          return `Module ${module.readableIdentifier(requestShortener)} is referenced ${explanations.length > 0 ? `by: ${explanations.join(\", \")}` : \"in an unsupported way\"}`;\n        };\n        statistics.incorrectDependency++;\n        failureCache.set(module, problem); // cache failures for performance\n        return problem;\n      }\n    }\n\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n    const incomingConnectionsFromModules = new Map();\n    for (const [originModule, connections] of incomingConnections) {\n      if (originModule) {\n        // Ignore connection from orphan modules\n        if (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue;\n\n        // We don't care for connections from other runtimes\n        let originRuntime = undefined;\n        for (const r of chunkGraph.getModuleRuntimes(originModule)) {\n          originRuntime = mergeRuntimeOwned(originRuntime, r);\n        }\n        if (!intersectRuntime(runtime, originRuntime)) continue;\n\n        // We are not interested in inactive connections\n        const activeConnections = connections.filter(connection => connection.isActive(runtime));\n        if (activeConnections.length > 0) incomingConnectionsFromModules.set(originModule, activeConnections);\n      }\n    }\n    const incomingModules = Array.from(incomingConnectionsFromModules.keys());\n\n    // Module must be in the same chunks like the referencing module\n    const otherChunkModules = incomingModules.filter(originModule => {\n      for (const chunk of chunkGraph.getModuleChunksIterable(config.rootModule)) {\n        if (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n          return true;\n        }\n      }\n      return false;\n    });\n    if (otherChunkModules.length > 0) {\n      const problem = requestShortener => {\n        const names = otherChunkModules.map(m => m.readableIdentifier(requestShortener)).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from different chunks by these modules: ${names.join(\", \")}`;\n      };\n      statistics.incorrectChunksOfImporter++;\n      failureCache.set(module, problem); // cache failures for performance\n      return problem;\n    }\n\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n    const nonHarmonyConnections = new Map();\n    for (const [originModule, connections] of incomingConnectionsFromModules) {\n      const selected = connections.filter(connection => !connection.dependency || !(connection.dependency instanceof HarmonyImportDependency));\n      if (selected.length > 0) nonHarmonyConnections.set(originModule, connections);\n    }\n    if (nonHarmonyConnections.size > 0) {\n      const problem = requestShortener => {\n        const names = Array.from(nonHarmonyConnections).map(_ref => {\n          let [originModule, connections] = _ref;\n          return `${originModule.readableIdentifier(requestShortener)} (referenced with ${Array.from(new Set(connections.map(c => c.dependency && c.dependency.type).filter(Boolean))).sort().join(\", \")})`;\n        }).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from these modules with unsupported syntax: ${names.join(\", \")}`;\n      };\n      statistics.incorrectModuleDependency++;\n      failureCache.set(module, problem); // cache failures for performance\n      return problem;\n    }\n    if (runtime !== undefined && typeof runtime !== \"string\") {\n      // Module must be consistently referenced in the same runtimes\n      /** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n      const otherRuntimeConnections = [];\n      outer: for (const [originModule, connections] of incomingConnectionsFromModules) {\n        /** @type {false | RuntimeSpec} */\n        let currentRuntimeCondition = false;\n        for (const connection of connections) {\n          const runtimeCondition = filterRuntime(runtime, runtime => {\n            return connection.isTargetActive(runtime);\n          });\n          if (runtimeCondition === false) continue;\n          if (runtimeCondition === true) continue outer;\n          if (currentRuntimeCondition !== false) {\n            currentRuntimeCondition = mergeRuntime(currentRuntimeCondition, runtimeCondition);\n          } else {\n            currentRuntimeCondition = runtimeCondition;\n          }\n        }\n        if (currentRuntimeCondition !== false) {\n          otherRuntimeConnections.push({\n            originModule,\n            runtimeCondition: currentRuntimeCondition\n          });\n        }\n      }\n      if (otherRuntimeConnections.length > 0) {\n        const problem = requestShortener => {\n          return `Module ${module.readableIdentifier(requestShortener)} is runtime-dependent referenced by these modules: ${Array.from(otherRuntimeConnections, _ref2 => {\n            let {\n              originModule,\n              runtimeCondition\n            } = _ref2;\n            return `${originModule.readableIdentifier(requestShortener)} (expected runtime ${runtimeToString(runtime)}, module is only referenced in ${runtimeToString( /** @type {RuntimeSpec} */runtimeCondition)})`;\n          }).join(\", \")}`;\n        };\n        statistics.incorrectRuntimeCondition++;\n        failureCache.set(module, problem); // cache failures for performance\n        return problem;\n      }\n    }\n    let backup;\n    if (avoidMutateOnFailure) {\n      backup = config.snapshot();\n    }\n\n    // Add the module\n    config.add(module);\n    incomingModules.sort(compareModulesByIdentifier);\n\n    // Every module which depends on the added module must be in the configuration too.\n    for (const originModule of incomingModules) {\n      const problem = this._tryToAdd(compilation, config, originModule, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, false, statistics);\n      if (problem) {\n        if (backup !== undefined) config.rollback(backup);\n        statistics.importerFailed++;\n        failureCache.set(module, problem); // cache failures for performance\n        return problem;\n      }\n    }\n\n    // Add imports to possible candidates list\n    for (const imp of this._getImports(compilation, module, runtime)) {\n      candidates.add(imp);\n    }\n    statistics.added++;\n    return null;\n  }\n}\nclass ConcatConfiguration {\n  /**\n   * @param {Module} rootModule the root module\n   * @param {RuntimeSpec} runtime the runtime\n   */\n  constructor(rootModule, runtime) {\n    this.rootModule = rootModule;\n    this.runtime = runtime;\n    /** @type {Set<Module>} */\n    this.modules = new Set();\n    this.modules.add(rootModule);\n    /** @type {Map<Module, Module | function(RequestShortener): string>} */\n    this.warnings = new Map();\n  }\n  add(module) {\n    this.modules.add(module);\n  }\n  has(module) {\n    return this.modules.has(module);\n  }\n  isEmpty() {\n    return this.modules.size === 1;\n  }\n  addWarning(module, problem) {\n    this.warnings.set(module, problem);\n  }\n  getWarningsSorted() {\n    return new Map(Array.from(this.warnings).sort((a, b) => {\n      const ai = a[0].identifier();\n      const bi = b[0].identifier();\n      if (ai < bi) return -1;\n      if (ai > bi) return 1;\n      return 0;\n    }));\n  }\n\n  /**\n   * @returns {Set<Module>} modules as set\n   */\n  getModules() {\n    return this.modules;\n  }\n  snapshot() {\n    return this.modules.size;\n  }\n  rollback(snapshot) {\n    const modules = this.modules;\n    for (const m of modules) {\n      if (snapshot === 0) {\n        modules.delete(m);\n      } else {\n        snapshot--;\n      }\n    }\n  }\n}\nmodule.exports = ModuleConcatenationPlugin;","map":{"version":3,"names":["asyncLib","require","ChunkGraph","ModuleGraph","STAGE_DEFAULT","HarmonyImportDependency","compareModulesByIdentifier","intersectRuntime","mergeRuntimeOwned","filterRuntime","runtimeToString","mergeRuntime","ConcatenatedModule","formatBailoutReason","msg","ModuleConcatenationPlugin","constructor","options","apply","compiler","_backCompat","backCompat","hooks","compilation","tap","moduleMemCaches","Error","moduleGraph","bailoutReasonMap","Map","setBailoutReason","module","reason","setInnerBailoutReason","getOptimizationBailout","push","rs","set","getInnerBailoutReason","requestShortener","get","formatBailoutWarning","problem","readableIdentifier","reasonWithPrefix","optimizeChunkModules","tapAsync","name","stage","allChunks","modules","callback","logger","getLogger","chunkGraph","relevantModules","possibleInners","Set","context","time","canBeRoot","canBeInner","bailoutReason","getConcatenationBailoutReason","isAsync","buildInfo","strict","getNumberOfModuleChunks","exportsInfo","getExportsInfo","relevantExports","getRelevantExports","undefined","unknownReexports","filter","exportInfo","isReexport","getTarget","length","Array","from","getUsedInfo","join","unknownProvidedExports","provided","getProvidedInfo","isEntryModule","add","timeEnd","debug","size","sort","a","b","getDepth","stats","cached","alreadyInConfig","invalidModule","incorrectChunks","incorrectDependency","incorrectModuleDependency","incorrectChunksOfImporter","incorrectRuntimeCondition","importerFailed","added","statsCandidates","statsSizeSum","statsEmptyConfigurations","concatConfigurations","usedAsInner","currentRoot","has","chunkRuntime","r","getModuleRuntimes","filteredRuntime","isModuleUsed","activeRuntime","currentConfiguration","ConcatConfiguration","failureCache","candidates","imp","_getImports","impCandidates","_tryToAdd","addWarning","c","isEmpty","getModules","rootModule","optimizationBailouts","warning","getWarningsSorted","usedModules","each","concatConfiguration","m","newModule","create","runtime","root","outputOptions","hashFunction","build","err","integrate","setChunkGraphForModule","setModuleGraphForModule","cloneModuleAttributes","builtModules","copyOutgoingModuleConnections","originModule","dependency","chunk","getModuleChunksIterable","sourceTypes","getChunkModuleSourceTypes","disconnectChunkAndModule","newSourceTypes","delete","setChunkModuleSourceTypes","clearChunkGraphForModule","clearModuleGraphForModule","replaceModule","moveModuleConnections","otherModule","innerConnection","process","nextTick","bind","dep","dependencies","connection","getConnection","isTargetActive","importedNames","getDependencyReferencedExports","every","i","isArray","getProvidedExports","config","possibleModules","avoidMutateOnFailure","statistics","cacheEntry","missingChunks","isModuleInChunk","missingChunksList","map","chunks","incomingConnections","getIncomingConnectionsByOriginModule","incomingConnectionsFromNonModules","activeNonModulesConnections","isActive","importingExplanations","explanation","Boolean","explanations","incomingConnectionsFromModules","connections","originRuntime","activeConnections","incomingModules","keys","otherChunkModules","names","nonHarmonyConnections","selected","_ref","type","otherRuntimeConnections","outer","currentRuntimeCondition","runtimeCondition","_ref2","backup","snapshot","rollback","warnings","ai","identifier","bi","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst ChunkGraph = require(\"../ChunkGraph\");\nconst ModuleGraph = require(\"../ModuleGraph\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst {\n\tintersectRuntime,\n\tmergeRuntimeOwned,\n\tfilterRuntime,\n\truntimeToString,\n\tmergeRuntime\n} = require(\"../util/runtime\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\nconst formatBailoutReason = msg => {\n\treturn \"ModuleConcatenation bailout: \" + msg;\n};\n\nclass ModuleConcatenationPlugin {\n\tconstructor(options) {\n\t\tif (typeof options !== \"object\") options = {};\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tcompiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"optimization.concatenateModules can't be used with cacheUnaffected as module concatenation is a global effect\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tconst bailoutReasonMap = new Map();\n\n\t\t\tconst setBailoutReason = (module, reason) => {\n\t\t\t\tsetInnerBailoutReason(module, reason);\n\t\t\t\tmoduleGraph\n\t\t\t\t\t.getOptimizationBailout(module)\n\t\t\t\t\t.push(\n\t\t\t\t\t\ttypeof reason === \"function\"\n\t\t\t\t\t\t\t? rs => formatBailoutReason(reason(rs))\n\t\t\t\t\t\t\t: formatBailoutReason(reason)\n\t\t\t\t\t);\n\t\t\t};\n\n\t\t\tconst setInnerBailoutReason = (module, reason) => {\n\t\t\t\tbailoutReasonMap.set(module, reason);\n\t\t\t};\n\n\t\t\tconst getInnerBailoutReason = (module, requestShortener) => {\n\t\t\t\tconst reason = bailoutReasonMap.get(module);\n\t\t\t\tif (typeof reason === \"function\") return reason(requestShortener);\n\t\t\t\treturn reason;\n\t\t\t};\n\n\t\t\tconst formatBailoutWarning = (module, problem) => requestShortener => {\n\t\t\t\tif (typeof problem === \"function\") {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}: ${problem(requestShortener)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst reason = getInnerBailoutReason(module, requestShortener);\n\t\t\t\tconst reasonWithPrefix = reason ? `: ${reason}` : \"\";\n\t\t\t\tif (module === problem) {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} because of ${problem.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcompilation.hooks.optimizeChunkModules.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"ModuleConcatenationPlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\t(allChunks, modules, callback) => {\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.ModuleConcatenationPlugin\"\n\t\t\t\t\t);\n\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\t\t\t\t\tconst relevantModules = [];\n\t\t\t\t\tconst possibleInners = new Set();\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t};\n\t\t\t\t\tlogger.time(\"select relevant modules\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tlet canBeRoot = true;\n\t\t\t\t\t\tlet canBeInner = true;\n\n\t\t\t\t\t\tconst bailoutReason = module.getConcatenationBailoutReason(context);\n\t\t\t\t\t\tif (bailoutReason) {\n\t\t\t\t\t\t\tsetBailoutReason(module, bailoutReason);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must not be an async module\n\t\t\t\t\t\tif (moduleGraph.isAsync(module)) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is async`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must be in strict mode\n\t\t\t\t\t\tif (!module.buildInfo.strict) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is not in strict mode`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must be in any chunk (we don't want to do useless work)\n\t\t\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n\t\t\t\t\t\t\tsetBailoutReason(module, \"Module is not in any chunk\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Exports must be known (and not dynamic)\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst relevantExports = exportsInfo.getRelevantExports(undefined);\n\t\t\t\t\t\tconst unknownReexports = relevantExports.filter(exportInfo => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\texportInfo.isReexport() && !exportInfo.getTarget(moduleGraph)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (unknownReexports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`Reexports in this module do not have a static target (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownReexports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Root modules must have a static list of exports\n\t\t\t\t\t\tconst unknownProvidedExports = relevantExports.filter(\n\t\t\t\t\t\t\texportInfo => {\n\t\t\t\t\t\t\t\treturn exportInfo.provided !== true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (unknownProvidedExports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`List of module exports is dynamic (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownProvidedExports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcanBeRoot = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must not be an entry point\n\t\t\t\t\t\tif (chunkGraph.isEntryModule(module)) {\n\t\t\t\t\t\t\tsetInnerBailoutReason(module, \"Module is an entry point\");\n\t\t\t\t\t\t\tcanBeInner = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canBeRoot) relevantModules.push(module);\n\t\t\t\t\t\tif (canBeInner) possibleInners.add(module);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"select relevant modules\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`\n\t\t\t\t\t);\n\t\t\t\t\t// sort by depth\n\t\t\t\t\t// modules with lower depth are more likely suited as roots\n\t\t\t\t\t// this improves performance, because modules already selected as inner are skipped\n\t\t\t\t\tlogger.time(\"sort relevant modules\");\n\t\t\t\t\trelevantModules.sort((a, b) => {\n\t\t\t\t\t\treturn moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(\"sort relevant modules\");\n\n\t\t\t\t\t/** @type {Statistics} */\n\t\t\t\t\tconst stats = {\n\t\t\t\t\t\tcached: 0,\n\t\t\t\t\t\talreadyInConfig: 0,\n\t\t\t\t\t\tinvalidModule: 0,\n\t\t\t\t\t\tincorrectChunks: 0,\n\t\t\t\t\t\tincorrectDependency: 0,\n\t\t\t\t\t\tincorrectModuleDependency: 0,\n\t\t\t\t\t\tincorrectChunksOfImporter: 0,\n\t\t\t\t\t\tincorrectRuntimeCondition: 0,\n\t\t\t\t\t\timporterFailed: 0,\n\t\t\t\t\t\tadded: 0\n\t\t\t\t\t};\n\t\t\t\t\tlet statsCandidates = 0;\n\t\t\t\t\tlet statsSizeSum = 0;\n\t\t\t\t\tlet statsEmptyConfigurations = 0;\n\n\t\t\t\t\tlogger.time(\"find modules to concatenate\");\n\t\t\t\t\tconst concatConfigurations = [];\n\t\t\t\t\tconst usedAsInner = new Set();\n\t\t\t\t\tfor (const currentRoot of relevantModules) {\n\t\t\t\t\t\t// when used by another configuration as inner:\n\t\t\t\t\t\t// the other configuration is better and we can skip this one\n\t\t\t\t\t\t// TODO reconsider that when it's only used in a different runtime\n\t\t\t\t\t\tif (usedAsInner.has(currentRoot)) continue;\n\n\t\t\t\t\t\tlet chunkRuntime = undefined;\n\t\t\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n\t\t\t\t\t\t\tchunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n\t\t\t\t\t\tconst filteredRuntime = filterRuntime(chunkRuntime, r =>\n\t\t\t\t\t\t\texportsInfo.isModuleUsed(r)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst activeRuntime =\n\t\t\t\t\t\t\tfilteredRuntime === true\n\t\t\t\t\t\t\t\t? chunkRuntime\n\t\t\t\t\t\t\t\t: filteredRuntime === false\n\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t: filteredRuntime;\n\n\t\t\t\t\t\t// create a configuration with the root\n\t\t\t\t\t\tconst currentConfiguration = new ConcatConfiguration(\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// cache failures to add modules\n\t\t\t\t\t\tconst failureCache = new Map();\n\n\t\t\t\t\t\t// potential optional import candidates\n\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\tconst candidates = new Set();\n\n\t\t\t\t\t\t// try to add all imports\n\t\t\t\t\t\tfor (const imp of this._getImports(\n\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tcandidates.add(imp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const imp of candidates) {\n\t\t\t\t\t\t\tconst impCandidates = new Set();\n\t\t\t\t\t\t\tconst problem = this._tryToAdd(\n\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\tcurrentConfiguration,\n\t\t\t\t\t\t\t\timp,\n\t\t\t\t\t\t\t\tchunkRuntime,\n\t\t\t\t\t\t\t\tactiveRuntime,\n\t\t\t\t\t\t\t\tpossibleInners,\n\t\t\t\t\t\t\t\timpCandidates,\n\t\t\t\t\t\t\t\tfailureCache,\n\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tstats\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (problem) {\n\t\t\t\t\t\t\t\tfailureCache.set(imp, problem);\n\t\t\t\t\t\t\t\tcurrentConfiguration.addWarning(imp, problem);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const c of impCandidates) {\n\t\t\t\t\t\t\t\t\tcandidates.add(c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatsCandidates += candidates.size;\n\t\t\t\t\t\tif (!currentConfiguration.isEmpty()) {\n\t\t\t\t\t\t\tconst modules = currentConfiguration.getModules();\n\t\t\t\t\t\t\tstatsSizeSum += modules.size;\n\t\t\t\t\t\t\tconcatConfigurations.push(currentConfiguration);\n\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\tif (module !== currentConfiguration.rootModule) {\n\t\t\t\t\t\t\t\t\tusedAsInner.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatsEmptyConfigurations++;\n\t\t\t\t\t\t\tconst optimizationBailouts =\n\t\t\t\t\t\t\t\tmoduleGraph.getOptimizationBailout(currentRoot);\n\t\t\t\t\t\t\tfor (const warning of currentConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\toptimizationBailouts.push(\n\t\t\t\t\t\t\t\t\tformatBailoutWarning(warning[0], warning[1])\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"find modules to concatenate\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${\n\t\t\t\t\t\t\tconcatConfigurations.length\n\t\t\t\t\t\t} successful concat configurations (avg size: ${\n\t\t\t\t\t\t\tstatsSizeSum / concatConfigurations.length\n\t\t\t\t\t\t}), ${statsEmptyConfigurations} bailed out completely`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`\n\t\t\t\t\t);\n\t\t\t\t\t// HACK: Sort configurations by length and start with the longest one\n\t\t\t\t\t// to get the biggest groups possible. Used modules are marked with usedModules\n\t\t\t\t\t// TODO: Allow to reuse existing configuration while trying to add dependencies.\n\t\t\t\t\t// This would improve performance. O(n^2) -> O(n)\n\t\t\t\t\tlogger.time(`sort concat configurations`);\n\t\t\t\t\tconcatConfigurations.sort((a, b) => {\n\t\t\t\t\t\treturn b.modules.size - a.modules.size;\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(`sort concat configurations`);\n\t\t\t\t\tconst usedModules = new Set();\n\n\t\t\t\t\tlogger.time(\"create concatenated modules\");\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tconcatConfigurations,\n\t\t\t\t\t\t(concatConfiguration, callback) => {\n\t\t\t\t\t\t\tconst rootModule = concatConfiguration.rootModule;\n\n\t\t\t\t\t\t\t// Avoid overlapping configurations\n\t\t\t\t\t\t\t// TODO: remove this when todo above is fixed\n\t\t\t\t\t\t\tif (usedModules.has(rootModule)) return callback();\n\t\t\t\t\t\t\tconst modules = concatConfiguration.getModules();\n\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\tusedModules.add(m);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Create a new ConcatenatedModule\n\t\t\t\t\t\t\tlet newModule = ConcatenatedModule.create(\n\t\t\t\t\t\t\t\trootModule,\n\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\tconcatConfiguration.runtime,\n\t\t\t\t\t\t\t\tcompiler.root,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst build = () => {\n\t\t\t\t\t\t\t\tnewModule.build(\n\t\t\t\t\t\t\t\t\tcompiler.options,\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (!err.module) {\n\t\t\t\t\t\t\t\t\t\t\t\terr.module = newModule;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tintegrate();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst integrate = () => {\n\t\t\t\t\t\t\t\tif (backCompat) {\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n\t\t\t\t\t\t\t\t\tModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (const warning of concatConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t\t.getOptimizationBailout(newModule)\n\t\t\t\t\t\t\t\t\t\t.push(formatBailoutWarning(warning[0], warning[1]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleGraph.cloneModuleAttributes(rootModule, newModule);\n\t\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\t\t// add to builtModules when one of the included modules was built\n\t\t\t\t\t\t\t\t\tif (compilation.builtModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcompilation.builtModules.add(newModule);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (m !== rootModule) {\n\t\t\t\t\t\t\t\t\t\t// attach external references to the concatenated module too\n\t\t\t\t\t\t\t\t\t\tmoduleGraph.copyOutgoingModuleConnections(\n\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\tnewModule,\n\t\t\t\t\t\t\t\t\t\t\tc => {\n\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\tc.originModule === m &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodules.has(c.module)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\t\trootModule\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tconst sourceTypes = chunkGraph.getChunkModuleSourceTypes(\n\t\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\t\tm\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (sourceTypes.size === 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, m);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tconst newSourceTypes = new Set(sourceTypes);\n\t\t\t\t\t\t\t\t\t\t\t\tnewSourceTypes.delete(\"javascript\");\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.setChunkModuleSourceTypes(\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewSourceTypes\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.modules.delete(rootModule);\n\t\t\t\t\t\t\t\tChunkGraph.clearChunkGraphForModule(rootModule);\n\t\t\t\t\t\t\t\tModuleGraph.clearModuleGraphForModule(rootModule);\n\n\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\tchunkGraph.replaceModule(rootModule, newModule);\n\t\t\t\t\t\t\t\t// replace module references with the concatenated module\n\t\t\t\t\t\t\t\tmoduleGraph.moveModuleConnections(rootModule, newModule, c => {\n\t\t\t\t\t\t\t\t\tconst otherModule =\n\t\t\t\t\t\t\t\t\t\tc.module === rootModule ? c.originModule : c.module;\n\t\t\t\t\t\t\t\t\tconst innerConnection =\n\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\tmodules.has(otherModule);\n\t\t\t\t\t\t\t\t\treturn !innerConnection;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// add concatenated module to the compilation\n\t\t\t\t\t\t\t\tcompilation.modules.add(newModule);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbuild();\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"create concatenated modules\");\n\t\t\t\t\t\t\tprocess.nextTick(callback.bind(null, err));\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope\n\t * @returns {Set<Module>} the imported modules\n\t */\n\t_getImports(compilation, module, runtime) {\n\t\tconst moduleGraph = compilation.moduleGraph;\n\t\tconst set = new Set();\n\t\tfor (const dep of module.dependencies) {\n\t\t\t// Get reference info only for harmony Dependencies\n\t\t\tif (!(dep instanceof HarmonyImportDependency)) continue;\n\n\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t// Reference is valid and has a module\n\t\t\tif (\n\t\t\t\t!connection ||\n\t\t\t\t!connection.module ||\n\t\t\t\t!connection.isTargetActive(runtime)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst importedNames = compilation.getDependencyReferencedExports(\n\t\t\t\tdep,\n\t\t\t\tundefined\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\timportedNames.every(i =>\n\t\t\t\t\tArray.isArray(i) ? i.length > 0 : i.name.length > 0\n\t\t\t\t) ||\n\t\t\t\tArray.isArray(moduleGraph.getProvidedExports(module))\n\t\t\t) {\n\t\t\t\tset.add(connection.module);\n\t\t\t}\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Compilation} compilation webpack compilation\n\t * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope of the generated code\n\t * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n\t * @param {Set<Module>} possibleModules modules that are candidates\n\t * @param {Set<Module>} candidates list of potential candidates (will be added to)\n\t * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n\t * @param {Statistics} statistics gathering metrics\n\t * @returns {Module | function(RequestShortener): string} the problematic module\n\t */\n\t_tryToAdd(\n\t\tcompilation,\n\t\tconfig,\n\t\tmodule,\n\t\truntime,\n\t\tactiveRuntime,\n\t\tpossibleModules,\n\t\tcandidates,\n\t\tfailureCache,\n\t\tchunkGraph,\n\t\tavoidMutateOnFailure,\n\t\tstatistics\n\t) {\n\t\tconst cacheEntry = failureCache.get(module);\n\t\tif (cacheEntry) {\n\t\t\tstatistics.cached++;\n\t\t\treturn cacheEntry;\n\t\t}\n\n\t\t// Already added?\n\t\tif (config.has(module)) {\n\t\t\tstatistics.alreadyInConfig++;\n\t\t\treturn null;\n\t\t}\n\n\t\t// Not possible to add?\n\t\tif (!possibleModules.has(module)) {\n\t\t\tstatistics.invalidModule++;\n\t\t\tfailureCache.set(module, module); // cache failures for performance\n\t\t\treturn module;\n\t\t}\n\n\t\t// Module must be in the correct chunks\n\t\tconst missingChunks = Array.from(\n\t\t\tchunkGraph.getModuleChunksIterable(config.rootModule)\n\t\t).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n\t\tif (missingChunks.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst missingChunksList = Array.from(\n\t\t\t\t\tnew Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))\n\t\t\t\t).sort();\n\t\t\t\tconst chunks = Array.from(\n\t\t\t\t\tnew Set(\n\t\t\t\t\t\tArray.from(chunkGraph.getModuleChunksIterable(module)).map(\n\t\t\t\t\t\t\tchunk => chunk.name || \"unnamed chunk(s)\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t).sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}, module is in chunk(s) ${chunks.join(\", \")})`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunks++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\tconst incomingConnections =\n\t\t\tmoduleGraph.getIncomingConnectionsByOriginModule(module);\n\n\t\tconst incomingConnectionsFromNonModules =\n\t\t\tincomingConnections.get(null) || incomingConnections.get(undefined);\n\t\tif (incomingConnectionsFromNonModules) {\n\t\t\tconst activeNonModulesConnections =\n\t\t\t\tincomingConnectionsFromNonModules.filter(connection => {\n\t\t\t\t\t// We are not interested in inactive connections\n\t\t\t\t\t// or connections without dependency\n\t\t\t\t\treturn connection.isActive(runtime);\n\t\t\t\t});\n\t\t\tif (activeNonModulesConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\tconst importingExplanations = new Set(\n\t\t\t\t\t\tactiveNonModulesConnections.map(c => c.explanation).filter(Boolean)\n\t\t\t\t\t);\n\t\t\t\t\tconst explanations = Array.from(importingExplanations).sort();\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is referenced ${\n\t\t\t\t\t\texplanations.length > 0\n\t\t\t\t\t\t\t? `by: ${explanations.join(\", \")}`\n\t\t\t\t\t\t\t: \"in an unsupported way\"\n\t\t\t\t\t}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectDependency++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst incomingConnectionsFromModules = new Map();\n\t\tfor (const [originModule, connections] of incomingConnections) {\n\t\t\tif (originModule) {\n\t\t\t\t// Ignore connection from orphan modules\n\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue;\n\n\t\t\t\t// We don't care for connections from other runtimes\n\t\t\t\tlet originRuntime = undefined;\n\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(originModule)) {\n\t\t\t\t\toriginRuntime = mergeRuntimeOwned(originRuntime, r);\n\t\t\t\t}\n\n\t\t\t\tif (!intersectRuntime(runtime, originRuntime)) continue;\n\n\t\t\t\t// We are not interested in inactive connections\n\t\t\t\tconst activeConnections = connections.filter(connection =>\n\t\t\t\t\tconnection.isActive(runtime)\n\t\t\t\t);\n\t\t\t\tif (activeConnections.length > 0)\n\t\t\t\t\tincomingConnectionsFromModules.set(originModule, activeConnections);\n\t\t\t}\n\t\t}\n\n\t\tconst incomingModules = Array.from(incomingConnectionsFromModules.keys());\n\n\t\t// Module must be in the same chunks like the referencing module\n\t\tconst otherChunkModules = incomingModules.filter(originModule => {\n\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\tconfig.rootModule\n\t\t\t)) {\n\t\t\t\tif (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tif (otherChunkModules.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = otherChunkModules\n\t\t\t\t\t.map(m => m.readableIdentifier(requestShortener))\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from different chunks by these modules: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunksOfImporter++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst nonHarmonyConnections = new Map();\n\t\tfor (const [originModule, connections] of incomingConnectionsFromModules) {\n\t\t\tconst selected = connections.filter(\n\t\t\t\tconnection =>\n\t\t\t\t\t!connection.dependency ||\n\t\t\t\t\t!(connection.dependency instanceof HarmonyImportDependency)\n\t\t\t);\n\t\t\tif (selected.length > 0)\n\t\t\t\tnonHarmonyConnections.set(originModule, connections);\n\t\t}\n\t\tif (nonHarmonyConnections.size > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = Array.from(nonHarmonyConnections)\n\t\t\t\t\t.map(([originModule, connections]) => {\n\t\t\t\t\t\treturn `${originModule.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} (referenced with ${Array.from(\n\t\t\t\t\t\t\tnew Set(\n\t\t\t\t\t\t\t\tconnections\n\t\t\t\t\t\t\t\t\t.map(c => c.dependency && c.dependency.type)\n\t\t\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t\t.join(\", \")})`;\n\t\t\t\t\t})\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from these modules with unsupported syntax: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectModuleDependency++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tif (runtime !== undefined && typeof runtime !== \"string\") {\n\t\t\t// Module must be consistently referenced in the same runtimes\n\t\t\t/** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n\t\t\tconst otherRuntimeConnections = [];\n\t\t\touter: for (const [\n\t\t\t\toriginModule,\n\t\t\t\tconnections\n\t\t\t] of incomingConnectionsFromModules) {\n\t\t\t\t/** @type {false | RuntimeSpec} */\n\t\t\t\tlet currentRuntimeCondition = false;\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst runtimeCondition = filterRuntime(runtime, runtime => {\n\t\t\t\t\t\treturn connection.isTargetActive(runtime);\n\t\t\t\t\t});\n\t\t\t\t\tif (runtimeCondition === false) continue;\n\t\t\t\t\tif (runtimeCondition === true) continue outer;\n\t\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\t\tcurrentRuntimeCondition = mergeRuntime(\n\t\t\t\t\t\t\tcurrentRuntimeCondition,\n\t\t\t\t\t\t\truntimeCondition\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentRuntimeCondition = runtimeCondition;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\totherRuntimeConnections.push({\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\truntimeCondition: currentRuntimeCondition\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (otherRuntimeConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is runtime-dependent referenced by these modules: ${Array.from(\n\t\t\t\t\t\totherRuntimeConnections,\n\t\t\t\t\t\t({ originModule, runtimeCondition }) =>\n\t\t\t\t\t\t\t`${originModule.readableIdentifier(\n\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t)} (expected runtime ${runtimeToString(\n\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t)}, module is only referenced in ${runtimeToString(\n\t\t\t\t\t\t\t\t/** @type {RuntimeSpec} */ (runtimeCondition)\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t).join(\", \")}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectRuntimeCondition++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\tlet backup;\n\t\tif (avoidMutateOnFailure) {\n\t\t\tbackup = config.snapshot();\n\t\t}\n\n\t\t// Add the module\n\t\tconfig.add(module);\n\n\t\tincomingModules.sort(compareModulesByIdentifier);\n\n\t\t// Every module which depends on the added module must be in the configuration too.\n\t\tfor (const originModule of incomingModules) {\n\t\t\tconst problem = this._tryToAdd(\n\t\t\t\tcompilation,\n\t\t\t\tconfig,\n\t\t\t\toriginModule,\n\t\t\t\truntime,\n\t\t\t\tactiveRuntime,\n\t\t\t\tpossibleModules,\n\t\t\t\tcandidates,\n\t\t\t\tfailureCache,\n\t\t\t\tchunkGraph,\n\t\t\t\tfalse,\n\t\t\t\tstatistics\n\t\t\t);\n\t\t\tif (problem) {\n\t\t\t\tif (backup !== undefined) config.rollback(backup);\n\t\t\t\tstatistics.importerFailed++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t// Add imports to possible candidates list\n\t\tfor (const imp of this._getImports(compilation, module, runtime)) {\n\t\t\tcandidates.add(imp);\n\t\t}\n\t\tstatistics.added++;\n\t\treturn null;\n\t}\n}\n\nclass ConcatConfiguration {\n\t/**\n\t * @param {Module} rootModule the root module\n\t * @param {RuntimeSpec} runtime the runtime\n\t */\n\tconstructor(rootModule, runtime) {\n\t\tthis.rootModule = rootModule;\n\t\tthis.runtime = runtime;\n\t\t/** @type {Set<Module>} */\n\t\tthis.modules = new Set();\n\t\tthis.modules.add(rootModule);\n\t\t/** @type {Map<Module, Module | function(RequestShortener): string>} */\n\t\tthis.warnings = new Map();\n\t}\n\n\tadd(module) {\n\t\tthis.modules.add(module);\n\t}\n\n\thas(module) {\n\t\treturn this.modules.has(module);\n\t}\n\n\tisEmpty() {\n\t\treturn this.modules.size === 1;\n\t}\n\n\taddWarning(module, problem) {\n\t\tthis.warnings.set(module, problem);\n\t}\n\n\tgetWarningsSorted() {\n\t\treturn new Map(\n\t\t\tArray.from(this.warnings).sort((a, b) => {\n\t\t\t\tconst ai = a[0].identifier();\n\t\t\t\tconst bi = b[0].identifier();\n\t\t\t\tif (ai < bi) return -1;\n\t\t\t\tif (ai > bi) return 1;\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @returns {Set<Module>} modules as set\n\t */\n\tgetModules() {\n\t\treturn this.modules;\n\t}\n\n\tsnapshot() {\n\t\treturn this.modules.size;\n\t}\n\n\trollback(snapshot) {\n\t\tconst modules = this.modules;\n\t\tfor (const m of modules) {\n\t\t\tif (snapshot === 0) {\n\t\t\t\tmodules.delete(m);\n\t\t\t} else {\n\t\t\t\tsnapshot--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ModuleConcatenationPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}