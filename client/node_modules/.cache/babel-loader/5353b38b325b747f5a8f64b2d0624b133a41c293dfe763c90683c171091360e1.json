{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sean Larkin @thelarkinn\n*/\n\n\"use strict\";\n\nconst {\n  find\n} = require(\"../util/SetHelpers\");\nconst AssetsOverSizeLimitWarning = require(\"./AssetsOverSizeLimitWarning\");\nconst EntrypointsOverSizeLimitWarning = require(\"./EntrypointsOverSizeLimitWarning\");\nconst NoAsyncChunksWarning = require(\"./NoAsyncChunksWarning\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").PerformanceOptions} PerformanceOptions */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Entrypoint\")} Entrypoint */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} AssetDetails\n * @property {string} name\n * @property {number} size\n */\n\n/**\n * @typedef {Object} EntrypointDetails\n * @property {string} name\n * @property {number} size\n * @property {string[]} files\n */\n\nconst isOverSizeLimitSet = new WeakSet();\nconst excludeSourceMap = (name, source, info) => !info.development;\nmodule.exports = class SizeLimitsPlugin {\n  /**\n   * @param {PerformanceOptions} options the plugin options\n   */\n  constructor(options) {\n    this.hints = options.hints;\n    this.maxAssetSize = options.maxAssetSize;\n    this.maxEntrypointSize = options.maxEntrypointSize;\n    this.assetFilter = options.assetFilter;\n  }\n\n  /**\n   * @param {ChunkGroup | Source} thing the resource to test\n   * @returns {boolean} true if over the limit\n   */\n  static isOverSizeLimit(thing) {\n    return isOverSizeLimitSet.has(thing);\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const entrypointSizeLimit = this.maxEntrypointSize;\n    const assetSizeLimit = this.maxAssetSize;\n    const hints = this.hints;\n    const assetFilter = this.assetFilter || excludeSourceMap;\n    compiler.hooks.afterEmit.tap(\"SizeLimitsPlugin\", compilation => {\n      /** @type {WebpackError[]} */\n      const warnings = [];\n\n      /**\n       * @param {Entrypoint} entrypoint an entrypoint\n       * @returns {number} the size of the entrypoint\n       */\n      const getEntrypointSize = entrypoint => {\n        let size = 0;\n        for (const file of entrypoint.getFiles()) {\n          const asset = compilation.getAsset(file);\n          if (asset && assetFilter(asset.name, asset.source, asset.info) && asset.source) {\n            size += asset.info.size || asset.source.size();\n          }\n        }\n        return size;\n      };\n\n      /** @type {AssetDetails[]} */\n      const assetsOverSizeLimit = [];\n      for (const {\n        name,\n        source,\n        info\n      } of compilation.getAssets()) {\n        if (!assetFilter(name, source, info) || !source) {\n          continue;\n        }\n        const size = info.size || source.size();\n        if (size > assetSizeLimit) {\n          assetsOverSizeLimit.push({\n            name,\n            size\n          });\n          isOverSizeLimitSet.add(source);\n        }\n      }\n      const fileFilter = name => {\n        const asset = compilation.getAsset(name);\n        return asset && assetFilter(asset.name, asset.source, asset.info);\n      };\n\n      /** @type {EntrypointDetails[]} */\n      const entrypointsOverLimit = [];\n      for (const [name, entry] of compilation.entrypoints) {\n        const size = getEntrypointSize(entry);\n        if (size > entrypointSizeLimit) {\n          entrypointsOverLimit.push({\n            name: name,\n            size: size,\n            files: entry.getFiles().filter(fileFilter)\n          });\n          isOverSizeLimitSet.add(entry);\n        }\n      }\n      if (hints) {\n        // 1. Individual Chunk: Size < 250kb\n        // 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb\n        // 3. No Async Chunks\n        // if !1, then 2, if !2 return\n        if (assetsOverSizeLimit.length > 0) {\n          warnings.push(new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit));\n        }\n        if (entrypointsOverLimit.length > 0) {\n          warnings.push(new EntrypointsOverSizeLimitWarning(entrypointsOverLimit, entrypointSizeLimit));\n        }\n        if (warnings.length > 0) {\n          const someAsyncChunk = find(compilation.chunks, chunk => !chunk.canBeInitial());\n          if (!someAsyncChunk) {\n            warnings.push(new NoAsyncChunksWarning());\n          }\n          if (hints === \"error\") {\n            compilation.errors.push(...warnings);\n          } else {\n            compilation.warnings.push(...warnings);\n          }\n        }\n      }\n    });\n  }\n};","map":{"version":3,"names":["find","require","AssetsOverSizeLimitWarning","EntrypointsOverSizeLimitWarning","NoAsyncChunksWarning","isOverSizeLimitSet","WeakSet","excludeSourceMap","name","source","info","development","module","exports","SizeLimitsPlugin","constructor","options","hints","maxAssetSize","maxEntrypointSize","assetFilter","isOverSizeLimit","thing","has","apply","compiler","entrypointSizeLimit","assetSizeLimit","hooks","afterEmit","tap","compilation","warnings","getEntrypointSize","entrypoint","size","file","getFiles","asset","getAsset","assetsOverSizeLimit","getAssets","push","add","fileFilter","entrypointsOverLimit","entry","entrypoints","files","filter","length","someAsyncChunk","chunks","chunk","canBeInitial","errors"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/performance/SizeLimitsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sean Larkin @thelarkinn\n*/\n\n\"use strict\";\n\nconst { find } = require(\"../util/SetHelpers\");\nconst AssetsOverSizeLimitWarning = require(\"./AssetsOverSizeLimitWarning\");\nconst EntrypointsOverSizeLimitWarning = require(\"./EntrypointsOverSizeLimitWarning\");\nconst NoAsyncChunksWarning = require(\"./NoAsyncChunksWarning\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").PerformanceOptions} PerformanceOptions */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Entrypoint\")} Entrypoint */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} AssetDetails\n * @property {string} name\n * @property {number} size\n */\n\n/**\n * @typedef {Object} EntrypointDetails\n * @property {string} name\n * @property {number} size\n * @property {string[]} files\n */\n\nconst isOverSizeLimitSet = new WeakSet();\n\nconst excludeSourceMap = (name, source, info) => !info.development;\n\nmodule.exports = class SizeLimitsPlugin {\n\t/**\n\t * @param {PerformanceOptions} options the plugin options\n\t */\n\tconstructor(options) {\n\t\tthis.hints = options.hints;\n\t\tthis.maxAssetSize = options.maxAssetSize;\n\t\tthis.maxEntrypointSize = options.maxEntrypointSize;\n\t\tthis.assetFilter = options.assetFilter;\n\t}\n\n\t/**\n\t * @param {ChunkGroup | Source} thing the resource to test\n\t * @returns {boolean} true if over the limit\n\t */\n\tstatic isOverSizeLimit(thing) {\n\t\treturn isOverSizeLimitSet.has(thing);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst entrypointSizeLimit = this.maxEntrypointSize;\n\t\tconst assetSizeLimit = this.maxAssetSize;\n\t\tconst hints = this.hints;\n\t\tconst assetFilter = this.assetFilter || excludeSourceMap;\n\n\t\tcompiler.hooks.afterEmit.tap(\"SizeLimitsPlugin\", compilation => {\n\t\t\t/** @type {WebpackError[]} */\n\t\t\tconst warnings = [];\n\n\t\t\t/**\n\t\t\t * @param {Entrypoint} entrypoint an entrypoint\n\t\t\t * @returns {number} the size of the entrypoint\n\t\t\t */\n\t\t\tconst getEntrypointSize = entrypoint => {\n\t\t\t\tlet size = 0;\n\t\t\t\tfor (const file of entrypoint.getFiles()) {\n\t\t\t\t\tconst asset = compilation.getAsset(file);\n\t\t\t\t\tif (\n\t\t\t\t\t\tasset &&\n\t\t\t\t\t\tassetFilter(asset.name, asset.source, asset.info) &&\n\t\t\t\t\t\tasset.source\n\t\t\t\t\t) {\n\t\t\t\t\t\tsize += asset.info.size || asset.source.size();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn size;\n\t\t\t};\n\n\t\t\t/** @type {AssetDetails[]} */\n\t\t\tconst assetsOverSizeLimit = [];\n\t\t\tfor (const { name, source, info } of compilation.getAssets()) {\n\t\t\t\tif (!assetFilter(name, source, info) || !source) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst size = info.size || source.size();\n\t\t\t\tif (size > assetSizeLimit) {\n\t\t\t\t\tassetsOverSizeLimit.push({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tsize\n\t\t\t\t\t});\n\t\t\t\t\tisOverSizeLimitSet.add(source);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst fileFilter = name => {\n\t\t\t\tconst asset = compilation.getAsset(name);\n\t\t\t\treturn asset && assetFilter(asset.name, asset.source, asset.info);\n\t\t\t};\n\n\t\t\t/** @type {EntrypointDetails[]} */\n\t\t\tconst entrypointsOverLimit = [];\n\t\t\tfor (const [name, entry] of compilation.entrypoints) {\n\t\t\t\tconst size = getEntrypointSize(entry);\n\n\t\t\t\tif (size > entrypointSizeLimit) {\n\t\t\t\t\tentrypointsOverLimit.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tsize: size,\n\t\t\t\t\t\tfiles: entry.getFiles().filter(fileFilter)\n\t\t\t\t\t});\n\t\t\t\t\tisOverSizeLimitSet.add(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hints) {\n\t\t\t\t// 1. Individual Chunk: Size < 250kb\n\t\t\t\t// 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb\n\t\t\t\t// 3. No Async Chunks\n\t\t\t\t// if !1, then 2, if !2 return\n\t\t\t\tif (assetsOverSizeLimit.length > 0) {\n\t\t\t\t\twarnings.push(\n\t\t\t\t\t\tnew AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (entrypointsOverLimit.length > 0) {\n\t\t\t\t\twarnings.push(\n\t\t\t\t\t\tnew EntrypointsOverSizeLimitWarning(\n\t\t\t\t\t\t\tentrypointsOverLimit,\n\t\t\t\t\t\t\tentrypointSizeLimit\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (warnings.length > 0) {\n\t\t\t\t\tconst someAsyncChunk = find(\n\t\t\t\t\t\tcompilation.chunks,\n\t\t\t\t\t\tchunk => !chunk.canBeInitial()\n\t\t\t\t\t);\n\n\t\t\t\t\tif (!someAsyncChunk) {\n\t\t\t\t\t\twarnings.push(new NoAsyncChunksWarning());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hints === \"error\") {\n\t\t\t\t\t\tcompilation.errors.push(...warnings);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcompilation.warnings.push(...warnings);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}