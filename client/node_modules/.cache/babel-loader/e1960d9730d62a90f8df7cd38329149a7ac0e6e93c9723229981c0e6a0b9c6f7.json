{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst Source = require(\"./Source\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\n// since v8 7.0, Array.prototype.sort is stable\nconst hasStableSort = typeof process === \"object\" && process.versions && typeof process.versions.v8 === \"string\" && !/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nconst MAX_SOURCE_POSITION = 0x20000000;\nclass Replacement {\n  constructor(start, end, content, name) {\n    this.start = start;\n    this.end = end;\n    this.content = content;\n    this.name = name;\n    if (!hasStableSort) {\n      this.index = -1;\n    }\n  }\n}\nclass ReplaceSource extends Source {\n  constructor(source, name) {\n    super();\n    this._source = source;\n    this._name = name;\n    /** @type {Replacement[]} */\n    this._replacements = [];\n    this._isSorted = true;\n  }\n  getName() {\n    return this._name;\n  }\n  getReplacements() {\n    this._sortReplacements();\n    return this._replacements;\n  }\n  replace(start, end, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n    this._replacements.push(new Replacement(start, end, newValue, name));\n    this._isSorted = false;\n  }\n  insert(pos, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n    this._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n    this._isSorted = false;\n  }\n  source() {\n    if (this._replacements.length === 0) {\n      return this._source.source();\n    }\n    let current = this._source.source();\n    let pos = 0;\n    const result = [];\n    this._sortReplacements();\n    for (const replacement of this._replacements) {\n      const start = Math.floor(replacement.start);\n      const end = Math.floor(replacement.end + 1);\n      if (pos < start) {\n        const offset = start - pos;\n        result.push(current.slice(0, offset));\n        current = current.slice(offset);\n        pos = start;\n      }\n      result.push(replacement.content);\n      if (pos < end) {\n        const offset = end - pos;\n        current = current.slice(offset);\n        pos = end;\n      }\n    }\n    result.push(current);\n    return result.join(\"\");\n  }\n  map(options) {\n    if (this._replacements.length === 0) {\n      return this._source.map(options);\n    }\n    return getMap(this, options);\n  }\n  sourceAndMap(options) {\n    if (this._replacements.length === 0) {\n      return this._source.sourceAndMap(options);\n    }\n    return getSourceAndMap(this, options);\n  }\n  original() {\n    return this._source;\n  }\n  _sortReplacements() {\n    if (this._isSorted) return;\n    if (hasStableSort) {\n      this._replacements.sort(function (a, b) {\n        const diff1 = a.start - b.start;\n        if (diff1 !== 0) return diff1;\n        const diff2 = a.end - b.end;\n        if (diff2 !== 0) return diff2;\n        return 0;\n      });\n    } else {\n      this._replacements.forEach((repl, i) => repl.index = i);\n      this._replacements.sort(function (a, b) {\n        const diff1 = a.start - b.start;\n        if (diff1 !== 0) return diff1;\n        const diff2 = a.end - b.end;\n        if (diff2 !== 0) return diff2;\n        return a.index - b.index;\n      });\n    }\n    this._isSorted = true;\n  }\n  streamChunks(options, onChunk, onSource, onName) {\n    this._sortReplacements();\n    const repls = this._replacements;\n    let pos = 0;\n    let i = 0;\n    let replacmentEnd = -1;\n    let nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n    let generatedLineOffset = 0;\n    let generatedColumnOffset = 0;\n    let generatedColumnOffsetLine = 0;\n    const sourceContents = [];\n    const nameMapping = new Map();\n    const nameIndexMapping = [];\n    const checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n      let content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : undefined;\n      if (content === undefined) return false;\n      if (typeof content === \"string\") {\n        content = splitIntoLines(content);\n        sourceContents[sourceIndex] = content;\n      }\n      const contentLine = line <= content.length ? content[line - 1] : null;\n      if (contentLine === null) return false;\n      return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;\n    };\n    let {\n      generatedLine,\n      generatedColumn\n    } = streamChunks(this._source, Object.assign({}, options, {\n      finalSource: false\n    }), (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n      let chunkPos = 0;\n      let endPos = pos + chunk.length;\n\n      // Skip over when it has been replaced\n      if (replacmentEnd > pos) {\n        // Skip over the whole chunk\n        if (replacmentEnd >= endPos) {\n          const line = generatedLine + generatedLineOffset;\n          if (chunk.endsWith(\"\\n\")) {\n            generatedLineOffset--;\n            if (generatedColumnOffsetLine === line) {\n              // undo exiting corrections form the current line\n              generatedColumnOffset += generatedColumn;\n            }\n          } else if (generatedColumnOffsetLine === line) {\n            generatedColumnOffset -= chunk.length;\n          } else {\n            generatedColumnOffset = -chunk.length;\n            generatedColumnOffsetLine = line;\n          }\n          pos = endPos;\n          return;\n        }\n\n        // Partially skip over chunk\n        chunkPos = replacmentEnd - pos;\n        if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(0, chunkPos))) {\n          originalColumn += chunkPos;\n        }\n        pos += chunkPos;\n        const line = generatedLine + generatedLineOffset;\n        if (generatedColumnOffsetLine === line) {\n          generatedColumnOffset -= chunkPos;\n        } else {\n          generatedColumnOffset = -chunkPos;\n          generatedColumnOffsetLine = line;\n        }\n        generatedColumn += chunkPos;\n      }\n\n      // Is a replacement in the chunk?\n      if (nextReplacement < endPos) {\n        do {\n          let line = generatedLine + generatedLineOffset;\n          if (nextReplacement > pos) {\n            // Emit chunk until replacement\n            const offset = nextReplacement - pos;\n            const chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n            onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]);\n            generatedColumn += offset;\n            chunkPos += offset;\n            pos = nextReplacement;\n            if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunkSlice)) {\n              originalColumn += chunkSlice.length;\n            }\n          }\n\n          // Insert replacement content splitted into chunks by lines\n          const {\n            content,\n            name\n          } = repls[i];\n          let matches = splitIntoLines(content);\n          let replacementNameIndex = nameIndex;\n          if (sourceIndex >= 0 && name) {\n            let globalIndex = nameMapping.get(name);\n            if (globalIndex === undefined) {\n              globalIndex = nameMapping.size;\n              nameMapping.set(name, globalIndex);\n              onName(globalIndex, name);\n            }\n            replacementNameIndex = globalIndex;\n          }\n          for (let m = 0; m < matches.length; m++) {\n            const contentLine = matches[m];\n            onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, replacementNameIndex);\n\n            // Only the first chunk has name assigned\n            replacementNameIndex = -1;\n            if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n              if (generatedColumnOffsetLine === line) {\n                generatedColumnOffset += contentLine.length;\n              } else {\n                generatedColumnOffset = contentLine.length;\n                generatedColumnOffsetLine = line;\n              }\n            } else {\n              generatedLineOffset++;\n              line++;\n              generatedColumnOffset = -generatedColumn;\n              generatedColumnOffsetLine = line;\n            }\n          }\n\n          // Remove replaced content by settings this variable\n          replacmentEnd = Math.max(replacmentEnd, Math.floor(repls[i].end + 1));\n\n          // Move to next replacment\n          i++;\n          nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\n          // Skip over when it has been replaced\n          const offset = chunk.length - endPos + replacmentEnd - chunkPos;\n          if (offset > 0) {\n            // Skip over whole chunk\n            if (replacmentEnd >= endPos) {\n              let line = generatedLine + generatedLineOffset;\n              if (chunk.endsWith(\"\\n\")) {\n                generatedLineOffset--;\n                if (generatedColumnOffsetLine === line) {\n                  // undo exiting corrections form the current line\n                  generatedColumnOffset += generatedColumn;\n                }\n              } else if (generatedColumnOffsetLine === line) {\n                generatedColumnOffset -= chunk.length - chunkPos;\n              } else {\n                generatedColumnOffset = chunkPos - chunk.length;\n                generatedColumnOffsetLine = line;\n              }\n              pos = endPos;\n              return;\n            }\n\n            // Partially skip over chunk\n            const line = generatedLine + generatedLineOffset;\n            if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(chunkPos, chunkPos + offset))) {\n              originalColumn += offset;\n            }\n            chunkPos += offset;\n            pos += offset;\n            if (generatedColumnOffsetLine === line) {\n              generatedColumnOffset -= offset;\n            } else {\n              generatedColumnOffset = -offset;\n              generatedColumnOffsetLine = line;\n            }\n            generatedColumn += offset;\n          }\n        } while (nextReplacement < endPos);\n      }\n\n      // Emit remaining chunk\n      if (chunkPos < chunk.length) {\n        const chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n        const line = generatedLine + generatedLineOffset;\n        onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]);\n      }\n      pos = endPos;\n    }, (sourceIndex, source, sourceContent) => {\n      while (sourceContents.length < sourceIndex) sourceContents.push(undefined);\n      sourceContents[sourceIndex] = sourceContent;\n      onSource(sourceIndex, source, sourceContent);\n    }, (nameIndex, name) => {\n      let globalIndex = nameMapping.get(name);\n      if (globalIndex === undefined) {\n        globalIndex = nameMapping.size;\n        nameMapping.set(name, globalIndex);\n        onName(globalIndex, name);\n      }\n      nameIndexMapping[nameIndex] = globalIndex;\n    });\n\n    // Handle remaining replacements\n    let remainer = \"\";\n    for (; i < repls.length; i++) {\n      remainer += repls[i].content;\n    }\n\n    // Insert remaining replacements content splitted into chunks by lines\n    let line = generatedLine + generatedLineOffset;\n    let matches = splitIntoLines(remainer);\n    for (let m = 0; m < matches.length; m++) {\n      const contentLine = matches[m];\n      onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), -1, -1, -1, -1);\n      if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n        if (generatedColumnOffsetLine === line) {\n          generatedColumnOffset += contentLine.length;\n        } else {\n          generatedColumnOffset = contentLine.length;\n          generatedColumnOffsetLine = line;\n        }\n      } else {\n        generatedLineOffset++;\n        line++;\n        generatedColumnOffset = -generatedColumn;\n        generatedColumnOffsetLine = line;\n      }\n    }\n    return {\n      generatedLine: line,\n      generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n    };\n  }\n  updateHash(hash) {\n    this._sortReplacements();\n    hash.update(\"ReplaceSource\");\n    this._source.updateHash(hash);\n    hash.update(this._name || \"\");\n    for (const repl of this._replacements) {\n      hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n    }\n  }\n}\nmodule.exports = ReplaceSource;","map":{"version":3,"names":["getMap","getSourceAndMap","require","streamChunks","Source","splitIntoLines","hasStableSort","process","versions","v8","test","MAX_SOURCE_POSITION","Replacement","constructor","start","end","content","name","index","ReplaceSource","source","_source","_name","_replacements","_isSorted","getName","getReplacements","_sortReplacements","replace","newValue","Error","push","insert","pos","length","current","result","replacement","Math","floor","offset","slice","join","map","options","sourceAndMap","original","sort","a","b","diff1","diff2","forEach","repl","i","onChunk","onSource","onName","repls","replacmentEnd","nextReplacement","generatedLineOffset","generatedColumnOffset","generatedColumnOffsetLine","sourceContents","nameMapping","Map","nameIndexMapping","checkOriginalContent","sourceIndex","line","column","expectedChunk","undefined","contentLine","generatedLine","generatedColumn","Object","assign","finalSource","chunk","originalLine","originalColumn","nameIndex","chunkPos","endPos","endsWith","chunkSlice","matches","replacementNameIndex","globalIndex","get","size","set","m","max","sourceContent","remainer","updateHash","hash","update","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack-sources/lib/ReplaceSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst Source = require(\"./Source\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\n// since v8 7.0, Array.prototype.sort is stable\nconst hasStableSort =\n\ttypeof process === \"object\" &&\n\tprocess.versions &&\n\ttypeof process.versions.v8 === \"string\" &&\n\t!/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n\tconstructor(start, end, content, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.name = name;\n\t\tif (!hasStableSort) {\n\t\t\tthis.index = -1;\n\t\t}\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis._replacements = [];\n\t\tthis._isSorted = true;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tgetReplacements() {\n\t\tthis._sortReplacements();\n\t\treturn this._replacements;\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(start, end, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" +\n\t\t\t\t\ttypeof newValue +\n\t\t\t\t\t\": \" +\n\t\t\t\t\tnewValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tsource() {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.source();\n\t\t}\n\t\tlet current = this._source.source();\n\t\tlet pos = 0;\n\t\tconst result = [];\n\n\t\tthis._sortReplacements();\n\t\tfor (const replacement of this._replacements) {\n\t\t\tconst start = Math.floor(replacement.start);\n\t\t\tconst end = Math.floor(replacement.end + 1);\n\t\t\tif (pos < start) {\n\t\t\t\tconst offset = start - pos;\n\t\t\t\tresult.push(current.slice(0, offset));\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = start;\n\t\t\t}\n\t\t\tresult.push(replacement.content);\n\t\t\tif (pos < end) {\n\t\t\t\tconst offset = end - pos;\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = end;\n\t\t\t}\n\t\t}\n\t\tresult.push(current);\n\t\treturn result.join(\"\");\n\t}\n\n\tmap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.map(options);\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.sourceAndMap(options);\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tif (this._isSorted) return;\n\t\tif (hasStableSort) {\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._replacements.forEach((repl, i) => (repl.index = i));\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn a.index - b.index;\n\t\t\t});\n\t\t}\n\t\tthis._isSorted = true;\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tthis._sortReplacements();\n\t\tconst repls = this._replacements;\n\t\tlet pos = 0;\n\t\tlet i = 0;\n\t\tlet replacmentEnd = -1;\n\t\tlet nextReplacement =\n\t\t\ti < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\t\tlet generatedLineOffset = 0;\n\t\tlet generatedColumnOffset = 0;\n\t\tlet generatedColumnOffsetLine = 0;\n\t\tconst sourceContents = [];\n\t\tconst nameMapping = new Map();\n\t\tconst nameIndexMapping = [];\n\t\tconst checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n\t\t\tlet content =\n\t\t\t\tsourceIndex < sourceContents.length\n\t\t\t\t\t? sourceContents[sourceIndex]\n\t\t\t\t\t: undefined;\n\t\t\tif (content === undefined) return false;\n\t\t\tif (typeof content === \"string\") {\n\t\t\t\tcontent = splitIntoLines(content);\n\t\t\t\tsourceContents[sourceIndex] = content;\n\t\t\t}\n\t\t\tconst contentLine = line <= content.length ? content[line - 1] : null;\n\t\t\tif (contentLine === null) return false;\n\t\t\treturn (\n\t\t\t\tcontentLine.slice(column, column + expectedChunk.length) ===\n\t\t\t\texpectedChunk\n\t\t\t);\n\t\t};\n\t\tlet { generatedLine, generatedColumn } = streamChunks(\n\t\t\tthis._source,\n\t\t\tObject.assign({}, options, { finalSource: false }),\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tlet chunkPos = 0;\n\t\t\t\tlet endPos = pos + chunk.length;\n\n\t\t\t\t// Skip over when it has been replaced\n\t\t\t\tif (replacmentEnd > pos) {\n\t\t\t\t\t// Skip over the whole chunk\n\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgeneratedColumnOffset = -chunk.length;\n\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\tchunkPos = replacmentEnd - pos;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tchunk.slice(0, chunkPos)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\toriginalColumn += chunkPos;\n\t\t\t\t\t}\n\t\t\t\t\tpos += chunkPos;\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\tgeneratedColumnOffset -= chunkPos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgeneratedColumnOffset = -chunkPos;\n\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t}\n\t\t\t\t\tgeneratedColumn += chunkPos;\n\t\t\t\t}\n\n\t\t\t\t// Is a replacement in the chunk?\n\t\t\t\tif (nextReplacement < endPos) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (nextReplacement > pos) {\n\t\t\t\t\t\t\t// Emit chunk until replacement\n\t\t\t\t\t\t\tconst offset = nextReplacement - pos;\n\t\t\t\t\t\t\tconst chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t\t: nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos = nextReplacement;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunkSlice\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += chunkSlice.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Insert replacement content splitted into chunks by lines\n\t\t\t\t\t\tconst { content, name } = repls[i];\n\t\t\t\t\t\tlet matches = splitIntoLines(content);\n\t\t\t\t\t\tlet replacementNameIndex = nameIndex;\n\t\t\t\t\t\tif (sourceIndex >= 0 && name) {\n\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treplacementNameIndex = globalIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\t\t\t\t\tconst contentLine = matches[m];\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tcontentLine,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\treplacementNameIndex\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Only the first chunk has name assigned\n\t\t\t\t\t\t\treplacementNameIndex = -1;\n\n\t\t\t\t\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedLineOffset++;\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove replaced content by settings this variable\n\t\t\t\t\t\treplacmentEnd = Math.max(\n\t\t\t\t\t\t\treplacmentEnd,\n\t\t\t\t\t\t\tMath.floor(repls[i].end + 1)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Move to next replacment\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tnextReplacement =\n\t\t\t\t\t\t\ti < repls.length\n\t\t\t\t\t\t\t\t? Math.floor(repls[i].start)\n\t\t\t\t\t\t\t\t: MAX_SOURCE_POSITION;\n\n\t\t\t\t\t\t// Skip over when it has been replaced\n\t\t\t\t\t\tconst offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\t\t\t\t\t\tif (offset > 0) {\n\t\t\t\t\t\t\t// Skip over whole chunk\n\t\t\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length - chunkPos;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = chunkPos - chunk.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunk.slice(chunkPos, chunkPos + offset)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += offset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos += offset;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset -= offset;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -offset;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (nextReplacement < endPos);\n\t\t\t\t}\n\n\t\t\t\t// Emit remaining chunk\n\t\t\t\tif (chunkPos < chunk.length) {\n\t\t\t\t\tconst chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex < 0 ? -1 : nameIndexMapping[nameIndex]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tpos = endPos;\n\t\t\t},\n\t\t\t(sourceIndex, source, sourceContent) => {\n\t\t\t\twhile (sourceContents.length < sourceIndex)\n\t\t\t\t\tsourceContents.push(undefined);\n\t\t\t\tsourceContents[sourceIndex] = sourceContent;\n\t\t\t\tonSource(sourceIndex, source, sourceContent);\n\t\t\t},\n\t\t\t(nameIndex, name) => {\n\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t}\n\t\t\t\tnameIndexMapping[nameIndex] = globalIndex;\n\t\t\t}\n\t\t);\n\n\t\t// Handle remaining replacements\n\t\tlet remainer = \"\";\n\t\tfor (; i < repls.length; i++) {\n\t\t\tremainer += repls[i].content;\n\t\t}\n\n\t\t// Insert remaining replacements content splitted into chunks by lines\n\t\tlet line = generatedLine + generatedLineOffset;\n\t\tlet matches = splitIntoLines(remainer);\n\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\tconst contentLine = matches[m];\n\t\t\tonChunk(\n\t\t\t\tcontentLine,\n\t\t\t\tline,\n\t\t\t\tgeneratedColumn +\n\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t);\n\n\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t} else {\n\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgeneratedLineOffset++;\n\t\t\t\tline++;\n\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgeneratedLine: line,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn +\n\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._sortReplacements();\n\t\thash.update(\"ReplaceSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._name || \"\");\n\t\tfor (const repl of this._replacements) {\n\t\t\thash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n\t\t}\n\t}\n}\n\nmodule.exports = ReplaceSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}