{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst {\n  RuntimeGlobals\n} = require(\"..\");\nconst HotUpdateChunk = require(\"../HotUpdateChunk\");\nconst Template = require(\"../Template\");\nconst {\n  getAllChunks\n} = require(\"../javascript/ChunkHelpers\");\nconst {\n  chunkHasJs,\n  getCompilationHooks,\n  getChunkFilenameTemplate\n} = require(\"../javascript/JavascriptModulesPlugin\");\nconst {\n  updateHashForEntryStartup\n} = require(\"../javascript/StartupHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass ModuleChunkFormatPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"ModuleChunkFormatPlugin\", compilation => {\n      compilation.hooks.additionalChunkRuntimeRequirements.tap(\"ModuleChunkFormatPlugin\", (chunk, set) => {\n        if (chunk.hasRuntime()) return;\n        if (compilation.chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n          set.add(RuntimeGlobals.require);\n          set.add(RuntimeGlobals.startupEntrypoint);\n          set.add(RuntimeGlobals.externalInstallChunk);\n        }\n      });\n      const hooks = getCompilationHooks(compilation);\n      hooks.renderChunk.tap(\"ModuleChunkFormatPlugin\", (modules, renderContext) => {\n        const {\n          chunk,\n          chunkGraph,\n          runtimeTemplate\n        } = renderContext;\n        const hotUpdateChunk = chunk instanceof HotUpdateChunk ? chunk : null;\n        const source = new ConcatSource();\n        if (hotUpdateChunk) {\n          throw new Error(\"HMR is not implemented for module chunk format yet\");\n        } else {\n          source.add(`export const id = ${JSON.stringify(chunk.id)};\\n`);\n          source.add(`export const ids = ${JSON.stringify(chunk.ids)};\\n`);\n          source.add(`export const modules = `);\n          source.add(modules);\n          source.add(`;\\n`);\n          const runtimeModules = chunkGraph.getChunkRuntimeModulesInOrder(chunk);\n          if (runtimeModules.length > 0) {\n            source.add(\"export const runtime =\\n\");\n            source.add(Template.renderChunkRuntimeModules(runtimeModules, renderContext));\n          }\n          const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));\n          if (entries.length > 0) {\n            const runtimeChunk = entries[0][1].getRuntimeChunk();\n            const currentOutputName = compilation.getPath(getChunkFilenameTemplate(chunk, compilation.outputOptions), {\n              chunk,\n              contentHashType: \"javascript\"\n            }).split(\"/\");\n\n            // remove filename, we only need the directory\n            currentOutputName.pop();\n            const getRelativePath = chunk => {\n              const baseOutputName = currentOutputName.slice();\n              const chunkOutputName = compilation.getPath(getChunkFilenameTemplate(chunk, compilation.outputOptions), {\n                chunk: chunk,\n                contentHashType: \"javascript\"\n              }).split(\"/\");\n\n              // remove common parts\n              while (baseOutputName.length > 0 && chunkOutputName.length > 0 && baseOutputName[0] === chunkOutputName[0]) {\n                baseOutputName.shift();\n                chunkOutputName.shift();\n              }\n              // create final path\n              return (baseOutputName.length > 0 ? \"../\".repeat(baseOutputName.length) : \"./\") + chunkOutputName.join(\"/\");\n            };\n            const entrySource = new ConcatSource();\n            entrySource.add(source);\n            entrySource.add(\";\\n\\n// load runtime\\n\");\n            entrySource.add(`import ${RuntimeGlobals.require} from ${JSON.stringify(getRelativePath(runtimeChunk))};\\n`);\n            const startupSource = new ConcatSource();\n            startupSource.add(`var __webpack_exec__ = ${runtimeTemplate.returningFunction(`${RuntimeGlobals.require}(${RuntimeGlobals.entryModuleId} = moduleId)`, \"moduleId\")}\\n`);\n            const loadedChunks = new Set();\n            let index = 0;\n            for (let i = 0; i < entries.length; i++) {\n              const [module, entrypoint] = entries[i];\n              const final = i + 1 === entries.length;\n              const moduleId = chunkGraph.getModuleId(module);\n              const chunks = getAllChunks(entrypoint, runtimeChunk, undefined);\n              for (const chunk of chunks) {\n                if (loadedChunks.has(chunk) || !chunkHasJs(chunk, chunkGraph)) continue;\n                loadedChunks.add(chunk);\n                startupSource.add(`import * as __webpack_chunk_${index}__ from ${JSON.stringify(getRelativePath(chunk))};\\n`);\n                startupSource.add(`${RuntimeGlobals.externalInstallChunk}(__webpack_chunk_${index}__);\\n`);\n                index++;\n              }\n              startupSource.add(`${final ? \"var __webpack_exports__ = \" : \"\"}__webpack_exec__(${JSON.stringify(moduleId)});\\n`);\n            }\n            entrySource.add(hooks.renderStartup.call(startupSource, entries[entries.length - 1][0], {\n              ...renderContext,\n              inlined: false\n            }));\n            return entrySource;\n          }\n        }\n        return source;\n      });\n      hooks.chunkHash.tap(\"ModuleChunkFormatPlugin\", (chunk, hash, _ref) => {\n        let {\n          chunkGraph,\n          runtimeTemplate\n        } = _ref;\n        if (chunk.hasRuntime()) return;\n        hash.update(\"ModuleChunkFormatPlugin\");\n        hash.update(\"1\");\n        const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));\n        updateHashForEntryStartup(hash, chunkGraph, entries, chunk);\n      });\n    });\n  }\n}\nmodule.exports = ModuleChunkFormatPlugin;","map":{"version":3,"names":["ConcatSource","require","RuntimeGlobals","HotUpdateChunk","Template","getAllChunks","chunkHasJs","getCompilationHooks","getChunkFilenameTemplate","updateHashForEntryStartup","ModuleChunkFormatPlugin","apply","compiler","hooks","thisCompilation","tap","compilation","additionalChunkRuntimeRequirements","chunk","set","hasRuntime","chunkGraph","getNumberOfEntryModules","add","startupEntrypoint","externalInstallChunk","renderChunk","modules","renderContext","runtimeTemplate","hotUpdateChunk","source","Error","JSON","stringify","id","ids","runtimeModules","getChunkRuntimeModulesInOrder","length","renderChunkRuntimeModules","entries","Array","from","getChunkEntryModulesWithChunkGroupIterable","runtimeChunk","getRuntimeChunk","currentOutputName","getPath","outputOptions","contentHashType","split","pop","getRelativePath","baseOutputName","slice","chunkOutputName","shift","repeat","join","entrySource","startupSource","returningFunction","entryModuleId","loadedChunks","Set","index","i","module","entrypoint","final","moduleId","getModuleId","chunks","undefined","has","renderStartup","call","inlined","chunkHash","hash","_ref","update","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/esm/ModuleChunkFormatPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst { RuntimeGlobals } = require(\"..\");\nconst HotUpdateChunk = require(\"../HotUpdateChunk\");\nconst Template = require(\"../Template\");\nconst { getAllChunks } = require(\"../javascript/ChunkHelpers\");\nconst {\n\tchunkHasJs,\n\tgetCompilationHooks,\n\tgetChunkFilenameTemplate\n} = require(\"../javascript/JavascriptModulesPlugin\");\nconst { updateHashForEntryStartup } = require(\"../javascript/StartupHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass ModuleChunkFormatPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"ModuleChunkFormatPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tcompilation.hooks.additionalChunkRuntimeRequirements.tap(\n\t\t\t\t\t\"ModuleChunkFormatPlugin\",\n\t\t\t\t\t(chunk, set) => {\n\t\t\t\t\t\tif (chunk.hasRuntime()) return;\n\t\t\t\t\t\tif (compilation.chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n\t\t\t\t\t\t\tset.add(RuntimeGlobals.require);\n\t\t\t\t\t\t\tset.add(RuntimeGlobals.startupEntrypoint);\n\t\t\t\t\t\t\tset.add(RuntimeGlobals.externalInstallChunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tconst hooks = getCompilationHooks(compilation);\n\t\t\t\thooks.renderChunk.tap(\n\t\t\t\t\t\"ModuleChunkFormatPlugin\",\n\t\t\t\t\t(modules, renderContext) => {\n\t\t\t\t\t\tconst { chunk, chunkGraph, runtimeTemplate } = renderContext;\n\t\t\t\t\t\tconst hotUpdateChunk =\n\t\t\t\t\t\t\tchunk instanceof HotUpdateChunk ? chunk : null;\n\t\t\t\t\t\tconst source = new ConcatSource();\n\t\t\t\t\t\tif (hotUpdateChunk) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\"HMR is not implemented for module chunk format yet\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.add(`export const id = ${JSON.stringify(chunk.id)};\\n`);\n\t\t\t\t\t\t\tsource.add(`export const ids = ${JSON.stringify(chunk.ids)};\\n`);\n\t\t\t\t\t\t\tsource.add(`export const modules = `);\n\t\t\t\t\t\t\tsource.add(modules);\n\t\t\t\t\t\t\tsource.add(`;\\n`);\n\t\t\t\t\t\t\tconst runtimeModules =\n\t\t\t\t\t\t\t\tchunkGraph.getChunkRuntimeModulesInOrder(chunk);\n\t\t\t\t\t\t\tif (runtimeModules.length > 0) {\n\t\t\t\t\t\t\t\tsource.add(\"export const runtime =\\n\");\n\t\t\t\t\t\t\t\tsource.add(\n\t\t\t\t\t\t\t\t\tTemplate.renderChunkRuntimeModules(\n\t\t\t\t\t\t\t\t\t\truntimeModules,\n\t\t\t\t\t\t\t\t\t\trenderContext\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst entries = Array.from(\n\t\t\t\t\t\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (entries.length > 0) {\n\t\t\t\t\t\t\t\tconst runtimeChunk = entries[0][1].getRuntimeChunk();\n\t\t\t\t\t\t\t\tconst currentOutputName = compilation\n\t\t\t\t\t\t\t\t\t.getPath(\n\t\t\t\t\t\t\t\t\t\tgetChunkFilenameTemplate(chunk, compilation.outputOptions),\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\tcontentHashType: \"javascript\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t.split(\"/\");\n\n\t\t\t\t\t\t\t\t// remove filename, we only need the directory\n\t\t\t\t\t\t\t\tcurrentOutputName.pop();\n\n\t\t\t\t\t\t\t\tconst getRelativePath = chunk => {\n\t\t\t\t\t\t\t\t\tconst baseOutputName = currentOutputName.slice();\n\t\t\t\t\t\t\t\t\tconst chunkOutputName = compilation\n\t\t\t\t\t\t\t\t\t\t.getPath(\n\t\t\t\t\t\t\t\t\t\t\tgetChunkFilenameTemplate(\n\t\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.outputOptions\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tchunk: chunk,\n\t\t\t\t\t\t\t\t\t\t\t\tcontentHashType: \"javascript\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t.split(\"/\");\n\n\t\t\t\t\t\t\t\t\t// remove common parts\n\t\t\t\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\t\t\t\tbaseOutputName.length > 0 &&\n\t\t\t\t\t\t\t\t\t\tchunkOutputName.length > 0 &&\n\t\t\t\t\t\t\t\t\t\tbaseOutputName[0] === chunkOutputName[0]\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tbaseOutputName.shift();\n\t\t\t\t\t\t\t\t\t\tchunkOutputName.shift();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// create final path\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t(baseOutputName.length > 0\n\t\t\t\t\t\t\t\t\t\t\t? \"../\".repeat(baseOutputName.length)\n\t\t\t\t\t\t\t\t\t\t\t: \"./\") + chunkOutputName.join(\"/\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst entrySource = new ConcatSource();\n\t\t\t\t\t\t\t\tentrySource.add(source);\n\t\t\t\t\t\t\t\tentrySource.add(\";\\n\\n// load runtime\\n\");\n\t\t\t\t\t\t\t\tentrySource.add(\n\t\t\t\t\t\t\t\t\t`import ${RuntimeGlobals.require} from ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tgetRelativePath(runtimeChunk)\n\t\t\t\t\t\t\t\t\t)};\\n`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconst startupSource = new ConcatSource();\n\t\t\t\t\t\t\t\tstartupSource.add(\n\t\t\t\t\t\t\t\t\t`var __webpack_exec__ = ${runtimeTemplate.returningFunction(\n\t\t\t\t\t\t\t\t\t\t`${RuntimeGlobals.require}(${RuntimeGlobals.entryModuleId} = moduleId)`,\n\t\t\t\t\t\t\t\t\t\t\"moduleId\"\n\t\t\t\t\t\t\t\t\t)}\\n`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconst loadedChunks = new Set();\n\t\t\t\t\t\t\t\tlet index = 0;\n\t\t\t\t\t\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\t\t\t\t\t\tconst [module, entrypoint] = entries[i];\n\t\t\t\t\t\t\t\t\tconst final = i + 1 === entries.length;\n\t\t\t\t\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\t\t\t\t\tconst chunks = getAllChunks(\n\t\t\t\t\t\t\t\t\t\tentrypoint,\n\t\t\t\t\t\t\t\t\t\truntimeChunk,\n\t\t\t\t\t\t\t\t\t\tundefined\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tloadedChunks.has(chunk) ||\n\t\t\t\t\t\t\t\t\t\t\t!chunkHasJs(chunk, chunkGraph)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\tloadedChunks.add(chunk);\n\t\t\t\t\t\t\t\t\t\tstartupSource.add(\n\t\t\t\t\t\t\t\t\t\t\t`import * as __webpack_chunk_${index}__ from ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\t\t\tgetRelativePath(chunk)\n\t\t\t\t\t\t\t\t\t\t\t)};\\n`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tstartupSource.add(\n\t\t\t\t\t\t\t\t\t\t\t`${RuntimeGlobals.externalInstallChunk}(__webpack_chunk_${index}__);\\n`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstartupSource.add(\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\tfinal ? \"var __webpack_exports__ = \" : \"\"\n\t\t\t\t\t\t\t\t\t\t}__webpack_exec__(${JSON.stringify(moduleId)});\\n`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tentrySource.add(\n\t\t\t\t\t\t\t\t\thooks.renderStartup.call(\n\t\t\t\t\t\t\t\t\t\tstartupSource,\n\t\t\t\t\t\t\t\t\t\tentries[entries.length - 1][0],\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t...renderContext,\n\t\t\t\t\t\t\t\t\t\t\tinlined: false\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn entrySource;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn source;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\thooks.chunkHash.tap(\n\t\t\t\t\t\"ModuleChunkFormatPlugin\",\n\t\t\t\t\t(chunk, hash, { chunkGraph, runtimeTemplate }) => {\n\t\t\t\t\t\tif (chunk.hasRuntime()) return;\n\t\t\t\t\t\thash.update(\"ModuleChunkFormatPlugin\");\n\t\t\t\t\t\thash.update(\"1\");\n\t\t\t\t\t\tconst entries = Array.from(\n\t\t\t\t\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tupdateHashForEntryStartup(hash, chunkGraph, entries, chunk);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = ModuleChunkFormatPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}