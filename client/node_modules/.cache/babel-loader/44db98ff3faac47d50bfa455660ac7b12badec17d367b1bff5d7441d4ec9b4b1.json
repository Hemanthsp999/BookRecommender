{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\nconst Template = require(\"../Template\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst {\n  getEntryRuntime\n} = require(\"../util/runtime\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\nconst KEYWORD_REGEX = /^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX = /^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\nconst isNameValid = name => {\n  return !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\nconst accessWithInit = function (accessor, existingLength) {\n  let initLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // This generates for [a, b, c, d]:\n  // (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n  const base = accessor[0];\n  if (accessor.length === 1 && !initLast) return base;\n  let current = existingLength > 0 ? base : `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`;\n\n  // i is the current position in accessor that has been printed\n  let i = 1;\n\n  // all properties printed so far (excluding base)\n  let propsSoFar;\n\n  // if there is existingLength, print all properties until this position as property access\n  if (existingLength > i) {\n    propsSoFar = accessor.slice(1, existingLength);\n    i = existingLength;\n    current += propertyAccess(propsSoFar);\n  } else {\n    propsSoFar = [];\n  }\n\n  // all remaining properties (except the last one when initLast is not set)\n  // should be printed as initializer\n  const initUntil = initLast ? accessor.length : accessor.length - 1;\n  for (; i < initUntil; i++) {\n    const prop = accessor[i];\n    propsSoFar.push(prop);\n    current = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(propsSoFar)} || {})`;\n  }\n\n  // print the last property as property access if not yet printed\n  if (i < accessor.length) current = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n  return current;\n};\n\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n  /**\n   * @param {AssignLibraryPluginOptions} options the plugin options\n   */\n  constructor(options) {\n    super({\n      pluginName: \"AssignLibraryPlugin\",\n      type: options.type\n    });\n    this.prefix = options.prefix;\n    this.declare = options.declare;\n    this.unnamed = options.unnamed;\n    this.named = options.named || \"assign\";\n  }\n\n  /**\n   * @param {LibraryOptions} library normalized library option\n   * @returns {T | false} preprocess as needed by overriding\n   */\n  parseOptions(library) {\n    const {\n      name\n    } = library;\n    if (this.unnamed === \"error\") {\n      if (typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    } else {\n      if (name && typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    }\n    return {\n      name: /** @type {string|string[]=} */name,\n      export: library.export\n    };\n  }\n\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {string} entryName the name of the entrypoint\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  finishEntryModule(module, entryName, _ref) {\n    let {\n      options,\n      compilation,\n      compilation: {\n        moduleGraph\n      }\n    } = _ref;\n    const runtime = getEntryRuntime(compilation, entryName);\n    if (options.export) {\n      const exportsInfo = moduleGraph.getExportInfo(module, Array.isArray(options.export) ? options.export[0] : options.export);\n      exportsInfo.setUsed(UsageState.Used, runtime);\n      exportsInfo.canMangleUse = false;\n    } else {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      exportsInfo.setUsedInUnknownWay(runtime);\n    }\n    moduleGraph.addExtraReason(module, \"used as library export\");\n  }\n  _getPrefix(compilation) {\n    return this.prefix === \"global\" ? [compilation.runtimeTemplate.globalObject] : this.prefix;\n  }\n  _getResolvedFullName(options, chunk, compilation) {\n    const prefix = this._getPrefix(compilation);\n    const fullName = options.name ? prefix.concat(options.name) : prefix;\n    return fullName.map(n => compilation.getPath(n, {\n      chunk\n    }));\n  }\n\n  /**\n   * @param {Source} source source\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n  render(source, _ref2, _ref3) {\n    let {\n      chunk\n    } = _ref2;\n    let {\n      options,\n      compilation\n    } = _ref3;\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    if (this.declare) {\n      const base = fullNameResolved[0];\n      if (!isNameValid(base)) {\n        throw new Error(`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(base)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n      source = new ConcatSource(`${this.declare} ${base};\\n`, source);\n    }\n    return source;\n  }\n\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n  embedInRuntimeBailout(module, _ref4, _ref5) {\n    let {\n      chunk,\n      codeGenerationResults\n    } = _ref4;\n    let {\n      options,\n      compilation\n    } = _ref5;\n    const {\n      data\n    } = codeGenerationResults.get(module, chunk.runtime);\n    const topLevelDeclarations = data && data.get(\"topLevelDeclarations\") || module.buildInfo && module.buildInfo.topLevelDeclarations;\n    if (!topLevelDeclarations) return \"it doesn't tell about top level declarations.\";\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    const base = fullNameResolved[0];\n    if (topLevelDeclarations.has(base)) return `it declares '${base}' on top-level, which conflicts with the current library output.`;\n  }\n\n  /**\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n  strictRuntimeBailout(_ref6, _ref7) {\n    let {\n      chunk\n    } = _ref6;\n    let {\n      options,\n      compilation\n    } = _ref7;\n    if (this.declare || this.prefix === \"global\" || this.prefix.length > 0 || !options.name) {\n      return;\n    }\n    return \"a global variable is assign and maybe created\";\n  }\n\n  /**\n   * @param {Source} source source\n   * @param {Module} module module\n   * @param {StartupRenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n  renderStartup(source, module, _ref8, _ref9) {\n    let {\n      moduleGraph,\n      chunk\n    } = _ref8;\n    let {\n      options,\n      compilation\n    } = _ref9;\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    const staticExports = this.unnamed === \"static\";\n    const exportAccess = options.export ? propertyAccess(Array.isArray(options.export) ? options.export : [options.export]) : \"\";\n    const result = new ConcatSource(source);\n    if (staticExports) {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      const exportTarget = accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true);\n      for (const exportInfo of exportsInfo.orderedExports) {\n        if (!exportInfo.provided) continue;\n        const nameAccess = propertyAccess([exportInfo.name]);\n        result.add(`${exportTarget}${nameAccess} = __webpack_exports__${exportAccess}${nameAccess};\\n`);\n      }\n      result.add(`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`);\n    } else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      result.add(`var __webpack_export_target__ = ${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true)};\\n`);\n      let exports = \"__webpack_exports__\";\n      if (exportAccess) {\n        result.add(`var __webpack_exports_export__ = __webpack_exports__${exportAccess};\\n`);\n        exports = \"__webpack_exports_export__\";\n      }\n      result.add(`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`);\n      result.add(`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`);\n    } else {\n      result.add(`${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, false)} = __webpack_exports__${exportAccess};\\n`);\n    }\n    return result;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} set runtime requirements\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  runtimeRequirements(chunk, set, libraryContext) {\n    // we don't need to return exports from runtime\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Hash} hash hash\n   * @param {ChunkHashContext} chunkHashContext chunk hash context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  chunkHash(chunk, hash, chunkHashContext, _ref10) {\n    let {\n      options,\n      compilation\n    } = _ref10;\n    hash.update(\"AssignLibraryPlugin\");\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      hash.update(\"copy\");\n    }\n    if (this.declare) {\n      hash.update(this.declare);\n    }\n    hash.update(fullNameResolved.join(\".\"));\n    if (options.export) {\n      hash.update(`${options.export}`);\n    }\n  }\n}\nmodule.exports = AssignLibraryPlugin;","map":{"version":3,"names":["ConcatSource","require","UsageState","Template","propertyAccess","getEntryRuntime","AbstractLibraryPlugin","KEYWORD_REGEX","IDENTIFIER_REGEX","isNameValid","name","test","accessWithInit","accessor","existingLength","initLast","arguments","length","undefined","base","current","i","propsSoFar","slice","initUntil","prop","push","AssignLibraryPlugin","constructor","options","pluginName","type","prefix","declare","unnamed","named","parseOptions","library","Array","isArray","Error","COMMON_LIBRARY_NAME_MESSAGE","export","finishEntryModule","module","entryName","_ref","compilation","moduleGraph","runtime","exportsInfo","getExportInfo","setUsed","Used","canMangleUse","getExportsInfo","setUsedInUnknownWay","addExtraReason","_getPrefix","runtimeTemplate","globalObject","_getResolvedFullName","chunk","fullName","concat","map","n","getPath","render","source","_ref2","_ref3","fullNameResolved","toIdentifier","embedInRuntimeBailout","_ref4","_ref5","codeGenerationResults","data","get","topLevelDeclarations","buildInfo","has","strictRuntimeBailout","_ref6","_ref7","renderStartup","_ref8","_ref9","staticExports","exportAccess","result","exportTarget","exportInfo","orderedExports","provided","nameAccess","add","exports","runtimeRequirements","set","libraryContext","chunkHash","hash","chunkHashContext","_ref10","update","join"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/library/AssignLibraryPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst { UsageState } = require(\"../ExportsInfo\");\nconst Template = require(\"../Template\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst { getEntryRuntime } = require(\"../util/runtime\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\nconst KEYWORD_REGEX =\n\t/^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX =\n\t/^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\nconst isNameValid = name => {\n\treturn !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\nconst accessWithInit = (accessor, existingLength, initLast = false) => {\n\t// This generates for [a, b, c, d]:\n\t// (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n\tconst base = accessor[0];\n\tif (accessor.length === 1 && !initLast) return base;\n\tlet current =\n\t\texistingLength > 0\n\t\t\t? base\n\t\t\t: `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`;\n\n\t// i is the current position in accessor that has been printed\n\tlet i = 1;\n\n\t// all properties printed so far (excluding base)\n\tlet propsSoFar;\n\n\t// if there is existingLength, print all properties until this position as property access\n\tif (existingLength > i) {\n\t\tpropsSoFar = accessor.slice(1, existingLength);\n\t\ti = existingLength;\n\t\tcurrent += propertyAccess(propsSoFar);\n\t} else {\n\t\tpropsSoFar = [];\n\t}\n\n\t// all remaining properties (except the last one when initLast is not set)\n\t// should be printed as initializer\n\tconst initUntil = initLast ? accessor.length : accessor.length - 1;\n\tfor (; i < initUntil; i++) {\n\t\tconst prop = accessor[i];\n\t\tpropsSoFar.push(prop);\n\t\tcurrent = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(\n\t\t\tpropsSoFar\n\t\t)} || {})`;\n\t}\n\n\t// print the last property as property access if not yet printed\n\tif (i < accessor.length)\n\t\tcurrent = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n\n\treturn current;\n};\n\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n\t/**\n\t * @param {AssignLibraryPluginOptions} options the plugin options\n\t */\n\tconstructor(options) {\n\t\tsuper({\n\t\t\tpluginName: \"AssignLibraryPlugin\",\n\t\t\ttype: options.type\n\t\t});\n\t\tthis.prefix = options.prefix;\n\t\tthis.declare = options.declare;\n\t\tthis.unnamed = options.unnamed;\n\t\tthis.named = options.named || \"assign\";\n\t}\n\n\t/**\n\t * @param {LibraryOptions} library normalized library option\n\t * @returns {T | false} preprocess as needed by overriding\n\t */\n\tparseOptions(library) {\n\t\tconst { name } = library;\n\t\tif (this.unnamed === \"error\") {\n\t\t\tif (typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name && typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: /** @type {string|string[]=} */ (name),\n\t\t\texport: library.export\n\t\t};\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {string} entryName the name of the entrypoint\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tfinishEntryModule(\n\t\tmodule,\n\t\tentryName,\n\t\t{ options, compilation, compilation: { moduleGraph } }\n\t) {\n\t\tconst runtime = getEntryRuntime(compilation, entryName);\n\t\tif (options.export) {\n\t\t\tconst exportsInfo = moduleGraph.getExportInfo(\n\t\t\t\tmodule,\n\t\t\t\tArray.isArray(options.export) ? options.export[0] : options.export\n\t\t\t);\n\t\t\texportsInfo.setUsed(UsageState.Used, runtime);\n\t\t\texportsInfo.canMangleUse = false;\n\t\t} else {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\texportsInfo.setUsedInUnknownWay(runtime);\n\t\t}\n\t\tmoduleGraph.addExtraReason(module, \"used as library export\");\n\t}\n\n\t_getPrefix(compilation) {\n\t\treturn this.prefix === \"global\"\n\t\t\t? [compilation.runtimeTemplate.globalObject]\n\t\t\t: this.prefix;\n\t}\n\n\t_getResolvedFullName(options, chunk, compilation) {\n\t\tconst prefix = this._getPrefix(compilation);\n\t\tconst fullName = options.name ? prefix.concat(options.name) : prefix;\n\t\treturn fullName.map(n =>\n\t\t\tcompilation.getPath(n, {\n\t\t\t\tchunk\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trender(source, { chunk }, { options, compilation }) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (this.declare) {\n\t\t\tconst base = fullNameResolved[0];\n\t\t\tif (!isNameValid(base)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(\n\t\t\t\t\t\tbase\n\t\t\t\t\t)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${\n\t\t\t\t\t\tAbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tsource = new ConcatSource(`${this.declare} ${base};\\n`, source);\n\t\t}\n\t\treturn source;\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tembedInRuntimeBailout(\n\t\tmodule,\n\t\t{ chunk, codeGenerationResults },\n\t\t{ options, compilation }\n\t) {\n\t\tconst { data } = codeGenerationResults.get(module, chunk.runtime);\n\t\tconst topLevelDeclarations =\n\t\t\t(data && data.get(\"topLevelDeclarations\")) ||\n\t\t\t(module.buildInfo && module.buildInfo.topLevelDeclarations);\n\t\tif (!topLevelDeclarations)\n\t\t\treturn \"it doesn't tell about top level declarations.\";\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst base = fullNameResolved[0];\n\t\tif (topLevelDeclarations.has(base))\n\t\t\treturn `it declares '${base}' on top-level, which conflicts with the current library output.`;\n\t}\n\n\t/**\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tstrictRuntimeBailout({ chunk }, { options, compilation }) {\n\t\tif (\n\t\t\tthis.declare ||\n\t\t\tthis.prefix === \"global\" ||\n\t\t\tthis.prefix.length > 0 ||\n\t\t\t!options.name\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\treturn \"a global variable is assign and maybe created\";\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {Module} module module\n\t * @param {StartupRenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trenderStartup(\n\t\tsource,\n\t\tmodule,\n\t\t{ moduleGraph, chunk },\n\t\t{ options, compilation }\n\t) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst staticExports = this.unnamed === \"static\";\n\t\tconst exportAccess = options.export\n\t\t\t? propertyAccess(\n\t\t\t\t\tArray.isArray(options.export) ? options.export : [options.export]\n\t\t\t  )\n\t\t\t: \"\";\n\t\tconst result = new ConcatSource(source);\n\t\tif (staticExports) {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\tconst exportTarget = accessWithInit(\n\t\t\t\tfullNameResolved,\n\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\t\tif (!exportInfo.provided) continue;\n\t\t\t\tconst nameAccess = propertyAccess([exportInfo.name]);\n\t\t\t\tresult.add(\n\t\t\t\t\t`${exportTarget}${nameAccess} = __webpack_exports__${exportAccess}${nameAccess};\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\tresult.add(\n\t\t\t\t`var __webpack_export_target__ = ${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\ttrue\n\t\t\t\t)};\\n`\n\t\t\t);\n\t\t\tlet exports = \"__webpack_exports__\";\n\t\t\tif (exportAccess) {\n\t\t\t\tresult.add(\n\t\t\t\t\t`var __webpack_exports_export__ = __webpack_exports__${exportAccess};\\n`\n\t\t\t\t);\n\t\t\t\texports = \"__webpack_exports_export__\";\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`\n\t\t\t);\n\t\t\tresult.add(\n\t\t\t\t`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else {\n\t\t\tresult.add(\n\t\t\t\t`${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\tfalse\n\t\t\t\t)} = __webpack_exports__${exportAccess};\\n`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} set runtime requirements\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\truntimeRequirements(chunk, set, libraryContext) {\n\t\t// we don't need to return exports from runtime\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Hash} hash hash\n\t * @param {ChunkHashContext} chunkHashContext chunk hash context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tchunkHash(chunk, hash, chunkHashContext, { options, compilation }) {\n\t\thash.update(\"AssignLibraryPlugin\");\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\thash.update(\"copy\");\n\t\t}\n\t\tif (this.declare) {\n\t\t\thash.update(this.declare);\n\t\t}\n\t\thash.update(fullNameResolved.join(\".\"));\n\t\tif (options.export) {\n\t\t\thash.update(`${options.export}`);\n\t\t}\n\t}\n}\n\nmodule.exports = AssignLibraryPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}