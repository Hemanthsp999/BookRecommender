{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nconst AMDRequireDependenciesBlock = require(\"./AMDRequireDependenciesBlock\");\nconst AMDRequireDependency = require(\"./AMDRequireDependency\");\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst {\n  getLocalModule\n} = require(\"./LocalModulesHelpers\");\nconst UnsupportedDependency = require(\"./UnsupportedDependency\");\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\nclass AMDRequireDependenciesBlockParserPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n  processFunctionArgument(parser, expression) {\n    let bindThis = true;\n    const fnData = getFunctionExpression(expression);\n    if (fnData) {\n      parser.inScope(fnData.fn.params.filter(i => {\n        return ![\"require\", \"module\", \"exports\"].includes(i.name);\n      }), () => {\n        if (fnData.fn.body.type === \"BlockStatement\") {\n          parser.walkStatement(fnData.fn.body);\n        } else {\n          parser.walkExpression(fnData.fn.body);\n        }\n      });\n      parser.walkExpressions(fnData.expressions);\n      if (fnData.needThis === false) {\n        bindThis = false;\n      }\n    } else {\n      parser.walkExpression(expression);\n    }\n    return bindThis;\n  }\n\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n  apply(parser) {\n    parser.hooks.call.for(\"require\").tap(\"AMDRequireDependenciesBlockParserPlugin\", this.processCallRequire.bind(this, parser));\n  }\n  processArray(parser, expr, param) {\n    if (param.isArray()) {\n      for (const p of param.items) {\n        const result = this.processItem(parser, expr, p);\n        if (result === undefined) {\n          this.processContext(parser, expr, p);\n        }\n      }\n      return true;\n    } else if (param.isConstArray()) {\n      const deps = [];\n      for (const request of param.array) {\n        let dep, localModule;\n        if (request === \"require\") {\n          dep = RuntimeGlobals.require;\n        } else if ([\"exports\", \"module\"].includes(request)) {\n          dep = request;\n        } else if (localModule = getLocalModule(parser.state, request)) {\n          localModule.flagUsed();\n          dep = new LocalModuleDependency(localModule, undefined, false);\n          dep.loc = expr.loc;\n          parser.state.module.addPresentationalDependency(dep);\n        } else {\n          dep = this.newRequireItemDependency(request);\n          dep.loc = expr.loc;\n          dep.optional = !!parser.scope.inTry;\n          parser.state.current.addDependency(dep);\n        }\n        deps.push(dep);\n      }\n      const dep = this.newRequireArrayDependency(deps, param.range);\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }\n  }\n  processItem(parser, expr, param) {\n    if (param.isConditional()) {\n      for (const p of param.options) {\n        const result = this.processItem(parser, expr, p);\n        if (result === undefined) {\n          this.processContext(parser, expr, p);\n        }\n      }\n      return true;\n    } else if (param.isString()) {\n      let dep, localModule;\n      if (param.string === \"require\") {\n        dep = new ConstDependency(RuntimeGlobals.require, param.string, [RuntimeGlobals.require]);\n      } else if (param.string === \"module\") {\n        dep = new ConstDependency(parser.state.module.buildInfo.moduleArgument, param.range, [RuntimeGlobals.module]);\n      } else if (param.string === \"exports\") {\n        dep = new ConstDependency(parser.state.module.buildInfo.exportsArgument, param.range, [RuntimeGlobals.exports]);\n      } else if (localModule = getLocalModule(parser.state, param.string)) {\n        localModule.flagUsed();\n        dep = new LocalModuleDependency(localModule, param.range, false);\n      } else {\n        dep = this.newRequireItemDependency(param.string, param.range);\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n      dep.loc = expr.loc;\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }\n  }\n  processContext(parser, expr, param) {\n    const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {\n      category: \"amd\"\n    }, parser);\n    if (!dep) return;\n    dep.loc = expr.loc;\n    dep.optional = !!parser.scope.inTry;\n    parser.state.current.addDependency(dep);\n    return true;\n  }\n  processArrayForRequestString(param) {\n    if (param.isArray()) {\n      const result = param.items.map(item => this.processItemForRequestString(item));\n      if (result.every(Boolean)) return result.join(\" \");\n    } else if (param.isConstArray()) {\n      return param.array.join(\" \");\n    }\n  }\n  processItemForRequestString(param) {\n    if (param.isConditional()) {\n      const result = param.options.map(item => this.processItemForRequestString(item));\n      if (result.every(Boolean)) return result.join(\"|\");\n    } else if (param.isString()) {\n      return param.string;\n    }\n  }\n  processCallRequire(parser, expr) {\n    let param;\n    let depBlock;\n    let dep;\n    let result;\n    const old = parser.state.current;\n    if (expr.arguments.length >= 1) {\n      param = parser.evaluateExpression(expr.arguments[0]);\n      depBlock = this.newRequireDependenciesBlock(expr.loc, this.processArrayForRequestString(param));\n      dep = this.newRequireDependency(expr.range, param.range, expr.arguments.length > 1 ? expr.arguments[1].range : null, expr.arguments.length > 2 ? expr.arguments[2].range : null);\n      dep.loc = expr.loc;\n      depBlock.addDependency(dep);\n      parser.state.current = depBlock;\n    }\n    if (expr.arguments.length === 1) {\n      parser.inScope([], () => {\n        result = this.processArray(parser, expr, param);\n      });\n      parser.state.current = old;\n      if (!result) return;\n      parser.state.current.addBlock(depBlock);\n      return true;\n    }\n    if (expr.arguments.length === 2 || expr.arguments.length === 3) {\n      try {\n        parser.inScope([], () => {\n          result = this.processArray(parser, expr, param);\n        });\n        if (!result) {\n          const dep = new UnsupportedDependency(\"unsupported\", expr.range);\n          old.addPresentationalDependency(dep);\n          if (parser.state.module) {\n            parser.state.module.addError(new UnsupportedFeatureWarning(\"Cannot statically analyse 'require(…, …)' in line \" + expr.loc.start.line, expr.loc));\n          }\n          depBlock = null;\n          return true;\n        }\n        dep.functionBindThis = this.processFunctionArgument(parser, expr.arguments[1]);\n        if (expr.arguments.length === 3) {\n          dep.errorCallbackBindThis = this.processFunctionArgument(parser, expr.arguments[2]);\n        }\n      } finally {\n        parser.state.current = old;\n        if (depBlock) parser.state.current.addBlock(depBlock);\n      }\n      return true;\n    }\n  }\n  newRequireDependenciesBlock(loc, request) {\n    return new AMDRequireDependenciesBlock(loc, request);\n  }\n  newRequireDependency(outerRange, arrayRange, functionRange, errorCallbackRange) {\n    return new AMDRequireDependency(outerRange, arrayRange, functionRange, errorCallbackRange);\n  }\n  newRequireItemDependency(request, range) {\n    return new AMDRequireItemDependency(request, range);\n  }\n  newRequireArrayDependency(depsArray, range) {\n    return new AMDRequireArrayDependency(depsArray, range);\n  }\n}\nmodule.exports = AMDRequireDependenciesBlockParserPlugin;","map":{"version":3,"names":["RuntimeGlobals","require","UnsupportedFeatureWarning","AMDRequireArrayDependency","AMDRequireContextDependency","AMDRequireDependenciesBlock","AMDRequireDependency","AMDRequireItemDependency","ConstDependency","ContextDependencyHelpers","LocalModuleDependency","getLocalModule","UnsupportedDependency","getFunctionExpression","AMDRequireDependenciesBlockParserPlugin","constructor","options","processFunctionArgument","parser","expression","bindThis","fnData","inScope","fn","params","filter","i","includes","name","body","type","walkStatement","walkExpression","walkExpressions","expressions","needThis","apply","hooks","call","for","tap","processCallRequire","bind","processArray","expr","param","isArray","p","items","result","processItem","undefined","processContext","isConstArray","deps","request","array","dep","localModule","state","flagUsed","loc","module","addPresentationalDependency","newRequireItemDependency","optional","scope","inTry","current","addDependency","push","newRequireArrayDependency","range","isConditional","isString","string","buildInfo","moduleArgument","exportsArgument","exports","create","category","processArrayForRequestString","map","item","processItemForRequestString","every","Boolean","join","depBlock","old","arguments","length","evaluateExpression","newRequireDependenciesBlock","newRequireDependency","addBlock","addError","start","line","functionBindThis","errorCallbackBindThis","outerRange","arrayRange","functionRange","errorCallbackRange","depsArray"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/dependencies/AMDRequireDependenciesBlockParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nconst AMDRequireDependenciesBlock = require(\"./AMDRequireDependenciesBlock\");\nconst AMDRequireDependency = require(\"./AMDRequireDependency\");\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst { getLocalModule } = require(\"./LocalModulesHelpers\");\nconst UnsupportedDependency = require(\"./UnsupportedDependency\");\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\nclass AMDRequireDependenciesBlockParserPlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\tprocessFunctionArgument(parser, expression) {\n\t\tlet bindThis = true;\n\t\tconst fnData = getFunctionExpression(expression);\n\t\tif (fnData) {\n\t\t\tparser.inScope(\n\t\t\t\tfnData.fn.params.filter(i => {\n\t\t\t\t\treturn ![\"require\", \"module\", \"exports\"].includes(i.name);\n\t\t\t\t}),\n\t\t\t\t() => {\n\t\t\t\t\tif (fnData.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\tparser.walkStatement(fnData.fn.body);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparser.walkExpression(fnData.fn.body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tparser.walkExpressions(fnData.expressions);\n\t\t\tif (fnData.needThis === false) {\n\t\t\t\tbindThis = false;\n\t\t\t}\n\t\t} else {\n\t\t\tparser.walkExpression(expression);\n\t\t}\n\t\treturn bindThis;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"require\")\n\t\t\t.tap(\n\t\t\t\t\"AMDRequireDependenciesBlockParserPlugin\",\n\t\t\t\tthis.processCallRequire.bind(this, parser)\n\t\t\t);\n\t}\n\n\tprocessArray(parser, expr, param) {\n\t\tif (param.isArray()) {\n\t\t\tfor (const p of param.items) {\n\t\t\t\tconst result = this.processItem(parser, expr, p);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, p);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (param.isConstArray()) {\n\t\t\tconst deps = [];\n\t\t\tfor (const request of param.array) {\n\t\t\t\tlet dep, localModule;\n\t\t\t\tif (request === \"require\") {\n\t\t\t\t\tdep = RuntimeGlobals.require;\n\t\t\t\t} else if ([\"exports\", \"module\"].includes(request)) {\n\t\t\t\t\tdep = request;\n\t\t\t\t} else if ((localModule = getLocalModule(parser.state, request))) {\n\t\t\t\t\tlocalModule.flagUsed();\n\t\t\t\t\tdep = new LocalModuleDependency(localModule, undefined, false);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t} else {\n\t\t\t\t\tdep = this.newRequireItemDependency(request);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t}\n\t\t\t\tdeps.push(dep);\n\t\t\t}\n\t\t\tconst dep = this.newRequireArrayDependency(deps, param.range);\n\t\t\tdep.loc = expr.loc;\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessItem(parser, expr, param) {\n\t\tif (param.isConditional()) {\n\t\t\tfor (const p of param.options) {\n\t\t\t\tconst result = this.processItem(parser, expr, p);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, p);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (param.isString()) {\n\t\t\tlet dep, localModule;\n\t\t\tif (param.string === \"require\") {\n\t\t\t\tdep = new ConstDependency(RuntimeGlobals.require, param.string, [\n\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t]);\n\t\t\t} else if (param.string === \"module\") {\n\t\t\t\tdep = new ConstDependency(\n\t\t\t\t\tparser.state.module.buildInfo.moduleArgument,\n\t\t\t\t\tparam.range,\n\t\t\t\t\t[RuntimeGlobals.module]\n\t\t\t\t);\n\t\t\t} else if (param.string === \"exports\") {\n\t\t\t\tdep = new ConstDependency(\n\t\t\t\t\tparser.state.module.buildInfo.exportsArgument,\n\t\t\t\t\tparam.range,\n\t\t\t\t\t[RuntimeGlobals.exports]\n\t\t\t\t);\n\t\t\t} else if ((localModule = getLocalModule(parser.state, param.string))) {\n\t\t\t\tlocalModule.flagUsed();\n\t\t\t\tdep = new LocalModuleDependency(localModule, param.range, false);\n\t\t\t} else {\n\t\t\t\tdep = this.newRequireItemDependency(param.string, param.range);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessContext(parser, expr, param) {\n\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\tAMDRequireContextDependency,\n\t\t\tparam.range,\n\t\t\tparam,\n\t\t\texpr,\n\t\t\tthis.options,\n\t\t\t{\n\t\t\t\tcategory: \"amd\"\n\t\t\t},\n\t\t\tparser\n\t\t);\n\t\tif (!dep) return;\n\t\tdep.loc = expr.loc;\n\t\tdep.optional = !!parser.scope.inTry;\n\t\tparser.state.current.addDependency(dep);\n\t\treturn true;\n\t}\n\n\tprocessArrayForRequestString(param) {\n\t\tif (param.isArray()) {\n\t\t\tconst result = param.items.map(item =>\n\t\t\t\tthis.processItemForRequestString(item)\n\t\t\t);\n\t\t\tif (result.every(Boolean)) return result.join(\" \");\n\t\t} else if (param.isConstArray()) {\n\t\t\treturn param.array.join(\" \");\n\t\t}\n\t}\n\n\tprocessItemForRequestString(param) {\n\t\tif (param.isConditional()) {\n\t\t\tconst result = param.options.map(item =>\n\t\t\t\tthis.processItemForRequestString(item)\n\t\t\t);\n\t\t\tif (result.every(Boolean)) return result.join(\"|\");\n\t\t} else if (param.isString()) {\n\t\t\treturn param.string;\n\t\t}\n\t}\n\n\tprocessCallRequire(parser, expr) {\n\t\tlet param;\n\t\tlet depBlock;\n\t\tlet dep;\n\t\tlet result;\n\n\t\tconst old = parser.state.current;\n\n\t\tif (expr.arguments.length >= 1) {\n\t\t\tparam = parser.evaluateExpression(expr.arguments[0]);\n\t\t\tdepBlock = this.newRequireDependenciesBlock(\n\t\t\t\texpr.loc,\n\t\t\t\tthis.processArrayForRequestString(param)\n\t\t\t);\n\t\t\tdep = this.newRequireDependency(\n\t\t\t\texpr.range,\n\t\t\t\tparam.range,\n\t\t\t\texpr.arguments.length > 1 ? expr.arguments[1].range : null,\n\t\t\t\texpr.arguments.length > 2 ? expr.arguments[2].range : null\n\t\t\t);\n\t\t\tdep.loc = expr.loc;\n\t\t\tdepBlock.addDependency(dep);\n\n\t\t\tparser.state.current = depBlock;\n\t\t}\n\n\t\tif (expr.arguments.length === 1) {\n\t\t\tparser.inScope([], () => {\n\t\t\t\tresult = this.processArray(parser, expr, param);\n\t\t\t});\n\t\t\tparser.state.current = old;\n\t\t\tif (!result) return;\n\t\t\tparser.state.current.addBlock(depBlock);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (expr.arguments.length === 2 || expr.arguments.length === 3) {\n\t\t\ttry {\n\t\t\t\tparser.inScope([], () => {\n\t\t\t\t\tresult = this.processArray(parser, expr, param);\n\t\t\t\t});\n\t\t\t\tif (!result) {\n\t\t\t\t\tconst dep = new UnsupportedDependency(\"unsupported\", expr.range);\n\t\t\t\t\told.addPresentationalDependency(dep);\n\t\t\t\t\tif (parser.state.module) {\n\t\t\t\t\t\tparser.state.module.addError(\n\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\"Cannot statically analyse 'require(…, …)' in line \" +\n\t\t\t\t\t\t\t\t\texpr.loc.start.line,\n\t\t\t\t\t\t\t\texpr.loc\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tdepBlock = null;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tdep.functionBindThis = this.processFunctionArgument(\n\t\t\t\t\tparser,\n\t\t\t\t\texpr.arguments[1]\n\t\t\t\t);\n\t\t\t\tif (expr.arguments.length === 3) {\n\t\t\t\t\tdep.errorCallbackBindThis = this.processFunctionArgument(\n\t\t\t\t\t\tparser,\n\t\t\t\t\t\texpr.arguments[2]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tparser.state.current = old;\n\t\t\t\tif (depBlock) parser.state.current.addBlock(depBlock);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tnewRequireDependenciesBlock(loc, request) {\n\t\treturn new AMDRequireDependenciesBlock(loc, request);\n\t}\n\tnewRequireDependency(\n\t\touterRange,\n\t\tarrayRange,\n\t\tfunctionRange,\n\t\terrorCallbackRange\n\t) {\n\t\treturn new AMDRequireDependency(\n\t\t\touterRange,\n\t\t\tarrayRange,\n\t\t\tfunctionRange,\n\t\t\terrorCallbackRange\n\t\t);\n\t}\n\tnewRequireItemDependency(request, range) {\n\t\treturn new AMDRequireItemDependency(request, range);\n\t}\n\tnewRequireArrayDependency(depsArray, range) {\n\t\treturn new AMDRequireArrayDependency(depsArray, range);\n\t}\n}\nmodule.exports = AMDRequireDependenciesBlockParserPlugin;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,cAAc,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AACnD,MAAMC,yBAAyB,GAAGD,OAAO,CAAC,8BAA8B,CAAC;AACzE,MAAME,yBAAyB,GAAGF,OAAO,CAAC,6BAA6B,CAAC;AACxE,MAAMG,2BAA2B,GAAGH,OAAO,CAAC,+BAA+B,CAAC;AAC5E,MAAMI,2BAA2B,GAAGJ,OAAO,CAAC,+BAA+B,CAAC;AAC5E,MAAMK,oBAAoB,GAAGL,OAAO,CAAC,wBAAwB,CAAC;AAC9D,MAAMM,wBAAwB,GAAGN,OAAO,CAAC,4BAA4B,CAAC;AACtE,MAAMO,eAAe,GAAGP,OAAO,CAAC,mBAAmB,CAAC;AACpD,MAAMQ,wBAAwB,GAAGR,OAAO,CAAC,4BAA4B,CAAC;AACtE,MAAMS,qBAAqB,GAAGT,OAAO,CAAC,yBAAyB,CAAC;AAChE,MAAM;EAAEU;AAAe,CAAC,GAAGV,OAAO,CAAC,uBAAuB,CAAC;AAC3D,MAAMW,qBAAqB,GAAGX,OAAO,CAAC,yBAAyB,CAAC;AAChE,MAAMY,qBAAqB,GAAGZ,OAAO,CAAC,yBAAyB,CAAC;;AAEhE;;AAEA,MAAMa,uCAAuC,CAAC;EAC7CC,WAAWA,CAACC,OAAO,EAAE;IACpB,IAAI,CAACA,OAAO,GAAGA,OAAO;EACvB;EAEAC,uBAAuBA,CAACC,MAAM,EAAEC,UAAU,EAAE;IAC3C,IAAIC,QAAQ,GAAG,IAAI;IACnB,MAAMC,MAAM,GAAGR,qBAAqB,CAACM,UAAU,CAAC;IAChD,IAAIE,MAAM,EAAE;MACXH,MAAM,CAACI,OAAO,CACbD,MAAM,CAACE,EAAE,CAACC,MAAM,CAACC,MAAM,CAACC,CAAC,IAAI;QAC5B,OAAO,CAAC,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAACC,QAAQ,CAACD,CAAC,CAACE,IAAI,CAAC;MAC1D,CAAC,CAAC,EACF,MAAM;QACL,IAAIP,MAAM,CAACE,EAAE,CAACM,IAAI,CAACC,IAAI,KAAK,gBAAgB,EAAE;UAC7CZ,MAAM,CAACa,aAAa,CAACV,MAAM,CAACE,EAAE,CAACM,IAAI,CAAC;QACrC,CAAC,MAAM;UACNX,MAAM,CAACc,cAAc,CAACX,MAAM,CAACE,EAAE,CAACM,IAAI,CAAC;QACtC;MACD,CACD,CAAC;MACDX,MAAM,CAACe,eAAe,CAACZ,MAAM,CAACa,WAAW,CAAC;MAC1C,IAAIb,MAAM,CAACc,QAAQ,KAAK,KAAK,EAAE;QAC9Bf,QAAQ,GAAG,KAAK;MACjB;IACD,CAAC,MAAM;MACNF,MAAM,CAACc,cAAc,CAACb,UAAU,CAAC;IAClC;IACA,OAAOC,QAAQ;EAChB;;EAEA;AACD;AACA;AACA;EACCgB,KAAKA,CAAClB,MAAM,EAAE;IACbA,MAAM,CAACmB,KAAK,CAACC,IAAI,CACfC,GAAG,CAAC,SAAS,CAAC,CACdC,GAAG,CACH,yCAAyC,EACzC,IAAI,CAACC,kBAAkB,CAACC,IAAI,CAAC,IAAI,EAAExB,MAAM,CAC1C,CAAC;EACH;EAEAyB,YAAYA,CAACzB,MAAM,EAAE0B,IAAI,EAAEC,KAAK,EAAE;IACjC,IAAIA,KAAK,CAACC,OAAO,CAAC,CAAC,EAAE;MACpB,KAAK,MAAMC,CAAC,IAAIF,KAAK,CAACG,KAAK,EAAE;QAC5B,MAAMC,MAAM,GAAG,IAAI,CAACC,WAAW,CAAChC,MAAM,EAAE0B,IAAI,EAAEG,CAAC,CAAC;QAChD,IAAIE,MAAM,KAAKE,SAAS,EAAE;UACzB,IAAI,CAACC,cAAc,CAAClC,MAAM,EAAE0B,IAAI,EAAEG,CAAC,CAAC;QACrC;MACD;MACA,OAAO,IAAI;IACZ,CAAC,MAAM,IAAIF,KAAK,CAACQ,YAAY,CAAC,CAAC,EAAE;MAChC,MAAMC,IAAI,GAAG,EAAE;MACf,KAAK,MAAMC,OAAO,IAAIV,KAAK,CAACW,KAAK,EAAE;QAClC,IAAIC,GAAG,EAAEC,WAAW;QACpB,IAAIH,OAAO,KAAK,SAAS,EAAE;UAC1BE,GAAG,GAAGzD,cAAc,CAACC,OAAO;QAC7B,CAAC,MAAM,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC0B,QAAQ,CAAC4B,OAAO,CAAC,EAAE;UACnDE,GAAG,GAAGF,OAAO;QACd,CAAC,MAAM,IAAKG,WAAW,GAAG/C,cAAc,CAACO,MAAM,CAACyC,KAAK,EAAEJ,OAAO,CAAC,EAAG;UACjEG,WAAW,CAACE,QAAQ,CAAC,CAAC;UACtBH,GAAG,GAAG,IAAI/C,qBAAqB,CAACgD,WAAW,EAAEP,SAAS,EAAE,KAAK,CAAC;UAC9DM,GAAG,CAACI,GAAG,GAAGjB,IAAI,CAACiB,GAAG;UAClB3C,MAAM,CAACyC,KAAK,CAACG,MAAM,CAACC,2BAA2B,CAACN,GAAG,CAAC;QACrD,CAAC,MAAM;UACNA,GAAG,GAAG,IAAI,CAACO,wBAAwB,CAACT,OAAO,CAAC;UAC5CE,GAAG,CAACI,GAAG,GAAGjB,IAAI,CAACiB,GAAG;UAClBJ,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAC/C,MAAM,CAACgD,KAAK,CAACC,KAAK;UACnCjD,MAAM,CAACyC,KAAK,CAACS,OAAO,CAACC,aAAa,CAACZ,GAAG,CAAC;QACxC;QACAH,IAAI,CAACgB,IAAI,CAACb,GAAG,CAAC;MACf;MACA,MAAMA,GAAG,GAAG,IAAI,CAACc,yBAAyB,CAACjB,IAAI,EAAET,KAAK,CAAC2B,KAAK,CAAC;MAC7Df,GAAG,CAACI,GAAG,GAAGjB,IAAI,CAACiB,GAAG;MAClBJ,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAC/C,MAAM,CAACgD,KAAK,CAACC,KAAK;MACnCjD,MAAM,CAACyC,KAAK,CAACG,MAAM,CAACC,2BAA2B,CAACN,GAAG,CAAC;MACpD,OAAO,IAAI;IACZ;EACD;EACAP,WAAWA,CAAChC,MAAM,EAAE0B,IAAI,EAAEC,KAAK,EAAE;IAChC,IAAIA,KAAK,CAAC4B,aAAa,CAAC,CAAC,EAAE;MAC1B,KAAK,MAAM1B,CAAC,IAAIF,KAAK,CAAC7B,OAAO,EAAE;QAC9B,MAAMiC,MAAM,GAAG,IAAI,CAACC,WAAW,CAAChC,MAAM,EAAE0B,IAAI,EAAEG,CAAC,CAAC;QAChD,IAAIE,MAAM,KAAKE,SAAS,EAAE;UACzB,IAAI,CAACC,cAAc,CAAClC,MAAM,EAAE0B,IAAI,EAAEG,CAAC,CAAC;QACrC;MACD;MACA,OAAO,IAAI;IACZ,CAAC,MAAM,IAAIF,KAAK,CAAC6B,QAAQ,CAAC,CAAC,EAAE;MAC5B,IAAIjB,GAAG,EAAEC,WAAW;MACpB,IAAIb,KAAK,CAAC8B,MAAM,KAAK,SAAS,EAAE;QAC/BlB,GAAG,GAAG,IAAIjD,eAAe,CAACR,cAAc,CAACC,OAAO,EAAE4C,KAAK,CAAC8B,MAAM,EAAE,CAC/D3E,cAAc,CAACC,OAAO,CACtB,CAAC;MACH,CAAC,MAAM,IAAI4C,KAAK,CAAC8B,MAAM,KAAK,QAAQ,EAAE;QACrClB,GAAG,GAAG,IAAIjD,eAAe,CACxBU,MAAM,CAACyC,KAAK,CAACG,MAAM,CAACc,SAAS,CAACC,cAAc,EAC5ChC,KAAK,CAAC2B,KAAK,EACX,CAACxE,cAAc,CAAC8D,MAAM,CACvB,CAAC;MACF,CAAC,MAAM,IAAIjB,KAAK,CAAC8B,MAAM,KAAK,SAAS,EAAE;QACtClB,GAAG,GAAG,IAAIjD,eAAe,CACxBU,MAAM,CAACyC,KAAK,CAACG,MAAM,CAACc,SAAS,CAACE,eAAe,EAC7CjC,KAAK,CAAC2B,KAAK,EACX,CAACxE,cAAc,CAAC+E,OAAO,CACxB,CAAC;MACF,CAAC,MAAM,IAAKrB,WAAW,GAAG/C,cAAc,CAACO,MAAM,CAACyC,KAAK,EAAEd,KAAK,CAAC8B,MAAM,CAAC,EAAG;QACtEjB,WAAW,CAACE,QAAQ,CAAC,CAAC;QACtBH,GAAG,GAAG,IAAI/C,qBAAqB,CAACgD,WAAW,EAAEb,KAAK,CAAC2B,KAAK,EAAE,KAAK,CAAC;MACjE,CAAC,MAAM;QACNf,GAAG,GAAG,IAAI,CAACO,wBAAwB,CAACnB,KAAK,CAAC8B,MAAM,EAAE9B,KAAK,CAAC2B,KAAK,CAAC;QAC9Df,GAAG,CAACI,GAAG,GAAGjB,IAAI,CAACiB,GAAG;QAClBJ,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAC/C,MAAM,CAACgD,KAAK,CAACC,KAAK;QACnCjD,MAAM,CAACyC,KAAK,CAACS,OAAO,CAACC,aAAa,CAACZ,GAAG,CAAC;QACvC,OAAO,IAAI;MACZ;MACAA,GAAG,CAACI,GAAG,GAAGjB,IAAI,CAACiB,GAAG;MAClB3C,MAAM,CAACyC,KAAK,CAACG,MAAM,CAACC,2BAA2B,CAACN,GAAG,CAAC;MACpD,OAAO,IAAI;IACZ;EACD;EACAL,cAAcA,CAAClC,MAAM,EAAE0B,IAAI,EAAEC,KAAK,EAAE;IACnC,MAAMY,GAAG,GAAGhD,wBAAwB,CAACuE,MAAM,CAC1C5E,2BAA2B,EAC3ByC,KAAK,CAAC2B,KAAK,EACX3B,KAAK,EACLD,IAAI,EACJ,IAAI,CAAC5B,OAAO,EACZ;MACCiE,QAAQ,EAAE;IACX,CAAC,EACD/D,MACD,CAAC;IACD,IAAI,CAACuC,GAAG,EAAE;IACVA,GAAG,CAACI,GAAG,GAAGjB,IAAI,CAACiB,GAAG;IAClBJ,GAAG,CAACQ,QAAQ,GAAG,CAAC,CAAC/C,MAAM,CAACgD,KAAK,CAACC,KAAK;IACnCjD,MAAM,CAACyC,KAAK,CAACS,OAAO,CAACC,aAAa,CAACZ,GAAG,CAAC;IACvC,OAAO,IAAI;EACZ;EAEAyB,4BAA4BA,CAACrC,KAAK,EAAE;IACnC,IAAIA,KAAK,CAACC,OAAO,CAAC,CAAC,EAAE;MACpB,MAAMG,MAAM,GAAGJ,KAAK,CAACG,KAAK,CAACmC,GAAG,CAACC,IAAI,IAClC,IAAI,CAACC,2BAA2B,CAACD,IAAI,CACtC,CAAC;MACD,IAAInC,MAAM,CAACqC,KAAK,CAACC,OAAO,CAAC,EAAE,OAAOtC,MAAM,CAACuC,IAAI,CAAC,GAAG,CAAC;IACnD,CAAC,MAAM,IAAI3C,KAAK,CAACQ,YAAY,CAAC,CAAC,EAAE;MAChC,OAAOR,KAAK,CAACW,KAAK,CAACgC,IAAI,CAAC,GAAG,CAAC;IAC7B;EACD;EAEAH,2BAA2BA,CAACxC,KAAK,EAAE;IAClC,IAAIA,KAAK,CAAC4B,aAAa,CAAC,CAAC,EAAE;MAC1B,MAAMxB,MAAM,GAAGJ,KAAK,CAAC7B,OAAO,CAACmE,GAAG,CAACC,IAAI,IACpC,IAAI,CAACC,2BAA2B,CAACD,IAAI,CACtC,CAAC;MACD,IAAInC,MAAM,CAACqC,KAAK,CAACC,OAAO,CAAC,EAAE,OAAOtC,MAAM,CAACuC,IAAI,CAAC,GAAG,CAAC;IACnD,CAAC,MAAM,IAAI3C,KAAK,CAAC6B,QAAQ,CAAC,CAAC,EAAE;MAC5B,OAAO7B,KAAK,CAAC8B,MAAM;IACpB;EACD;EAEAlC,kBAAkBA,CAACvB,MAAM,EAAE0B,IAAI,EAAE;IAChC,IAAIC,KAAK;IACT,IAAI4C,QAAQ;IACZ,IAAIhC,GAAG;IACP,IAAIR,MAAM;IAEV,MAAMyC,GAAG,GAAGxE,MAAM,CAACyC,KAAK,CAACS,OAAO;IAEhC,IAAIxB,IAAI,CAAC+C,SAAS,CAACC,MAAM,IAAI,CAAC,EAAE;MAC/B/C,KAAK,GAAG3B,MAAM,CAAC2E,kBAAkB,CAACjD,IAAI,CAAC+C,SAAS,CAAC,CAAC,CAAC,CAAC;MACpDF,QAAQ,GAAG,IAAI,CAACK,2BAA2B,CAC1ClD,IAAI,CAACiB,GAAG,EACR,IAAI,CAACqB,4BAA4B,CAACrC,KAAK,CACxC,CAAC;MACDY,GAAG,GAAG,IAAI,CAACsC,oBAAoB,CAC9BnD,IAAI,CAAC4B,KAAK,EACV3B,KAAK,CAAC2B,KAAK,EACX5B,IAAI,CAAC+C,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGhD,IAAI,CAAC+C,SAAS,CAAC,CAAC,CAAC,CAACnB,KAAK,GAAG,IAAI,EAC1D5B,IAAI,CAAC+C,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGhD,IAAI,CAAC+C,SAAS,CAAC,CAAC,CAAC,CAACnB,KAAK,GAAG,IACvD,CAAC;MACDf,GAAG,CAACI,GAAG,GAAGjB,IAAI,CAACiB,GAAG;MAClB4B,QAAQ,CAACpB,aAAa,CAACZ,GAAG,CAAC;MAE3BvC,MAAM,CAACyC,KAAK,CAACS,OAAO,GAAGqB,QAAQ;IAChC;IAEA,IAAI7C,IAAI,CAAC+C,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAChC1E,MAAM,CAACI,OAAO,CAAC,EAAE,EAAE,MAAM;QACxB2B,MAAM,GAAG,IAAI,CAACN,YAAY,CAACzB,MAAM,EAAE0B,IAAI,EAAEC,KAAK,CAAC;MAChD,CAAC,CAAC;MACF3B,MAAM,CAACyC,KAAK,CAACS,OAAO,GAAGsB,GAAG;MAC1B,IAAI,CAACzC,MAAM,EAAE;MACb/B,MAAM,CAACyC,KAAK,CAACS,OAAO,CAAC4B,QAAQ,CAACP,QAAQ,CAAC;MACvC,OAAO,IAAI;IACZ;IAEA,IAAI7C,IAAI,CAAC+C,SAAS,CAACC,MAAM,KAAK,CAAC,IAAIhD,IAAI,CAAC+C,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MAC/D,IAAI;QACH1E,MAAM,CAACI,OAAO,CAAC,EAAE,EAAE,MAAM;UACxB2B,MAAM,GAAG,IAAI,CAACN,YAAY,CAACzB,MAAM,EAAE0B,IAAI,EAAEC,KAAK,CAAC;QAChD,CAAC,CAAC;QACF,IAAI,CAACI,MAAM,EAAE;UACZ,MAAMQ,GAAG,GAAG,IAAI7C,qBAAqB,CAAC,aAAa,EAAEgC,IAAI,CAAC4B,KAAK,CAAC;UAChEkB,GAAG,CAAC3B,2BAA2B,CAACN,GAAG,CAAC;UACpC,IAAIvC,MAAM,CAACyC,KAAK,CAACG,MAAM,EAAE;YACxB5C,MAAM,CAACyC,KAAK,CAACG,MAAM,CAACmC,QAAQ,CAC3B,IAAI/F,yBAAyB,CAC5B,oDAAoD,GACnD0C,IAAI,CAACiB,GAAG,CAACqC,KAAK,CAACC,IAAI,EACpBvD,IAAI,CAACiB,GACN,CACD,CAAC;UACF;UACA4B,QAAQ,GAAG,IAAI;UACf,OAAO,IAAI;QACZ;QACAhC,GAAG,CAAC2C,gBAAgB,GAAG,IAAI,CAACnF,uBAAuB,CAClDC,MAAM,EACN0B,IAAI,CAAC+C,SAAS,CAAC,CAAC,CACjB,CAAC;QACD,IAAI/C,IAAI,CAAC+C,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;UAChCnC,GAAG,CAAC4C,qBAAqB,GAAG,IAAI,CAACpF,uBAAuB,CACvDC,MAAM,EACN0B,IAAI,CAAC+C,SAAS,CAAC,CAAC,CACjB,CAAC;QACF;MACD,CAAC,SAAS;QACTzE,MAAM,CAACyC,KAAK,CAACS,OAAO,GAAGsB,GAAG;QAC1B,IAAID,QAAQ,EAAEvE,MAAM,CAACyC,KAAK,CAACS,OAAO,CAAC4B,QAAQ,CAACP,QAAQ,CAAC;MACtD;MACA,OAAO,IAAI;IACZ;EACD;EAEAK,2BAA2BA,CAACjC,GAAG,EAAEN,OAAO,EAAE;IACzC,OAAO,IAAIlD,2BAA2B,CAACwD,GAAG,EAAEN,OAAO,CAAC;EACrD;EACAwC,oBAAoBA,CACnBO,UAAU,EACVC,UAAU,EACVC,aAAa,EACbC,kBAAkB,EACjB;IACD,OAAO,IAAInG,oBAAoB,CAC9BgG,UAAU,EACVC,UAAU,EACVC,aAAa,EACbC,kBACD,CAAC;EACF;EACAzC,wBAAwBA,CAACT,OAAO,EAAEiB,KAAK,EAAE;IACxC,OAAO,IAAIjE,wBAAwB,CAACgD,OAAO,EAAEiB,KAAK,CAAC;EACpD;EACAD,yBAAyBA,CAACmC,SAAS,EAAElC,KAAK,EAAE;IAC3C,OAAO,IAAIrE,yBAAyB,CAACuG,SAAS,EAAElC,KAAK,CAAC;EACvD;AACD;AACAV,MAAM,CAACiB,OAAO,GAAGjE,uCAAuC"},"metadata":{},"sourceType":"script","externalDependencies":[]}