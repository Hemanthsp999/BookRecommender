{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst streamChunksOfSourceMap = require(\"./streamChunksOfSourceMap\");\nconst splitIntoLines = require(\"./splitIntoLines\");\nconst streamChunksOfCombinedSourceMap = (source, sourceMap, innerSourceName, innerSource, innerSourceMap, removeInnerSource, onChunk, onSource, onName, finalSource, columns) => {\n  let sourceMapping = new Map();\n  let nameMapping = new Map();\n  const sourceIndexMapping = [];\n  const nameIndexMapping = [];\n  const nameIndexValueMapping = [];\n  let innerSourceIndex = -2;\n  const innerSourceIndexMapping = [];\n  const innerSourceIndexValueMapping = [];\n  const innerSourceContents = [];\n  const innerSourceContentLines = [];\n  const innerNameIndexMapping = [];\n  const innerNameIndexValueMapping = [];\n  const innerSourceMapLineData = [];\n  const findInnerMapping = (line, column) => {\n    if (line > innerSourceMapLineData.length) return -1;\n    const {\n      mappingsData\n    } = innerSourceMapLineData[line - 1];\n    let l = 0;\n    let r = mappingsData.length / 5;\n    while (l < r) {\n      let m = l + r >> 1;\n      if (mappingsData[m * 5] <= column) {\n        l = m + 1;\n      } else {\n        r = m;\n      }\n    }\n    if (l === 0) return -1;\n    return l - 1;\n  };\n  return streamChunksOfSourceMap(source, sourceMap, (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n    // Check if this is a mapping to the inner source\n    if (sourceIndex === innerSourceIndex) {\n      // Check if there is a mapping in the inner source\n      const idx = findInnerMapping(originalLine, originalColumn);\n      if (idx !== -1) {\n        const {\n          chunks,\n          mappingsData\n        } = innerSourceMapLineData[originalLine - 1];\n        const mi = idx * 5;\n        const innerSourceIndex = mappingsData[mi + 1];\n        const innerOriginalLine = mappingsData[mi + 2];\n        let innerOriginalColumn = mappingsData[mi + 3];\n        let innerNameIndex = mappingsData[mi + 4];\n        if (innerSourceIndex >= 0) {\n          // Check for an identity mapping\n          // where we are allowed to adjust the original column\n          const innerChunk = chunks[idx];\n          const innerGeneratedColumn = mappingsData[mi];\n          const locationInChunk = originalColumn - innerGeneratedColumn;\n          if (locationInChunk > 0) {\n            let originalSourceLines = innerSourceIndex < innerSourceContentLines.length ? innerSourceContentLines[innerSourceIndex] : null;\n            if (originalSourceLines === undefined) {\n              const originalSource = innerSourceContents[innerSourceIndex];\n              originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;\n              innerSourceContentLines[innerSourceIndex] = originalSourceLines;\n            }\n            if (originalSourceLines !== null) {\n              const originalChunk = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(innerOriginalColumn, innerOriginalColumn + locationInChunk) : \"\";\n              if (innerChunk.slice(0, locationInChunk) === originalChunk) {\n                innerOriginalColumn += locationInChunk;\n                innerNameIndex = -1;\n              }\n            }\n          }\n\n          // We have a inner mapping to original source\n\n          // emit source when needed and compute global source index\n          let sourceIndex = innerSourceIndex < innerSourceIndexMapping.length ? innerSourceIndexMapping[innerSourceIndex] : -2;\n          if (sourceIndex === -2) {\n            const [source, sourceContent] = innerSourceIndex < innerSourceIndexValueMapping.length ? innerSourceIndexValueMapping[innerSourceIndex] : [null, undefined];\n            let globalIndex = sourceMapping.get(source);\n            if (globalIndex === undefined) {\n              sourceMapping.set(source, globalIndex = sourceMapping.size);\n              onSource(globalIndex, source, sourceContent);\n            }\n            sourceIndex = globalIndex;\n            innerSourceIndexMapping[innerSourceIndex] = sourceIndex;\n          }\n\n          // emit name when needed and compute global name index\n          let finalNameIndex = -1;\n          if (innerNameIndex >= 0) {\n            // when we have a inner name\n            finalNameIndex = innerNameIndex < innerNameIndexMapping.length ? innerNameIndexMapping[innerNameIndex] : -2;\n            if (finalNameIndex === -2) {\n              const name = innerNameIndex < innerNameIndexValueMapping.length ? innerNameIndexValueMapping[innerNameIndex] : undefined;\n              if (name) {\n                let globalIndex = nameMapping.get(name);\n                if (globalIndex === undefined) {\n                  nameMapping.set(name, globalIndex = nameMapping.size);\n                  onName(globalIndex, name);\n                }\n                finalNameIndex = globalIndex;\n              } else {\n                finalNameIndex = -1;\n              }\n              innerNameIndexMapping[innerNameIndex] = finalNameIndex;\n            }\n          } else if (nameIndex >= 0) {\n            // when we don't have an inner name,\n            // but we have an outer name\n            // it can be used when inner original code equals to the name\n            let originalSourceLines = innerSourceContentLines[innerSourceIndex];\n            if (originalSourceLines === undefined) {\n              const originalSource = innerSourceContents[innerSourceIndex];\n              originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;\n              innerSourceContentLines[innerSourceIndex] = originalSourceLines;\n            }\n            if (originalSourceLines !== null) {\n              const name = nameIndexValueMapping[nameIndex];\n              const originalName = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(innerOriginalColumn, innerOriginalColumn + name.length) : \"\";\n              if (name === originalName) {\n                finalNameIndex = nameIndex < nameIndexMapping.length ? nameIndexMapping[nameIndex] : -2;\n                if (finalNameIndex === -2) {\n                  const name = nameIndexValueMapping[nameIndex];\n                  if (name) {\n                    let globalIndex = nameMapping.get(name);\n                    if (globalIndex === undefined) {\n                      nameMapping.set(name, globalIndex = nameMapping.size);\n                      onName(globalIndex, name);\n                    }\n                    finalNameIndex = globalIndex;\n                  } else {\n                    finalNameIndex = -1;\n                  }\n                  nameIndexMapping[nameIndex] = finalNameIndex;\n                }\n              }\n            }\n          }\n          onChunk(chunk, generatedLine, generatedColumn, sourceIndex, innerOriginalLine, innerOriginalColumn, finalNameIndex);\n          return;\n        }\n      }\n\n      // We have a mapping to the inner source, but no inner mapping\n      if (removeInnerSource) {\n        onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n        return;\n      } else {\n        if (sourceIndexMapping[sourceIndex] === -2) {\n          let globalIndex = sourceMapping.get(innerSourceName);\n          if (globalIndex === undefined) {\n            sourceMapping.set(source, globalIndex = sourceMapping.size);\n            onSource(globalIndex, innerSourceName, innerSource);\n          }\n          sourceIndexMapping[sourceIndex] = globalIndex;\n        }\n      }\n    }\n    const finalSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];\n    if (finalSourceIndex < 0) {\n      // no source, so we make it a generated chunk\n      onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n    } else {\n      // Pass through the chunk with mapping\n      let finalNameIndex = -1;\n      if (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {\n        finalNameIndex = nameIndexMapping[nameIndex];\n        if (finalNameIndex === -2) {\n          const name = nameIndexValueMapping[nameIndex];\n          let globalIndex = nameMapping.get(name);\n          if (globalIndex === undefined) {\n            nameMapping.set(name, globalIndex = nameMapping.size);\n            onName(globalIndex, name);\n          }\n          finalNameIndex = globalIndex;\n          nameIndexMapping[nameIndex] = finalNameIndex;\n        }\n      }\n      onChunk(chunk, generatedLine, generatedColumn, finalSourceIndex, originalLine, originalColumn, finalNameIndex);\n    }\n  }, (i, source, sourceContent) => {\n    if (source === innerSourceName) {\n      innerSourceIndex = i;\n      if (innerSource !== undefined) sourceContent = innerSource;else innerSource = sourceContent;\n      sourceIndexMapping[i] = -2;\n      streamChunksOfSourceMap(sourceContent, innerSourceMap, (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n        while (innerSourceMapLineData.length < generatedLine) {\n          innerSourceMapLineData.push({\n            mappingsData: [],\n            chunks: []\n          });\n        }\n        const data = innerSourceMapLineData[generatedLine - 1];\n        data.mappingsData.push(generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n        data.chunks.push(chunk);\n      }, (i, source, sourceContent) => {\n        innerSourceContents[i] = sourceContent;\n        innerSourceContentLines[i] = undefined;\n        innerSourceIndexMapping[i] = -2;\n        innerSourceIndexValueMapping[i] = [source, sourceContent];\n      }, (i, name) => {\n        innerNameIndexMapping[i] = -2;\n        innerNameIndexValueMapping[i] = name;\n      }, false, columns);\n    } else {\n      let globalIndex = sourceMapping.get(source);\n      if (globalIndex === undefined) {\n        sourceMapping.set(source, globalIndex = sourceMapping.size);\n        onSource(globalIndex, source, sourceContent);\n      }\n      sourceIndexMapping[i] = globalIndex;\n    }\n  }, (i, name) => {\n    nameIndexMapping[i] = -2;\n    nameIndexValueMapping[i] = name;\n  }, finalSource, columns);\n};\nmodule.exports = streamChunksOfCombinedSourceMap;","map":{"version":3,"names":["streamChunksOfSourceMap","require","splitIntoLines","streamChunksOfCombinedSourceMap","source","sourceMap","innerSourceName","innerSource","innerSourceMap","removeInnerSource","onChunk","onSource","onName","finalSource","columns","sourceMapping","Map","nameMapping","sourceIndexMapping","nameIndexMapping","nameIndexValueMapping","innerSourceIndex","innerSourceIndexMapping","innerSourceIndexValueMapping","innerSourceContents","innerSourceContentLines","innerNameIndexMapping","innerNameIndexValueMapping","innerSourceMapLineData","findInnerMapping","line","column","length","mappingsData","l","r","m","chunk","generatedLine","generatedColumn","sourceIndex","originalLine","originalColumn","nameIndex","idx","chunks","mi","innerOriginalLine","innerOriginalColumn","innerNameIndex","innerChunk","innerGeneratedColumn","locationInChunk","originalSourceLines","undefined","originalSource","originalChunk","slice","sourceContent","globalIndex","get","set","size","finalNameIndex","name","originalName","finalSourceIndex","i","push","data","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst streamChunksOfSourceMap = require(\"./streamChunksOfSourceMap\");\nconst splitIntoLines = require(\"./splitIntoLines\");\n\nconst streamChunksOfCombinedSourceMap = (\n\tsource,\n\tsourceMap,\n\tinnerSourceName,\n\tinnerSource,\n\tinnerSourceMap,\n\tremoveInnerSource,\n\tonChunk,\n\tonSource,\n\tonName,\n\tfinalSource,\n\tcolumns\n) => {\n\tlet sourceMapping = new Map();\n\tlet nameMapping = new Map();\n\tconst sourceIndexMapping = [];\n\tconst nameIndexMapping = [];\n\tconst nameIndexValueMapping = [];\n\tlet innerSourceIndex = -2;\n\tconst innerSourceIndexMapping = [];\n\tconst innerSourceIndexValueMapping = [];\n\tconst innerSourceContents = [];\n\tconst innerSourceContentLines = [];\n\tconst innerNameIndexMapping = [];\n\tconst innerNameIndexValueMapping = [];\n\tconst innerSourceMapLineData = [];\n\tconst findInnerMapping = (line, column) => {\n\t\tif (line > innerSourceMapLineData.length) return -1;\n\t\tconst { mappingsData } = innerSourceMapLineData[line - 1];\n\t\tlet l = 0;\n\t\tlet r = mappingsData.length / 5;\n\t\twhile (l < r) {\n\t\t\tlet m = (l + r) >> 1;\n\t\t\tif (mappingsData[m * 5] <= column) {\n\t\t\t\tl = m + 1;\n\t\t\t} else {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tif (l === 0) return -1;\n\t\treturn l - 1;\n\t};\n\treturn streamChunksOfSourceMap(\n\t\tsource,\n\t\tsourceMap,\n\t\t(\n\t\t\tchunk,\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn,\n\t\t\tsourceIndex,\n\t\t\toriginalLine,\n\t\t\toriginalColumn,\n\t\t\tnameIndex\n\t\t) => {\n\t\t\t// Check if this is a mapping to the inner source\n\t\t\tif (sourceIndex === innerSourceIndex) {\n\t\t\t\t// Check if there is a mapping in the inner source\n\t\t\t\tconst idx = findInnerMapping(originalLine, originalColumn);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tconst { chunks, mappingsData } = innerSourceMapLineData[\n\t\t\t\t\t\toriginalLine - 1\n\t\t\t\t\t];\n\t\t\t\t\tconst mi = idx * 5;\n\t\t\t\t\tconst innerSourceIndex = mappingsData[mi + 1];\n\t\t\t\t\tconst innerOriginalLine = mappingsData[mi + 2];\n\t\t\t\t\tlet innerOriginalColumn = mappingsData[mi + 3];\n\t\t\t\t\tlet innerNameIndex = mappingsData[mi + 4];\n\t\t\t\t\tif (innerSourceIndex >= 0) {\n\t\t\t\t\t\t// Check for an identity mapping\n\t\t\t\t\t\t// where we are allowed to adjust the original column\n\t\t\t\t\t\tconst innerChunk = chunks[idx];\n\t\t\t\t\t\tconst innerGeneratedColumn = mappingsData[mi];\n\t\t\t\t\t\tconst locationInChunk = originalColumn - innerGeneratedColumn;\n\t\t\t\t\t\tif (locationInChunk > 0) {\n\t\t\t\t\t\t\tlet originalSourceLines =\n\t\t\t\t\t\t\t\tinnerSourceIndex < innerSourceContentLines.length\n\t\t\t\t\t\t\t\t\t? innerSourceContentLines[innerSourceIndex]\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (originalSourceLines === undefined) {\n\t\t\t\t\t\t\t\tconst originalSource = innerSourceContents[innerSourceIndex];\n\t\t\t\t\t\t\t\toriginalSourceLines = originalSource\n\t\t\t\t\t\t\t\t\t? splitIntoLines(originalSource)\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex] = originalSourceLines;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (originalSourceLines !== null) {\n\t\t\t\t\t\t\t\tconst originalChunk =\n\t\t\t\t\t\t\t\t\tinnerOriginalLine <= originalSourceLines.length\n\t\t\t\t\t\t\t\t\t\t? originalSourceLines[innerOriginalLine - 1].slice(\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn + locationInChunk\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t: \"\";\n\t\t\t\t\t\t\t\tif (innerChunk.slice(0, locationInChunk) === originalChunk) {\n\t\t\t\t\t\t\t\t\tinnerOriginalColumn += locationInChunk;\n\t\t\t\t\t\t\t\t\tinnerNameIndex = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We have a inner mapping to original source\n\n\t\t\t\t\t\t// emit source when needed and compute global source index\n\t\t\t\t\t\tlet sourceIndex =\n\t\t\t\t\t\t\tinnerSourceIndex < innerSourceIndexMapping.length\n\t\t\t\t\t\t\t\t? innerSourceIndexMapping[innerSourceIndex]\n\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\tif (sourceIndex === -2) {\n\t\t\t\t\t\t\tconst [source, sourceContent] =\n\t\t\t\t\t\t\t\tinnerSourceIndex < innerSourceIndexValueMapping.length\n\t\t\t\t\t\t\t\t\t? innerSourceIndexValueMapping[innerSourceIndex]\n\t\t\t\t\t\t\t\t\t: [null, undefined];\n\t\t\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsourceIndex = globalIndex;\n\t\t\t\t\t\t\tinnerSourceIndexMapping[innerSourceIndex] = sourceIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// emit name when needed and compute global name index\n\t\t\t\t\t\tlet finalNameIndex = -1;\n\t\t\t\t\t\tif (innerNameIndex >= 0) {\n\t\t\t\t\t\t\t// when we have a inner name\n\t\t\t\t\t\t\tfinalNameIndex =\n\t\t\t\t\t\t\t\tinnerNameIndex < innerNameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? innerNameIndexMapping[innerNameIndex]\n\t\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\t\t\tconst name =\n\t\t\t\t\t\t\t\t\tinnerNameIndex < innerNameIndexValueMapping.length\n\t\t\t\t\t\t\t\t\t\t? innerNameIndexValueMapping[innerNameIndex]\n\t\t\t\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfinalNameIndex = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinnerNameIndexMapping[innerNameIndex] = finalNameIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (nameIndex >= 0) {\n\t\t\t\t\t\t\t// when we don't have an inner name,\n\t\t\t\t\t\t\t// but we have an outer name\n\t\t\t\t\t\t\t// it can be used when inner original code equals to the name\n\t\t\t\t\t\t\tlet originalSourceLines =\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex];\n\t\t\t\t\t\t\tif (originalSourceLines === undefined) {\n\t\t\t\t\t\t\t\tconst originalSource = innerSourceContents[innerSourceIndex];\n\t\t\t\t\t\t\t\toriginalSourceLines = originalSource\n\t\t\t\t\t\t\t\t\t? splitIntoLines(originalSource)\n\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\t\tinnerSourceContentLines[innerSourceIndex] = originalSourceLines;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (originalSourceLines !== null) {\n\t\t\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\t\t\tconst originalName =\n\t\t\t\t\t\t\t\t\tinnerOriginalLine <= originalSourceLines.length\n\t\t\t\t\t\t\t\t\t\t? originalSourceLines[innerOriginalLine - 1].slice(\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\t\t\t\t\t\tinnerOriginalColumn + name.length\n\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t: \"\";\n\t\t\t\t\t\t\t\tif (name === originalName) {\n\t\t\t\t\t\t\t\t\tfinalNameIndex =\n\t\t\t\t\t\t\t\t\t\tnameIndex < nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t\t\t? nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t\t\t\t\t: -2;\n\t\t\t\t\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tfinalNameIndex = -1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tnameIndexMapping[nameIndex] = finalNameIndex;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tinnerOriginalLine,\n\t\t\t\t\t\t\tinnerOriginalColumn,\n\t\t\t\t\t\t\tfinalNameIndex\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We have a mapping to the inner source, but no inner mapping\n\t\t\t\tif (removeInnerSource) {\n\t\t\t\t\tonChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif (sourceIndexMapping[sourceIndex] === -2) {\n\t\t\t\t\t\tlet globalIndex = sourceMapping.get(innerSourceName);\n\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\t\tonSource(globalIndex, innerSourceName, innerSource);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsourceIndexMapping[sourceIndex] = globalIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst finalSourceIndex =\n\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t? -1\n\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\tif (finalSourceIndex < 0) {\n\t\t\t\t// no source, so we make it a generated chunk\n\t\t\t\tonChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t} else {\n\t\t\t\t// Pass through the chunk with mapping\n\t\t\t\tlet finalNameIndex = -1;\n\t\t\t\tif (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {\n\t\t\t\t\tfinalNameIndex = nameIndexMapping[nameIndex];\n\t\t\t\t\tif (finalNameIndex === -2) {\n\t\t\t\t\t\tconst name = nameIndexValueMapping[nameIndex];\n\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinalNameIndex = globalIndex;\n\t\t\t\t\t\tnameIndexMapping[nameIndex] = finalNameIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tfinalSourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tfinalNameIndex\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\t(i, source, sourceContent) => {\n\t\t\tif (source === innerSourceName) {\n\t\t\t\tinnerSourceIndex = i;\n\t\t\t\tif (innerSource !== undefined) sourceContent = innerSource;\n\t\t\t\telse innerSource = sourceContent;\n\t\t\t\tsourceIndexMapping[i] = -2;\n\t\t\t\tstreamChunksOfSourceMap(\n\t\t\t\t\tsourceContent,\n\t\t\t\t\tinnerSourceMap,\n\t\t\t\t\t(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tgeneratedLine,\n\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex\n\t\t\t\t\t) => {\n\t\t\t\t\t\twhile (innerSourceMapLineData.length < generatedLine) {\n\t\t\t\t\t\t\tinnerSourceMapLineData.push({\n\t\t\t\t\t\t\t\tmappingsData: [],\n\t\t\t\t\t\t\t\tchunks: []\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst data = innerSourceMapLineData[generatedLine - 1];\n\t\t\t\t\t\tdata.mappingsData.push(\n\t\t\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tnameIndex\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.chunks.push(chunk);\n\t\t\t\t\t},\n\t\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\t\tinnerSourceContents[i] = sourceContent;\n\t\t\t\t\t\tinnerSourceContentLines[i] = undefined;\n\t\t\t\t\t\tinnerSourceIndexMapping[i] = -2;\n\t\t\t\t\t\tinnerSourceIndexValueMapping[i] = [source, sourceContent];\n\t\t\t\t\t},\n\t\t\t\t\t(i, name) => {\n\t\t\t\t\t\tinnerNameIndexMapping[i] = -2;\n\t\t\t\t\t\tinnerNameIndexValueMapping[i] = name;\n\t\t\t\t\t},\n\t\t\t\t\tfalse,\n\t\t\t\t\tcolumns\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t}\n\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t}\n\t\t},\n\t\t(i, name) => {\n\t\t\tnameIndexMapping[i] = -2;\n\t\t\tnameIndexValueMapping[i] = name;\n\t\t},\n\t\tfinalSource,\n\t\tcolumns\n\t);\n};\n\nmodule.exports = streamChunksOfCombinedSourceMap;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,uBAAuB,GAAGC,OAAO,CAAC,2BAA2B,CAAC;AACpE,MAAMC,cAAc,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAElD,MAAME,+BAA+B,GAAGA,CACvCC,MAAM,EACNC,SAAS,EACTC,eAAe,EACfC,WAAW,EACXC,cAAc,EACdC,iBAAiB,EACjBC,OAAO,EACPC,QAAQ,EACRC,MAAM,EACNC,WAAW,EACXC,OAAO,KACH;EACJ,IAAIC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC7B,IAAIC,WAAW,GAAG,IAAID,GAAG,CAAC,CAAC;EAC3B,MAAME,kBAAkB,GAAG,EAAE;EAC7B,MAAMC,gBAAgB,GAAG,EAAE;EAC3B,MAAMC,qBAAqB,GAAG,EAAE;EAChC,IAAIC,gBAAgB,GAAG,CAAC,CAAC;EACzB,MAAMC,uBAAuB,GAAG,EAAE;EAClC,MAAMC,4BAA4B,GAAG,EAAE;EACvC,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,MAAMC,uBAAuB,GAAG,EAAE;EAClC,MAAMC,qBAAqB,GAAG,EAAE;EAChC,MAAMC,0BAA0B,GAAG,EAAE;EACrC,MAAMC,sBAAsB,GAAG,EAAE;EACjC,MAAMC,gBAAgB,GAAGA,CAACC,IAAI,EAAEC,MAAM,KAAK;IAC1C,IAAID,IAAI,GAAGF,sBAAsB,CAACI,MAAM,EAAE,OAAO,CAAC,CAAC;IACnD,MAAM;MAAEC;IAAa,CAAC,GAAGL,sBAAsB,CAACE,IAAI,GAAG,CAAC,CAAC;IACzD,IAAII,CAAC,GAAG,CAAC;IACT,IAAIC,CAAC,GAAGF,YAAY,CAACD,MAAM,GAAG,CAAC;IAC/B,OAAOE,CAAC,GAAGC,CAAC,EAAE;MACb,IAAIC,CAAC,GAAIF,CAAC,GAAGC,CAAC,IAAK,CAAC;MACpB,IAAIF,YAAY,CAACG,CAAC,GAAG,CAAC,CAAC,IAAIL,MAAM,EAAE;QAClCG,CAAC,GAAGE,CAAC,GAAG,CAAC;MACV,CAAC,MAAM;QACND,CAAC,GAAGC,CAAC;MACN;IACD;IACA,IAAIF,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;IACtB,OAAOA,CAAC,GAAG,CAAC;EACb,CAAC;EACD,OAAOlC,uBAAuB,CAC7BI,MAAM,EACNC,SAAS,EACT,CACCgC,KAAK,EACLC,aAAa,EACbC,eAAe,EACfC,WAAW,EACXC,YAAY,EACZC,cAAc,EACdC,SAAS,KACL;IACJ;IACA,IAAIH,WAAW,KAAKnB,gBAAgB,EAAE;MACrC;MACA,MAAMuB,GAAG,GAAGf,gBAAgB,CAACY,YAAY,EAAEC,cAAc,CAAC;MAC1D,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE;QACf,MAAM;UAAEC,MAAM;UAAEZ;QAAa,CAAC,GAAGL,sBAAsB,CACtDa,YAAY,GAAG,CAAC,CAChB;QACD,MAAMK,EAAE,GAAGF,GAAG,GAAG,CAAC;QAClB,MAAMvB,gBAAgB,GAAGY,YAAY,CAACa,EAAE,GAAG,CAAC,CAAC;QAC7C,MAAMC,iBAAiB,GAAGd,YAAY,CAACa,EAAE,GAAG,CAAC,CAAC;QAC9C,IAAIE,mBAAmB,GAAGf,YAAY,CAACa,EAAE,GAAG,CAAC,CAAC;QAC9C,IAAIG,cAAc,GAAGhB,YAAY,CAACa,EAAE,GAAG,CAAC,CAAC;QACzC,IAAIzB,gBAAgB,IAAI,CAAC,EAAE;UAC1B;UACA;UACA,MAAM6B,UAAU,GAAGL,MAAM,CAACD,GAAG,CAAC;UAC9B,MAAMO,oBAAoB,GAAGlB,YAAY,CAACa,EAAE,CAAC;UAC7C,MAAMM,eAAe,GAAGV,cAAc,GAAGS,oBAAoB;UAC7D,IAAIC,eAAe,GAAG,CAAC,EAAE;YACxB,IAAIC,mBAAmB,GACtBhC,gBAAgB,GAAGI,uBAAuB,CAACO,MAAM,GAC9CP,uBAAuB,CAACJ,gBAAgB,CAAC,GACzC,IAAI;YACR,IAAIgC,mBAAmB,KAAKC,SAAS,EAAE;cACtC,MAAMC,cAAc,GAAG/B,mBAAmB,CAACH,gBAAgB,CAAC;cAC5DgC,mBAAmB,GAAGE,cAAc,GACjCrD,cAAc,CAACqD,cAAc,CAAC,GAC9B,IAAI;cACP9B,uBAAuB,CAACJ,gBAAgB,CAAC,GAAGgC,mBAAmB;YAChE;YACA,IAAIA,mBAAmB,KAAK,IAAI,EAAE;cACjC,MAAMG,aAAa,GAClBT,iBAAiB,IAAIM,mBAAmB,CAACrB,MAAM,GAC5CqB,mBAAmB,CAACN,iBAAiB,GAAG,CAAC,CAAC,CAACU,KAAK,CAChDT,mBAAmB,EACnBA,mBAAmB,GAAGI,eACtB,CAAC,GACD,EAAE;cACN,IAAIF,UAAU,CAACO,KAAK,CAAC,CAAC,EAAEL,eAAe,CAAC,KAAKI,aAAa,EAAE;gBAC3DR,mBAAmB,IAAII,eAAe;gBACtCH,cAAc,GAAG,CAAC,CAAC;cACpB;YACD;UACD;;UAEA;;UAEA;UACA,IAAIT,WAAW,GACdnB,gBAAgB,GAAGC,uBAAuB,CAACU,MAAM,GAC9CV,uBAAuB,CAACD,gBAAgB,CAAC,GACzC,CAAC,CAAC;UACN,IAAImB,WAAW,KAAK,CAAC,CAAC,EAAE;YACvB,MAAM,CAACpC,MAAM,EAAEsD,aAAa,CAAC,GAC5BrC,gBAAgB,GAAGE,4BAA4B,CAACS,MAAM,GACnDT,4BAA4B,CAACF,gBAAgB,CAAC,GAC9C,CAAC,IAAI,EAAEiC,SAAS,CAAC;YACrB,IAAIK,WAAW,GAAG5C,aAAa,CAAC6C,GAAG,CAACxD,MAAM,CAAC;YAC3C,IAAIuD,WAAW,KAAKL,SAAS,EAAE;cAC9BvC,aAAa,CAAC8C,GAAG,CAACzD,MAAM,EAAGuD,WAAW,GAAG5C,aAAa,CAAC+C,IAAK,CAAC;cAC7DnD,QAAQ,CAACgD,WAAW,EAAEvD,MAAM,EAAEsD,aAAa,CAAC;YAC7C;YACAlB,WAAW,GAAGmB,WAAW;YACzBrC,uBAAuB,CAACD,gBAAgB,CAAC,GAAGmB,WAAW;UACxD;;UAEA;UACA,IAAIuB,cAAc,GAAG,CAAC,CAAC;UACvB,IAAId,cAAc,IAAI,CAAC,EAAE;YACxB;YACAc,cAAc,GACbd,cAAc,GAAGvB,qBAAqB,CAACM,MAAM,GAC1CN,qBAAqB,CAACuB,cAAc,CAAC,GACrC,CAAC,CAAC;YACN,IAAIc,cAAc,KAAK,CAAC,CAAC,EAAE;cAC1B,MAAMC,IAAI,GACTf,cAAc,GAAGtB,0BAA0B,CAACK,MAAM,GAC/CL,0BAA0B,CAACsB,cAAc,CAAC,GAC1CK,SAAS;cACb,IAAIU,IAAI,EAAE;gBACT,IAAIL,WAAW,GAAG1C,WAAW,CAAC2C,GAAG,CAACI,IAAI,CAAC;gBACvC,IAAIL,WAAW,KAAKL,SAAS,EAAE;kBAC9BrC,WAAW,CAAC4C,GAAG,CAACG,IAAI,EAAGL,WAAW,GAAG1C,WAAW,CAAC6C,IAAK,CAAC;kBACvDlD,MAAM,CAAC+C,WAAW,EAAEK,IAAI,CAAC;gBAC1B;gBACAD,cAAc,GAAGJ,WAAW;cAC7B,CAAC,MAAM;gBACNI,cAAc,GAAG,CAAC,CAAC;cACpB;cACArC,qBAAqB,CAACuB,cAAc,CAAC,GAAGc,cAAc;YACvD;UACD,CAAC,MAAM,IAAIpB,SAAS,IAAI,CAAC,EAAE;YAC1B;YACA;YACA;YACA,IAAIU,mBAAmB,GACtB5B,uBAAuB,CAACJ,gBAAgB,CAAC;YAC1C,IAAIgC,mBAAmB,KAAKC,SAAS,EAAE;cACtC,MAAMC,cAAc,GAAG/B,mBAAmB,CAACH,gBAAgB,CAAC;cAC5DgC,mBAAmB,GAAGE,cAAc,GACjCrD,cAAc,CAACqD,cAAc,CAAC,GAC9B,IAAI;cACP9B,uBAAuB,CAACJ,gBAAgB,CAAC,GAAGgC,mBAAmB;YAChE;YACA,IAAIA,mBAAmB,KAAK,IAAI,EAAE;cACjC,MAAMW,IAAI,GAAG5C,qBAAqB,CAACuB,SAAS,CAAC;cAC7C,MAAMsB,YAAY,GACjBlB,iBAAiB,IAAIM,mBAAmB,CAACrB,MAAM,GAC5CqB,mBAAmB,CAACN,iBAAiB,GAAG,CAAC,CAAC,CAACU,KAAK,CAChDT,mBAAmB,EACnBA,mBAAmB,GAAGgB,IAAI,CAAChC,MAC3B,CAAC,GACD,EAAE;cACN,IAAIgC,IAAI,KAAKC,YAAY,EAAE;gBAC1BF,cAAc,GACbpB,SAAS,GAAGxB,gBAAgB,CAACa,MAAM,GAChCb,gBAAgB,CAACwB,SAAS,CAAC,GAC3B,CAAC,CAAC;gBACN,IAAIoB,cAAc,KAAK,CAAC,CAAC,EAAE;kBAC1B,MAAMC,IAAI,GAAG5C,qBAAqB,CAACuB,SAAS,CAAC;kBAC7C,IAAIqB,IAAI,EAAE;oBACT,IAAIL,WAAW,GAAG1C,WAAW,CAAC2C,GAAG,CAACI,IAAI,CAAC;oBACvC,IAAIL,WAAW,KAAKL,SAAS,EAAE;sBAC9BrC,WAAW,CAAC4C,GAAG,CAACG,IAAI,EAAGL,WAAW,GAAG1C,WAAW,CAAC6C,IAAK,CAAC;sBACvDlD,MAAM,CAAC+C,WAAW,EAAEK,IAAI,CAAC;oBAC1B;oBACAD,cAAc,GAAGJ,WAAW;kBAC7B,CAAC,MAAM;oBACNI,cAAc,GAAG,CAAC,CAAC;kBACpB;kBACA5C,gBAAgB,CAACwB,SAAS,CAAC,GAAGoB,cAAc;gBAC7C;cACD;YACD;UACD;UACArD,OAAO,CACN2B,KAAK,EACLC,aAAa,EACbC,eAAe,EACfC,WAAW,EACXO,iBAAiB,EACjBC,mBAAmB,EACnBe,cACD,CAAC;UACD;QACD;MACD;;MAEA;MACA,IAAItD,iBAAiB,EAAE;QACtBC,OAAO,CAAC2B,KAAK,EAAEC,aAAa,EAAEC,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9D;MACD,CAAC,MAAM;QACN,IAAIrB,kBAAkB,CAACsB,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE;UAC3C,IAAImB,WAAW,GAAG5C,aAAa,CAAC6C,GAAG,CAACtD,eAAe,CAAC;UACpD,IAAIqD,WAAW,KAAKL,SAAS,EAAE;YAC9BvC,aAAa,CAAC8C,GAAG,CAACzD,MAAM,EAAGuD,WAAW,GAAG5C,aAAa,CAAC+C,IAAK,CAAC;YAC7DnD,QAAQ,CAACgD,WAAW,EAAErD,eAAe,EAAEC,WAAW,CAAC;UACpD;UACAW,kBAAkB,CAACsB,WAAW,CAAC,GAAGmB,WAAW;QAC9C;MACD;IACD;IAEA,MAAMO,gBAAgB,GACrB1B,WAAW,GAAG,CAAC,IAAIA,WAAW,IAAItB,kBAAkB,CAACc,MAAM,GACxD,CAAC,CAAC,GACFd,kBAAkB,CAACsB,WAAW,CAAC;IACnC,IAAI0B,gBAAgB,GAAG,CAAC,EAAE;MACzB;MACAxD,OAAO,CAAC2B,KAAK,EAAEC,aAAa,EAAEC,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/D,CAAC,MAAM;MACN;MACA,IAAIwB,cAAc,GAAG,CAAC,CAAC;MACvB,IAAIpB,SAAS,IAAI,CAAC,IAAIA,SAAS,GAAGxB,gBAAgB,CAACa,MAAM,EAAE;QAC1D+B,cAAc,GAAG5C,gBAAgB,CAACwB,SAAS,CAAC;QAC5C,IAAIoB,cAAc,KAAK,CAAC,CAAC,EAAE;UAC1B,MAAMC,IAAI,GAAG5C,qBAAqB,CAACuB,SAAS,CAAC;UAC7C,IAAIgB,WAAW,GAAG1C,WAAW,CAAC2C,GAAG,CAACI,IAAI,CAAC;UACvC,IAAIL,WAAW,KAAKL,SAAS,EAAE;YAC9BrC,WAAW,CAAC4C,GAAG,CAACG,IAAI,EAAGL,WAAW,GAAG1C,WAAW,CAAC6C,IAAK,CAAC;YACvDlD,MAAM,CAAC+C,WAAW,EAAEK,IAAI,CAAC;UAC1B;UACAD,cAAc,GAAGJ,WAAW;UAC5BxC,gBAAgB,CAACwB,SAAS,CAAC,GAAGoB,cAAc;QAC7C;MACD;MACArD,OAAO,CACN2B,KAAK,EACLC,aAAa,EACbC,eAAe,EACf2B,gBAAgB,EAChBzB,YAAY,EACZC,cAAc,EACdqB,cACD,CAAC;IACF;EACD,CAAC,EACD,CAACI,CAAC,EAAE/D,MAAM,EAAEsD,aAAa,KAAK;IAC7B,IAAItD,MAAM,KAAKE,eAAe,EAAE;MAC/Be,gBAAgB,GAAG8C,CAAC;MACpB,IAAI5D,WAAW,KAAK+C,SAAS,EAAEI,aAAa,GAAGnD,WAAW,CAAC,KACtDA,WAAW,GAAGmD,aAAa;MAChCxC,kBAAkB,CAACiD,CAAC,CAAC,GAAG,CAAC,CAAC;MAC1BnE,uBAAuB,CACtB0D,aAAa,EACblD,cAAc,EACd,CACC6B,KAAK,EACLC,aAAa,EACbC,eAAe,EACfC,WAAW,EACXC,YAAY,EACZC,cAAc,EACdC,SAAS,KACL;QACJ,OAAOf,sBAAsB,CAACI,MAAM,GAAGM,aAAa,EAAE;UACrDV,sBAAsB,CAACwC,IAAI,CAAC;YAC3BnC,YAAY,EAAE,EAAE;YAChBY,MAAM,EAAE;UACT,CAAC,CAAC;QACH;QACA,MAAMwB,IAAI,GAAGzC,sBAAsB,CAACU,aAAa,GAAG,CAAC,CAAC;QACtD+B,IAAI,CAACpC,YAAY,CAACmC,IAAI,CACrB7B,eAAe,EACfC,WAAW,EACXC,YAAY,EACZC,cAAc,EACdC,SACD,CAAC;QACD0B,IAAI,CAACxB,MAAM,CAACuB,IAAI,CAAC/B,KAAK,CAAC;MACxB,CAAC,EACD,CAAC8B,CAAC,EAAE/D,MAAM,EAAEsD,aAAa,KAAK;QAC7BlC,mBAAmB,CAAC2C,CAAC,CAAC,GAAGT,aAAa;QACtCjC,uBAAuB,CAAC0C,CAAC,CAAC,GAAGb,SAAS;QACtChC,uBAAuB,CAAC6C,CAAC,CAAC,GAAG,CAAC,CAAC;QAC/B5C,4BAA4B,CAAC4C,CAAC,CAAC,GAAG,CAAC/D,MAAM,EAAEsD,aAAa,CAAC;MAC1D,CAAC,EACD,CAACS,CAAC,EAAEH,IAAI,KAAK;QACZtC,qBAAqB,CAACyC,CAAC,CAAC,GAAG,CAAC,CAAC;QAC7BxC,0BAA0B,CAACwC,CAAC,CAAC,GAAGH,IAAI;MACrC,CAAC,EACD,KAAK,EACLlD,OACD,CAAC;IACF,CAAC,MAAM;MACN,IAAI6C,WAAW,GAAG5C,aAAa,CAAC6C,GAAG,CAACxD,MAAM,CAAC;MAC3C,IAAIuD,WAAW,KAAKL,SAAS,EAAE;QAC9BvC,aAAa,CAAC8C,GAAG,CAACzD,MAAM,EAAGuD,WAAW,GAAG5C,aAAa,CAAC+C,IAAK,CAAC;QAC7DnD,QAAQ,CAACgD,WAAW,EAAEvD,MAAM,EAAEsD,aAAa,CAAC;MAC7C;MACAxC,kBAAkB,CAACiD,CAAC,CAAC,GAAGR,WAAW;IACpC;EACD,CAAC,EACD,CAACQ,CAAC,EAAEH,IAAI,KAAK;IACZ7C,gBAAgB,CAACgD,CAAC,CAAC,GAAG,CAAC,CAAC;IACxB/C,qBAAqB,CAAC+C,CAAC,CAAC,GAAGH,IAAI;EAChC,CAAC,EACDnD,WAAW,EACXC,OACD,CAAC;AACF,CAAC;AAEDwD,MAAM,CAACC,OAAO,GAAGpE,+BAA+B"},"metadata":{},"sourceType":"script","externalDependencies":[]}