{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst WebpackError = require(\"../WebpackError\");\nconst {\n  evaluateToIdentifier\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst ImportMetaContextDependency = require(\"./ImportMetaContextDependency\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").SourceLocation} SourceLocation */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"../ChunkGroup\").RawChunkGroupOptions} RawChunkGroupOptions */\n/** @typedef {Pick<ContextModuleOptions, 'mode'|'recursive'|'regExp'|'include'|'exclude'|'chunkName'>&{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions[\"referencedExports\"]}} ImportMetaContextOptions */\n\n/**\n * @param {TODO} prop property\n * @param {string} expect except message\n * @returns {WebpackError} error\n */\nfunction createPropertyParseError(prop, expect) {\n  return createError(`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(prop.key.name)}, expected type ${expect}.`, prop.value.loc);\n}\n\n/**\n * @param {string} msg message\n * @param {SourceLocation} loc location\n * @returns {WebpackError} error\n */\nfunction createError(msg, loc) {\n  const error = new WebpackError(msg);\n  error.name = \"ImportMetaContextError\";\n  error.loc = loc;\n  return error;\n}\nmodule.exports = class ImportMetaContextDependencyParserPlugin {\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {void}\n   */\n  apply(parser) {\n    parser.hooks.evaluateIdentifier.for(\"import.meta.webpackContext\").tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n      return evaluateToIdentifier(\"import.meta.webpackContext\", \"import.meta\", () => [\"webpackContext\"], true)(expr);\n    });\n    parser.hooks.call.for(\"import.meta.webpackContext\").tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n      if (expr.arguments.length < 1 || expr.arguments.length > 2) return;\n      const [directoryNode, optionsNode] = expr.arguments;\n      if (optionsNode && optionsNode.type !== \"ObjectExpression\") return;\n      const requestExpr = parser.evaluateExpression( /** @type {Expression} */directoryNode);\n      if (!requestExpr.isString()) return;\n      const request = requestExpr.string;\n      const errors = [];\n      let regExp = /^\\.\\/.*$/;\n      let recursive = true;\n      /** @type {ContextModuleOptions[\"mode\"]} */\n      let mode = \"sync\";\n      /** @type {ContextModuleOptions[\"include\"]} */\n      let include;\n      /** @type {ContextModuleOptions[\"exclude\"]} */\n      let exclude;\n      /** @type {RawChunkGroupOptions} */\n      const groupOptions = {};\n      /** @type {ContextModuleOptions[\"chunkName\"]} */\n      let chunkName;\n      /** @type {ContextModuleOptions[\"referencedExports\"]} */\n      let exports;\n      if (optionsNode) {\n        for (const prop of /** @type {ObjectExpression} */optionsNode.properties) {\n          if (prop.type !== \"Property\" || prop.key.type !== \"Identifier\") {\n            errors.push(createError(\"Parsing import.meta.webpackContext options failed.\", optionsNode.loc));\n            break;\n          }\n          switch (prop.key.name) {\n            case \"regExp\":\n              {\n                const regExpExpr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (!regExpExpr.isRegExp()) {\n                  errors.push(createPropertyParseError(prop, \"RegExp\"));\n                } else {\n                  regExp = regExpExpr.regExp;\n                }\n                break;\n              }\n            case \"include\":\n              {\n                const regExpExpr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (!regExpExpr.isRegExp()) {\n                  errors.push(createPropertyParseError(prop, \"RegExp\"));\n                } else {\n                  include = regExpExpr.regExp;\n                }\n                break;\n              }\n            case \"exclude\":\n              {\n                const regExpExpr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (!regExpExpr.isRegExp()) {\n                  errors.push(createPropertyParseError(prop, \"RegExp\"));\n                } else {\n                  exclude = regExpExpr.regExp;\n                }\n                break;\n              }\n            case \"mode\":\n              {\n                const modeExpr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (!modeExpr.isString()) {\n                  errors.push(createPropertyParseError(prop, \"string\"));\n                } else {\n                  mode = /** @type {ContextModuleOptions[\"mode\"]} */\n                  modeExpr.string;\n                }\n                break;\n              }\n            case \"chunkName\":\n              {\n                const expr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (!expr.isString()) {\n                  errors.push(createPropertyParseError(prop, \"string\"));\n                } else {\n                  chunkName = expr.string;\n                }\n                break;\n              }\n            case \"exports\":\n              {\n                const expr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (expr.isString()) {\n                  exports = [[expr.string]];\n                } else if (expr.isArray()) {\n                  const items = expr.items;\n                  if (items.every(i => {\n                    if (!i.isArray()) return false;\n                    const innerItems = i.items;\n                    return innerItems.every(i => i.isString());\n                  })) {\n                    exports = [];\n                    for (const i1 of items) {\n                      const export_ = [];\n                      for (const i2 of i1.items) {\n                        export_.push(i2.string);\n                      }\n                      exports.push(export_);\n                    }\n                  } else {\n                    errors.push(createPropertyParseError(prop, \"string|string[][]\"));\n                  }\n                } else {\n                  errors.push(createPropertyParseError(prop, \"string|string[][]\"));\n                }\n                break;\n              }\n            case \"prefetch\":\n              {\n                const expr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (expr.isBoolean()) {\n                  groupOptions.prefetchOrder = 0;\n                } else if (expr.isNumber()) {\n                  groupOptions.prefetchOrder = expr.number;\n                } else {\n                  errors.push(createPropertyParseError(prop, \"boolean|number\"));\n                }\n                break;\n              }\n            case \"preload\":\n              {\n                const expr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (expr.isBoolean()) {\n                  groupOptions.preloadOrder = 0;\n                } else if (expr.isNumber()) {\n                  groupOptions.preloadOrder = expr.number;\n                } else {\n                  errors.push(createPropertyParseError(prop, \"boolean|number\"));\n                }\n                break;\n              }\n            case \"recursive\":\n              {\n                const recursiveExpr = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                if (!recursiveExpr.isBoolean()) {\n                  errors.push(createPropertyParseError(prop, \"boolean\"));\n                } else {\n                  recursive = recursiveExpr.bool;\n                }\n                break;\n              }\n            default:\n              errors.push(createError(`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(prop.key.name)}.`, optionsNode.loc));\n          }\n        }\n      }\n      if (errors.length) {\n        for (const error of errors) parser.state.current.addError(error);\n        return;\n      }\n      const dep = new ImportMetaContextDependency({\n        request,\n        include,\n        exclude,\n        recursive,\n        regExp,\n        groupOptions,\n        chunkName,\n        referencedExports: exports,\n        mode,\n        category: \"esm\"\n      }, expr.range);\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    });\n  }\n};","map":{"version":3,"names":["WebpackError","require","evaluateToIdentifier","ImportMetaContextDependency","createPropertyParseError","prop","expect","createError","JSON","stringify","key","name","value","loc","msg","error","module","exports","ImportMetaContextDependencyParserPlugin","apply","parser","hooks","evaluateIdentifier","for","tap","expr","call","arguments","length","directoryNode","optionsNode","type","requestExpr","evaluateExpression","isString","request","string","errors","regExp","recursive","mode","include","exclude","groupOptions","chunkName","properties","push","regExpExpr","isRegExp","modeExpr","isArray","items","every","i","innerItems","i1","export_","i2","isBoolean","prefetchOrder","isNumber","number","preloadOrder","recursiveExpr","bool","state","current","addError","dep","referencedExports","category","range","optional","scope","inTry","addDependency"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/dependencies/ImportMetaContextDependencyParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst WebpackError = require(\"../WebpackError\");\nconst {\n\tevaluateToIdentifier\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst ImportMetaContextDependency = require(\"./ImportMetaContextDependency\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").SourceLocation} SourceLocation */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"../ChunkGroup\").RawChunkGroupOptions} RawChunkGroupOptions */\n/** @typedef {Pick<ContextModuleOptions, 'mode'|'recursive'|'regExp'|'include'|'exclude'|'chunkName'>&{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions[\"referencedExports\"]}} ImportMetaContextOptions */\n\n/**\n * @param {TODO} prop property\n * @param {string} expect except message\n * @returns {WebpackError} error\n */\nfunction createPropertyParseError(prop, expect) {\n\treturn createError(\n\t\t`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(\n\t\t\tprop.key.name\n\t\t)}, expected type ${expect}.`,\n\t\tprop.value.loc\n\t);\n}\n\n/**\n * @param {string} msg message\n * @param {SourceLocation} loc location\n * @returns {WebpackError} error\n */\nfunction createError(msg, loc) {\n\tconst error = new WebpackError(msg);\n\terror.name = \"ImportMetaContextError\";\n\terror.loc = loc;\n\treturn error;\n}\n\nmodule.exports = class ImportMetaContextDependencyParserPlugin {\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {void}\n\t */\n\tapply(parser) {\n\t\tparser.hooks.evaluateIdentifier\n\t\t\t.for(\"import.meta.webpackContext\")\n\t\t\t.tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n\t\t\t\treturn evaluateToIdentifier(\n\t\t\t\t\t\"import.meta.webpackContext\",\n\t\t\t\t\t\"import.meta\",\n\t\t\t\t\t() => [\"webpackContext\"],\n\t\t\t\t\ttrue\n\t\t\t\t)(expr);\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(\"import.meta.webpackContext\")\n\t\t\t.tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n\t\t\t\tif (expr.arguments.length < 1 || expr.arguments.length > 2) return;\n\t\t\t\tconst [directoryNode, optionsNode] = expr.arguments;\n\t\t\t\tif (optionsNode && optionsNode.type !== \"ObjectExpression\") return;\n\t\t\t\tconst requestExpr = parser.evaluateExpression(\n\t\t\t\t\t/** @type {Expression} */ (directoryNode)\n\t\t\t\t);\n\t\t\t\tif (!requestExpr.isString()) return;\n\t\t\t\tconst request = requestExpr.string;\n\t\t\t\tconst errors = [];\n\t\t\t\tlet regExp = /^\\.\\/.*$/;\n\t\t\t\tlet recursive = true;\n\t\t\t\t/** @type {ContextModuleOptions[\"mode\"]} */\n\t\t\t\tlet mode = \"sync\";\n\t\t\t\t/** @type {ContextModuleOptions[\"include\"]} */\n\t\t\t\tlet include;\n\t\t\t\t/** @type {ContextModuleOptions[\"exclude\"]} */\n\t\t\t\tlet exclude;\n\t\t\t\t/** @type {RawChunkGroupOptions} */\n\t\t\t\tconst groupOptions = {};\n\t\t\t\t/** @type {ContextModuleOptions[\"chunkName\"]} */\n\t\t\t\tlet chunkName;\n\t\t\t\t/** @type {ContextModuleOptions[\"referencedExports\"]} */\n\t\t\t\tlet exports;\n\t\t\t\tif (optionsNode) {\n\t\t\t\t\tfor (const prop of /** @type {ObjectExpression} */ (optionsNode)\n\t\t\t\t\t\t.properties) {\n\t\t\t\t\t\tif (prop.type !== \"Property\" || prop.key.type !== \"Identifier\") {\n\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\tcreateError(\n\t\t\t\t\t\t\t\t\t\"Parsing import.meta.webpackContext options failed.\",\n\t\t\t\t\t\t\t\t\toptionsNode.loc\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (prop.key.name) {\n\t\t\t\t\t\t\tcase \"regExp\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tregExp = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"include\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinclude = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"exclude\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\texclude = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"mode\": {\n\t\t\t\t\t\t\t\tconst modeExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!modeExpr.isString()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"string\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmode = /** @type {ContextModuleOptions[\"mode\"]} */ (\n\t\t\t\t\t\t\t\t\t\tmodeExpr.string\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"chunkName\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!expr.isString()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"string\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchunkName = expr.string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"exports\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isString()) {\n\t\t\t\t\t\t\t\t\texports = [[expr.string]];\n\t\t\t\t\t\t\t\t} else if (expr.isArray()) {\n\t\t\t\t\t\t\t\t\tconst items = expr.items;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\titems.every(i => {\n\t\t\t\t\t\t\t\t\t\t\tif (!i.isArray()) return false;\n\t\t\t\t\t\t\t\t\t\t\tconst innerItems = i.items;\n\t\t\t\t\t\t\t\t\t\t\treturn innerItems.every(i => i.isString());\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\texports = [];\n\t\t\t\t\t\t\t\t\t\tfor (const i1 of items) {\n\t\t\t\t\t\t\t\t\t\t\tconst export_ = [];\n\t\t\t\t\t\t\t\t\t\t\tfor (const i2 of i1.items) {\n\t\t\t\t\t\t\t\t\t\t\t\texport_.push(i2.string);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\texports.push(export_);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\t\t\tcreatePropertyParseError(prop, \"string|string[][]\")\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\t\tcreatePropertyParseError(prop, \"string|string[][]\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"prefetch\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isBoolean()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.prefetchOrder = 0;\n\t\t\t\t\t\t\t\t} else if (expr.isNumber()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.prefetchOrder = expr.number;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean|number\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"preload\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isBoolean()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.preloadOrder = 0;\n\t\t\t\t\t\t\t\t} else if (expr.isNumber()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.preloadOrder = expr.number;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean|number\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"recursive\": {\n\t\t\t\t\t\t\t\tconst recursiveExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!recursiveExpr.isBoolean()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trecursive = recursiveExpr.bool;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\tcreateError(\n\t\t\t\t\t\t\t\t\t\t`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\t\tprop.key.name\n\t\t\t\t\t\t\t\t\t\t)}.`,\n\t\t\t\t\t\t\t\t\t\toptionsNode.loc\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (errors.length) {\n\t\t\t\t\tfor (const error of errors) parser.state.current.addError(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst dep = new ImportMetaContextDependency(\n\t\t\t\t\t{\n\t\t\t\t\t\trequest,\n\t\t\t\t\t\tinclude,\n\t\t\t\t\t\texclude,\n\t\t\t\t\t\trecursive,\n\t\t\t\t\t\tregExp,\n\t\t\t\t\t\tgroupOptions,\n\t\t\t\t\t\tchunkName,\n\t\t\t\t\t\treferencedExports: exports,\n\t\t\t\t\t\tmode,\n\t\t\t\t\t\tcategory: \"esm\"\n\t\t\t\t\t},\n\t\t\t\t\texpr.range\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}