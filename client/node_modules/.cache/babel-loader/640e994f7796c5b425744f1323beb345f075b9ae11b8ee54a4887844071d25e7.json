{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  AsyncParallelHook,\n  AsyncSeriesBailHook,\n  SyncHook\n} = require(\"tapable\");\nconst {\n  makeWebpackError,\n  makeWebpackErrorCallback\n} = require(\"./HookWebpackError\");\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} Etag\n * @property {function(): string} toString\n */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @callback GotHandler\n * @param {any} result\n * @param {function(Error=): void} callback\n * @returns {void}\n */\n\nconst needCalls = (times, callback) => {\n  return err => {\n    if (--times === 0) {\n      return callback(err);\n    }\n    if (err && times > 0) {\n      times = 0;\n      return callback(err);\n    }\n  };\n};\nclass Cache {\n  constructor() {\n    this.hooks = {\n      /** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>} */\n      get: new AsyncSeriesBailHook([\"identifier\", \"etag\", \"gotHandlers\"]),\n      /** @type {AsyncParallelHook<[string, Etag | null, any]>} */\n      store: new AsyncParallelHook([\"identifier\", \"etag\", \"data\"]),\n      /** @type {AsyncParallelHook<[Iterable<string>]>} */\n      storeBuildDependencies: new AsyncParallelHook([\"dependencies\"]),\n      /** @type {SyncHook<[]>} */\n      beginIdle: new SyncHook([]),\n      /** @type {AsyncParallelHook<[]>} */\n      endIdle: new AsyncParallelHook([]),\n      /** @type {AsyncParallelHook<[]>} */\n      shutdown: new AsyncParallelHook([])\n    };\n  }\n\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n  get(identifier, etag, callback) {\n    const gotHandlers = [];\n    this.hooks.get.callAsync(identifier, etag, gotHandlers, (err, result) => {\n      if (err) {\n        callback(makeWebpackError(err, \"Cache.hooks.get\"));\n        return;\n      }\n      if (result === null) {\n        result = undefined;\n      }\n      if (gotHandlers.length > 1) {\n        const innerCallback = needCalls(gotHandlers.length, () => callback(null, result));\n        for (const gotHandler of gotHandlers) {\n          gotHandler(result, innerCallback);\n        }\n      } else if (gotHandlers.length === 1) {\n        gotHandlers[0](result, () => callback(null, result));\n      } else {\n        callback(null, result);\n      }\n    });\n  }\n\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n  store(identifier, etag, data, callback) {\n    this.hooks.store.callAsync(identifier, etag, data, makeWebpackErrorCallback(callback, \"Cache.hooks.store\"));\n  }\n\n  /**\n   * After this method has succeeded the cache can only be restored when build dependencies are\n   * @param {Iterable<string>} dependencies list of all build dependencies\n   * @param {CallbackCache<void>} callback signals when the dependencies are stored\n   * @returns {void}\n   */\n  storeBuildDependencies(dependencies, callback) {\n    this.hooks.storeBuildDependencies.callAsync(dependencies, makeWebpackErrorCallback(callback, \"Cache.hooks.storeBuildDependencies\"));\n  }\n\n  /**\n   * @returns {void}\n   */\n  beginIdle() {\n    this.hooks.beginIdle.call();\n  }\n\n  /**\n   * @param {CallbackCache<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n  endIdle(callback) {\n    this.hooks.endIdle.callAsync(makeWebpackErrorCallback(callback, \"Cache.hooks.endIdle\"));\n  }\n\n  /**\n   * @param {CallbackCache<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n  shutdown(callback) {\n    this.hooks.shutdown.callAsync(makeWebpackErrorCallback(callback, \"Cache.hooks.shutdown\"));\n  }\n}\nCache.STAGE_MEMORY = -10;\nCache.STAGE_DEFAULT = 0;\nCache.STAGE_DISK = 10;\nCache.STAGE_NETWORK = 20;\nmodule.exports = Cache;","map":{"version":3,"names":["AsyncParallelHook","AsyncSeriesBailHook","SyncHook","require","makeWebpackError","makeWebpackErrorCallback","needCalls","times","callback","err","Cache","constructor","hooks","get","store","storeBuildDependencies","beginIdle","endIdle","shutdown","identifier","etag","gotHandlers","callAsync","result","undefined","length","innerCallback","gotHandler","data","dependencies","call","STAGE_MEMORY","STAGE_DEFAULT","STAGE_DISK","STAGE_NETWORK","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/Cache.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { AsyncParallelHook, AsyncSeriesBailHook, SyncHook } = require(\"tapable\");\nconst {\n\tmakeWebpackError,\n\tmakeWebpackErrorCallback\n} = require(\"./HookWebpackError\");\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} Etag\n * @property {function(): string} toString\n */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @callback GotHandler\n * @param {any} result\n * @param {function(Error=): void} callback\n * @returns {void}\n */\n\nconst needCalls = (times, callback) => {\n\treturn err => {\n\t\tif (--times === 0) {\n\t\t\treturn callback(err);\n\t\t}\n\t\tif (err && times > 0) {\n\t\t\ttimes = 0;\n\t\t\treturn callback(err);\n\t\t}\n\t};\n};\n\nclass Cache {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>} */\n\t\t\tget: new AsyncSeriesBailHook([\"identifier\", \"etag\", \"gotHandlers\"]),\n\t\t\t/** @type {AsyncParallelHook<[string, Etag | null, any]>} */\n\t\t\tstore: new AsyncParallelHook([\"identifier\", \"etag\", \"data\"]),\n\t\t\t/** @type {AsyncParallelHook<[Iterable<string>]>} */\n\t\t\tstoreBuildDependencies: new AsyncParallelHook([\"dependencies\"]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tbeginIdle: new SyncHook([]),\n\t\t\t/** @type {AsyncParallelHook<[]>} */\n\t\t\tendIdle: new AsyncParallelHook([]),\n\t\t\t/** @type {AsyncParallelHook<[]>} */\n\t\t\tshutdown: new AsyncParallelHook([])\n\t\t};\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tconst gotHandlers = [];\n\t\tthis.hooks.get.callAsync(identifier, etag, gotHandlers, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(makeWebpackError(err, \"Cache.hooks.get\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (result === null) {\n\t\t\t\tresult = undefined;\n\t\t\t}\n\t\t\tif (gotHandlers.length > 1) {\n\t\t\t\tconst innerCallback = needCalls(gotHandlers.length, () =>\n\t\t\t\t\tcallback(null, result)\n\t\t\t\t);\n\t\t\t\tfor (const gotHandler of gotHandlers) {\n\t\t\t\t\tgotHandler(result, innerCallback);\n\t\t\t\t}\n\t\t\t} else if (gotHandlers.length === 1) {\n\t\t\t\tgotHandlers[0](result, () => callback(null, result));\n\t\t\t} else {\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis.hooks.store.callAsync(\n\t\t\tidentifier,\n\t\t\tetag,\n\t\t\tdata,\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.store\")\n\t\t);\n\t}\n\n\t/**\n\t * After this method has succeeded the cache can only be restored when build dependencies are\n\t * @param {Iterable<string>} dependencies list of all build dependencies\n\t * @param {CallbackCache<void>} callback signals when the dependencies are stored\n\t * @returns {void}\n\t */\n\tstoreBuildDependencies(dependencies, callback) {\n\t\tthis.hooks.storeBuildDependencies.callAsync(\n\t\t\tdependencies,\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.storeBuildDependencies\")\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tbeginIdle() {\n\t\tthis.hooks.beginIdle.call();\n\t}\n\n\t/**\n\t * @param {CallbackCache<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\tendIdle(callback) {\n\t\tthis.hooks.endIdle.callAsync(\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.endIdle\")\n\t\t);\n\t}\n\n\t/**\n\t * @param {CallbackCache<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\tshutdown(callback) {\n\t\tthis.hooks.shutdown.callAsync(\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.shutdown\")\n\t\t);\n\t}\n}\n\nCache.STAGE_MEMORY = -10;\nCache.STAGE_DEFAULT = 0;\nCache.STAGE_DISK = 10;\nCache.STAGE_NETWORK = 20;\n\nmodule.exports = Cache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}