{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst ExportsInfo = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst WeakTupleMap = require(\"./util/WeakTupleMap\");\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./ExportsInfo\").ExportInfo} ExportInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleProfile\")} ModuleProfile */\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @callback OptimizationBailoutFunction\n * @param {RequestShortener} requestShortener\n * @returns {string}\n */\n\nconst EMPTY_SET = new Set();\n\n/**\n * @param {SortableSet<ModuleGraphConnection>} set input\n * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]>} mapped by origin module\n */\nconst getConnectionsByOriginModule = set => {\n  const map = new Map();\n  /** @type {Module | 0} */\n  let lastModule = 0;\n  /** @type {ModuleGraphConnection[]} */\n  let lastList = undefined;\n  for (const connection of set) {\n    const {\n      originModule\n    } = connection;\n    if (lastModule === originModule) {\n      lastList.push(connection);\n    } else {\n      lastModule = originModule;\n      const list = map.get(originModule);\n      if (list !== undefined) {\n        lastList = list;\n        list.push(connection);\n      } else {\n        const list = [connection];\n        lastList = list;\n        map.set(originModule, list);\n      }\n    }\n  }\n  return map;\n};\n\n/**\n * @param {SortableSet<ModuleGraphConnection>} set input\n * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]>} mapped by module\n */\nconst getConnectionsByModule = set => {\n  const map = new Map();\n  /** @type {Module | 0} */\n  let lastModule = 0;\n  /** @type {ModuleGraphConnection[]} */\n  let lastList = undefined;\n  for (const connection of set) {\n    const {\n      module\n    } = connection;\n    if (lastModule === module) {\n      lastList.push(connection);\n    } else {\n      lastModule = module;\n      const list = map.get(module);\n      if (list !== undefined) {\n        lastList = list;\n        list.push(connection);\n      } else {\n        const list = [connection];\n        lastList = list;\n        map.set(module, list);\n      }\n    }\n  }\n  return map;\n};\nclass ModuleGraphModule {\n  constructor() {\n    /** @type {SortableSet<ModuleGraphConnection>} */\n    this.incomingConnections = new SortableSet();\n    /** @type {SortableSet<ModuleGraphConnection> | undefined} */\n    this.outgoingConnections = undefined;\n    /** @type {Module | null} */\n    this.issuer = undefined;\n    /** @type {(string | OptimizationBailoutFunction)[]} */\n    this.optimizationBailout = [];\n    /** @type {ExportsInfo} */\n    this.exports = new ExportsInfo();\n    /** @type {number} */\n    this.preOrderIndex = null;\n    /** @type {number} */\n    this.postOrderIndex = null;\n    /** @type {number} */\n    this.depth = null;\n    /** @type {ModuleProfile} */\n    this.profile = undefined;\n    /** @type {boolean} */\n    this.async = false;\n    /** @type {ModuleGraphConnection[]} */\n    this._unassignedConnections = undefined;\n  }\n}\nclass ModuleGraph {\n  constructor() {\n    /** @type {WeakMap<Dependency, ModuleGraphConnection>} */\n    this._dependencyMap = new WeakMap();\n    /** @type {Map<Module, ModuleGraphModule>} */\n    this._moduleMap = new Map();\n    /** @type {WeakMap<any, Object>} */\n    this._metaMap = new WeakMap();\n\n    /** @type {WeakTupleMap<any[], any>} */\n    this._cache = undefined;\n\n    /** @type {Map<Module, WeakTupleMap<any, any>>} */\n    this._moduleMemCaches = undefined;\n\n    /** @type {string} */\n    this._cacheStage = undefined;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {ModuleGraphModule} the internal module\n   */\n  _getModuleGraphModule(module) {\n    let mgm = this._moduleMap.get(module);\n    if (mgm === undefined) {\n      mgm = new ModuleGraphModule();\n      this._moduleMap.set(module, mgm);\n    }\n    return mgm;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency\n   * @param {DependenciesBlock} block parent block\n   * @param {Module} module parent module\n   * @param {number=} indexInBlock position in block\n   * @returns {void}\n   */\n  setParents(dependency, block, module) {\n    let indexInBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n    dependency._parentDependenciesBlockIndex = indexInBlock;\n    dependency._parentDependenciesBlock = block;\n    dependency._parentModule = module;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency\n   * @returns {Module} parent module\n   */\n  getParentModule(dependency) {\n    return dependency._parentModule;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency\n   * @returns {DependenciesBlock} parent block\n   */\n  getParentBlock(dependency) {\n    return dependency._parentDependenciesBlock;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency\n   * @returns {number} index\n   */\n  getParentBlockIndex(dependency) {\n    return dependency._parentDependenciesBlockIndex;\n  }\n\n  /**\n   * @param {Module} originModule the referencing module\n   * @param {Dependency} dependency the referencing dependency\n   * @param {Module} module the referenced module\n   * @returns {void}\n   */\n  setResolvedModule(originModule, dependency, module) {\n    const connection = new ModuleGraphConnection(originModule, dependency, module, undefined, dependency.weak, dependency.getCondition(this));\n    const connections = this._getModuleGraphModule(module).incomingConnections;\n    connections.add(connection);\n    if (originModule) {\n      const mgm = this._getModuleGraphModule(originModule);\n      if (mgm._unassignedConnections === undefined) {\n        mgm._unassignedConnections = [];\n      }\n      mgm._unassignedConnections.push(connection);\n      if (mgm.outgoingConnections === undefined) {\n        mgm.outgoingConnections = new SortableSet();\n      }\n      mgm.outgoingConnections.add(connection);\n    } else {\n      this._dependencyMap.set(dependency, connection);\n    }\n  }\n\n  /**\n   * @param {Dependency} dependency the referencing dependency\n   * @param {Module} module the referenced module\n   * @returns {void}\n   */\n  updateModule(dependency, module) {\n    const connection = this.getConnection(dependency);\n    if (connection.module === module) return;\n    const newConnection = connection.clone();\n    newConnection.module = module;\n    this._dependencyMap.set(dependency, newConnection);\n    connection.setActive(false);\n    const originMgm = this._getModuleGraphModule(connection.originModule);\n    originMgm.outgoingConnections.add(newConnection);\n    const targetMgm = this._getModuleGraphModule(module);\n    targetMgm.incomingConnections.add(newConnection);\n  }\n\n  /**\n   * @param {Dependency} dependency the referencing dependency\n   * @returns {void}\n   */\n  removeConnection(dependency) {\n    const connection = this.getConnection(dependency);\n    const targetMgm = this._getModuleGraphModule(connection.module);\n    targetMgm.incomingConnections.delete(connection);\n    const originMgm = this._getModuleGraphModule(connection.originModule);\n    originMgm.outgoingConnections.delete(connection);\n    this._dependencyMap.set(dependency, null);\n  }\n\n  /**\n   * @param {Dependency} dependency the referencing dependency\n   * @param {string} explanation an explanation\n   * @returns {void}\n   */\n  addExplanation(dependency, explanation) {\n    const connection = this.getConnection(dependency);\n    connection.addExplanation(explanation);\n  }\n\n  /**\n   * @param {Module} sourceModule the source module\n   * @param {Module} targetModule the target module\n   * @returns {void}\n   */\n  cloneModuleAttributes(sourceModule, targetModule) {\n    const oldMgm = this._getModuleGraphModule(sourceModule);\n    const newMgm = this._getModuleGraphModule(targetModule);\n    newMgm.postOrderIndex = oldMgm.postOrderIndex;\n    newMgm.preOrderIndex = oldMgm.preOrderIndex;\n    newMgm.depth = oldMgm.depth;\n    newMgm.exports = oldMgm.exports;\n    newMgm.async = oldMgm.async;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n  removeModuleAttributes(module) {\n    const mgm = this._getModuleGraphModule(module);\n    mgm.postOrderIndex = null;\n    mgm.preOrderIndex = null;\n    mgm.depth = null;\n    mgm.async = false;\n  }\n\n  /**\n   * @returns {void}\n   */\n  removeAllModuleAttributes() {\n    for (const mgm of this._moduleMap.values()) {\n      mgm.postOrderIndex = null;\n      mgm.preOrderIndex = null;\n      mgm.depth = null;\n      mgm.async = false;\n    }\n  }\n\n  /**\n   * @param {Module} oldModule the old referencing module\n   * @param {Module} newModule the new referencing module\n   * @param {function(ModuleGraphConnection): boolean} filterConnection filter predicate for replacement\n   * @returns {void}\n   */\n  moveModuleConnections(oldModule, newModule, filterConnection) {\n    if (oldModule === newModule) return;\n    const oldMgm = this._getModuleGraphModule(oldModule);\n    const newMgm = this._getModuleGraphModule(newModule);\n    // Outgoing connections\n    const oldConnections = oldMgm.outgoingConnections;\n    if (oldConnections !== undefined) {\n      if (newMgm.outgoingConnections === undefined) {\n        newMgm.outgoingConnections = new SortableSet();\n      }\n      const newConnections = newMgm.outgoingConnections;\n      for (const connection of oldConnections) {\n        if (filterConnection(connection)) {\n          connection.originModule = newModule;\n          newConnections.add(connection);\n          oldConnections.delete(connection);\n        }\n      }\n    }\n    // Incoming connections\n    const oldConnections2 = oldMgm.incomingConnections;\n    const newConnections2 = newMgm.incomingConnections;\n    for (const connection of oldConnections2) {\n      if (filterConnection(connection)) {\n        connection.module = newModule;\n        newConnections2.add(connection);\n        oldConnections2.delete(connection);\n      }\n    }\n  }\n\n  /**\n   * @param {Module} oldModule the old referencing module\n   * @param {Module} newModule the new referencing module\n   * @param {function(ModuleGraphConnection): boolean} filterConnection filter predicate for replacement\n   * @returns {void}\n   */\n  copyOutgoingModuleConnections(oldModule, newModule, filterConnection) {\n    if (oldModule === newModule) return;\n    const oldMgm = this._getModuleGraphModule(oldModule);\n    const newMgm = this._getModuleGraphModule(newModule);\n    // Outgoing connections\n    const oldConnections = oldMgm.outgoingConnections;\n    if (oldConnections !== undefined) {\n      if (newMgm.outgoingConnections === undefined) {\n        newMgm.outgoingConnections = new SortableSet();\n      }\n      const newConnections = newMgm.outgoingConnections;\n      for (const connection of oldConnections) {\n        if (filterConnection(connection)) {\n          const newConnection = connection.clone();\n          newConnection.originModule = newModule;\n          newConnections.add(newConnection);\n          if (newConnection.module !== undefined) {\n            const otherMgm = this._getModuleGraphModule(newConnection.module);\n            otherMgm.incomingConnections.add(newConnection);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Module} module the referenced module\n   * @param {string} explanation an explanation why it's referenced\n   * @returns {void}\n   */\n  addExtraReason(module, explanation) {\n    const connections = this._getModuleGraphModule(module).incomingConnections;\n    connections.add(new ModuleGraphConnection(null, null, module, explanation));\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency to look for a referenced module\n   * @returns {Module} the referenced module\n   */\n  getResolvedModule(dependency) {\n    const connection = this.getConnection(dependency);\n    return connection !== undefined ? connection.resolvedModule : null;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency to look for a referenced module\n   * @returns {ModuleGraphConnection | undefined} the connection\n   */\n  getConnection(dependency) {\n    const connection = this._dependencyMap.get(dependency);\n    if (connection === undefined) {\n      const module = this.getParentModule(dependency);\n      if (module !== undefined) {\n        const mgm = this._getModuleGraphModule(module);\n        if (mgm._unassignedConnections && mgm._unassignedConnections.length !== 0) {\n          let foundConnection;\n          for (const connection of mgm._unassignedConnections) {\n            this._dependencyMap.set(connection.dependency, connection);\n            if (connection.dependency === dependency) foundConnection = connection;\n          }\n          mgm._unassignedConnections.length = 0;\n          if (foundConnection !== undefined) {\n            return foundConnection;\n          }\n        }\n      }\n      this._dependencyMap.set(dependency, null);\n      return undefined;\n    }\n    return connection === null ? undefined : connection;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency to look for a referenced module\n   * @returns {Module} the referenced module\n   */\n  getModule(dependency) {\n    const connection = this.getConnection(dependency);\n    return connection !== undefined ? connection.module : null;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency to look for a referencing module\n   * @returns {Module} the referencing module\n   */\n  getOrigin(dependency) {\n    const connection = this.getConnection(dependency);\n    return connection !== undefined ? connection.originModule : null;\n  }\n\n  /**\n   * @param {Dependency} dependency the dependency to look for a referencing module\n   * @returns {Module} the original referencing module\n   */\n  getResolvedOrigin(dependency) {\n    const connection = this.getConnection(dependency);\n    return connection !== undefined ? connection.resolvedOriginModule : null;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {Iterable<ModuleGraphConnection>} reasons why a module is included\n   */\n  getIncomingConnections(module) {\n    const connections = this._getModuleGraphModule(module).incomingConnections;\n    return connections;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {Iterable<ModuleGraphConnection>} list of outgoing connections\n   */\n  getOutgoingConnections(module) {\n    const connections = this._getModuleGraphModule(module).outgoingConnections;\n    return connections === undefined ? EMPTY_SET : connections;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]>} reasons why a module is included, in a map by source module\n   */\n  getIncomingConnectionsByOriginModule(module) {\n    const connections = this._getModuleGraphModule(module).incomingConnections;\n    return connections.getFromUnorderedCache(getConnectionsByOriginModule);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]> | undefined} connections to modules, in a map by module\n   */\n  getOutgoingConnectionsByModule(module) {\n    const connections = this._getModuleGraphModule(module).outgoingConnections;\n    return connections === undefined ? undefined : connections.getFromUnorderedCache(getConnectionsByModule);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {ModuleProfile | null} the module profile\n   */\n  getProfile(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.profile;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {ModuleProfile | null} profile the module profile\n   * @returns {void}\n   */\n  setProfile(module, profile) {\n    const mgm = this._getModuleGraphModule(module);\n    mgm.profile = profile;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {Module | null} the issuer module\n   */\n  getIssuer(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.issuer;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {Module | null} issuer the issuer module\n   * @returns {void}\n   */\n  setIssuer(module, issuer) {\n    const mgm = this._getModuleGraphModule(module);\n    mgm.issuer = issuer;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {Module | null} issuer the issuer module\n   * @returns {void}\n   */\n  setIssuerIfUnset(module, issuer) {\n    const mgm = this._getModuleGraphModule(module);\n    if (mgm.issuer === undefined) mgm.issuer = issuer;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {(string | OptimizationBailoutFunction)[]} optimization bailouts\n   */\n  getOptimizationBailout(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.optimizationBailout;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {true | string[] | null} the provided exports\n   */\n  getProvidedExports(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.exports.getProvidedExports();\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {string | string[]} exportName a name of an export\n   * @returns {boolean | null} true, if the export is provided by the module.\n   * null, if it's unknown.\n   * false, if it's not provided.\n   */\n  isExportProvided(module, exportName) {\n    const mgm = this._getModuleGraphModule(module);\n    const result = mgm.exports.isExportProvided(exportName);\n    return result === undefined ? null : result;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {ExportsInfo} info about the exports\n   */\n  getExportsInfo(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.exports;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {string} exportName the export\n   * @returns {ExportInfo} info about the export\n   */\n  getExportInfo(module, exportName) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.exports.getExportInfo(exportName);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {string} exportName the export\n   * @returns {ExportInfo} info about the export (do not modify)\n   */\n  getReadOnlyExportInfo(module, exportName) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.exports.getReadOnlyExportInfo(exportName);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {false | true | SortableSet<string> | null} the used exports\n   * false: module is not used at all.\n   * true: the module namespace/object export is used.\n   * SortableSet<string>: these export names are used.\n   * empty SortableSet<string>: module is used but no export.\n   * null: unknown, worst case should be assumed.\n   */\n  getUsedExports(module, runtime) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.exports.getUsedExports(runtime);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {number} the index of the module\n   */\n  getPreOrderIndex(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.preOrderIndex;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {number} the index of the module\n   */\n  getPostOrderIndex(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.postOrderIndex;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n  setPreOrderIndex(module, index) {\n    const mgm = this._getModuleGraphModule(module);\n    mgm.preOrderIndex = index;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {number} index the index of the module\n   * @returns {boolean} true, if the index was set\n   */\n  setPreOrderIndexIfUnset(module, index) {\n    const mgm = this._getModuleGraphModule(module);\n    if (mgm.preOrderIndex === null) {\n      mgm.preOrderIndex = index;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n  setPostOrderIndex(module, index) {\n    const mgm = this._getModuleGraphModule(module);\n    mgm.postOrderIndex = index;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {number} index the index of the module\n   * @returns {boolean} true, if the index was set\n   */\n  setPostOrderIndexIfUnset(module, index) {\n    const mgm = this._getModuleGraphModule(module);\n    if (mgm.postOrderIndex === null) {\n      mgm.postOrderIndex = index;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {number} the depth of the module\n   */\n  getDepth(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.depth;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {number} depth the depth of the module\n   * @returns {void}\n   */\n  setDepth(module, depth) {\n    const mgm = this._getModuleGraphModule(module);\n    mgm.depth = depth;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {number} depth the depth of the module\n   * @returns {boolean} true, if the depth was set\n   */\n  setDepthIfLower(module, depth) {\n    const mgm = this._getModuleGraphModule(module);\n    if (mgm.depth === null || mgm.depth > depth) {\n      mgm.depth = depth;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, if the module is async\n   */\n  isAsync(module) {\n    const mgm = this._getModuleGraphModule(module);\n    return mgm.async;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n  setAsync(module) {\n    const mgm = this._getModuleGraphModule(module);\n    mgm.async = true;\n  }\n\n  /**\n   * @param {any} thing any thing\n   * @returns {Object} metadata\n   */\n  getMeta(thing) {\n    let meta = this._metaMap.get(thing);\n    if (meta === undefined) {\n      meta = Object.create(null);\n      this._metaMap.set(thing, meta);\n    }\n    return meta;\n  }\n\n  /**\n   * @param {any} thing any thing\n   * @returns {Object} metadata\n   */\n  getMetaIfExisting(thing) {\n    return this._metaMap.get(thing);\n  }\n\n  /**\n   * @param {string=} cacheStage a persistent stage name for caching\n   */\n  freeze(cacheStage) {\n    this._cache = new WeakTupleMap();\n    this._cacheStage = cacheStage;\n  }\n  unfreeze() {\n    this._cache = undefined;\n    this._cacheStage = undefined;\n  }\n\n  /**\n   * @template {any[]} T\n   * @template V\n   * @param {(moduleGraph: ModuleGraph, ...args: T) => V} fn computer\n   * @param {T} args arguments\n   * @returns {V} computed value or cached\n   */\n  cached(fn) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (this._cache === undefined) return fn(this, ...args);\n    return this._cache.provide(fn, ...args, () => fn(this, ...args));\n  }\n\n  /**\n   * @param {Map<Module, WeakTupleMap<any, any>>} moduleMemCaches mem caches for modules for better caching\n   */\n  setModuleMemCaches(moduleMemCaches) {\n    this._moduleMemCaches = moduleMemCaches;\n  }\n\n  /**\n   * @param {Dependency} dependency dependency\n   * @param {...any} args arguments, last argument is a function called with moduleGraph, dependency, ...args\n   * @returns {any} computed value or cached\n   */\n  dependencyCacheProvide(dependency) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    /** @type {(moduleGraph: ModuleGraph, dependency: Dependency, ...args: any[]) => any} */\n    const fn = args.pop();\n    if (this._moduleMemCaches && this._cacheStage) {\n      const memCache = this._moduleMemCaches.get(this.getParentModule(dependency));\n      if (memCache !== undefined) {\n        return memCache.provide(dependency, this._cacheStage, ...args, () => fn(this, dependency, ...args));\n      }\n    }\n    if (this._cache === undefined) return fn(this, dependency, ...args);\n    return this._cache.provide(dependency, ...args, () => fn(this, dependency, ...args));\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Module} module the module\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ModuleGraph} the module graph\n   */\n  static getModuleGraphForModule(module, deprecateMessage, deprecationCode) {\n    const fn = deprecateMap.get(deprecateMessage);\n    if (fn) return fn(module);\n    const newFn = util.deprecate(\n    /**\n     * @param {Module} module the module\n     * @returns {ModuleGraph} the module graph\n     */\n    module => {\n      const moduleGraph = moduleGraphForModuleMap.get(module);\n      if (!moduleGraph) throw new Error(deprecateMessage + \"There was no ModuleGraph assigned to the Module for backward-compat (Use the new API)\");\n      return moduleGraph;\n    }, deprecateMessage + \": Use new ModuleGraph API\", deprecationCode);\n    deprecateMap.set(deprecateMessage, newFn);\n    return newFn(module);\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Module} module the module\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @returns {void}\n   */\n  static setModuleGraphForModule(module, moduleGraph) {\n    moduleGraphForModuleMap.set(module, moduleGraph);\n  }\n\n  // TODO remove in webpack 6\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n  static clearModuleGraphForModule(module) {\n    moduleGraphForModuleMap.delete(module);\n  }\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ModuleGraph>} */\nconst moduleGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ModuleGraph>} */\nconst deprecateMap = new Map();\nmodule.exports = ModuleGraph;\nmodule.exports.ModuleGraphConnection = ModuleGraphConnection;","map":{"version":3,"names":["util","require","ExportsInfo","ModuleGraphConnection","SortableSet","WeakTupleMap","EMPTY_SET","Set","getConnectionsByOriginModule","set","map","Map","lastModule","lastList","undefined","connection","originModule","push","list","get","getConnectionsByModule","module","ModuleGraphModule","constructor","incomingConnections","outgoingConnections","issuer","optimizationBailout","exports","preOrderIndex","postOrderIndex","depth","profile","async","_unassignedConnections","ModuleGraph","_dependencyMap","WeakMap","_moduleMap","_metaMap","_cache","_moduleMemCaches","_cacheStage","_getModuleGraphModule","mgm","setParents","dependency","block","indexInBlock","arguments","length","_parentDependenciesBlockIndex","_parentDependenciesBlock","_parentModule","getParentModule","getParentBlock","getParentBlockIndex","setResolvedModule","weak","getCondition","connections","add","updateModule","getConnection","newConnection","clone","setActive","originMgm","targetMgm","removeConnection","delete","addExplanation","explanation","cloneModuleAttributes","sourceModule","targetModule","oldMgm","newMgm","removeModuleAttributes","removeAllModuleAttributes","values","moveModuleConnections","oldModule","newModule","filterConnection","oldConnections","newConnections","oldConnections2","newConnections2","copyOutgoingModuleConnections","otherMgm","addExtraReason","getResolvedModule","resolvedModule","foundConnection","getModule","getOrigin","getResolvedOrigin","resolvedOriginModule","getIncomingConnections","getOutgoingConnections","getIncomingConnectionsByOriginModule","getFromUnorderedCache","getOutgoingConnectionsByModule","getProfile","setProfile","getIssuer","setIssuer","setIssuerIfUnset","getOptimizationBailout","getProvidedExports","isExportProvided","exportName","result","getExportsInfo","getExportInfo","getReadOnlyExportInfo","getUsedExports","runtime","getPreOrderIndex","getPostOrderIndex","setPreOrderIndex","index","setPreOrderIndexIfUnset","setPostOrderIndex","setPostOrderIndexIfUnset","getDepth","setDepth","setDepthIfLower","isAsync","setAsync","getMeta","thing","meta","Object","create","getMetaIfExisting","freeze","cacheStage","unfreeze","cached","fn","_len","args","Array","_key","provide","setModuleMemCaches","moduleMemCaches","dependencyCacheProvide","_len2","_key2","pop","memCache","getModuleGraphForModule","deprecateMessage","deprecationCode","deprecateMap","newFn","deprecate","moduleGraph","moduleGraphForModuleMap","Error","setModuleGraphForModule","clearModuleGraphForModule"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/ModuleGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst ExportsInfo = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst WeakTupleMap = require(\"./util/WeakTupleMap\");\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./ExportsInfo\").ExportInfo} ExportInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleProfile\")} ModuleProfile */\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @callback OptimizationBailoutFunction\n * @param {RequestShortener} requestShortener\n * @returns {string}\n */\n\nconst EMPTY_SET = new Set();\n\n/**\n * @param {SortableSet<ModuleGraphConnection>} set input\n * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]>} mapped by origin module\n */\nconst getConnectionsByOriginModule = set => {\n\tconst map = new Map();\n\t/** @type {Module | 0} */\n\tlet lastModule = 0;\n\t/** @type {ModuleGraphConnection[]} */\n\tlet lastList = undefined;\n\tfor (const connection of set) {\n\t\tconst { originModule } = connection;\n\t\tif (lastModule === originModule) {\n\t\t\tlastList.push(connection);\n\t\t} else {\n\t\t\tlastModule = originModule;\n\t\t\tconst list = map.get(originModule);\n\t\t\tif (list !== undefined) {\n\t\t\t\tlastList = list;\n\t\t\t\tlist.push(connection);\n\t\t\t} else {\n\t\t\t\tconst list = [connection];\n\t\t\t\tlastList = list;\n\t\t\t\tmap.set(originModule, list);\n\t\t\t}\n\t\t}\n\t}\n\treturn map;\n};\n\n/**\n * @param {SortableSet<ModuleGraphConnection>} set input\n * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]>} mapped by module\n */\nconst getConnectionsByModule = set => {\n\tconst map = new Map();\n\t/** @type {Module | 0} */\n\tlet lastModule = 0;\n\t/** @type {ModuleGraphConnection[]} */\n\tlet lastList = undefined;\n\tfor (const connection of set) {\n\t\tconst { module } = connection;\n\t\tif (lastModule === module) {\n\t\t\tlastList.push(connection);\n\t\t} else {\n\t\t\tlastModule = module;\n\t\t\tconst list = map.get(module);\n\t\t\tif (list !== undefined) {\n\t\t\t\tlastList = list;\n\t\t\t\tlist.push(connection);\n\t\t\t} else {\n\t\t\t\tconst list = [connection];\n\t\t\t\tlastList = list;\n\t\t\t\tmap.set(module, list);\n\t\t\t}\n\t\t}\n\t}\n\treturn map;\n};\n\nclass ModuleGraphModule {\n\tconstructor() {\n\t\t/** @type {SortableSet<ModuleGraphConnection>} */\n\t\tthis.incomingConnections = new SortableSet();\n\t\t/** @type {SortableSet<ModuleGraphConnection> | undefined} */\n\t\tthis.outgoingConnections = undefined;\n\t\t/** @type {Module | null} */\n\t\tthis.issuer = undefined;\n\t\t/** @type {(string | OptimizationBailoutFunction)[]} */\n\t\tthis.optimizationBailout = [];\n\t\t/** @type {ExportsInfo} */\n\t\tthis.exports = new ExportsInfo();\n\t\t/** @type {number} */\n\t\tthis.preOrderIndex = null;\n\t\t/** @type {number} */\n\t\tthis.postOrderIndex = null;\n\t\t/** @type {number} */\n\t\tthis.depth = null;\n\t\t/** @type {ModuleProfile} */\n\t\tthis.profile = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.async = false;\n\t\t/** @type {ModuleGraphConnection[]} */\n\t\tthis._unassignedConnections = undefined;\n\t}\n}\n\nclass ModuleGraph {\n\tconstructor() {\n\t\t/** @type {WeakMap<Dependency, ModuleGraphConnection>} */\n\t\tthis._dependencyMap = new WeakMap();\n\t\t/** @type {Map<Module, ModuleGraphModule>} */\n\t\tthis._moduleMap = new Map();\n\t\t/** @type {WeakMap<any, Object>} */\n\t\tthis._metaMap = new WeakMap();\n\n\t\t/** @type {WeakTupleMap<any[], any>} */\n\t\tthis._cache = undefined;\n\n\t\t/** @type {Map<Module, WeakTupleMap<any, any>>} */\n\t\tthis._moduleMemCaches = undefined;\n\n\t\t/** @type {string} */\n\t\tthis._cacheStage = undefined;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {ModuleGraphModule} the internal module\n\t */\n\t_getModuleGraphModule(module) {\n\t\tlet mgm = this._moduleMap.get(module);\n\t\tif (mgm === undefined) {\n\t\t\tmgm = new ModuleGraphModule();\n\t\t\tthis._moduleMap.set(module, mgm);\n\t\t}\n\t\treturn mgm;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency\n\t * @param {DependenciesBlock} block parent block\n\t * @param {Module} module parent module\n\t * @param {number=} indexInBlock position in block\n\t * @returns {void}\n\t */\n\tsetParents(dependency, block, module, indexInBlock = -1) {\n\t\tdependency._parentDependenciesBlockIndex = indexInBlock;\n\t\tdependency._parentDependenciesBlock = block;\n\t\tdependency._parentModule = module;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency\n\t * @returns {Module} parent module\n\t */\n\tgetParentModule(dependency) {\n\t\treturn dependency._parentModule;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency\n\t * @returns {DependenciesBlock} parent block\n\t */\n\tgetParentBlock(dependency) {\n\t\treturn dependency._parentDependenciesBlock;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency\n\t * @returns {number} index\n\t */\n\tgetParentBlockIndex(dependency) {\n\t\treturn dependency._parentDependenciesBlockIndex;\n\t}\n\n\t/**\n\t * @param {Module} originModule the referencing module\n\t * @param {Dependency} dependency the referencing dependency\n\t * @param {Module} module the referenced module\n\t * @returns {void}\n\t */\n\tsetResolvedModule(originModule, dependency, module) {\n\t\tconst connection = new ModuleGraphConnection(\n\t\t\toriginModule,\n\t\t\tdependency,\n\t\t\tmodule,\n\t\t\tundefined,\n\t\t\tdependency.weak,\n\t\t\tdependency.getCondition(this)\n\t\t);\n\t\tconst connections = this._getModuleGraphModule(module).incomingConnections;\n\t\tconnections.add(connection);\n\t\tif (originModule) {\n\t\t\tconst mgm = this._getModuleGraphModule(originModule);\n\t\t\tif (mgm._unassignedConnections === undefined) {\n\t\t\t\tmgm._unassignedConnections = [];\n\t\t\t}\n\t\t\tmgm._unassignedConnections.push(connection);\n\t\t\tif (mgm.outgoingConnections === undefined) {\n\t\t\t\tmgm.outgoingConnections = new SortableSet();\n\t\t\t}\n\t\t\tmgm.outgoingConnections.add(connection);\n\t\t} else {\n\t\t\tthis._dependencyMap.set(dependency, connection);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the referencing dependency\n\t * @param {Module} module the referenced module\n\t * @returns {void}\n\t */\n\tupdateModule(dependency, module) {\n\t\tconst connection = this.getConnection(dependency);\n\t\tif (connection.module === module) return;\n\t\tconst newConnection = connection.clone();\n\t\tnewConnection.module = module;\n\t\tthis._dependencyMap.set(dependency, newConnection);\n\t\tconnection.setActive(false);\n\t\tconst originMgm = this._getModuleGraphModule(connection.originModule);\n\t\toriginMgm.outgoingConnections.add(newConnection);\n\t\tconst targetMgm = this._getModuleGraphModule(module);\n\t\ttargetMgm.incomingConnections.add(newConnection);\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the referencing dependency\n\t * @returns {void}\n\t */\n\tremoveConnection(dependency) {\n\t\tconst connection = this.getConnection(dependency);\n\t\tconst targetMgm = this._getModuleGraphModule(connection.module);\n\t\ttargetMgm.incomingConnections.delete(connection);\n\t\tconst originMgm = this._getModuleGraphModule(connection.originModule);\n\t\toriginMgm.outgoingConnections.delete(connection);\n\t\tthis._dependencyMap.set(dependency, null);\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the referencing dependency\n\t * @param {string} explanation an explanation\n\t * @returns {void}\n\t */\n\taddExplanation(dependency, explanation) {\n\t\tconst connection = this.getConnection(dependency);\n\t\tconnection.addExplanation(explanation);\n\t}\n\n\t/**\n\t * @param {Module} sourceModule the source module\n\t * @param {Module} targetModule the target module\n\t * @returns {void}\n\t */\n\tcloneModuleAttributes(sourceModule, targetModule) {\n\t\tconst oldMgm = this._getModuleGraphModule(sourceModule);\n\t\tconst newMgm = this._getModuleGraphModule(targetModule);\n\t\tnewMgm.postOrderIndex = oldMgm.postOrderIndex;\n\t\tnewMgm.preOrderIndex = oldMgm.preOrderIndex;\n\t\tnewMgm.depth = oldMgm.depth;\n\t\tnewMgm.exports = oldMgm.exports;\n\t\tnewMgm.async = oldMgm.async;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tremoveModuleAttributes(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tmgm.postOrderIndex = null;\n\t\tmgm.preOrderIndex = null;\n\t\tmgm.depth = null;\n\t\tmgm.async = false;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremoveAllModuleAttributes() {\n\t\tfor (const mgm of this._moduleMap.values()) {\n\t\t\tmgm.postOrderIndex = null;\n\t\t\tmgm.preOrderIndex = null;\n\t\t\tmgm.depth = null;\n\t\t\tmgm.async = false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the old referencing module\n\t * @param {Module} newModule the new referencing module\n\t * @param {function(ModuleGraphConnection): boolean} filterConnection filter predicate for replacement\n\t * @returns {void}\n\t */\n\tmoveModuleConnections(oldModule, newModule, filterConnection) {\n\t\tif (oldModule === newModule) return;\n\t\tconst oldMgm = this._getModuleGraphModule(oldModule);\n\t\tconst newMgm = this._getModuleGraphModule(newModule);\n\t\t// Outgoing connections\n\t\tconst oldConnections = oldMgm.outgoingConnections;\n\t\tif (oldConnections !== undefined) {\n\t\t\tif (newMgm.outgoingConnections === undefined) {\n\t\t\t\tnewMgm.outgoingConnections = new SortableSet();\n\t\t\t}\n\t\t\tconst newConnections = newMgm.outgoingConnections;\n\t\t\tfor (const connection of oldConnections) {\n\t\t\t\tif (filterConnection(connection)) {\n\t\t\t\t\tconnection.originModule = newModule;\n\t\t\t\t\tnewConnections.add(connection);\n\t\t\t\t\toldConnections.delete(connection);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Incoming connections\n\t\tconst oldConnections2 = oldMgm.incomingConnections;\n\t\tconst newConnections2 = newMgm.incomingConnections;\n\t\tfor (const connection of oldConnections2) {\n\t\t\tif (filterConnection(connection)) {\n\t\t\t\tconnection.module = newModule;\n\t\t\t\tnewConnections2.add(connection);\n\t\t\t\toldConnections2.delete(connection);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the old referencing module\n\t * @param {Module} newModule the new referencing module\n\t * @param {function(ModuleGraphConnection): boolean} filterConnection filter predicate for replacement\n\t * @returns {void}\n\t */\n\tcopyOutgoingModuleConnections(oldModule, newModule, filterConnection) {\n\t\tif (oldModule === newModule) return;\n\t\tconst oldMgm = this._getModuleGraphModule(oldModule);\n\t\tconst newMgm = this._getModuleGraphModule(newModule);\n\t\t// Outgoing connections\n\t\tconst oldConnections = oldMgm.outgoingConnections;\n\t\tif (oldConnections !== undefined) {\n\t\t\tif (newMgm.outgoingConnections === undefined) {\n\t\t\t\tnewMgm.outgoingConnections = new SortableSet();\n\t\t\t}\n\t\t\tconst newConnections = newMgm.outgoingConnections;\n\t\t\tfor (const connection of oldConnections) {\n\t\t\t\tif (filterConnection(connection)) {\n\t\t\t\t\tconst newConnection = connection.clone();\n\t\t\t\t\tnewConnection.originModule = newModule;\n\t\t\t\t\tnewConnections.add(newConnection);\n\t\t\t\t\tif (newConnection.module !== undefined) {\n\t\t\t\t\t\tconst otherMgm = this._getModuleGraphModule(newConnection.module);\n\t\t\t\t\t\totherMgm.incomingConnections.add(newConnection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the referenced module\n\t * @param {string} explanation an explanation why it's referenced\n\t * @returns {void}\n\t */\n\taddExtraReason(module, explanation) {\n\t\tconst connections = this._getModuleGraphModule(module).incomingConnections;\n\t\tconnections.add(new ModuleGraphConnection(null, null, module, explanation));\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency to look for a referenced module\n\t * @returns {Module} the referenced module\n\t */\n\tgetResolvedModule(dependency) {\n\t\tconst connection = this.getConnection(dependency);\n\t\treturn connection !== undefined ? connection.resolvedModule : null;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency to look for a referenced module\n\t * @returns {ModuleGraphConnection | undefined} the connection\n\t */\n\tgetConnection(dependency) {\n\t\tconst connection = this._dependencyMap.get(dependency);\n\t\tif (connection === undefined) {\n\t\t\tconst module = this.getParentModule(dependency);\n\t\t\tif (module !== undefined) {\n\t\t\t\tconst mgm = this._getModuleGraphModule(module);\n\t\t\t\tif (\n\t\t\t\t\tmgm._unassignedConnections &&\n\t\t\t\t\tmgm._unassignedConnections.length !== 0\n\t\t\t\t) {\n\t\t\t\t\tlet foundConnection;\n\t\t\t\t\tfor (const connection of mgm._unassignedConnections) {\n\t\t\t\t\t\tthis._dependencyMap.set(connection.dependency, connection);\n\t\t\t\t\t\tif (connection.dependency === dependency)\n\t\t\t\t\t\t\tfoundConnection = connection;\n\t\t\t\t\t}\n\t\t\t\t\tmgm._unassignedConnections.length = 0;\n\t\t\t\t\tif (foundConnection !== undefined) {\n\t\t\t\t\t\treturn foundConnection;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dependencyMap.set(dependency, null);\n\t\t\treturn undefined;\n\t\t}\n\t\treturn connection === null ? undefined : connection;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency to look for a referenced module\n\t * @returns {Module} the referenced module\n\t */\n\tgetModule(dependency) {\n\t\tconst connection = this.getConnection(dependency);\n\t\treturn connection !== undefined ? connection.module : null;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency to look for a referencing module\n\t * @returns {Module} the referencing module\n\t */\n\tgetOrigin(dependency) {\n\t\tconst connection = this.getConnection(dependency);\n\t\treturn connection !== undefined ? connection.originModule : null;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency the dependency to look for a referencing module\n\t * @returns {Module} the original referencing module\n\t */\n\tgetResolvedOrigin(dependency) {\n\t\tconst connection = this.getConnection(dependency);\n\t\treturn connection !== undefined ? connection.resolvedOriginModule : null;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<ModuleGraphConnection>} reasons why a module is included\n\t */\n\tgetIncomingConnections(module) {\n\t\tconst connections = this._getModuleGraphModule(module).incomingConnections;\n\t\treturn connections;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<ModuleGraphConnection>} list of outgoing connections\n\t */\n\tgetOutgoingConnections(module) {\n\t\tconst connections = this._getModuleGraphModule(module).outgoingConnections;\n\t\treturn connections === undefined ? EMPTY_SET : connections;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]>} reasons why a module is included, in a map by source module\n\t */\n\tgetIncomingConnectionsByOriginModule(module) {\n\t\tconst connections = this._getModuleGraphModule(module).incomingConnections;\n\t\treturn connections.getFromUnorderedCache(getConnectionsByOriginModule);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {readonly Map<Module | undefined, readonly ModuleGraphConnection[]> | undefined} connections to modules, in a map by module\n\t */\n\tgetOutgoingConnectionsByModule(module) {\n\t\tconst connections = this._getModuleGraphModule(module).outgoingConnections;\n\t\treturn connections === undefined\n\t\t\t? undefined\n\t\t\t: connections.getFromUnorderedCache(getConnectionsByModule);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {ModuleProfile | null} the module profile\n\t */\n\tgetProfile(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.profile;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {ModuleProfile | null} profile the module profile\n\t * @returns {void}\n\t */\n\tsetProfile(module, profile) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tmgm.profile = profile;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Module | null} the issuer module\n\t */\n\tgetIssuer(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.issuer;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Module | null} issuer the issuer module\n\t * @returns {void}\n\t */\n\tsetIssuer(module, issuer) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tmgm.issuer = issuer;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Module | null} issuer the issuer module\n\t * @returns {void}\n\t */\n\tsetIssuerIfUnset(module, issuer) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tif (mgm.issuer === undefined) mgm.issuer = issuer;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {(string | OptimizationBailoutFunction)[]} optimization bailouts\n\t */\n\tgetOptimizationBailout(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.optimizationBailout;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {true | string[] | null} the provided exports\n\t */\n\tgetProvidedExports(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.exports.getProvidedExports();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string | string[]} exportName a name of an export\n\t * @returns {boolean | null} true, if the export is provided by the module.\n\t * null, if it's unknown.\n\t * false, if it's not provided.\n\t */\n\tisExportProvided(module, exportName) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tconst result = mgm.exports.isExportProvided(exportName);\n\t\treturn result === undefined ? null : result;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {ExportsInfo} info about the exports\n\t */\n\tgetExportsInfo(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.exports;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} exportName the export\n\t * @returns {ExportInfo} info about the export\n\t */\n\tgetExportInfo(module, exportName) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.exports.getExportInfo(exportName);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} exportName the export\n\t * @returns {ExportInfo} info about the export (do not modify)\n\t */\n\tgetReadOnlyExportInfo(module, exportName) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.exports.getReadOnlyExportInfo(exportName);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {false | true | SortableSet<string> | null} the used exports\n\t * false: module is not used at all.\n\t * true: the module namespace/object export is used.\n\t * SortableSet<string>: these export names are used.\n\t * empty SortableSet<string>: module is used but no export.\n\t * null: unknown, worst case should be assumed.\n\t */\n\tgetUsedExports(module, runtime) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.exports.getUsedExports(runtime);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the index of the module\n\t */\n\tgetPreOrderIndex(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.preOrderIndex;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the index of the module\n\t */\n\tgetPostOrderIndex(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.postOrderIndex;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetPreOrderIndex(module, index) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tmgm.preOrderIndex = index;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {number} index the index of the module\n\t * @returns {boolean} true, if the index was set\n\t */\n\tsetPreOrderIndexIfUnset(module, index) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tif (mgm.preOrderIndex === null) {\n\t\t\tmgm.preOrderIndex = index;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetPostOrderIndex(module, index) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tmgm.postOrderIndex = index;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {number} index the index of the module\n\t * @returns {boolean} true, if the index was set\n\t */\n\tsetPostOrderIndexIfUnset(module, index) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tif (mgm.postOrderIndex === null) {\n\t\t\tmgm.postOrderIndex = index;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the depth of the module\n\t */\n\tgetDepth(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.depth;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {number} depth the depth of the module\n\t * @returns {void}\n\t */\n\tsetDepth(module, depth) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tmgm.depth = depth;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {number} depth the depth of the module\n\t * @returns {boolean} true, if the depth was set\n\t */\n\tsetDepthIfLower(module, depth) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tif (mgm.depth === null || mgm.depth > depth) {\n\t\t\tmgm.depth = depth;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the module is async\n\t */\n\tisAsync(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\treturn mgm.async;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tsetAsync(module) {\n\t\tconst mgm = this._getModuleGraphModule(module);\n\t\tmgm.async = true;\n\t}\n\n\t/**\n\t * @param {any} thing any thing\n\t * @returns {Object} metadata\n\t */\n\tgetMeta(thing) {\n\t\tlet meta = this._metaMap.get(thing);\n\t\tif (meta === undefined) {\n\t\t\tmeta = Object.create(null);\n\t\t\tthis._metaMap.set(thing, meta);\n\t\t}\n\t\treturn meta;\n\t}\n\n\t/**\n\t * @param {any} thing any thing\n\t * @returns {Object} metadata\n\t */\n\tgetMetaIfExisting(thing) {\n\t\treturn this._metaMap.get(thing);\n\t}\n\n\t/**\n\t * @param {string=} cacheStage a persistent stage name for caching\n\t */\n\tfreeze(cacheStage) {\n\t\tthis._cache = new WeakTupleMap();\n\t\tthis._cacheStage = cacheStage;\n\t}\n\n\tunfreeze() {\n\t\tthis._cache = undefined;\n\t\tthis._cacheStage = undefined;\n\t}\n\n\t/**\n\t * @template {any[]} T\n\t * @template V\n\t * @param {(moduleGraph: ModuleGraph, ...args: T) => V} fn computer\n\t * @param {T} args arguments\n\t * @returns {V} computed value or cached\n\t */\n\tcached(fn, ...args) {\n\t\tif (this._cache === undefined) return fn(this, ...args);\n\t\treturn this._cache.provide(fn, ...args, () => fn(this, ...args));\n\t}\n\n\t/**\n\t * @param {Map<Module, WeakTupleMap<any, any>>} moduleMemCaches mem caches for modules for better caching\n\t */\n\tsetModuleMemCaches(moduleMemCaches) {\n\t\tthis._moduleMemCaches = moduleMemCaches;\n\t}\n\n\t/**\n\t * @param {Dependency} dependency dependency\n\t * @param {...any} args arguments, last argument is a function called with moduleGraph, dependency, ...args\n\t * @returns {any} computed value or cached\n\t */\n\tdependencyCacheProvide(dependency, ...args) {\n\t\t/** @type {(moduleGraph: ModuleGraph, dependency: Dependency, ...args: any[]) => any} */\n\t\tconst fn = args.pop();\n\t\tif (this._moduleMemCaches && this._cacheStage) {\n\t\t\tconst memCache = this._moduleMemCaches.get(\n\t\t\t\tthis.getParentModule(dependency)\n\t\t\t);\n\t\t\tif (memCache !== undefined) {\n\t\t\t\treturn memCache.provide(dependency, this._cacheStage, ...args, () =>\n\t\t\t\t\tfn(this, dependency, ...args)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (this._cache === undefined) return fn(this, dependency, ...args);\n\t\treturn this._cache.provide(dependency, ...args, () =>\n\t\t\tfn(this, dependency, ...args)\n\t\t);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ModuleGraph} the module graph\n\t */\n\tstatic getModuleGraphForModule(module, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateMap.get(deprecateMessage);\n\t\tif (fn) return fn(module);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {ModuleGraph} the module graph\n\t\t\t */\n\t\t\tmodule => {\n\t\t\t\tconst moduleGraph = moduleGraphForModuleMap.get(module);\n\t\t\t\tif (!moduleGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\"There was no ModuleGraph assigned to the Module for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn moduleGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ModuleGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateMap.set(deprecateMessage, newFn);\n\t\treturn newFn(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @returns {void}\n\t */\n\tstatic setModuleGraphForModule(module, moduleGraph) {\n\t\tmoduleGraphForModuleMap.set(module, moduleGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tstatic clearModuleGraphForModule(module) {\n\t\tmoduleGraphForModuleMap.delete(module);\n\t}\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ModuleGraph>} */\nconst moduleGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ModuleGraph>} */\nconst deprecateMap = new Map();\n\nmodule.exports = ModuleGraph;\nmodule.exports.ModuleGraphConnection = ModuleGraphConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}