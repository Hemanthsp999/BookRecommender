{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\nconst stringsAsRawSources = new WeakSet();\nclass ConcatSource extends Source {\n  constructor() {\n    super();\n    this._children = [];\n    for (let i = 0; i < arguments.length; i++) {\n      const item = arguments[i];\n      if (item instanceof ConcatSource) {\n        for (const child of item._children) {\n          this._children.push(child);\n        }\n      } else {\n        this._children.push(item);\n      }\n    }\n    this._isOptimized = arguments.length === 0;\n  }\n  getChildren() {\n    if (!this._isOptimized) this._optimize();\n    return this._children;\n  }\n  add(item) {\n    if (item instanceof ConcatSource) {\n      for (const child of item._children) {\n        this._children.push(child);\n      }\n    } else {\n      this._children.push(item);\n    }\n    this._isOptimized = false;\n  }\n  addAllSkipOptimizing(items) {\n    for (const item of items) {\n      this._children.push(item);\n    }\n  }\n  buffer() {\n    if (!this._isOptimized) this._optimize();\n    const buffers = [];\n    for (const child of this._children) {\n      if (typeof child.buffer === \"function\") {\n        buffers.push(child.buffer());\n      } else {\n        const bufferOrString = child.source();\n        if (Buffer.isBuffer(bufferOrString)) {\n          buffers.push(bufferOrString);\n        } else {\n          // This will not happen\n          buffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n        }\n      }\n    }\n    return Buffer.concat(buffers);\n  }\n  source() {\n    if (!this._isOptimized) this._optimize();\n    let source = \"\";\n    for (const child of this._children) {\n      source += child.source();\n    }\n    return source;\n  }\n  size() {\n    if (!this._isOptimized) this._optimize();\n    let size = 0;\n    for (const child of this._children) {\n      size += child.size();\n    }\n    return size;\n  }\n  map(options) {\n    return getMap(this, options);\n  }\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n  streamChunks(options, onChunk, onSource, onName) {\n    if (!this._isOptimized) this._optimize();\n    if (this._children.length === 1) return this._children[0].streamChunks(options, onChunk, onSource, onName);\n    let currentLineOffset = 0;\n    let currentColumnOffset = 0;\n    let sourceMapping = new Map();\n    let nameMapping = new Map();\n    const finalSource = !!(options && options.finalSource);\n    let code = \"\";\n    let needToCloseMapping = false;\n    for (const item of this._children) {\n      const sourceIndexMapping = [];\n      const nameIndexMapping = [];\n      let lastMappingLine = 0;\n      const {\n        generatedLine,\n        generatedColumn,\n        source\n      } = streamChunks(item, options,\n      // eslint-disable-next-line no-loop-func\n      (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {\n        const line = generatedLine + currentLineOffset;\n        const column = generatedLine === 1 ? generatedColumn + currentColumnOffset : generatedColumn;\n        if (needToCloseMapping) {\n          if (generatedLine !== 1 || generatedColumn !== 0) {\n            onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n          }\n          needToCloseMapping = false;\n        }\n        const resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];\n        const resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];\n        lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n        if (finalSource) {\n          if (chunk !== undefined) code += chunk;\n          if (resultSourceIndex >= 0) {\n            onChunk(undefined, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n          }\n        } else {\n          if (resultSourceIndex < 0) {\n            onChunk(chunk, line, column, -1, -1, -1, -1);\n          } else {\n            onChunk(chunk, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n          }\n        }\n      }, (i, source, sourceContent) => {\n        let globalIndex = sourceMapping.get(source);\n        if (globalIndex === undefined) {\n          sourceMapping.set(source, globalIndex = sourceMapping.size);\n          onSource(globalIndex, source, sourceContent);\n        }\n        sourceIndexMapping[i] = globalIndex;\n      }, (i, name) => {\n        let globalIndex = nameMapping.get(name);\n        if (globalIndex === undefined) {\n          nameMapping.set(name, globalIndex = nameMapping.size);\n          onName(globalIndex, name);\n        }\n        nameIndexMapping[i] = globalIndex;\n      });\n      if (source !== undefined) code += source;\n      if (needToCloseMapping) {\n        if (generatedLine !== 1 || generatedColumn !== 0) {\n          onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n          needToCloseMapping = false;\n        }\n      }\n      if (generatedLine > 1) {\n        currentColumnOffset = generatedColumn;\n      } else {\n        currentColumnOffset += generatedColumn;\n      }\n      needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;\n      currentLineOffset += generatedLine - 1;\n    }\n    return {\n      generatedLine: currentLineOffset + 1,\n      generatedColumn: currentColumnOffset,\n      source: finalSource ? code : undefined\n    };\n  }\n  updateHash(hash) {\n    if (!this._isOptimized) this._optimize();\n    hash.update(\"ConcatSource\");\n    for (const item of this._children) {\n      item.updateHash(hash);\n    }\n  }\n  _optimize() {\n    const newChildren = [];\n    let currentString = undefined;\n    let currentRawSources = undefined;\n    const addStringToRawSources = string => {\n      if (currentRawSources === undefined) {\n        currentRawSources = string;\n      } else if (Array.isArray(currentRawSources)) {\n        currentRawSources.push(string);\n      } else {\n        currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), string];\n      }\n    };\n    const addSourceToRawSources = source => {\n      if (currentRawSources === undefined) {\n        currentRawSources = source;\n      } else if (Array.isArray(currentRawSources)) {\n        currentRawSources.push(source.source());\n      } else {\n        currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), source.source()];\n      }\n    };\n    const mergeRawSources = () => {\n      if (Array.isArray(currentRawSources)) {\n        const rawSource = new RawSource(currentRawSources.join(\"\"));\n        stringsAsRawSources.add(rawSource);\n        newChildren.push(rawSource);\n      } else if (typeof currentRawSources === \"string\") {\n        const rawSource = new RawSource(currentRawSources);\n        stringsAsRawSources.add(rawSource);\n        newChildren.push(rawSource);\n      } else {\n        newChildren.push(currentRawSources);\n      }\n    };\n    for (const child of this._children) {\n      if (typeof child === \"string\") {\n        if (currentString === undefined) {\n          currentString = child;\n        } else {\n          currentString += child;\n        }\n      } else {\n        if (currentString !== undefined) {\n          addStringToRawSources(currentString);\n          currentString = undefined;\n        }\n        if (stringsAsRawSources.has(child)) {\n          addSourceToRawSources(child);\n        } else {\n          if (currentRawSources !== undefined) {\n            mergeRawSources();\n            currentRawSources = undefined;\n          }\n          newChildren.push(child);\n        }\n      }\n    }\n    if (currentString !== undefined) {\n      addStringToRawSources(currentString);\n    }\n    if (currentRawSources !== undefined) {\n      mergeRawSources();\n    }\n    this._children = newChildren;\n    this._isOptimized = true;\n  }\n}\nmodule.exports = ConcatSource;","map":{"version":3,"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","stringsAsRawSources","WeakSet","ConcatSource","constructor","_children","i","arguments","length","item","child","push","_isOptimized","getChildren","_optimize","add","addAllSkipOptimizing","items","buffer","buffers","bufferOrString","source","Buffer","isBuffer","from","concat","size","map","options","sourceAndMap","onChunk","onSource","onName","currentLineOffset","currentColumnOffset","sourceMapping","Map","nameMapping","finalSource","code","needToCloseMapping","sourceIndexMapping","nameIndexMapping","lastMappingLine","generatedLine","generatedColumn","chunk","sourceIndex","originalLine","originalColumn","nameIndex","line","column","undefined","resultSourceIndex","resultNameIndex","sourceContent","globalIndex","get","set","name","updateHash","hash","update","newChildren","currentString","currentRawSources","addStringToRawSources","string","Array","isArray","addSourceToRawSources","mergeRawSources","rawSource","join","has","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack-sources/lib/ConcatSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\n\nconst stringsAsRawSources = new WeakSet();\n\nclass ConcatSource extends Source {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._children = [];\n\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\tconst item = arguments[i];\n\t\t\tif (item instanceof ConcatSource) {\n\t\t\t\tfor (const child of item._children) {\n\t\t\t\t\tthis._children.push(child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._children.push(item);\n\t\t\t}\n\t\t}\n\t\tthis._isOptimized = arguments.length === 0;\n\t}\n\n\tgetChildren() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\treturn this._children;\n\t}\n\n\tadd(item) {\n\t\tif (item instanceof ConcatSource) {\n\t\t\tfor (const child of item._children) {\n\t\t\t\tthis._children.push(child);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._children.push(item);\n\t\t}\n\t\tthis._isOptimized = false;\n\t}\n\n\taddAllSkipOptimizing(items) {\n\t\tfor (const item of items) {\n\t\t\tthis._children.push(item);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tconst buffers = [];\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child.buffer === \"function\") {\n\t\t\t\tbuffers.push(child.buffer());\n\t\t\t} else {\n\t\t\t\tconst bufferOrString = child.source();\n\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\tbuffers.push(bufferOrString);\n\t\t\t\t} else {\n\t\t\t\t\t// This will not happen\n\t\t\t\t\tbuffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Buffer.concat(buffers);\n\t}\n\n\tsource() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet source = \"\";\n\t\tfor (const child of this._children) {\n\t\t\tsource += child.source();\n\t\t}\n\t\treturn source;\n\t}\n\n\tsize() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet size = 0;\n\t\tfor (const child of this._children) {\n\t\t\tsize += child.size();\n\t\t}\n\t\treturn size;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tif (this._children.length === 1)\n\t\t\treturn this._children[0].streamChunks(options, onChunk, onSource, onName);\n\t\tlet currentLineOffset = 0;\n\t\tlet currentColumnOffset = 0;\n\t\tlet sourceMapping = new Map();\n\t\tlet nameMapping = new Map();\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tlet code = \"\";\n\t\tlet needToCloseMapping = false;\n\t\tfor (const item of this._children) {\n\t\t\tconst sourceIndexMapping = [];\n\t\t\tconst nameIndexMapping = [];\n\t\t\tlet lastMappingLine = 0;\n\t\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\t\titem,\n\t\t\t\toptions,\n\t\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\t\t(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t) => {\n\t\t\t\t\tconst line = generatedLine + currentLineOffset;\n\t\t\t\t\tconst column =\n\t\t\t\t\t\tgeneratedLine === 1\n\t\t\t\t\t\t\t? generatedColumn + currentColumnOffset\n\t\t\t\t\t\t\t: generatedColumn;\n\t\t\t\t\tif (needToCloseMapping) {\n\t\t\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t\t}\n\t\t\t\t\tconst resultSourceIndex =\n\t\t\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\t\t\tconst resultNameIndex =\n\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: nameIndexMapping[nameIndex];\n\t\t\t\t\tlastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\t\t\t\t\tif (finalSource) {\n\t\t\t\t\t\tif (chunk !== undefined) code += chunk;\n\t\t\t\t\t\tif (resultSourceIndex >= 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (resultSourceIndex < 0) {\n\t\t\t\t\t\t\tonChunk(chunk, line, column, -1, -1, -1, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t\t},\n\t\t\t\t(i, name) => {\n\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t}\n\t\t\t\t\tnameIndexMapping[i] = globalIndex;\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (source !== undefined) code += source;\n\t\t\tif (needToCloseMapping) {\n\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1\n\t\t\t\t\t);\n\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (generatedLine > 1) {\n\t\t\t\tcurrentColumnOffset = generatedColumn;\n\t\t\t} else {\n\t\t\t\tcurrentColumnOffset += generatedColumn;\n\t\t\t}\n\t\t\tneedToCloseMapping =\n\t\t\t\tneedToCloseMapping ||\n\t\t\t\t(finalSource && lastMappingLine === generatedLine);\n\t\t\tcurrentLineOffset += generatedLine - 1;\n\t\t}\n\t\treturn {\n\t\t\tgeneratedLine: currentLineOffset + 1,\n\t\t\tgeneratedColumn: currentColumnOffset,\n\t\t\tsource: finalSource ? code : undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\thash.update(\"ConcatSource\");\n\t\tfor (const item of this._children) {\n\t\t\titem.updateHash(hash);\n\t\t}\n\t}\n\n\t_optimize() {\n\t\tconst newChildren = [];\n\t\tlet currentString = undefined;\n\t\tlet currentRawSources = undefined;\n\t\tconst addStringToRawSources = string => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = string;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(string);\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tstring\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst addSourceToRawSources = source => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = source;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(source.source());\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tsource.source()\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst mergeRawSources = () => {\n\t\t\tif (Array.isArray(currentRawSources)) {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources.join(\"\"));\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else if (typeof currentRawSources === \"string\") {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources);\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else {\n\t\t\t\tnewChildren.push(currentRawSources);\n\t\t\t}\n\t\t};\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child === \"string\") {\n\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\tcurrentString = child;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentString += child;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\taddStringToRawSources(currentString);\n\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t}\n\t\t\t\tif (stringsAsRawSources.has(child)) {\n\t\t\t\t\taddSourceToRawSources(child);\n\t\t\t\t} else {\n\t\t\t\t\tif (currentRawSources !== undefined) {\n\t\t\t\t\t\tmergeRawSources();\n\t\t\t\t\t\tcurrentRawSources = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (currentString !== undefined) {\n\t\t\taddStringToRawSources(currentString);\n\t\t}\n\t\tif (currentRawSources !== undefined) {\n\t\t\tmergeRawSources();\n\t\t}\n\t\tthis._children = newChildren;\n\t\tthis._isOptimized = true;\n\t}\n}\n\nmodule.exports = ConcatSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}