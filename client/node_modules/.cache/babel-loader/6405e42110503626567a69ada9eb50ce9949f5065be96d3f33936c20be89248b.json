{"ast":null,"code":"\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n    return exclusive ? \"<\" : \"<=\";\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ? /** @type {RangeValueCallback} */\n    _ref => {\n      let [value] = _ref;\n      return value <= minMax;\n    } : /** @type {RangeValueCallback} */\n    _ref2 => {\n      let [value] = _ref2;\n      return value >= minMax;\n    };\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n    if (j > -1) {\n      return values[j];\n    }\n    return [Infinity, true];\n  }\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n  left(value) {\n    let exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n  right(value) {\n    let exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n  format() {\n    let logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n}\nmodule.exports = Range;","map":{"version":3,"names":["Range","getOperator","side","exclusive","formatRight","value","logic","formatLeft","formatRange","start","end","startExclusive","endExclusive","result","getRangeValue","values","minMax","Infinity","j","predicate","_ref","_ref2","i","length","constructor","_left","_right","left","arguments","undefined","push","right","format","leftExclusive","rightExclusive","Number","isFinite","realStart","realEnd","module","exports"],"sources":["/home/hemanth/react-project/client/node_modules/schema-utils/dist/util/Range.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n\n    return exclusive ? \"<\" : \"<=\";\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}