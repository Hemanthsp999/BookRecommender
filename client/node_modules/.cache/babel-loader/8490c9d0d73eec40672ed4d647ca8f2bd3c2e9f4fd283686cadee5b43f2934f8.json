{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\n\n// TODO add originPath to PathItem for better errors\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\nconst getArguments = function () {\n  let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : webpackSchema;\n  /** @type {Record<string, Argument>} */\n  const flags = {};\n  const pathToArgumentName = input => {\n    return input.replace(/\\./g, \"-\").replace(/\\[\\]/g, \"\").replace(/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu, \"$1-$2\").replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\").toLowerCase();\n  };\n  const getSchemaPart = path => {\n    const newPath = path.split(\"/\");\n    let schemaPart = schema;\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[newPath[i]];\n      if (!inner) {\n        break;\n      }\n      schemaPart = inner;\n    }\n    return schemaPart;\n  };\n\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} description\n   */\n  const getDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.description) return schema.cli.description;\n      }\n      if (schema.description) return schema.description;\n    }\n  };\n\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} negative description\n   */\n  const getNegatedDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n      }\n    }\n  };\n\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} reset description\n   */\n  const getResetDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.resetDescription) return schema.cli.resetDescription;\n      }\n    }\n  };\n\n  /**\n   *\n   * @param {any} schemaPart schema\n   * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n   */\n  const schemaToArgumentConfig = schemaPart => {\n    if (schemaPart.enum) {\n      return {\n        type: \"enum\",\n        values: schemaPart.enum\n      };\n    }\n    switch (schemaPart.type) {\n      case \"number\":\n        return {\n          type: \"number\"\n        };\n      case \"string\":\n        return {\n          type: schemaPart.absolutePath ? \"path\" : \"string\"\n        };\n      case \"boolean\":\n        return {\n          type: \"boolean\"\n        };\n    }\n    if (schemaPart.instanceof === \"RegExp\") {\n      return {\n        type: \"RegExp\"\n      };\n    }\n    return undefined;\n  };\n\n  /**\n   * @param {PathItem[]} path path in the schema\n   * @returns {void}\n   */\n  const addResetFlag = path => {\n    const schemaPath = path[0].path;\n    const name = pathToArgumentName(`${schemaPath}.reset`);\n    const description = getResetDescription(path) || `Clear all items provided in '${schemaPath}' configuration. ${getDescription(path)}`;\n    flags[name] = {\n      configs: [{\n        type: \"reset\",\n        multiple: false,\n        description,\n        path: schemaPath\n      }],\n      description: undefined,\n      simpleType: undefined,\n      multiple: undefined\n    };\n  };\n\n  /**\n   * @param {PathItem[]} path full path in schema\n   * @param {boolean} multiple inside of an array\n   * @returns {number} number of arguments added\n   */\n  const addFlag = (path, multiple) => {\n    const argConfigBase = schemaToArgumentConfig(path[0].schema);\n    if (!argConfigBase) return 0;\n    const negatedDescription = getNegatedDescription(path);\n    const name = pathToArgumentName(path[0].path);\n    /** @type {ArgumentConfig} */\n    const argConfig = {\n      ...argConfigBase,\n      multiple,\n      description: getDescription(path),\n      path: path[0].path\n    };\n    if (negatedDescription) {\n      argConfig.negatedDescription = negatedDescription;\n    }\n    if (!flags[name]) {\n      flags[name] = {\n        configs: [],\n        description: undefined,\n        simpleType: undefined,\n        multiple: undefined\n      };\n    }\n    if (flags[name].configs.some(item => JSON.stringify(item) === JSON.stringify(argConfig))) {\n      return 0;\n    }\n    if (flags[name].configs.some(item => item.type === argConfig.type && item.multiple !== multiple)) {\n      if (multiple) {\n        throw new Error(`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`);\n      }\n      return 0;\n    }\n    flags[name].configs.push(argConfig);\n    return 1;\n  };\n\n  // TODO support `not` and `if/then/else`\n  // TODO support `const`, but we don't use it on our schema\n  /**\n   *\n   * @param {object} schemaPart the current schema\n   * @param {string} schemaPath the current path in the schema\n   * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n   * @param {string | null} inArray if inside of an array, the path to the array\n   * @returns {number} added arguments\n   */\n  const traverse = function (schemaPart) {\n    let schemaPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let inArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    while (schemaPart.$ref) {\n      schemaPart = getSchemaPart(schemaPart.$ref);\n    }\n    const repetitions = path.filter(_ref => {\n      let {\n        schema\n      } = _ref;\n      return schema === schemaPart;\n    });\n    if (repetitions.length >= 2 || repetitions.some(_ref2 => {\n      let {\n        path\n      } = _ref2;\n      return path === schemaPath;\n    })) {\n      return 0;\n    }\n    if (schemaPart.cli && schemaPart.cli.exclude) return 0;\n    const fullPath = [{\n      schema: schemaPart,\n      path: schemaPath\n    }, ...path];\n    let addedArguments = 0;\n    addedArguments += addFlag(fullPath, !!inArray);\n    if (schemaPart.type === \"object\") {\n      if (schemaPart.properties) {\n        for (const property of Object.keys(schemaPart.properties)) {\n          addedArguments += traverse(schemaPart.properties[property], schemaPath ? `${schemaPath}.${property}` : property, fullPath, inArray);\n        }\n      }\n      return addedArguments;\n    }\n    if (schemaPart.type === \"array\") {\n      if (inArray) {\n        return 0;\n      }\n      if (Array.isArray(schemaPart.items)) {\n        let i = 0;\n        for (const item of schemaPart.items) {\n          addedArguments += traverse(item, `${schemaPath}.${i}`, fullPath, schemaPath);\n        }\n        return addedArguments;\n      }\n      addedArguments += traverse(schemaPart.items, `${schemaPath}[]`, fullPath, schemaPath);\n      if (addedArguments > 0) {\n        addResetFlag(fullPath);\n        addedArguments++;\n      }\n      return addedArguments;\n    }\n    const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n    if (maybeOf) {\n      const items = maybeOf;\n      for (let i = 0; i < items.length; i++) {\n        addedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n      }\n      return addedArguments;\n    }\n    return addedArguments;\n  };\n  traverse(schema);\n\n  // Summarize flags\n  for (const name of Object.keys(flags)) {\n    const argument = flags[name];\n    argument.description = argument.configs.reduce((desc, _ref3) => {\n      let {\n        description\n      } = _ref3;\n      if (!desc) return description;\n      if (!description) return desc;\n      if (desc.includes(description)) return desc;\n      return `${desc} ${description}`;\n    }, /** @type {string | undefined} */undefined);\n    argument.simpleType = argument.configs.reduce((t, argConfig) => {\n      /** @type {\"string\" | \"number\" | \"boolean\"} */\n      let type = \"string\";\n      switch (argConfig.type) {\n        case \"number\":\n          type = \"number\";\n          break;\n        case \"reset\":\n        case \"boolean\":\n          type = \"boolean\";\n          break;\n        case \"enum\":\n          if (argConfig.values.every(v => typeof v === \"boolean\")) type = \"boolean\";\n          if (argConfig.values.every(v => typeof v === \"number\")) type = \"number\";\n          break;\n      }\n      if (t === undefined) return type;\n      return t === type ? t : \"string\";\n    }, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */undefined);\n    argument.multiple = argument.configs.some(c => c.multiple);\n  }\n  return flags;\n};\nconst cliAddedItems = new WeakMap();\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\nconst getObjectAndProperty = function (config, schemaPath) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!schemaPath) return {\n    value: config\n  };\n  const parts = schemaPath.split(\".\");\n  let property = parts.pop();\n  let current = config;\n  let i = 0;\n  for (const part of parts) {\n    const isArray = part.endsWith(\"[]\");\n    const name = isArray ? part.slice(0, -2) : part;\n    let value = current[name];\n    if (isArray) {\n      if (value === undefined) {\n        value = {};\n        current[name] = [...Array.from({\n          length: index\n        }), value];\n        cliAddedItems.set(current[name], index + 1);\n      } else if (!Array.isArray(value)) {\n        return {\n          problem: {\n            type: \"unexpected-non-array-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      } else {\n        let addedItems = cliAddedItems.get(value) || 0;\n        while (addedItems <= index) {\n          value.push(undefined);\n          addedItems++;\n        }\n        cliAddedItems.set(value, addedItems);\n        const x = value.length - addedItems + index;\n        if (value[x] === undefined) {\n          value[x] = {};\n        } else if (value[x] === null || typeof value[x] !== \"object\") {\n          return {\n            problem: {\n              type: \"unexpected-non-object-in-path\",\n              path: parts.slice(0, i).join(\".\")\n            }\n          };\n        }\n        value = value[x];\n      }\n    } else {\n      if (value === undefined) {\n        value = current[name] = {};\n      } else if (value === null || typeof value !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      }\n    }\n    current = value;\n    i++;\n  }\n  let value = current[property];\n  if (property.endsWith(\"[]\")) {\n    const name = property.slice(0, -2);\n    const value = current[name];\n    if (value === undefined) {\n      current[name] = [...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index,\n        value: undefined\n      };\n    } else if (!Array.isArray(value)) {\n      current[name] = [value, ...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index + 1,\n        value: undefined\n      };\n    } else {\n      let addedItems = cliAddedItems.get(value) || 0;\n      while (addedItems <= index) {\n        value.push(undefined);\n        addedItems++;\n      }\n      cliAddedItems.set(value, addedItems);\n      const x = value.length - addedItems + index;\n      if (value[x] === undefined) {\n        value[x] = {};\n      } else if (value[x] === null || typeof value[x] !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: schemaPath\n          }\n        };\n      }\n      return {\n        object: value,\n        property: x,\n        value: value[x]\n      };\n    }\n  }\n  return {\n    object: current,\n    property,\n    value\n  };\n};\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\nconst setValue = (config, schemaPath, value, index) => {\n  const {\n    problem,\n    object,\n    property\n  } = getObjectAndProperty(config, schemaPath, index);\n  if (problem) return problem;\n  object[property] = value;\n  return null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\nconst processArgumentConfig = (argConfig, config, value, index) => {\n  if (index !== undefined && !argConfig.multiple) {\n    return {\n      type: \"multiple-values-unexpected\",\n      path: argConfig.path\n    };\n  }\n  const parsed = parseValueForArgumentConfig(argConfig, value);\n  if (parsed === undefined) {\n    return {\n      type: \"invalid-value\",\n      path: argConfig.path,\n      expected: getExpectedValue(argConfig)\n    };\n  }\n  const problem = setValue(config, argConfig.path, parsed, index);\n  if (problem) return problem;\n  return null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\nconst getExpectedValue = argConfig => {\n  switch (argConfig.type) {\n    default:\n      return argConfig.type;\n    case \"boolean\":\n      return \"true | false\";\n    case \"RegExp\":\n      return \"regular expression (example: /ab?c*/)\";\n    case \"enum\":\n      return argConfig.values.map(v => `${v}`).join(\" | \");\n    case \"reset\":\n      return \"true (will reset the previous value to an empty array)\";\n  }\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\nconst parseValueForArgumentConfig = (argConfig, value) => {\n  switch (argConfig.type) {\n    case \"string\":\n      if (typeof value === \"string\") {\n        return value;\n      }\n      break;\n    case \"path\":\n      if (typeof value === \"string\") {\n        return path.resolve(value);\n      }\n      break;\n    case \"number\":\n      if (typeof value === \"number\") return value;\n      if (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n        const n = +value;\n        if (!isNaN(n)) return n;\n      }\n      break;\n    case \"boolean\":\n      if (typeof value === \"boolean\") return value;\n      if (value === \"true\") return true;\n      if (value === \"false\") return false;\n      break;\n    case \"RegExp\":\n      if (value instanceof RegExp) return value;\n      if (typeof value === \"string\") {\n        // cspell:word yugi\n        const match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n        if (match && !/[^\\\\]\\//.test(match[1])) return new RegExp(match[1], match[2]);\n      }\n      break;\n    case \"enum\":\n      if (argConfig.values.includes(value)) return value;\n      for (const item of argConfig.values) {\n        if (`${item}` === value) return item;\n      }\n      break;\n    case \"reset\":\n      if (value === true) return [];\n      break;\n  }\n};\n\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\nconst processArguments = (args, config, values) => {\n  /** @type {Problem[]} */\n  const problems = [];\n  for (const key of Object.keys(values)) {\n    const arg = args[key];\n    if (!arg) {\n      problems.push({\n        type: \"unknown-argument\",\n        path: \"\",\n        argument: key\n      });\n      continue;\n    }\n    const processValue = (value, i) => {\n      const currentProblems = [];\n      for (const argConfig of arg.configs) {\n        const problem = processArgumentConfig(argConfig, config, value, i);\n        if (!problem) {\n          return;\n        }\n        currentProblems.push({\n          ...problem,\n          argument: key,\n          value: value,\n          index: i\n        });\n      }\n      problems.push(...currentProblems);\n    };\n    let value = values[key];\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        processValue(value[i], i);\n      }\n    } else {\n      processValue(value, undefined);\n    }\n  }\n  if (problems.length === 0) return null;\n  return problems;\n};\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;","map":{"version":3,"names":["path","require","webpackSchema","getArguments","schema","arguments","length","undefined","flags","pathToArgumentName","input","replace","toLowerCase","getSchemaPart","newPath","split","schemaPart","i","inner","getDescription","cli","helper","description","getNegatedDescription","negatedDescription","getResetDescription","resetDescription","schemaToArgumentConfig","enum","type","values","absolutePath","instanceof","addResetFlag","schemaPath","name","configs","multiple","simpleType","addFlag","argConfigBase","argConfig","some","item","JSON","stringify","Error","push","traverse","inArray","$ref","repetitions","filter","_ref","_ref2","exclude","fullPath","addedArguments","properties","property","Object","keys","Array","isArray","items","maybeOf","oneOf","anyOf","allOf","argument","reduce","desc","_ref3","includes","t","every","v","c","cliAddedItems","WeakMap","getObjectAndProperty","config","index","value","parts","pop","current","part","endsWith","slice","from","set","problem","join","addedItems","get","x","object","setValue","processArgumentConfig","parsed","parseValueForArgumentConfig","expected","getExpectedValue","map","resolve","n","isNaN","RegExp","match","exec","test","processArguments","args","problems","key","arg","processValue","currentProblems","exports"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/cli.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\n\n// TODO add originPath to PathItem for better errors\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\nconst getArguments = (schema = webpackSchema) => {\n\t/** @type {Record<string, Argument>} */\n\tconst flags = {};\n\n\tconst pathToArgumentName = input => {\n\t\treturn input\n\t\t\t.replace(/\\./g, \"-\")\n\t\t\t.replace(/\\[\\]/g, \"\")\n\t\t\t.replace(\n\t\t\t\t/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu,\n\t\t\t\t\"$1-$2\"\n\t\t\t)\n\t\t\t.replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\")\n\t\t\t.toLowerCase();\n\t};\n\n\tconst getSchemaPart = path => {\n\t\tconst newPath = path.split(\"/\");\n\n\t\tlet schemaPart = schema;\n\n\t\tfor (let i = 1; i < newPath.length; i++) {\n\t\t\tconst inner = schemaPart[newPath[i]];\n\n\t\t\tif (!inner) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tschemaPart = inner;\n\t\t}\n\n\t\treturn schemaPart;\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} description\n\t */\n\tconst getDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.description) return schema.cli.description;\n\t\t\t}\n\t\t\tif (schema.description) return schema.description;\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} negative description\n\t */\n\tconst getNegatedDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} reset description\n\t */\n\tconst getResetDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.resetDescription) return schema.cli.resetDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {any} schemaPart schema\n\t * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n\t */\n\tconst schemaToArgumentConfig = schemaPart => {\n\t\tif (schemaPart.enum) {\n\t\t\treturn {\n\t\t\t\ttype: \"enum\",\n\t\t\t\tvalues: schemaPart.enum\n\t\t\t};\n\t\t}\n\t\tswitch (schemaPart.type) {\n\t\t\tcase \"number\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"number\"\n\t\t\t\t};\n\t\t\tcase \"string\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: schemaPart.absolutePath ? \"path\" : \"string\"\n\t\t\t\t};\n\t\t\tcase \"boolean\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"boolean\"\n\t\t\t\t};\n\t\t}\n\t\tif (schemaPart.instanceof === \"RegExp\") {\n\t\t\treturn {\n\t\t\t\ttype: \"RegExp\"\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t};\n\n\t/**\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {void}\n\t */\n\tconst addResetFlag = path => {\n\t\tconst schemaPath = path[0].path;\n\t\tconst name = pathToArgumentName(`${schemaPath}.reset`);\n\t\tconst description =\n\t\t\tgetResetDescription(path) ||\n\t\t\t`Clear all items provided in '${schemaPath}' configuration. ${getDescription(\n\t\t\t\tpath\n\t\t\t)}`;\n\t\tflags[name] = {\n\t\t\tconfigs: [\n\t\t\t\t{\n\t\t\t\t\ttype: \"reset\",\n\t\t\t\t\tmultiple: false,\n\t\t\t\t\tdescription,\n\t\t\t\t\tpath: schemaPath\n\t\t\t\t}\n\t\t\t],\n\t\t\tdescription: undefined,\n\t\t\tsimpleType: undefined,\n\t\t\tmultiple: undefined\n\t\t};\n\t};\n\n\t/**\n\t * @param {PathItem[]} path full path in schema\n\t * @param {boolean} multiple inside of an array\n\t * @returns {number} number of arguments added\n\t */\n\tconst addFlag = (path, multiple) => {\n\t\tconst argConfigBase = schemaToArgumentConfig(path[0].schema);\n\t\tif (!argConfigBase) return 0;\n\n\t\tconst negatedDescription = getNegatedDescription(path);\n\t\tconst name = pathToArgumentName(path[0].path);\n\t\t/** @type {ArgumentConfig} */\n\t\tconst argConfig = {\n\t\t\t...argConfigBase,\n\t\t\tmultiple,\n\t\t\tdescription: getDescription(path),\n\t\t\tpath: path[0].path\n\t\t};\n\n\t\tif (negatedDescription) {\n\t\t\targConfig.negatedDescription = negatedDescription;\n\t\t}\n\n\t\tif (!flags[name]) {\n\t\t\tflags[name] = {\n\t\t\t\tconfigs: [],\n\t\t\t\tdescription: undefined,\n\t\t\t\tsimpleType: undefined,\n\t\t\t\tmultiple: undefined\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => JSON.stringify(item) === JSON.stringify(argConfig)\n\t\t\t)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => item.type === argConfig.type && item.multiple !== multiple\n\t\t\t)\n\t\t) {\n\t\t\tif (multiple) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tflags[name].configs.push(argConfig);\n\n\t\treturn 1;\n\t};\n\n\t// TODO support `not` and `if/then/else`\n\t// TODO support `const`, but we don't use it on our schema\n\t/**\n\t *\n\t * @param {object} schemaPart the current schema\n\t * @param {string} schemaPath the current path in the schema\n\t * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n\t * @param {string | null} inArray if inside of an array, the path to the array\n\t * @returns {number} added arguments\n\t */\n\tconst traverse = (schemaPart, schemaPath = \"\", path = [], inArray = null) => {\n\t\twhile (schemaPart.$ref) {\n\t\t\tschemaPart = getSchemaPart(schemaPart.$ref);\n\t\t}\n\n\t\tconst repetitions = path.filter(({ schema }) => schema === schemaPart);\n\t\tif (\n\t\t\trepetitions.length >= 2 ||\n\t\t\trepetitions.some(({ path }) => path === schemaPath)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (schemaPart.cli && schemaPart.cli.exclude) return 0;\n\n\t\tconst fullPath = [{ schema: schemaPart, path: schemaPath }, ...path];\n\n\t\tlet addedArguments = 0;\n\n\t\taddedArguments += addFlag(fullPath, !!inArray);\n\n\t\tif (schemaPart.type === \"object\") {\n\t\t\tif (schemaPart.properties) {\n\t\t\t\tfor (const property of Object.keys(schemaPart.properties)) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\tschemaPart.properties[property],\n\t\t\t\t\t\tschemaPath ? `${schemaPath}.${property}` : property,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tinArray\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tif (schemaPart.type === \"array\") {\n\t\t\tif (inArray) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (Array.isArray(schemaPart.items)) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const item of schemaPart.items) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\titem,\n\t\t\t\t\t\t`${schemaPath}.${i}`,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tschemaPath\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn addedArguments;\n\t\t\t}\n\n\t\t\taddedArguments += traverse(\n\t\t\t\tschemaPart.items,\n\t\t\t\t`${schemaPath}[]`,\n\t\t\t\tfullPath,\n\t\t\t\tschemaPath\n\t\t\t);\n\n\t\t\tif (addedArguments > 0) {\n\t\t\t\taddResetFlag(fullPath);\n\t\t\t\taddedArguments++;\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tconst maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n\n\t\tif (maybeOf) {\n\t\t\tconst items = maybeOf;\n\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\taddedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\treturn addedArguments;\n\t};\n\n\ttraverse(schema);\n\n\t// Summarize flags\n\tfor (const name of Object.keys(flags)) {\n\t\tconst argument = flags[name];\n\t\targument.description = argument.configs.reduce((desc, { description }) => {\n\t\t\tif (!desc) return description;\n\t\t\tif (!description) return desc;\n\t\t\tif (desc.includes(description)) return desc;\n\t\t\treturn `${desc} ${description}`;\n\t\t}, /** @type {string | undefined} */ (undefined));\n\t\targument.simpleType = argument.configs.reduce((t, argConfig) => {\n\t\t\t/** @type {\"string\" | \"number\" | \"boolean\"} */\n\t\t\tlet type = \"string\";\n\t\t\tswitch (argConfig.type) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"reset\":\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enum\":\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"boolean\"))\n\t\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"number\"))\n\t\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t === undefined) return type;\n\t\t\treturn t === type ? t : \"string\";\n\t\t}, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */ (undefined));\n\t\targument.multiple = argument.configs.some(c => c.multiple);\n\t}\n\n\treturn flags;\n};\n\nconst cliAddedItems = new WeakMap();\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\nconst getObjectAndProperty = (config, schemaPath, index = 0) => {\n\tif (!schemaPath) return { value: config };\n\tconst parts = schemaPath.split(\".\");\n\tlet property = parts.pop();\n\tlet current = config;\n\tlet i = 0;\n\tfor (const part of parts) {\n\t\tconst isArray = part.endsWith(\"[]\");\n\t\tconst name = isArray ? part.slice(0, -2) : part;\n\t\tlet value = current[name];\n\t\tif (isArray) {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = {};\n\t\t\t\tcurrent[name] = [...Array.from({ length: index }), value];\n\t\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\t} else if (!Array.isArray(value)) {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-array-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\t\twhile (addedItems <= index) {\n\t\t\t\t\tvalue.push(undefined);\n\t\t\t\t\taddedItems++;\n\t\t\t\t}\n\t\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\t\tconst x = value.length - addedItems + index;\n\t\t\t\tif (value[x] === undefined) {\n\t\t\t\t\tvalue[x] = {};\n\t\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tproblem: {\n\t\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvalue = value[x];\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = current[name] = {};\n\t\t\t} else if (value === null || typeof value !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tcurrent = value;\n\t\ti++;\n\t}\n\tlet value = current[property];\n\tif (property.endsWith(\"[]\")) {\n\t\tconst name = property.slice(0, -2);\n\t\tconst value = current[name];\n\t\tif (value === undefined) {\n\t\t\tcurrent[name] = [...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index, value: undefined };\n\t\t} else if (!Array.isArray(value)) {\n\t\t\tcurrent[name] = [value, ...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index + 1, value: undefined };\n\t\t} else {\n\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\twhile (addedItems <= index) {\n\t\t\t\tvalue.push(undefined);\n\t\t\t\taddedItems++;\n\t\t\t}\n\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\tconst x = value.length - addedItems + index;\n\t\t\tif (value[x] === undefined) {\n\t\t\t\tvalue[x] = {};\n\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: schemaPath\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tobject: value,\n\t\t\t\tproperty: x,\n\t\t\t\tvalue: value[x]\n\t\t\t};\n\t\t}\n\t}\n\treturn { object: current, property, value };\n};\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\nconst setValue = (config, schemaPath, value, index) => {\n\tconst { problem, object, property } = getObjectAndProperty(\n\t\tconfig,\n\t\tschemaPath,\n\t\tindex\n\t);\n\tif (problem) return problem;\n\tobject[property] = value;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\nconst processArgumentConfig = (argConfig, config, value, index) => {\n\tif (index !== undefined && !argConfig.multiple) {\n\t\treturn {\n\t\t\ttype: \"multiple-values-unexpected\",\n\t\t\tpath: argConfig.path\n\t\t};\n\t}\n\tconst parsed = parseValueForArgumentConfig(argConfig, value);\n\tif (parsed === undefined) {\n\t\treturn {\n\t\t\ttype: \"invalid-value\",\n\t\t\tpath: argConfig.path,\n\t\t\texpected: getExpectedValue(argConfig)\n\t\t};\n\t}\n\tconst problem = setValue(config, argConfig.path, parsed, index);\n\tif (problem) return problem;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\nconst getExpectedValue = argConfig => {\n\tswitch (argConfig.type) {\n\t\tdefault:\n\t\t\treturn argConfig.type;\n\t\tcase \"boolean\":\n\t\t\treturn \"true | false\";\n\t\tcase \"RegExp\":\n\t\t\treturn \"regular expression (example: /ab?c*/)\";\n\t\tcase \"enum\":\n\t\t\treturn argConfig.values.map(v => `${v}`).join(\" | \");\n\t\tcase \"reset\":\n\t\t\treturn \"true (will reset the previous value to an empty array)\";\n\t}\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\nconst parseValueForArgumentConfig = (argConfig, value) => {\n\tswitch (argConfig.type) {\n\t\tcase \"string\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"path\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn path.resolve(value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"number\":\n\t\t\tif (typeof value === \"number\") return value;\n\t\t\tif (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n\t\t\t\tconst n = +value;\n\t\t\t\tif (!isNaN(n)) return n;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"boolean\":\n\t\t\tif (typeof value === \"boolean\") return value;\n\t\t\tif (value === \"true\") return true;\n\t\t\tif (value === \"false\") return false;\n\t\t\tbreak;\n\t\tcase \"RegExp\":\n\t\t\tif (value instanceof RegExp) return value;\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\t// cspell:word yugi\n\t\t\t\tconst match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n\t\t\t\tif (match && !/[^\\\\]\\//.test(match[1]))\n\t\t\t\t\treturn new RegExp(match[1], match[2]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"enum\":\n\t\t\tif (argConfig.values.includes(value)) return value;\n\t\t\tfor (const item of argConfig.values) {\n\t\t\t\tif (`${item}` === value) return item;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"reset\":\n\t\t\tif (value === true) return [];\n\t\t\tbreak;\n\t}\n};\n\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\nconst processArguments = (args, config, values) => {\n\t/** @type {Problem[]} */\n\tconst problems = [];\n\tfor (const key of Object.keys(values)) {\n\t\tconst arg = args[key];\n\t\tif (!arg) {\n\t\t\tproblems.push({\n\t\t\t\ttype: \"unknown-argument\",\n\t\t\t\tpath: \"\",\n\t\t\t\targument: key\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tconst processValue = (value, i) => {\n\t\t\tconst currentProblems = [];\n\t\t\tfor (const argConfig of arg.configs) {\n\t\t\t\tconst problem = processArgumentConfig(argConfig, config, value, i);\n\t\t\t\tif (!problem) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentProblems.push({\n\t\t\t\t\t...problem,\n\t\t\t\t\targument: key,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tindex: i\n\t\t\t\t});\n\t\t\t}\n\t\t\tproblems.push(...currentProblems);\n\t\t};\n\t\tlet value = values[key];\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tprocessValue(value[i], i);\n\t\t\t}\n\t\t} else {\n\t\t\tprocessValue(value, undefined);\n\t\t}\n\t}\n\tif (problems.length === 0) return null;\n\treturn problems;\n};\n\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}