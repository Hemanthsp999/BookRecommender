{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Mikola Lysenko @mikolalysenko\n*/\n\n\"use strict\";\n\n/* cspell:disable-next-line */\n// Refactor: Peter Somogyvari @petermetz\n\n/** @typedef {\">=\" | \"<=\" | \"<\" | \">\" | \"-\" } BinarySearchPredicate */\n/** @typedef {\"GE\" | \"GT\" | \"LT\" | \"LE\" | \"EQ\" } SearchPredicateSuffix */\n\n/**\n * Helper function for compiling binary search functions.\n *\n * The generated code uses a while loop to repeatedly divide the search interval\n * in half until the desired element is found, or the search interval is empty.\n *\n * The following is an example of a generated function for calling `compileSearch(\"P\", \"c(x,y)<=0\", true, [\"y\", \"c\"], false)`:\n *\n * ```js\n * function P(a,l,h,y,c){var i=l-1;while(l<=h){var m=(l+h)>>>1,x=a[m];if(c(x,y)<=0){i=m;l=m+1}else{h=m-1}}return i};\n * ```\n *\n * @param {string} funcName The name of the function to be compiled.\n * @param {string} predicate The predicate / comparison operator to be used in the binary search.\n * @param {boolean} reversed Whether the search should be reversed.\n * @param {string[]} extraArgs Extra arguments to be passed to the function.\n * @param {boolean=} earlyOut Whether the search should return as soon as a match is found.\n * @returns {string} The compiled binary search function.\n */\nconst compileSearch = (funcName, predicate, reversed, extraArgs, earlyOut) => {\n  const code = [\"function \", funcName, \"(a,l,h,\", extraArgs.join(\",\"), \"){\", earlyOut ? \"\" : \"var i=\", reversed ? \"l-1\" : \"h+1\", \";while(l<=h){var m=(l+h)>>>1,x=a[m]\"];\n  if (earlyOut) {\n    if (predicate.indexOf(\"c\") < 0) {\n      code.push(\";if(x===y){return m}else if(x<=y){\");\n    } else {\n      code.push(\";var p=c(x,y);if(p===0){return m}else if(p<=0){\");\n    }\n  } else {\n    code.push(\";if(\", predicate, \"){i=m;\");\n  }\n  if (reversed) {\n    code.push(\"l=m+1}else{h=m-1}\");\n  } else {\n    code.push(\"h=m-1}else{l=m+1}\");\n  }\n  code.push(\"}\");\n  if (earlyOut) {\n    code.push(\"return -1};\");\n  } else {\n    code.push(\"return i};\");\n  }\n  return code.join(\"\");\n};\n\n/**\n * This helper functions generate code for two binary search functions:\n * A(): Performs a binary search on an array using the comparison operator specified.\n * P(): Performs a binary search on an array using a _custom comparison function_\n * `c(x,y)` **and** comparison operator specified by `predicate`.\n *\n * @param {BinarySearchPredicate} predicate The predicate / comparison operator to be used in the binary search.\n * @param {boolean} reversed Whether the search should be reversed.\n * @param {SearchPredicateSuffix} suffix The suffix to be used in the function name.\n * @param {boolean=} earlyOut Whether the search should return as soon as a match is found.\n * @returns {function} The compiled binary search function.\n */\nconst compileBoundsSearch = (predicate, reversed, suffix, earlyOut) => {\n  const arg1 = compileSearch(\"A\", \"x\" + predicate + \"y\", reversed, [\"y\"], earlyOut);\n  const arg2 = compileSearch(\"P\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], earlyOut);\n  const fnHeader = \"function dispatchBinarySearch\";\n  const fnBody = \"(a,y,c,l,h){\\\nif(typeof(c)==='function'){\\\nreturn P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\\\n}else{\\\nreturn A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\\\n}}\\\nreturn dispatchBinarySearch\";\n  const fnArgList = [arg1, arg2, fnHeader, suffix, fnBody, suffix];\n  const fnSource = fnArgList.join(\"\");\n  const result = new Function(fnSource);\n  return result();\n};\n\n/**\n * These functions are used to perform binary searches on arrays.\n *\n * @example\n * ```js\n * const { gt, le} = require(\"./binarySearchBounds\");\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n *\n * // Find the index of the first element greater than 5\n * const index1 = gt(arr, 5); // index1 === 3\n *\n * // Find the index of the first element less than or equal to 5\n * const index2 = le(arr, 5); // index2 === 4\n * ```\n */\nmodule.exports = {\n  ge: compileBoundsSearch(\">=\", false, \"GE\"),\n  gt: compileBoundsSearch(\">\", false, \"GT\"),\n  lt: compileBoundsSearch(\"<\", true, \"LT\"),\n  le: compileBoundsSearch(\"<=\", true, \"LE\"),\n  eq: compileBoundsSearch(\"-\", true, \"EQ\", true)\n};","map":{"version":3,"names":["compileSearch","funcName","predicate","reversed","extraArgs","earlyOut","code","join","indexOf","push","compileBoundsSearch","suffix","arg1","arg2","fnHeader","fnBody","fnArgList","fnSource","result","Function","module","exports","ge","gt","lt","le","eq"],"sources":["/home/hemanth/react-project/client/node_modules/webpack/lib/util/binarySearchBounds.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Mikola Lysenko @mikolalysenko\n*/\n\n\"use strict\";\n\n/* cspell:disable-next-line */\n// Refactor: Peter Somogyvari @petermetz\n\n/** @typedef {\">=\" | \"<=\" | \"<\" | \">\" | \"-\" } BinarySearchPredicate */\n/** @typedef {\"GE\" | \"GT\" | \"LT\" | \"LE\" | \"EQ\" } SearchPredicateSuffix */\n\n/**\n * Helper function for compiling binary search functions.\n *\n * The generated code uses a while loop to repeatedly divide the search interval\n * in half until the desired element is found, or the search interval is empty.\n *\n * The following is an example of a generated function for calling `compileSearch(\"P\", \"c(x,y)<=0\", true, [\"y\", \"c\"], false)`:\n *\n * ```js\n * function P(a,l,h,y,c){var i=l-1;while(l<=h){var m=(l+h)>>>1,x=a[m];if(c(x,y)<=0){i=m;l=m+1}else{h=m-1}}return i};\n * ```\n *\n * @param {string} funcName The name of the function to be compiled.\n * @param {string} predicate The predicate / comparison operator to be used in the binary search.\n * @param {boolean} reversed Whether the search should be reversed.\n * @param {string[]} extraArgs Extra arguments to be passed to the function.\n * @param {boolean=} earlyOut Whether the search should return as soon as a match is found.\n * @returns {string} The compiled binary search function.\n */\nconst compileSearch = (funcName, predicate, reversed, extraArgs, earlyOut) => {\n\tconst code = [\n\t\t\"function \",\n\t\tfuncName,\n\t\t\"(a,l,h,\",\n\t\textraArgs.join(\",\"),\n\t\t\"){\",\n\t\tearlyOut ? \"\" : \"var i=\",\n\t\treversed ? \"l-1\" : \"h+1\",\n\t\t\";while(l<=h){var m=(l+h)>>>1,x=a[m]\"\n\t];\n\n\tif (earlyOut) {\n\t\tif (predicate.indexOf(\"c\") < 0) {\n\t\t\tcode.push(\";if(x===y){return m}else if(x<=y){\");\n\t\t} else {\n\t\t\tcode.push(\";var p=c(x,y);if(p===0){return m}else if(p<=0){\");\n\t\t}\n\t} else {\n\t\tcode.push(\";if(\", predicate, \"){i=m;\");\n\t}\n\tif (reversed) {\n\t\tcode.push(\"l=m+1}else{h=m-1}\");\n\t} else {\n\t\tcode.push(\"h=m-1}else{l=m+1}\");\n\t}\n\tcode.push(\"}\");\n\tif (earlyOut) {\n\t\tcode.push(\"return -1};\");\n\t} else {\n\t\tcode.push(\"return i};\");\n\t}\n\treturn code.join(\"\");\n};\n\n/**\n * This helper functions generate code for two binary search functions:\n * A(): Performs a binary search on an array using the comparison operator specified.\n * P(): Performs a binary search on an array using a _custom comparison function_\n * `c(x,y)` **and** comparison operator specified by `predicate`.\n *\n * @param {BinarySearchPredicate} predicate The predicate / comparison operator to be used in the binary search.\n * @param {boolean} reversed Whether the search should be reversed.\n * @param {SearchPredicateSuffix} suffix The suffix to be used in the function name.\n * @param {boolean=} earlyOut Whether the search should return as soon as a match is found.\n * @returns {function} The compiled binary search function.\n */\nconst compileBoundsSearch = (predicate, reversed, suffix, earlyOut) => {\n\tconst arg1 = compileSearch(\n\t\t\"A\",\n\t\t\"x\" + predicate + \"y\",\n\t\treversed,\n\t\t[\"y\"],\n\t\tearlyOut\n\t);\n\n\tconst arg2 = compileSearch(\n\t\t\"P\",\n\t\t\"c(x,y)\" + predicate + \"0\",\n\t\treversed,\n\t\t[\"y\", \"c\"],\n\t\tearlyOut\n\t);\n\n\tconst fnHeader = \"function dispatchBinarySearch\";\n\n\tconst fnBody =\n\t\t\"(a,y,c,l,h){\\\nif(typeof(c)==='function'){\\\nreturn P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\\\n}else{\\\nreturn A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\\\n}}\\\nreturn dispatchBinarySearch\";\n\n\tconst fnArgList = [arg1, arg2, fnHeader, suffix, fnBody, suffix];\n\tconst fnSource = fnArgList.join(\"\");\n\tconst result = new Function(fnSource);\n\treturn result();\n};\n\n/**\n * These functions are used to perform binary searches on arrays.\n *\n * @example\n * ```js\n * const { gt, le} = require(\"./binarySearchBounds\");\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n *\n * // Find the index of the first element greater than 5\n * const index1 = gt(arr, 5); // index1 === 3\n *\n * // Find the index of the first element less than or equal to 5\n * const index2 = le(arr, 5); // index2 === 4\n * ```\n */\nmodule.exports = {\n\tge: compileBoundsSearch(\">=\", false, \"GE\"),\n\tgt: compileBoundsSearch(\">\", false, \"GT\"),\n\tlt: compileBoundsSearch(\"<\", true, \"LT\"),\n\tle: compileBoundsSearch(\"<=\", true, \"LE\"),\n\teq: compileBoundsSearch(\"-\", true, \"EQ\", true)\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}