{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst {\n  promisify\n} = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n  STR_CLOSE,\n  STR_END,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = function () {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.isArray(value) ? value : [value];\n};\nconst flatten = function (list) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\nconst normalizeIgnored = function () {\n  let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;\n  return path => {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n};\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n    return entry.fullPath;\n  }\n  entryPath(entry) {\n    return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    var _this;\n    super();\n    _this = this;\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n    this._closers = new Map();\n    /** @type {Set<String>} */\n    this._ignoredPaths = new Set();\n\n    /** @type {Map<ThrottleType, Map>} */\n    this._throttled = new Map();\n\n    /** @type {Map<Path, String|Boolean>} */\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false;\n\n    // Set up default options.\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n    // Enable fsevents on OS X when polling isn't explicitly enabled.\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n    // If we can't use fsevents, ensure the options reflect it's disabled.\n    const canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false;\n\n    // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    }\n\n    // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n    if (isIBMi) {\n      opts.usePolling = true;\n    }\n\n    // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    }\n\n    // Editor atomic write normalization enabled by default with fs.watch\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n    this._emitReady = () => {\n      readyCalls++;\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN;\n        this._readyEmitted = true;\n        // use process.nextTick to allow time for listener to be bound\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n    this._emitRaw = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.emit(EV_RAW, ...args);\n    };\n    this._readyEmitted = false;\n    this.options = opts;\n\n    // Initialize with proper watcher.\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new FsEventsHandler(this);\n    } else {\n      this._nodeFsHandler = new NodeFsHandler(this);\n    }\n\n    // You’re frozen when your heart’s not open.\n    Object.freeze(opts);\n  }\n\n  // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd);\n\n        // Check `path` instead of `absPath` because the cwd portion can't be a glob\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n        return normalizePath(absPath);\n      });\n    }\n\n    // set aside negated glob strings\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG)) {\n        this._ignoredPaths.add(path.slice(1));\n        return false;\n      }\n\n      // if a path is being added that was previously ignored, stop ignoring it\n      this._ignoredPaths.delete(path);\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n      // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n      this._userIgnored = undefined;\n      return true;\n    });\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n        });\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath.join(cwd, path);\n        path = sysPath.resolve(path);\n      }\n      this._closePath(path);\n      this._ignoredPaths.add(path);\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      }\n\n      // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true;\n\n    // Memory management.\n    this.removeAllListeners();\n    const closers = [];\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n    this._streams.forEach(stream => stream.destroy());\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n    this._watched.forEach(dirent => dirent.dispose());\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n  getWatched() {\n    const watchList = {};\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n    return watchList;\n  }\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n  }\n\n  // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows) path = sysPath.normalize(path);\n    if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n    /** @type Array<any> */\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n    if (opts.atomic) {\n      if (event === EV_UNLINK) {\n        this._pendingUnlinks.set(path, args);\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n      if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE;\n        this._pendingUnlinks.delete(path);\n      }\n    }\n    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n          this.emitWithAll(event, args);\n        }\n      };\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n      return this;\n    }\n    if (event === EV_CHANGE) {\n      const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n      if (isThrottled) return this;\n    }\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n      let stats;\n      try {\n        stats = await stat(fullPath);\n      } catch (err) {}\n      // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n    this.emitWithAll(event, args);\n    return this;\n  }\n\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n  _handleError(error) {\n    const code = error && error.code;\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR, error);\n    }\n    return error || this.closed;\n  }\n\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n\n    /** @type {Map<Path, Object>} */\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n    const actionPath = action.get(path);\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n    let timeoutObject;\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n    if (this.options.cwd && !sysPath.isAbsolute(path)) {\n      fullPath = sysPath.join(this.options.cwd, path);\n    }\n    const now = new Date();\n    const awaitWriteFinish = prevStat => {\n      fs.stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n        const now = Number(new Date());\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n        const pw = this._pendingWrites.get(path);\n        const df = now - pw.lastChange;\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n    return this._userIgnored([path, stats]);\n  }\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  }\n\n  // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath.resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  }\n\n  // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true;\n\n    // stats.mode may be bigint\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath.join(directory, item);\n    const fullPath = sysPath.resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);\n\n    // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n    if (!this._throttle('remove', path, 100)) return;\n\n    // if the only watched file is removed, watch for its return\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    }\n\n    // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n    const wp = this._getWatchedDir(path);\n    const nestedDirectoryChildren = wp.getChildren();\n\n    // Recursively remove children directories / files.\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n    // Check if item was on the watched list and remove it\n    const parent = this._getWatchedDir(directory);\n    const wasTracked = parent.has(item);\n    parent.remove(item);\n\n    // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n    // but never removed from the map in case the path was deleted.\n    // This leads to an incorrect state if the path was recreated:\n    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n    if (this._symlinkPaths.has(fullPath)) {\n      this._symlinkPaths.delete(fullPath);\n    }\n\n    // If we wait for this file to be fully written, cancel the wait.\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n      if (event === EV_ADD) return;\n    }\n\n    // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n    this._watched.delete(path);\n    this._watched.delete(fullPath);\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n    // Avoid conflicts if we later create another file with the same name\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n  _closePath(path) {\n    this._closeFile(path);\n    const dir = sysPath.dirname(path);\n    this._getWatchedDir(dir).remove(sysPath.basename(path));\n  }\n\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n    if (!closers) return;\n    closers.forEach(closer => closer());\n    this._closers.delete(path);\n  }\n\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n    let list = this._closers.get(path);\n    if (!list) {\n      list = [];\n      this._closers.set(path, list);\n    }\n    list.push(closer);\n  }\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp(root, options);\n    this._streams.add(stream);\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END, () => {\n      if (stream) {\n        this._streams.delete(stream);\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\nexports.watch = watch;","map":{"version":3,"names":["EventEmitter","require","fs","sysPath","promisify","readdirp","anymatch","default","globParent","isGlob","braces","normalizePath","NodeFsHandler","FsEventsHandler","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_UNLINK","EV_ADD_DIR","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_CLOSE","STR_END","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","GLOBSTAR","SLASH_GLOBSTAR","ANYMATCH_OPTS","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","isWindows","isMacos","isIBMi","stat","readdir","arrify","value","arguments","length","undefined","Array","isArray","flatten","list","result","forEach","item","push","unifyPaths","paths_","paths","every","p","TypeError","map","normalizePathToUnix","toUnix","string","str","replace","prepend","startsWith","match","path","normalize","normalizeIgnored","cwd","isAbsolute","join","getAbsolutePath","slice","undef","opts","key","DirEntry","constructor","dir","removeWatcher","_removeWatcher","items","Set","add","remove","delete","size","err","dirname","basename","has","getChildren","values","dispose","clear","Object","freeze","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","watchPath","follow","fsw","fullWatchPath","resolve","hasGlob","globSymlink","globFilter","dirParts","getDirParts","parts","pop","followSymlinks","statMethod","checkGlobSymlink","entry","fullParentDir","realPath","linkPath","fullPath","entryPath","relative","filterPath","stats","isSymbolicLink","filterDir","resolvedPath","matchesGlob","_isntIgnored","_hasReadPermissions","expandedPath","includes","expand","split","entryParts","globstar","unmatchedGlob","some","part","i","FSWatcher","_opts","_this","this","assign","_watched","Map","_closers","_ignoredPaths","_throttled","_symlinkPaths","_streams","closed","persistent","ignoreInitial","ignorePermissionErrors","interval","binaryInterval","disableGlobbing","enableBinaryInterval","useFsEvents","usePolling","canUseFsEvents","canUse","envPoll","process","env","CHOKIDAR_USEPOLLING","envLower","toLowerCase","envInterval","CHOKIDAR_INTERVAL","Number","parseInt","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","ignored","readyCalls","_emitReady","_readyCount","_readyEmitted","nextTick","emit","_emitRaw","_len","args","_key","options","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","absPath","filter","_userIgnored","_addToFsEvents","Promise","all","res","_addToNodeFs","then","results","unwatch","_closePath","close","_closePromise","removeAllListeners","closers","closerList","closer","promise","stream","destroy","dirent","getWatched","watchList","sort","emitWithAll","event","_emit","val1","val2","val3","pw","get","lastChange","Date","set","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","_throttle","alwaysStat","_handleError","error","code","actionType","timeout","action","actionPath","count","timeoutObject","clearTimeout","thr","_incrReadyCount","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","_isIgnored","test","ign","concat","_getWatchHelpers","depth","_getWatchedDir","directory","_boundRemove","_remove","bind","md","mode","st","it","toString","Boolean","isDirectory","wp","nestedDirectoryChildren","nested","parent","wasTracked","relPath","eventName","_closeFile","_addPathCloser","_readdirp","root","type","lstat","once","exports","watch","watcher"],"sources":["/home/hemanth/react-project/client/node_modules/chokidar/index.js"],"sourcesContent":["'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}